(function () {
  try {
    var t =
        typeof window < "u"
          ? window
          : typeof global < "u"
          ? global
          : typeof self < "u"
          ? self
          : {},
      e = new Error().stack;
    e &&
      ((t._sentryDebugIds = t._sentryDebugIds || {}),
      (t._sentryDebugIds[e] = "00f64045-5e6e-4b5d-b705-e85fce2914eb"),
      (t._sentryDebugIdIdentifier =
        "sentry-dbid-00f64045-5e6e-4b5d-b705-e85fce2914eb"));
  } catch {}
})();
function Uee(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              t,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const a of s.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
var jee =
  typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
jee.SENTRY_RELEASE = { id: "34da761cb08d18d329b4496ef1012c4897863feb" };
var Ur =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function oa(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function w9(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", { value: !0 }),
    Object.keys(t).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return t[r];
              },
            }
      );
    }),
    n
  );
}
var DB = { exports: {} },
  aw = {},
  RB = { exports: {} },
  Gn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var dy = Symbol.for("react.element"),
  Hee = Symbol.for("react.portal"),
  zee = Symbol.for("react.fragment"),
  Vee = Symbol.for("react.strict_mode"),
  Gee = Symbol.for("react.profiler"),
  Wee = Symbol.for("react.provider"),
  qee = Symbol.for("react.context"),
  Kee = Symbol.for("react.forward_ref"),
  Xee = Symbol.for("react.suspense"),
  Zee = Symbol.for("react.memo"),
  Yee = Symbol.for("react.lazy"),
  FC = Symbol.iterator;
function Qee(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (FC && t[FC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var MB = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  LB = Object.assign,
  BB = {};
function a1(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = BB),
    (this.updater = n || MB);
}
a1.prototype.isReactComponent = {};
a1.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
a1.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function FB() {}
FB.prototype = a1.prototype;
function _9(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = BB),
    (this.updater = n || MB);
}
var E9 = (_9.prototype = new FB());
E9.constructor = _9;
LB(E9, a1.prototype);
E9.isPureReactComponent = !0;
var $C = Array.isArray,
  $B = Object.prototype.hasOwnProperty,
  x9 = { current: null },
  UB = { key: !0, ref: !0, __self: !0, __source: !0 };
function jB(t, e, n) {
  var r,
    i = {},
    s = null,
    a = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (a = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      $B.call(e, r) && !UB.hasOwnProperty(r) && (i[r] = e[r]);
  var o = arguments.length - 2;
  if (o === 1) i.children = n;
  else if (1 < o) {
    for (var l = Array(o), u = 0; u < o; u++) l[u] = arguments[u + 2];
    i.children = l;
  }
  if (t && t.defaultProps)
    for (r in ((o = t.defaultProps), o)) i[r] === void 0 && (i[r] = o[r]);
  return {
    $$typeof: dy,
    type: t,
    key: s,
    ref: a,
    props: i,
    _owner: x9.current,
  };
}
function Jee(t, e) {
  return {
    $$typeof: dy,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function T9(t) {
  return typeof t == "object" && t !== null && t.$$typeof === dy;
}
function ete(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var UC = /\/+/g;
function q3(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? ete("" + t.key)
    : e.toString(36);
}
function $v(t, e, n, r, i) {
  var s = typeof t;
  (s === "undefined" || s === "boolean") && (t = null);
  var a = !1;
  if (t === null) a = !0;
  else
    switch (s) {
      case "string":
      case "number":
        a = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case dy:
          case Hee:
            a = !0;
        }
    }
  if (a)
    return (
      (a = t),
      (i = i(a)),
      (t = r === "" ? "." + q3(a, 0) : r),
      $C(i)
        ? ((n = ""),
          t != null && (n = t.replace(UC, "$&/") + "/"),
          $v(i, e, n, "", function (u) {
            return u;
          }))
        : i != null &&
          (T9(i) &&
            (i = Jee(
              i,
              n +
                (!i.key || (a && a.key === i.key)
                  ? ""
                  : ("" + i.key).replace(UC, "$&/") + "/") +
                t
            )),
          e.push(i)),
      1
    );
  if (((a = 0), (r = r === "" ? "." : r + ":"), $C(t)))
    for (var o = 0; o < t.length; o++) {
      s = t[o];
      var l = r + q3(s, o);
      a += $v(s, e, n, l, i);
    }
  else if (((l = Qee(t)), typeof l == "function"))
    for (t = l.call(t), o = 0; !(s = t.next()).done; )
      (s = s.value), (l = r + q3(s, o++)), (a += $v(s, e, n, l, i));
  else if (s === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return a;
}
function B2(t, e, n) {
  if (t == null) return t;
  var r = [],
    i = 0;
  return (
    $v(t, r, "", "", function (s) {
      return e.call(n, s, i++);
    }),
    r
  );
}
function tte(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var Na = { current: null },
  Uv = { transition: null },
  nte = {
    ReactCurrentDispatcher: Na,
    ReactCurrentBatchConfig: Uv,
    ReactCurrentOwner: x9,
  };
Gn.Children = {
  map: B2,
  forEach: function (t, e, n) {
    B2(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      B2(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      B2(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!T9(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
Gn.Component = a1;
Gn.Fragment = zee;
Gn.Profiler = Gee;
Gn.PureComponent = _9;
Gn.StrictMode = Vee;
Gn.Suspense = Xee;
Gn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nte;
Gn.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var r = LB({}, t.props),
    i = t.key,
    s = t.ref,
    a = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (a = x9.current)),
      e.key !== void 0 && (i = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var o = t.type.defaultProps;
    for (l in e)
      $B.call(e, l) &&
        !UB.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && o !== void 0 ? o[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
    o = Array(l);
    for (var u = 0; u < l; u++) o[u] = arguments[u + 2];
    r.children = o;
  }
  return { $$typeof: dy, type: t.type, key: i, ref: s, props: r, _owner: a };
};
Gn.createContext = function (t) {
  return (
    (t = {
      $$typeof: qee,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: Wee, _context: t }),
    (t.Consumer = t)
  );
};
Gn.createElement = jB;
Gn.createFactory = function (t) {
  var e = jB.bind(null, t);
  return (e.type = t), e;
};
Gn.createRef = function () {
  return { current: null };
};
Gn.forwardRef = function (t) {
  return { $$typeof: Kee, render: t };
};
Gn.isValidElement = T9;
Gn.lazy = function (t) {
  return { $$typeof: Yee, _payload: { _status: -1, _result: t }, _init: tte };
};
Gn.memo = function (t, e) {
  return { $$typeof: Zee, type: t, compare: e === void 0 ? null : e };
};
Gn.startTransition = function (t) {
  var e = Uv.transition;
  Uv.transition = {};
  try {
    t();
  } finally {
    Uv.transition = e;
  }
};
Gn.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
Gn.useCallback = function (t, e) {
  return Na.current.useCallback(t, e);
};
Gn.useContext = function (t) {
  return Na.current.useContext(t);
};
Gn.useDebugValue = function () {};
Gn.useDeferredValue = function (t) {
  return Na.current.useDeferredValue(t);
};
Gn.useEffect = function (t, e) {
  return Na.current.useEffect(t, e);
};
Gn.useId = function () {
  return Na.current.useId();
};
Gn.useImperativeHandle = function (t, e, n) {
  return Na.current.useImperativeHandle(t, e, n);
};
Gn.useInsertionEffect = function (t, e) {
  return Na.current.useInsertionEffect(t, e);
};
Gn.useLayoutEffect = function (t, e) {
  return Na.current.useLayoutEffect(t, e);
};
Gn.useMemo = function (t, e) {
  return Na.current.useMemo(t, e);
};
Gn.useReducer = function (t, e, n) {
  return Na.current.useReducer(t, e, n);
};
Gn.useRef = function (t) {
  return Na.current.useRef(t);
};
Gn.useState = function (t) {
  return Na.current.useState(t);
};
Gn.useSyncExternalStore = function (t, e, n) {
  return Na.current.useSyncExternalStore(t, e, n);
};
Gn.useTransition = function () {
  return Na.current.useTransition();
};
Gn.version = "18.2.0";
RB.exports = Gn;
var Z = RB.exports;
const Qa = oa(Z),
  rte = Uee({ __proto__: null, default: Qa }, [Z]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ite = Z,
  ste = Symbol.for("react.element"),
  ate = Symbol.for("react.fragment"),
  ote = Object.prototype.hasOwnProperty,
  lte =
    ite.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  ute = { key: !0, ref: !0, __self: !0, __source: !0 };
function HB(t, e, n) {
  var r,
    i = {},
    s = null,
    a = null;
  n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (a = e.ref);
  for (r in e) ote.call(e, r) && !ute.hasOwnProperty(r) && (i[r] = e[r]);
  if (t && t.defaultProps)
    for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: ste,
    type: t,
    key: s,
    ref: a,
    props: i,
    _owner: lte.current,
  };
}
aw.Fragment = ate;
aw.jsx = HB;
aw.jsxs = HB;
DB.exports = aw;
var G = DB.exports,
  o4 = {},
  zB = { exports: {} },
  Mo = {},
  VB = { exports: {} },
  GB = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e($, B) {
    var R = $.length;
    $.push(B);
    e: for (; 0 < R; ) {
      var V = (R - 1) >>> 1,
        oe = $[V];
      if (0 < i(oe, B)) ($[V] = B), ($[R] = oe), (R = V);
      else break e;
    }
  }
  function n($) {
    return $.length === 0 ? null : $[0];
  }
  function r($) {
    if ($.length === 0) return null;
    var B = $[0],
      R = $.pop();
    if (R !== B) {
      $[0] = R;
      e: for (var V = 0, oe = $.length, le = oe >>> 1; V < le; ) {
        var fe = 2 * (V + 1) - 1,
          z = $[fe],
          se = fe + 1,
          Y = $[se];
        if (0 > i(z, R))
          se < oe && 0 > i(Y, z)
            ? (($[V] = Y), ($[se] = R), (V = se))
            : (($[V] = z), ($[fe] = R), (V = fe));
        else if (se < oe && 0 > i(Y, R)) ($[V] = Y), ($[se] = R), (V = se);
        else break e;
      }
    }
    return B;
  }
  function i($, B) {
    var R = $.sortIndex - B.sortIndex;
    return R !== 0 ? R : $.id - B.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function () {
      return s.now();
    };
  } else {
    var a = Date,
      o = a.now();
    t.unstable_now = function () {
      return a.now() - o;
    };
  }
  var l = [],
    u = [],
    f = 1,
    c = null,
    d = 3,
    p = !1,
    m = !1,
    g = !1,
    w = typeof setTimeout == "function" ? setTimeout : null,
    y = typeof clearTimeout == "function" ? clearTimeout : null,
    v = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function E($) {
    for (var B = n(u); B !== null; ) {
      if (B.callback === null) r(u);
      else if (B.startTime <= $)
        r(u), (B.sortIndex = B.expirationTime), e(l, B);
      else break;
      B = n(u);
    }
  }
  function S($) {
    if (((g = !1), E($), !m))
      if (n(l) !== null) (m = !0), L(D);
      else {
        var B = n(u);
        B !== null && U(S, B.startTime - $);
      }
  }
  function D($, B) {
    (m = !1), g && ((g = !1), y(_), (_ = -1)), (p = !0);
    var R = d;
    try {
      for (
        E(B), c = n(l);
        c !== null && (!(c.expirationTime > B) || ($ && !M()));

      ) {
        var V = c.callback;
        if (typeof V == "function") {
          (c.callback = null), (d = c.priorityLevel);
          var oe = V(c.expirationTime <= B);
          (B = t.unstable_now()),
            typeof oe == "function" ? (c.callback = oe) : c === n(l) && r(l),
            E(B);
        } else r(l);
        c = n(l);
      }
      if (c !== null) var le = !0;
      else {
        var fe = n(u);
        fe !== null && U(S, fe.startTime - B), (le = !1);
      }
      return le;
    } finally {
      (c = null), (d = R), (p = !1);
    }
  }
  var P = !1,
    x = null,
    _ = -1,
    A = 5,
    N = -1;
  function M() {
    return !(t.unstable_now() - N < A);
  }
  function T() {
    if (x !== null) {
      var $ = t.unstable_now();
      N = $;
      var B = !0;
      try {
        B = x(!0, $);
      } finally {
        B ? O() : ((P = !1), (x = null));
      }
    } else P = !1;
  }
  var O;
  if (typeof v == "function")
    O = function () {
      v(T);
    };
  else if (typeof MessageChannel < "u") {
    var I = new MessageChannel(),
      k = I.port2;
    (I.port1.onmessage = T),
      (O = function () {
        k.postMessage(null);
      });
  } else
    O = function () {
      w(T, 0);
    };
  function L($) {
    (x = $), P || ((P = !0), O());
  }
  function U($, B) {
    _ = w(function () {
      $(t.unstable_now());
    }, B);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function ($) {
      $.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      m || p || ((m = !0), L(D));
    }),
    (t.unstable_forceFrameRate = function ($) {
      0 > $ || 125 < $
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (A = 0 < $ ? Math.floor(1e3 / $) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return d;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function ($) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var B = 3;
          break;
        default:
          B = d;
      }
      var R = d;
      d = B;
      try {
        return $();
      } finally {
        d = R;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function ($, B) {
      switch ($) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          $ = 3;
      }
      var R = d;
      d = $;
      try {
        return B();
      } finally {
        d = R;
      }
    }),
    (t.unstable_scheduleCallback = function ($, B, R) {
      var V = t.unstable_now();
      switch (
        (typeof R == "object" && R !== null
          ? ((R = R.delay), (R = typeof R == "number" && 0 < R ? V + R : V))
          : (R = V),
        $)
      ) {
        case 1:
          var oe = -1;
          break;
        case 2:
          oe = 250;
          break;
        case 5:
          oe = 1073741823;
          break;
        case 4:
          oe = 1e4;
          break;
        default:
          oe = 5e3;
      }
      return (
        (oe = R + oe),
        ($ = {
          id: f++,
          callback: B,
          priorityLevel: $,
          startTime: R,
          expirationTime: oe,
          sortIndex: -1,
        }),
        R > V
          ? (($.sortIndex = R),
            e(u, $),
            n(l) === null &&
              $ === n(u) &&
              (g ? (y(_), (_ = -1)) : (g = !0), U(S, R - V)))
          : (($.sortIndex = oe), e(l, $), m || p || ((m = !0), L(D))),
        $
      );
    }),
    (t.unstable_shouldYield = M),
    (t.unstable_wrapCallback = function ($) {
      var B = d;
      return function () {
        var R = d;
        d = B;
        try {
          return $.apply(this, arguments);
        } finally {
          d = R;
        }
      };
    });
})(GB);
VB.exports = GB;
var cte = VB.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var WB = Z,
  Ro = cte;
function Qe(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var qB = new Set(),
  pg = {};
function Ph(t, e) {
  T0(t, e), T0(t + "Capture", e);
}
function T0(t, e) {
  for (pg[t] = e, t = 0; t < e.length; t++) qB.add(e[t]);
}
var Vc = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  l4 = Object.prototype.hasOwnProperty,
  fte =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  jC = {},
  HC = {};
function dte(t) {
  return l4.call(HC, t)
    ? !0
    : l4.call(jC, t)
    ? !1
    : fte.test(t)
    ? (HC[t] = !0)
    : ((jC[t] = !0), !1);
}
function hte(t, e, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function pte(t, e, n, r) {
  if (e === null || typeof e > "u" || hte(t, e, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Da(t, e, n, r, i, s, a) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = a);
}
var Rs = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    Rs[t] = new Da(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  Rs[e] = new Da(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  Rs[t] = new Da(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  Rs[t] = new Da(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    Rs[t] = new Da(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  Rs[t] = new Da(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  Rs[t] = new Da(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  Rs[t] = new Da(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  Rs[t] = new Da(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var S9 = /[\-:]([a-z])/g;
function A9(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(S9, A9);
    Rs[e] = new Da(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(S9, A9);
    Rs[e] = new Da(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(S9, A9);
  Rs[e] = new Da(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  Rs[t] = new Da(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
Rs.xlinkHref = new Da(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  Rs[t] = new Da(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function C9(t, e, n, r) {
  var i = Rs.hasOwnProperty(e) ? Rs[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (pte(e, n, i, r) && (n = null),
    r || i === null
      ? dte(e) &&
        (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : i.mustUseProperty
      ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
}
var rf = WB.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  F2 = Symbol.for("react.element"),
  Dp = Symbol.for("react.portal"),
  Rp = Symbol.for("react.fragment"),
  k9 = Symbol.for("react.strict_mode"),
  u4 = Symbol.for("react.profiler"),
  KB = Symbol.for("react.provider"),
  XB = Symbol.for("react.context"),
  I9 = Symbol.for("react.forward_ref"),
  c4 = Symbol.for("react.suspense"),
  f4 = Symbol.for("react.suspense_list"),
  O9 = Symbol.for("react.memo"),
  Of = Symbol.for("react.lazy"),
  ZB = Symbol.for("react.offscreen"),
  zC = Symbol.iterator;
function Q1(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (zC && t[zC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var ui = Object.assign,
  K3;
function Pm(t) {
  if (K3 === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      K3 = (e && e[1]) || "";
    }
  return (
    `
` +
    K3 +
    t
  );
}
var X3 = !1;
function Z3(t, e) {
  if (!t || X3) return "";
  X3 = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var r = u;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          r = u;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        r = u;
      }
      t();
    }
  } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (
        var i = u.stack.split(`
`),
          s = r.stack.split(`
`),
          a = i.length - 1,
          o = s.length - 1;
        1 <= a && 0 <= o && i[a] !== s[o];

      )
        o--;
      for (; 1 <= a && 0 <= o; a--, o--)
        if (i[a] !== s[o]) {
          if (a !== 1 || o !== 1)
            do
              if ((a--, o--, 0 > o || i[a] !== s[o])) {
                var l =
                  `
` + i[a].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= a && 0 <= o);
          break;
        }
    }
  } finally {
    (X3 = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? Pm(t) : "";
}
function mte(t) {
  switch (t.tag) {
    case 5:
      return Pm(t.type);
    case 16:
      return Pm("Lazy");
    case 13:
      return Pm("Suspense");
    case 19:
      return Pm("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = Z3(t.type, !1)), t;
    case 11:
      return (t = Z3(t.type.render, !1)), t;
    case 1:
      return (t = Z3(t.type, !0)), t;
    default:
      return "";
  }
}
function d4(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Rp:
      return "Fragment";
    case Dp:
      return "Portal";
    case u4:
      return "Profiler";
    case k9:
      return "StrictMode";
    case c4:
      return "Suspense";
    case f4:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case XB:
        return (t.displayName || "Context") + ".Consumer";
      case KB:
        return (t._context.displayName || "Context") + ".Provider";
      case I9:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case O9:
        return (
          (e = t.displayName || null), e !== null ? e : d4(t.type) || "Memo"
        );
      case Of:
        (e = t._payload), (t = t._init);
        try {
          return d4(t(e));
        } catch {}
    }
  return null;
}
function gte(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return d4(e);
    case 8:
      return e === k9 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function sd(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function YB(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function yte(t) {
  var e = YB(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      s = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (a) {
          (r = "" + a), s.call(this, a);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (a) {
          r = "" + a;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function $2(t) {
  t._valueTracker || (t._valueTracker = yte(t));
}
function QB(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    r = "";
  return (
    t && (r = YB(t) ? (t.checked ? "true" : "false") : t.value),
    (t = r),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function xb(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function h4(t, e) {
  var n = e.checked;
  return ui({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function VC(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (n = sd(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function JB(t, e) {
  (e = e.checked), e != null && C9(t, "checked", e, !1);
}
function p4(t, e) {
  JB(t, e);
  var n = sd(e.value),
    r = e.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (r === "submit" || r === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? m4(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && m4(t, e.type, sd(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function GC(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function m4(t, e, n) {
  (e !== "number" || xb(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var Nm = Array.isArray;
function e0(t, e, n, r) {
  if (((t = t.options), e)) {
    e = {};
    for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
    for (n = 0; n < t.length; n++)
      (i = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== i && (t[n].selected = i),
        i && r && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + sd(n), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === n) {
        (t[i].selected = !0), r && (t[i].defaultSelected = !0);
        return;
      }
      e !== null || t[i].disabled || (e = t[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function g4(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Qe(91));
  return ui({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function WC(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(Qe(92));
      if (Nm(n)) {
        if (1 < n.length) throw Error(Qe(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: sd(n) };
}
function eF(t, e) {
  var n = sd(e.value),
    r = sd(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = "" + r);
}
function qC(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function tF(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function y4(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? tF(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var U2,
  nF = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        U2 = U2 || document.createElement("div"),
          U2.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = U2.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function mg(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var Ym = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  vte = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ym).forEach(function (t) {
  vte.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Ym[e] = Ym[t]);
  });
});
function rF(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (Ym.hasOwnProperty(t) && Ym[t])
    ? ("" + e).trim()
    : e + "px";
}
function iF(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = rF(n, e[n], r);
      n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : (t[n] = i);
    }
}
var bte = ui(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function v4(t, e) {
  if (e) {
    if (bte[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Qe(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Qe(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Qe(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Qe(62));
  }
}
function b4(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var w4 = null;
function P9(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var _4 = null,
  t0 = null,
  n0 = null;
function KC(t) {
  if ((t = my(t))) {
    if (typeof _4 != "function") throw Error(Qe(280));
    var e = t.stateNode;
    e && ((e = fw(e)), _4(t.stateNode, t.type, e));
  }
}
function sF(t) {
  t0 ? (n0 ? n0.push(t) : (n0 = [t])) : (t0 = t);
}
function aF() {
  if (t0) {
    var t = t0,
      e = n0;
    if (((n0 = t0 = null), KC(t), e)) for (t = 0; t < e.length; t++) KC(e[t]);
  }
}
function oF(t, e) {
  return t(e);
}
function lF() {}
var Y3 = !1;
function uF(t, e, n) {
  if (Y3) return t(e, n);
  Y3 = !0;
  try {
    return oF(t, e, n);
  } finally {
    (Y3 = !1), (t0 !== null || n0 !== null) && (lF(), aF());
  }
}
function gg(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var r = fw(n);
  if (r === null) return null;
  n = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((t = t.type),
        (r = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !r);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(Qe(231, e, typeof n));
  return n;
}
var E4 = !1;
if (Vc)
  try {
    var J1 = {};
    Object.defineProperty(J1, "passive", {
      get: function () {
        E4 = !0;
      },
    }),
      window.addEventListener("test", J1, J1),
      window.removeEventListener("test", J1, J1);
  } catch {
    E4 = !1;
  }
function wte(t, e, n, r, i, s, a, o, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, u);
  } catch (f) {
    this.onError(f);
  }
}
var Qm = !1,
  Tb = null,
  Sb = !1,
  x4 = null,
  _te = {
    onError: function (t) {
      (Qm = !0), (Tb = t);
    },
  };
function Ete(t, e, n, r, i, s, a, o, l) {
  (Qm = !1), (Tb = null), wte.apply(_te, arguments);
}
function xte(t, e, n, r, i, s, a, o, l) {
  if ((Ete.apply(this, arguments), Qm)) {
    if (Qm) {
      var u = Tb;
      (Qm = !1), (Tb = null);
    } else throw Error(Qe(198));
    Sb || ((Sb = !0), (x4 = u));
  }
}
function Nh(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function cF(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function XC(t) {
  if (Nh(t) !== t) throw Error(Qe(188));
}
function Tte(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = Nh(t)), e === null)) throw Error(Qe(188));
    return e !== t ? null : t;
  }
  for (var n = t, r = e; ; ) {
    var i = n.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return XC(i), t;
        if (s === r) return XC(i), e;
        s = s.sibling;
      }
      throw Error(Qe(188));
    }
    if (n.return !== r.return) (n = i), (r = s);
    else {
      for (var a = !1, o = i.child; o; ) {
        if (o === n) {
          (a = !0), (n = i), (r = s);
          break;
        }
        if (o === r) {
          (a = !0), (r = i), (n = s);
          break;
        }
        o = o.sibling;
      }
      if (!a) {
        for (o = s.child; o; ) {
          if (o === n) {
            (a = !0), (n = s), (r = i);
            break;
          }
          if (o === r) {
            (a = !0), (r = s), (n = i);
            break;
          }
          o = o.sibling;
        }
        if (!a) throw Error(Qe(189));
      }
    }
    if (n.alternate !== r) throw Error(Qe(190));
  }
  if (n.tag !== 3) throw Error(Qe(188));
  return n.stateNode.current === n ? t : e;
}
function fF(t) {
  return (t = Tte(t)), t !== null ? dF(t) : null;
}
function dF(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = dF(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var hF = Ro.unstable_scheduleCallback,
  ZC = Ro.unstable_cancelCallback,
  Ste = Ro.unstable_shouldYield,
  Ate = Ro.unstable_requestPaint,
  Ii = Ro.unstable_now,
  Cte = Ro.unstable_getCurrentPriorityLevel,
  N9 = Ro.unstable_ImmediatePriority,
  pF = Ro.unstable_UserBlockingPriority,
  Ab = Ro.unstable_NormalPriority,
  kte = Ro.unstable_LowPriority,
  mF = Ro.unstable_IdlePriority,
  ow = null,
  ju = null;
function Ite(t) {
  if (ju && typeof ju.onCommitFiberRoot == "function")
    try {
      ju.onCommitFiberRoot(ow, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var nu = Math.clz32 ? Math.clz32 : Nte,
  Ote = Math.log,
  Pte = Math.LN2;
function Nte(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((Ote(t) / Pte) | 0)) | 0;
}
var j2 = 64,
  H2 = 4194304;
function Dm(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function Cb(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = t.suspendedLanes,
    s = t.pingedLanes,
    a = n & 268435455;
  if (a !== 0) {
    var o = a & ~i;
    o !== 0 ? (r = Dm(o)) : ((s &= a), s !== 0 && (r = Dm(s)));
  } else (a = n & ~i), a !== 0 ? (r = Dm(a)) : s !== 0 && (r = Dm(s));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= r; 0 < e; )
      (n = 31 - nu(e)), (i = 1 << n), (r |= t[n]), (e &= ~i);
  return r;
}
function Dte(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function Rte(t, e) {
  for (
    var n = t.suspendedLanes,
      r = t.pingedLanes,
      i = t.expirationTimes,
      s = t.pendingLanes;
    0 < s;

  ) {
    var a = 31 - nu(s),
      o = 1 << a,
      l = i[a];
    l === -1
      ? (!(o & n) || o & r) && (i[a] = Dte(o, e))
      : l <= e && (t.expiredLanes |= o),
      (s &= ~o);
  }
}
function T4(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function gF() {
  var t = j2;
  return (j2 <<= 1), !(j2 & 4194240) && (j2 = 64), t;
}
function Q3(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function hy(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - nu(e)),
    (t[e] = n);
}
function Mte(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var r = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var i = 31 - nu(n),
      s = 1 << i;
    (e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~s);
  }
}
function D9(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var r = 31 - nu(n),
      i = 1 << r;
    (i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i);
  }
}
var gr = 0;
function yF(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var vF,
  R9,
  bF,
  wF,
  _F,
  S4 = !1,
  z2 = [],
  Gf = null,
  Wf = null,
  qf = null,
  yg = new Map(),
  vg = new Map(),
  Lf = [],
  Lte =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function YC(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Gf = null;
      break;
    case "dragenter":
    case "dragleave":
      Wf = null;
      break;
    case "mouseover":
    case "mouseout":
      qf = null;
      break;
    case "pointerover":
    case "pointerout":
      yg.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      vg.delete(e.pointerId);
  }
}
function em(t, e, n, r, i, s) {
  return t === null || t.nativeEvent !== s
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = my(e)), e !== null && R9(e)),
      t)
    : ((t.eventSystemFlags |= r),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t);
}
function Bte(t, e, n, r, i) {
  switch (e) {
    case "focusin":
      return (Gf = em(Gf, t, e, n, r, i)), !0;
    case "dragenter":
      return (Wf = em(Wf, t, e, n, r, i)), !0;
    case "mouseover":
      return (qf = em(qf, t, e, n, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return yg.set(s, em(yg.get(s) || null, t, e, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), vg.set(s, em(vg.get(s) || null, t, e, n, r, i)), !0
      );
  }
  return !1;
}
function EF(t) {
  var e = qd(t.target);
  if (e !== null) {
    var n = Nh(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = cF(n)), e !== null)) {
          (t.blockedOn = e),
            _F(t.priority, function () {
              bF(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function jv(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = A4(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var r = new n.constructor(n.type, n);
      (w4 = r), n.target.dispatchEvent(r), (w4 = null);
    } else return (e = my(n)), e !== null && R9(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function QC(t, e, n) {
  jv(t) && n.delete(e);
}
function Fte() {
  (S4 = !1),
    Gf !== null && jv(Gf) && (Gf = null),
    Wf !== null && jv(Wf) && (Wf = null),
    qf !== null && jv(qf) && (qf = null),
    yg.forEach(QC),
    vg.forEach(QC);
}
function tm(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    S4 ||
      ((S4 = !0),
      Ro.unstable_scheduleCallback(Ro.unstable_NormalPriority, Fte)));
}
function bg(t) {
  function e(i) {
    return tm(i, t);
  }
  if (0 < z2.length) {
    tm(z2[0], t);
    for (var n = 1; n < z2.length; n++) {
      var r = z2[n];
      r.blockedOn === t && (r.blockedOn = null);
    }
  }
  for (
    Gf !== null && tm(Gf, t),
      Wf !== null && tm(Wf, t),
      qf !== null && tm(qf, t),
      yg.forEach(e),
      vg.forEach(e),
      n = 0;
    n < Lf.length;
    n++
  )
    (r = Lf[n]), r.blockedOn === t && (r.blockedOn = null);
  for (; 0 < Lf.length && ((n = Lf[0]), n.blockedOn === null); )
    EF(n), n.blockedOn === null && Lf.shift();
}
var r0 = rf.ReactCurrentBatchConfig,
  kb = !0;
function $te(t, e, n, r) {
  var i = gr,
    s = r0.transition;
  r0.transition = null;
  try {
    (gr = 1), M9(t, e, n, r);
  } finally {
    (gr = i), (r0.transition = s);
  }
}
function Ute(t, e, n, r) {
  var i = gr,
    s = r0.transition;
  r0.transition = null;
  try {
    (gr = 4), M9(t, e, n, r);
  } finally {
    (gr = i), (r0.transition = s);
  }
}
function M9(t, e, n, r) {
  if (kb) {
    var i = A4(t, e, n, r);
    if (i === null) l_(t, e, r, Ib, n), YC(t, r);
    else if (Bte(i, t, e, n, r)) r.stopPropagation();
    else if ((YC(t, r), e & 4 && -1 < Lte.indexOf(t))) {
      for (; i !== null; ) {
        var s = my(i);
        if (
          (s !== null && vF(s),
          (s = A4(t, e, n, r)),
          s === null && l_(t, e, r, Ib, n),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else l_(t, e, r, null, n);
  }
}
var Ib = null;
function A4(t, e, n, r) {
  if (((Ib = null), (t = P9(r)), (t = qd(t)), t !== null))
    if (((e = Nh(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = cF(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (Ib = t), null;
}
function xF(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Cte()) {
        case N9:
          return 1;
        case pF:
          return 4;
        case Ab:
        case kte:
          return 16;
        case mF:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Uf = null,
  L9 = null,
  Hv = null;
function TF() {
  if (Hv) return Hv;
  var t,
    e = L9,
    n = e.length,
    r,
    i = "value" in Uf ? Uf.value : Uf.textContent,
    s = i.length;
  for (t = 0; t < n && e[t] === i[t]; t++);
  var a = n - t;
  for (r = 1; r <= a && e[n - r] === i[s - r]; r++);
  return (Hv = i.slice(t, 1 < r ? 1 - r : void 0));
}
function zv(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function V2() {
  return !0;
}
function JC() {
  return !1;
}
function Lo(t) {
  function e(n, r, i, s, a) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = a),
      (this.currentTarget = null);
    for (var o in t)
      t.hasOwnProperty(o) && ((n = t[o]), (this[o] = n ? n(s) : s[o]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? V2
        : JC),
      (this.isPropagationStopped = JC),
      this
    );
  }
  return (
    ui(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = V2));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = V2));
      },
      persist: function () {},
      isPersistent: V2,
    }),
    e
  );
}
var o1 = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  B9 = Lo(o1),
  py = ui({}, o1, { view: 0, detail: 0 }),
  jte = Lo(py),
  J3,
  e_,
  nm,
  lw = ui({}, py, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: F9,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== nm &&
            (nm && t.type === "mousemove"
              ? ((J3 = t.screenX - nm.screenX), (e_ = t.screenY - nm.screenY))
              : (e_ = J3 = 0),
            (nm = t)),
          J3);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : e_;
    },
  }),
  ek = Lo(lw),
  Hte = ui({}, lw, { dataTransfer: 0 }),
  zte = Lo(Hte),
  Vte = ui({}, py, { relatedTarget: 0 }),
  t_ = Lo(Vte),
  Gte = ui({}, o1, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Wte = Lo(Gte),
  qte = ui({}, o1, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  Kte = Lo(qte),
  Xte = ui({}, o1, { data: 0 }),
  tk = Lo(Xte),
  Zte = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Yte = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Qte = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Jte(t) {
  var e = this.nativeEvent;
  return e.getModifierState
    ? e.getModifierState(t)
    : (t = Qte[t])
    ? !!e[t]
    : !1;
}
function F9() {
  return Jte;
}
var ene = ui({}, py, {
    key: function (t) {
      if (t.key) {
        var e = Zte[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = zv(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? Yte[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: F9,
    charCode: function (t) {
      return t.type === "keypress" ? zv(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? zv(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  tne = Lo(ene),
  nne = ui({}, lw, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  nk = Lo(nne),
  rne = ui({}, py, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: F9,
  }),
  ine = Lo(rne),
  sne = ui({}, o1, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  ane = Lo(sne),
  one = ui({}, lw, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  lne = Lo(one),
  une = [9, 13, 27, 32],
  $9 = Vc && "CompositionEvent" in window,
  Jm = null;
Vc && "documentMode" in document && (Jm = document.documentMode);
var cne = Vc && "TextEvent" in window && !Jm,
  SF = Vc && (!$9 || (Jm && 8 < Jm && 11 >= Jm)),
  rk = String.fromCharCode(32),
  ik = !1;
function AF(t, e) {
  switch (t) {
    case "keyup":
      return une.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function CF(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Mp = !1;
function fne(t, e) {
  switch (t) {
    case "compositionend":
      return CF(e);
    case "keypress":
      return e.which !== 32 ? null : ((ik = !0), rk);
    case "textInput":
      return (t = e.data), t === rk && ik ? null : t;
    default:
      return null;
  }
}
function dne(t, e) {
  if (Mp)
    return t === "compositionend" || (!$9 && AF(t, e))
      ? ((t = TF()), (Hv = L9 = Uf = null), (Mp = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return SF && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var hne = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function sk(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!hne[t.type] : e === "textarea";
}
function kF(t, e, n, r) {
  sF(r),
    (e = Ob(e, "onChange")),
    0 < e.length &&
      ((n = new B9("onChange", "change", null, n, r)),
      t.push({ event: n, listeners: e }));
}
var eg = null,
  wg = null;
function pne(t) {
  $F(t, 0);
}
function uw(t) {
  var e = Fp(t);
  if (QB(e)) return t;
}
function mne(t, e) {
  if (t === "change") return e;
}
var IF = !1;
if (Vc) {
  var n_;
  if (Vc) {
    var r_ = "oninput" in document;
    if (!r_) {
      var ak = document.createElement("div");
      ak.setAttribute("oninput", "return;"),
        (r_ = typeof ak.oninput == "function");
    }
    n_ = r_;
  } else n_ = !1;
  IF = n_ && (!document.documentMode || 9 < document.documentMode);
}
function ok() {
  eg && (eg.detachEvent("onpropertychange", OF), (wg = eg = null));
}
function OF(t) {
  if (t.propertyName === "value" && uw(wg)) {
    var e = [];
    kF(e, wg, t, P9(t)), uF(pne, e);
  }
}
function gne(t, e, n) {
  t === "focusin"
    ? (ok(), (eg = e), (wg = n), eg.attachEvent("onpropertychange", OF))
    : t === "focusout" && ok();
}
function yne(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return uw(wg);
}
function vne(t, e) {
  if (t === "click") return uw(e);
}
function bne(t, e) {
  if (t === "input" || t === "change") return uw(e);
}
function wne(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var au = typeof Object.is == "function" ? Object.is : wne;
function _g(t, e) {
  if (au(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!l4.call(e, i) || !au(t[i], e[i])) return !1;
  }
  return !0;
}
function lk(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function uk(t, e) {
  var n = lk(t);
  t = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = t + n.textContent.length), t <= e && r >= e))
        return { node: n, offset: e - t };
      t = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = lk(n);
  }
}
function PF(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? PF(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function NF() {
  for (var t = window, e = xb(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = xb(t.document);
  }
  return e;
}
function U9(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function _ne(t) {
  var e = NF(),
    n = t.focusedElem,
    r = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    PF(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && U9(n)) {
      if (
        ((e = r.start),
        (t = r.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var i = n.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !t.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = uk(n, s));
        var a = uk(n, r);
        i &&
          a &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== a.node ||
            t.focusOffset !== a.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          s > r
            ? (t.addRange(e), t.extend(a.node, a.offset))
            : (e.setEnd(a.node, a.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var Ene = Vc && "documentMode" in document && 11 >= document.documentMode,
  Lp = null,
  C4 = null,
  tg = null,
  k4 = !1;
function ck(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  k4 ||
    Lp == null ||
    Lp !== xb(r) ||
    ((r = Lp),
    "selectionStart" in r && U9(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (tg && _g(tg, r)) ||
      ((tg = r),
      (r = Ob(C4, "onSelect")),
      0 < r.length &&
        ((e = new B9("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: r }),
        (e.target = Lp))));
}
function G2(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var Bp = {
    animationend: G2("Animation", "AnimationEnd"),
    animationiteration: G2("Animation", "AnimationIteration"),
    animationstart: G2("Animation", "AnimationStart"),
    transitionend: G2("Transition", "TransitionEnd"),
  },
  i_ = {},
  DF = {};
Vc &&
  ((DF = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Bp.animationend.animation,
    delete Bp.animationiteration.animation,
    delete Bp.animationstart.animation),
  "TransitionEvent" in window || delete Bp.transitionend.transition);
function cw(t) {
  if (i_[t]) return i_[t];
  if (!Bp[t]) return t;
  var e = Bp[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in DF) return (i_[t] = e[n]);
  return t;
}
var RF = cw("animationend"),
  MF = cw("animationiteration"),
  LF = cw("animationstart"),
  BF = cw("transitionend"),
  FF = new Map(),
  fk =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function md(t, e) {
  FF.set(t, e), Ph(e, [t]);
}
for (var s_ = 0; s_ < fk.length; s_++) {
  var a_ = fk[s_],
    xne = a_.toLowerCase(),
    Tne = a_[0].toUpperCase() + a_.slice(1);
  md(xne, "on" + Tne);
}
md(RF, "onAnimationEnd");
md(MF, "onAnimationIteration");
md(LF, "onAnimationStart");
md("dblclick", "onDoubleClick");
md("focusin", "onFocus");
md("focusout", "onBlur");
md(BF, "onTransitionEnd");
T0("onMouseEnter", ["mouseout", "mouseover"]);
T0("onMouseLeave", ["mouseout", "mouseover"]);
T0("onPointerEnter", ["pointerout", "pointerover"]);
T0("onPointerLeave", ["pointerout", "pointerover"]);
Ph(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Ph(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Ph("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ph(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Ph(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Ph(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Rm =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Sne = new Set(
    "cancel close invalid load scroll toggle".split(" ").concat(Rm)
  );
function dk(t, e, n) {
  var r = t.type || "unknown-event";
  (t.currentTarget = n), xte(r, e, void 0, t), (t.currentTarget = null);
}
function $F(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var a = r.length - 1; 0 <= a; a--) {
          var o = r[a],
            l = o.instance,
            u = o.currentTarget;
          if (((o = o.listener), l !== s && i.isPropagationStopped())) break e;
          dk(i, o, u), (s = l);
        }
      else
        for (a = 0; a < r.length; a++) {
          if (
            ((o = r[a]),
            (l = o.instance),
            (u = o.currentTarget),
            (o = o.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          dk(i, o, u), (s = l);
        }
    }
  }
  if (Sb) throw ((t = x4), (Sb = !1), (x4 = null), t);
}
function Fr(t, e) {
  var n = e[D4];
  n === void 0 && (n = e[D4] = new Set());
  var r = t + "__bubble";
  n.has(r) || (UF(e, t, 2, !1), n.add(r));
}
function o_(t, e, n) {
  var r = 0;
  e && (r |= 4), UF(n, t, r, e);
}
var W2 = "_reactListening" + Math.random().toString(36).slice(2);
function Eg(t) {
  if (!t[W2]) {
    (t[W2] = !0),
      qB.forEach(function (n) {
        n !== "selectionchange" && (Sne.has(n) || o_(n, !1, t), o_(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[W2] || ((e[W2] = !0), o_("selectionchange", !1, e));
  }
}
function UF(t, e, n, r) {
  switch (xF(e)) {
    case 1:
      var i = $te;
      break;
    case 4:
      i = Ute;
      break;
    default:
      i = M9;
  }
  (n = i.bind(null, e, n, t)),
    (i = void 0),
    !E4 ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: i })
        : t.addEventListener(e, n, !0)
      : i !== void 0
      ? t.addEventListener(e, n, { passive: i })
      : t.addEventListener(e, n, !1);
}
function l_(t, e, n, r, i) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var a = r.tag;
      if (a === 3 || a === 4) {
        var o = r.stateNode.containerInfo;
        if (o === i || (o.nodeType === 8 && o.parentNode === i)) break;
        if (a === 4)
          for (a = r.return; a !== null; ) {
            var l = a.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = a.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            a = a.return;
          }
        for (; o !== null; ) {
          if (((a = qd(o)), a === null)) return;
          if (((l = a.tag), l === 5 || l === 6)) {
            r = s = a;
            continue e;
          }
          o = o.parentNode;
        }
      }
      r = r.return;
    }
  uF(function () {
    var u = s,
      f = P9(n),
      c = [];
    e: {
      var d = FF.get(t);
      if (d !== void 0) {
        var p = B9,
          m = t;
        switch (t) {
          case "keypress":
            if (zv(n) === 0) break e;
          case "keydown":
          case "keyup":
            p = tne;
            break;
          case "focusin":
            (m = "focus"), (p = t_);
            break;
          case "focusout":
            (m = "blur"), (p = t_);
            break;
          case "beforeblur":
          case "afterblur":
            p = t_;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = ek;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = zte;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = ine;
            break;
          case RF:
          case MF:
          case LF:
            p = Wte;
            break;
          case BF:
            p = ane;
            break;
          case "scroll":
            p = jte;
            break;
          case "wheel":
            p = lne;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = Kte;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = nk;
        }
        var g = (e & 4) !== 0,
          w = !g && t === "scroll",
          y = g ? (d !== null ? d + "Capture" : null) : d;
        g = [];
        for (var v = u, E; v !== null; ) {
          E = v;
          var S = E.stateNode;
          if (
            (E.tag === 5 &&
              S !== null &&
              ((E = S),
              y !== null && ((S = gg(v, y)), S != null && g.push(xg(v, S, E)))),
            w)
          )
            break;
          v = v.return;
        }
        0 < g.length &&
          ((d = new p(d, m, null, n, f)), c.push({ event: d, listeners: g }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((d = t === "mouseover" || t === "pointerover"),
          (p = t === "mouseout" || t === "pointerout"),
          d &&
            n !== w4 &&
            (m = n.relatedTarget || n.fromElement) &&
            (qd(m) || m[Gc]))
        )
          break e;
        if (
          (p || d) &&
          ((d =
            f.window === f
              ? f
              : (d = f.ownerDocument)
              ? d.defaultView || d.parentWindow
              : window),
          p
            ? ((m = n.relatedTarget || n.toElement),
              (p = u),
              (m = m ? qd(m) : null),
              m !== null &&
                ((w = Nh(m)), m !== w || (m.tag !== 5 && m.tag !== 6)) &&
                (m = null))
            : ((p = null), (m = u)),
          p !== m)
        ) {
          if (
            ((g = ek),
            (S = "onMouseLeave"),
            (y = "onMouseEnter"),
            (v = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((g = nk),
              (S = "onPointerLeave"),
              (y = "onPointerEnter"),
              (v = "pointer")),
            (w = p == null ? d : Fp(p)),
            (E = m == null ? d : Fp(m)),
            (d = new g(S, v + "leave", p, n, f)),
            (d.target = w),
            (d.relatedTarget = E),
            (S = null),
            qd(f) === u &&
              ((g = new g(y, v + "enter", m, n, f)),
              (g.target = E),
              (g.relatedTarget = w),
              (S = g)),
            (w = S),
            p && m)
          )
            t: {
              for (g = p, y = m, v = 0, E = g; E; E = op(E)) v++;
              for (E = 0, S = y; S; S = op(S)) E++;
              for (; 0 < v - E; ) (g = op(g)), v--;
              for (; 0 < E - v; ) (y = op(y)), E--;
              for (; v--; ) {
                if (g === y || (y !== null && g === y.alternate)) break t;
                (g = op(g)), (y = op(y));
              }
              g = null;
            }
          else g = null;
          p !== null && hk(c, d, p, g, !1),
            m !== null && w !== null && hk(c, w, m, g, !0);
        }
      }
      e: {
        if (
          ((d = u ? Fp(u) : window),
          (p = d.nodeName && d.nodeName.toLowerCase()),
          p === "select" || (p === "input" && d.type === "file"))
        )
          var D = mne;
        else if (sk(d))
          if (IF) D = bne;
          else {
            D = yne;
            var P = gne;
          }
        else
          (p = d.nodeName) &&
            p.toLowerCase() === "input" &&
            (d.type === "checkbox" || d.type === "radio") &&
            (D = vne);
        if (D && (D = D(t, u))) {
          kF(c, D, n, f);
          break e;
        }
        P && P(t, d, u),
          t === "focusout" &&
            (P = d._wrapperState) &&
            P.controlled &&
            d.type === "number" &&
            m4(d, "number", d.value);
      }
      switch (((P = u ? Fp(u) : window), t)) {
        case "focusin":
          (sk(P) || P.contentEditable === "true") &&
            ((Lp = P), (C4 = u), (tg = null));
          break;
        case "focusout":
          tg = C4 = Lp = null;
          break;
        case "mousedown":
          k4 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (k4 = !1), ck(c, n, f);
          break;
        case "selectionchange":
          if (Ene) break;
        case "keydown":
        case "keyup":
          ck(c, n, f);
      }
      var x;
      if ($9)
        e: {
          switch (t) {
            case "compositionstart":
              var _ = "onCompositionStart";
              break e;
            case "compositionend":
              _ = "onCompositionEnd";
              break e;
            case "compositionupdate":
              _ = "onCompositionUpdate";
              break e;
          }
          _ = void 0;
        }
      else
        Mp
          ? AF(t, n) && (_ = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (_ = "onCompositionStart");
      _ &&
        (SF &&
          n.locale !== "ko" &&
          (Mp || _ !== "onCompositionStart"
            ? _ === "onCompositionEnd" && Mp && (x = TF())
            : ((Uf = f),
              (L9 = "value" in Uf ? Uf.value : Uf.textContent),
              (Mp = !0))),
        (P = Ob(u, _)),
        0 < P.length &&
          ((_ = new tk(_, t, null, n, f)),
          c.push({ event: _, listeners: P }),
          x ? (_.data = x) : ((x = CF(n)), x !== null && (_.data = x)))),
        (x = cne ? fne(t, n) : dne(t, n)) &&
          ((u = Ob(u, "onBeforeInput")),
          0 < u.length &&
            ((f = new tk("onBeforeInput", "beforeinput", null, n, f)),
            c.push({ event: f, listeners: u }),
            (f.data = x)));
    }
    $F(c, e);
  });
}
function xg(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function Ob(t, e) {
  for (var n = e + "Capture", r = []; t !== null; ) {
    var i = t,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = gg(t, n)),
      s != null && r.unshift(xg(t, s, i)),
      (s = gg(t, e)),
      s != null && r.push(xg(t, s, i))),
      (t = t.return);
  }
  return r;
}
function op(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function hk(t, e, n, r, i) {
  for (var s = e._reactName, a = []; n !== null && n !== r; ) {
    var o = n,
      l = o.alternate,
      u = o.stateNode;
    if (l !== null && l === r) break;
    o.tag === 5 &&
      u !== null &&
      ((o = u),
      i
        ? ((l = gg(n, s)), l != null && a.unshift(xg(n, l, o)))
        : i || ((l = gg(n, s)), l != null && a.push(xg(n, l, o)))),
      (n = n.return);
  }
  a.length !== 0 && t.push({ event: e, listeners: a });
}
var Ane = /\r\n?/g,
  Cne = /\u0000|\uFFFD/g;
function pk(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      Ane,
      `
`
    )
    .replace(Cne, "");
}
function q2(t, e, n) {
  if (((e = pk(e)), pk(t) !== e && n)) throw Error(Qe(425));
}
function Pb() {}
var I4 = null,
  O4 = null;
function P4(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var N4 = typeof setTimeout == "function" ? setTimeout : void 0,
  kne = typeof clearTimeout == "function" ? clearTimeout : void 0,
  mk = typeof Promise == "function" ? Promise : void 0,
  Ine =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof mk < "u"
      ? function (t) {
          return mk.resolve(null).then(t).catch(One);
        }
      : N4;
function One(t) {
  setTimeout(function () {
    throw t;
  });
}
function u_(t, e) {
  var n = e,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((t.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          t.removeChild(i), bg(e);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  bg(e);
}
function Kf(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function gk(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var l1 = Math.random().toString(36).slice(2),
  Ru = "__reactFiber$" + l1,
  Tg = "__reactProps$" + l1,
  Gc = "__reactContainer$" + l1,
  D4 = "__reactEvents$" + l1,
  Pne = "__reactListeners$" + l1,
  Nne = "__reactHandles$" + l1;
function qd(t) {
  var e = t[Ru];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[Gc] || n[Ru])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = gk(t); t !== null; ) {
          if ((n = t[Ru])) return n;
          t = gk(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function my(t) {
  return (
    (t = t[Ru] || t[Gc]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function Fp(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(Qe(33));
}
function fw(t) {
  return t[Tg] || null;
}
var R4 = [],
  $p = -1;
function gd(t) {
  return { current: t };
}
function zr(t) {
  0 > $p || ((t.current = R4[$p]), (R4[$p] = null), $p--);
}
function Rr(t, e) {
  $p++, (R4[$p] = t.current), (t.current = e);
}
var ad = {},
  sa = gd(ad),
  to = gd(!1),
  ch = ad;
function S0(t, e) {
  var n = t.type.contextTypes;
  if (!n) return ad;
  var r = t.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in n) i[s] = e[s];
  return (
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function no(t) {
  return (t = t.childContextTypes), t != null;
}
function Nb() {
  zr(to), zr(sa);
}
function yk(t, e, n) {
  if (sa.current !== ad) throw Error(Qe(168));
  Rr(sa, e), Rr(to, n);
}
function jF(t, e, n) {
  var r = t.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(Qe(108, gte(t) || "Unknown", i));
  return ui({}, n, r);
}
function Db(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || ad),
    (ch = sa.current),
    Rr(sa, t),
    Rr(to, to.current),
    !0
  );
}
function vk(t, e, n) {
  var r = t.stateNode;
  if (!r) throw Error(Qe(169));
  n
    ? ((t = jF(t, e, ch)),
      (r.__reactInternalMemoizedMergedChildContext = t),
      zr(to),
      zr(sa),
      Rr(sa, t))
    : zr(to),
    Rr(to, n);
}
var Pc = null,
  dw = !1,
  c_ = !1;
function HF(t) {
  Pc === null ? (Pc = [t]) : Pc.push(t);
}
function Dne(t) {
  (dw = !0), HF(t);
}
function yd() {
  if (!c_ && Pc !== null) {
    c_ = !0;
    var t = 0,
      e = gr;
    try {
      var n = Pc;
      for (gr = 1; t < n.length; t++) {
        var r = n[t];
        do r = r(!0);
        while (r !== null);
      }
      (Pc = null), (dw = !1);
    } catch (i) {
      throw (Pc !== null && (Pc = Pc.slice(t + 1)), hF(N9, yd), i);
    } finally {
      (gr = e), (c_ = !1);
    }
  }
  return null;
}
var Up = [],
  jp = 0,
  Rb = null,
  Mb = 0,
  ll = [],
  ul = 0,
  fh = null,
  Mc = 1,
  Lc = "";
function Ud(t, e) {
  (Up[jp++] = Mb), (Up[jp++] = Rb), (Rb = t), (Mb = e);
}
function zF(t, e, n) {
  (ll[ul++] = Mc), (ll[ul++] = Lc), (ll[ul++] = fh), (fh = t);
  var r = Mc;
  t = Lc;
  var i = 32 - nu(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var s = 32 - nu(e) + i;
  if (30 < s) {
    var a = i - (i % 5);
    (s = (r & ((1 << a) - 1)).toString(32)),
      (r >>= a),
      (i -= a),
      (Mc = (1 << (32 - nu(e) + i)) | (n << i) | r),
      (Lc = s + t);
  } else (Mc = (1 << s) | (n << i) | r), (Lc = t);
}
function j9(t) {
  t.return !== null && (Ud(t, 1), zF(t, 1, 0));
}
function H9(t) {
  for (; t === Rb; )
    (Rb = Up[--jp]), (Up[jp] = null), (Mb = Up[--jp]), (Up[jp] = null);
  for (; t === fh; )
    (fh = ll[--ul]),
      (ll[ul] = null),
      (Lc = ll[--ul]),
      (ll[ul] = null),
      (Mc = ll[--ul]),
      (ll[ul] = null);
}
var Do = null,
  Oo = null,
  Kr = !1,
  Xl = null;
function VF(t, e) {
  var n = cl(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function bk(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (Do = t), (Oo = Kf(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (Do = t), (Oo = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = fh !== null ? { id: Mc, overflow: Lc } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = cl(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (Do = t),
            (Oo = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function M4(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function L4(t) {
  if (Kr) {
    var e = Oo;
    if (e) {
      var n = e;
      if (!bk(t, e)) {
        if (M4(t)) throw Error(Qe(418));
        e = Kf(n.nextSibling);
        var r = Do;
        e && bk(t, e)
          ? VF(r, n)
          : ((t.flags = (t.flags & -4097) | 2), (Kr = !1), (Do = t));
      }
    } else {
      if (M4(t)) throw Error(Qe(418));
      (t.flags = (t.flags & -4097) | 2), (Kr = !1), (Do = t);
    }
  }
}
function wk(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  Do = t;
}
function K2(t) {
  if (t !== Do) return !1;
  if (!Kr) return wk(t), (Kr = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !P4(t.type, t.memoizedProps))),
    e && (e = Oo))
  ) {
    if (M4(t)) throw (GF(), Error(Qe(418)));
    for (; e; ) VF(t, e), (e = Kf(e.nextSibling));
  }
  if ((wk(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(Qe(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              Oo = Kf(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      Oo = null;
    }
  } else Oo = Do ? Kf(t.stateNode.nextSibling) : null;
  return !0;
}
function GF() {
  for (var t = Oo; t; ) t = Kf(t.nextSibling);
}
function A0() {
  (Oo = Do = null), (Kr = !1);
}
function z9(t) {
  Xl === null ? (Xl = [t]) : Xl.push(t);
}
var Rne = rf.ReactCurrentBatchConfig;
function zl(t, e) {
  if (t && t.defaultProps) {
    (e = ui({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
var Lb = gd(null),
  Bb = null,
  Hp = null,
  V9 = null;
function G9() {
  V9 = Hp = Bb = null;
}
function W9(t) {
  var e = Lb.current;
  zr(Lb), (t._currentValue = e);
}
function B4(t, e, n) {
  for (; t !== null; ) {
    var r = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function i0(t, e) {
  (Bb = t),
    (V9 = Hp = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (Ja = !0), (t.firstContext = null));
}
function pl(t) {
  var e = t._currentValue;
  if (V9 !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), Hp === null)) {
      if (Bb === null) throw Error(Qe(308));
      (Hp = t), (Bb.dependencies = { lanes: 0, firstContext: t });
    } else Hp = Hp.next = t;
  return e;
}
var Kd = null;
function q9(t) {
  Kd === null ? (Kd = [t]) : Kd.push(t);
}
function WF(t, e, n, r) {
  var i = e.interleaved;
  return (
    i === null ? ((n.next = n), q9(e)) : ((n.next = i.next), (i.next = n)),
    (e.interleaved = n),
    Wc(t, r)
  );
}
function Wc(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var Pf = !1;
function K9(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function qF(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function $c(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Xf(t, e, n) {
  var r = t.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), rr & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Wc(t, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), q9(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Wc(t, n)
  );
}
function Vv(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), D9(t, n);
  }
}
function _k(t, e) {
  var n = t.updateQueue,
    r = t.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var a = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (i = s = a) : (s = s.next = a), (n = n.next);
      } while (n !== null);
      s === null ? (i = s = e) : (s = s.next = e);
    } else i = s = e;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function Fb(t, e, n, r) {
  var i = t.updateQueue;
  Pf = !1;
  var s = i.firstBaseUpdate,
    a = i.lastBaseUpdate,
    o = i.shared.pending;
  if (o !== null) {
    i.shared.pending = null;
    var l = o,
      u = l.next;
    (l.next = null), a === null ? (s = u) : (a.next = u), (a = l);
    var f = t.alternate;
    f !== null &&
      ((f = f.updateQueue),
      (o = f.lastBaseUpdate),
      o !== a &&
        (o === null ? (f.firstBaseUpdate = u) : (o.next = u),
        (f.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var c = i.baseState;
    (a = 0), (f = u = l = null), (o = s);
    do {
      var d = o.lane,
        p = o.eventTime;
      if ((r & d) === d) {
        f !== null &&
          (f = f.next =
            {
              eventTime: p,
              lane: 0,
              tag: o.tag,
              payload: o.payload,
              callback: o.callback,
              next: null,
            });
        e: {
          var m = t,
            g = o;
          switch (((d = e), (p = n), g.tag)) {
            case 1:
              if (((m = g.payload), typeof m == "function")) {
                c = m.call(p, c, d);
                break e;
              }
              c = m;
              break e;
            case 3:
              m.flags = (m.flags & -65537) | 128;
            case 0:
              if (
                ((m = g.payload),
                (d = typeof m == "function" ? m.call(p, c, d) : m),
                d == null)
              )
                break e;
              c = ui({}, c, d);
              break e;
            case 2:
              Pf = !0;
          }
        }
        o.callback !== null &&
          o.lane !== 0 &&
          ((t.flags |= 64),
          (d = i.effects),
          d === null ? (i.effects = [o]) : d.push(o));
      } else
        (p = {
          eventTime: p,
          lane: d,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null,
        }),
          f === null ? ((u = f = p), (l = c)) : (f = f.next = p),
          (a |= d);
      if (((o = o.next), o === null)) {
        if (((o = i.shared.pending), o === null)) break;
        (d = o),
          (o = d.next),
          (d.next = null),
          (i.lastBaseUpdate = d),
          (i.shared.pending = null);
      }
    } while (1);
    if (
      (f === null && (l = c),
      (i.baseState = l),
      (i.firstBaseUpdate = u),
      (i.lastBaseUpdate = f),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (a |= i.lane), (i = i.next);
      while (i !== e);
    } else s === null && (i.shared.lanes = 0);
    (hh |= a), (t.lanes = a), (t.memoizedState = c);
  }
}
function Ek(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(Qe(191, i));
        i.call(r);
      }
    }
}
var KF = new WB.Component().refs;
function F4(t, e, n, r) {
  (e = t.memoizedState),
    (n = n(r, e)),
    (n = n == null ? e : ui({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var hw = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Nh(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var r = Sa(),
      i = Yf(t),
      s = $c(r, i);
    (s.payload = e),
      n != null && (s.callback = n),
      (e = Xf(t, s, i)),
      e !== null && (ru(e, t, i, r), Vv(e, t, i));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var r = Sa(),
      i = Yf(t),
      s = $c(r, i);
    (s.tag = 1),
      (s.payload = e),
      n != null && (s.callback = n),
      (e = Xf(t, s, i)),
      e !== null && (ru(e, t, i, r), Vv(e, t, i));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = Sa(),
      r = Yf(t),
      i = $c(n, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = Xf(t, i, r)),
      e !== null && (ru(e, t, r, n), Vv(e, t, r));
  },
};
function xk(t, e, n, r, i, s, a) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(r, s, a)
      : e.prototype && e.prototype.isPureReactComponent
      ? !_g(n, r) || !_g(i, s)
      : !0
  );
}
function XF(t, e, n) {
  var r = !1,
    i = ad,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = pl(s))
      : ((i = no(e) ? ch : sa.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? S0(t, i) : ad)),
    (e = new e(n, s)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = hw),
    (t.stateNode = e),
    (e._reactInternals = t),
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function Tk(t, e, n, r) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && hw.enqueueReplaceState(e, e.state, null);
}
function $4(t, e, n, r) {
  var i = t.stateNode;
  (i.props = n), (i.state = t.memoizedState), (i.refs = KF), K9(t);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (i.context = pl(s))
    : ((s = no(e) ? ch : sa.current), (i.context = S0(t, s))),
    (i.state = t.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (F4(t, e, s, n), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && hw.enqueueReplaceState(i, i.state, null),
      Fb(t, n, i, r),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function rm(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(Qe(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(Qe(147, t));
      var i = r,
        s = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (a) {
            var o = i.refs;
            o === KF && (o = i.refs = {}),
              a === null ? delete o[s] : (o[s] = a);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof t != "string") throw Error(Qe(284));
    if (!n._owner) throw Error(Qe(290, t));
  }
  return t;
}
function X2(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      Qe(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function Sk(t) {
  var e = t._init;
  return e(t._payload);
}
function ZF(t) {
  function e(y, v) {
    if (t) {
      var E = y.deletions;
      E === null ? ((y.deletions = [v]), (y.flags |= 16)) : E.push(v);
    }
  }
  function n(y, v) {
    if (!t) return null;
    for (; v !== null; ) e(y, v), (v = v.sibling);
    return null;
  }
  function r(y, v) {
    for (y = new Map(); v !== null; )
      v.key !== null ? y.set(v.key, v) : y.set(v.index, v), (v = v.sibling);
    return y;
  }
  function i(y, v) {
    return (y = Qf(y, v)), (y.index = 0), (y.sibling = null), y;
  }
  function s(y, v, E) {
    return (
      (y.index = E),
      t
        ? ((E = y.alternate),
          E !== null
            ? ((E = E.index), E < v ? ((y.flags |= 2), v) : E)
            : ((y.flags |= 2), v))
        : ((y.flags |= 1048576), v)
    );
  }
  function a(y) {
    return t && y.alternate === null && (y.flags |= 2), y;
  }
  function o(y, v, E, S) {
    return v === null || v.tag !== 6
      ? ((v = y_(E, y.mode, S)), (v.return = y), v)
      : ((v = i(v, E)), (v.return = y), v);
  }
  function l(y, v, E, S) {
    var D = E.type;
    return D === Rp
      ? f(y, v, E.props.children, S, E.key)
      : v !== null &&
        (v.elementType === D ||
          (typeof D == "object" &&
            D !== null &&
            D.$$typeof === Of &&
            Sk(D) === v.type))
      ? ((S = i(v, E.props)), (S.ref = rm(y, v, E)), (S.return = y), S)
      : ((S = Zv(E.type, E.key, E.props, null, y.mode, S)),
        (S.ref = rm(y, v, E)),
        (S.return = y),
        S);
  }
  function u(y, v, E, S) {
    return v === null ||
      v.tag !== 4 ||
      v.stateNode.containerInfo !== E.containerInfo ||
      v.stateNode.implementation !== E.implementation
      ? ((v = v_(E, y.mode, S)), (v.return = y), v)
      : ((v = i(v, E.children || [])), (v.return = y), v);
  }
  function f(y, v, E, S, D) {
    return v === null || v.tag !== 7
      ? ((v = ah(E, y.mode, S, D)), (v.return = y), v)
      : ((v = i(v, E)), (v.return = y), v);
  }
  function c(y, v, E) {
    if ((typeof v == "string" && v !== "") || typeof v == "number")
      return (v = y_("" + v, y.mode, E)), (v.return = y), v;
    if (typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case F2:
          return (
            (E = Zv(v.type, v.key, v.props, null, y.mode, E)),
            (E.ref = rm(y, null, v)),
            (E.return = y),
            E
          );
        case Dp:
          return (v = v_(v, y.mode, E)), (v.return = y), v;
        case Of:
          var S = v._init;
          return c(y, S(v._payload), E);
      }
      if (Nm(v) || Q1(v))
        return (v = ah(v, y.mode, E, null)), (v.return = y), v;
      X2(y, v);
    }
    return null;
  }
  function d(y, v, E, S) {
    var D = v !== null ? v.key : null;
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return D !== null ? null : o(y, v, "" + E, S);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case F2:
          return E.key === D ? l(y, v, E, S) : null;
        case Dp:
          return E.key === D ? u(y, v, E, S) : null;
        case Of:
          return (D = E._init), d(y, v, D(E._payload), S);
      }
      if (Nm(E) || Q1(E)) return D !== null ? null : f(y, v, E, S, null);
      X2(y, E);
    }
    return null;
  }
  function p(y, v, E, S, D) {
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return (y = y.get(E) || null), o(v, y, "" + S, D);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case F2:
          return (y = y.get(S.key === null ? E : S.key) || null), l(v, y, S, D);
        case Dp:
          return (y = y.get(S.key === null ? E : S.key) || null), u(v, y, S, D);
        case Of:
          var P = S._init;
          return p(y, v, E, P(S._payload), D);
      }
      if (Nm(S) || Q1(S)) return (y = y.get(E) || null), f(v, y, S, D, null);
      X2(v, S);
    }
    return null;
  }
  function m(y, v, E, S) {
    for (
      var D = null, P = null, x = v, _ = (v = 0), A = null;
      x !== null && _ < E.length;
      _++
    ) {
      x.index > _ ? ((A = x), (x = null)) : (A = x.sibling);
      var N = d(y, x, E[_], S);
      if (N === null) {
        x === null && (x = A);
        break;
      }
      t && x && N.alternate === null && e(y, x),
        (v = s(N, v, _)),
        P === null ? (D = N) : (P.sibling = N),
        (P = N),
        (x = A);
    }
    if (_ === E.length) return n(y, x), Kr && Ud(y, _), D;
    if (x === null) {
      for (; _ < E.length; _++)
        (x = c(y, E[_], S)),
          x !== null &&
            ((v = s(x, v, _)), P === null ? (D = x) : (P.sibling = x), (P = x));
      return Kr && Ud(y, _), D;
    }
    for (x = r(y, x); _ < E.length; _++)
      (A = p(x, y, _, E[_], S)),
        A !== null &&
          (t && A.alternate !== null && x.delete(A.key === null ? _ : A.key),
          (v = s(A, v, _)),
          P === null ? (D = A) : (P.sibling = A),
          (P = A));
    return (
      t &&
        x.forEach(function (M) {
          return e(y, M);
        }),
      Kr && Ud(y, _),
      D
    );
  }
  function g(y, v, E, S) {
    var D = Q1(E);
    if (typeof D != "function") throw Error(Qe(150));
    if (((E = D.call(E)), E == null)) throw Error(Qe(151));
    for (
      var P = (D = null), x = v, _ = (v = 0), A = null, N = E.next();
      x !== null && !N.done;
      _++, N = E.next()
    ) {
      x.index > _ ? ((A = x), (x = null)) : (A = x.sibling);
      var M = d(y, x, N.value, S);
      if (M === null) {
        x === null && (x = A);
        break;
      }
      t && x && M.alternate === null && e(y, x),
        (v = s(M, v, _)),
        P === null ? (D = M) : (P.sibling = M),
        (P = M),
        (x = A);
    }
    if (N.done) return n(y, x), Kr && Ud(y, _), D;
    if (x === null) {
      for (; !N.done; _++, N = E.next())
        (N = c(y, N.value, S)),
          N !== null &&
            ((v = s(N, v, _)), P === null ? (D = N) : (P.sibling = N), (P = N));
      return Kr && Ud(y, _), D;
    }
    for (x = r(y, x); !N.done; _++, N = E.next())
      (N = p(x, y, _, N.value, S)),
        N !== null &&
          (t && N.alternate !== null && x.delete(N.key === null ? _ : N.key),
          (v = s(N, v, _)),
          P === null ? (D = N) : (P.sibling = N),
          (P = N));
    return (
      t &&
        x.forEach(function (T) {
          return e(y, T);
        }),
      Kr && Ud(y, _),
      D
    );
  }
  function w(y, v, E, S) {
    if (
      (typeof E == "object" &&
        E !== null &&
        E.type === Rp &&
        E.key === null &&
        (E = E.props.children),
      typeof E == "object" && E !== null)
    ) {
      switch (E.$$typeof) {
        case F2:
          e: {
            for (var D = E.key, P = v; P !== null; ) {
              if (P.key === D) {
                if (((D = E.type), D === Rp)) {
                  if (P.tag === 7) {
                    n(y, P.sibling),
                      (v = i(P, E.props.children)),
                      (v.return = y),
                      (y = v);
                    break e;
                  }
                } else if (
                  P.elementType === D ||
                  (typeof D == "object" &&
                    D !== null &&
                    D.$$typeof === Of &&
                    Sk(D) === P.type)
                ) {
                  n(y, P.sibling),
                    (v = i(P, E.props)),
                    (v.ref = rm(y, P, E)),
                    (v.return = y),
                    (y = v);
                  break e;
                }
                n(y, P);
                break;
              } else e(y, P);
              P = P.sibling;
            }
            E.type === Rp
              ? ((v = ah(E.props.children, y.mode, S, E.key)),
                (v.return = y),
                (y = v))
              : ((S = Zv(E.type, E.key, E.props, null, y.mode, S)),
                (S.ref = rm(y, v, E)),
                (S.return = y),
                (y = S));
          }
          return a(y);
        case Dp:
          e: {
            for (P = E.key; v !== null; ) {
              if (v.key === P)
                if (
                  v.tag === 4 &&
                  v.stateNode.containerInfo === E.containerInfo &&
                  v.stateNode.implementation === E.implementation
                ) {
                  n(y, v.sibling),
                    (v = i(v, E.children || [])),
                    (v.return = y),
                    (y = v);
                  break e;
                } else {
                  n(y, v);
                  break;
                }
              else e(y, v);
              v = v.sibling;
            }
            (v = v_(E, y.mode, S)), (v.return = y), (y = v);
          }
          return a(y);
        case Of:
          return (P = E._init), w(y, v, P(E._payload), S);
      }
      if (Nm(E)) return m(y, v, E, S);
      if (Q1(E)) return g(y, v, E, S);
      X2(y, E);
    }
    return (typeof E == "string" && E !== "") || typeof E == "number"
      ? ((E = "" + E),
        v !== null && v.tag === 6
          ? (n(y, v.sibling), (v = i(v, E)), (v.return = y), (y = v))
          : (n(y, v), (v = y_(E, y.mode, S)), (v.return = y), (y = v)),
        a(y))
      : n(y, v);
  }
  return w;
}
var C0 = ZF(!0),
  YF = ZF(!1),
  gy = {},
  Hu = gd(gy),
  Sg = gd(gy),
  Ag = gd(gy);
function Xd(t) {
  if (t === gy) throw Error(Qe(174));
  return t;
}
function X9(t, e) {
  switch ((Rr(Ag, e), Rr(Sg, t), Rr(Hu, gy), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : y4(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = y4(e, t));
  }
  zr(Hu), Rr(Hu, e);
}
function k0() {
  zr(Hu), zr(Sg), zr(Ag);
}
function QF(t) {
  Xd(Ag.current);
  var e = Xd(Hu.current),
    n = y4(e, t.type);
  e !== n && (Rr(Sg, t), Rr(Hu, n));
}
function Z9(t) {
  Sg.current === t && (zr(Hu), zr(Sg));
}
var ii = gd(0);
function $b(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var f_ = [];
function Y9() {
  for (var t = 0; t < f_.length; t++)
    f_[t]._workInProgressVersionPrimary = null;
  f_.length = 0;
}
var Gv = rf.ReactCurrentDispatcher,
  d_ = rf.ReactCurrentBatchConfig,
  dh = 0,
  li = null,
  Yi = null,
  bs = null,
  Ub = !1,
  ng = !1,
  Cg = 0,
  Mne = 0;
function Ws() {
  throw Error(Qe(321));
}
function Q9(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!au(t[n], e[n])) return !1;
  return !0;
}
function J9(t, e, n, r, i, s) {
  if (
    ((dh = s),
    (li = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Gv.current = t === null || t.memoizedState === null ? $ne : Une),
    (t = n(r, i)),
    ng)
  ) {
    s = 0;
    do {
      if (((ng = !1), (Cg = 0), 25 <= s)) throw Error(Qe(301));
      (s += 1),
        (bs = Yi = null),
        (e.updateQueue = null),
        (Gv.current = jne),
        (t = n(r, i));
    } while (ng);
  }
  if (
    ((Gv.current = jb),
    (e = Yi !== null && Yi.next !== null),
    (dh = 0),
    (bs = Yi = li = null),
    (Ub = !1),
    e)
  )
    throw Error(Qe(300));
  return t;
}
function e7() {
  var t = Cg !== 0;
  return (Cg = 0), t;
}
function ku() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return bs === null ? (li.memoizedState = bs = t) : (bs = bs.next = t), bs;
}
function ml() {
  if (Yi === null) {
    var t = li.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Yi.next;
  var e = bs === null ? li.memoizedState : bs.next;
  if (e !== null) (bs = e), (Yi = t);
  else {
    if (t === null) throw Error(Qe(310));
    (Yi = t),
      (t = {
        memoizedState: Yi.memoizedState,
        baseState: Yi.baseState,
        baseQueue: Yi.baseQueue,
        queue: Yi.queue,
        next: null,
      }),
      bs === null ? (li.memoizedState = bs = t) : (bs = bs.next = t);
  }
  return bs;
}
function kg(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function h_(t) {
  var e = ml(),
    n = e.queue;
  if (n === null) throw Error(Qe(311));
  n.lastRenderedReducer = t;
  var r = Yi,
    i = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (i !== null) {
      var a = i.next;
      (i.next = s.next), (s.next = a);
    }
    (r.baseQueue = i = s), (n.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var o = (a = null),
      l = null,
      u = s;
    do {
      var f = u.lane;
      if ((dh & f) === f)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (r = u.hasEagerState ? u.eagerState : t(r, u.action));
      else {
        var c = {
          lane: f,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        l === null ? ((o = l = c), (a = r)) : (l = l.next = c),
          (li.lanes |= f),
          (hh |= f);
      }
      u = u.next;
    } while (u !== null && u !== s);
    l === null ? (a = r) : (l.next = o),
      au(r, e.memoizedState) || (Ja = !0),
      (e.memoizedState = r),
      (e.baseState = a),
      (e.baseQueue = l),
      (n.lastRenderedState = r);
  }
  if (((t = n.interleaved), t !== null)) {
    i = t;
    do (s = i.lane), (li.lanes |= s), (hh |= s), (i = i.next);
    while (i !== t);
  } else i === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function p_(t) {
  var e = ml(),
    n = e.queue;
  if (n === null) throw Error(Qe(311));
  n.lastRenderedReducer = t;
  var r = n.dispatch,
    i = n.pending,
    s = e.memoizedState;
  if (i !== null) {
    n.pending = null;
    var a = (i = i.next);
    do (s = t(s, a.action)), (a = a.next);
    while (a !== i);
    au(s, e.memoizedState) || (Ja = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, r];
}
function JF() {}
function e$(t, e) {
  var n = li,
    r = ml(),
    i = e(),
    s = !au(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (Ja = !0)),
    (r = r.queue),
    t7(r$.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || s || (bs !== null && bs.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Ig(9, n$.bind(null, n, r, i, e), void 0, null),
      Ss === null)
    )
      throw Error(Qe(349));
    dh & 30 || t$(n, e, i);
  }
  return i;
}
function t$(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = li.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (li.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function n$(t, e, n, r) {
  (e.value = n), (e.getSnapshot = r), i$(e) && s$(t);
}
function r$(t, e, n) {
  return n(function () {
    i$(e) && s$(t);
  });
}
function i$(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !au(t, n);
  } catch {
    return !0;
  }
}
function s$(t) {
  var e = Wc(t, 1);
  e !== null && ru(e, t, 1, -1);
}
function Ak(t) {
  var e = ku();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: kg,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = Fne.bind(null, li, t)),
    [e.memoizedState, t]
  );
}
function Ig(t, e, n, r) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
    (e = li.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (li.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
    t
  );
}
function a$() {
  return ml().memoizedState;
}
function Wv(t, e, n, r) {
  var i = ku();
  (li.flags |= t),
    (i.memoizedState = Ig(1 | e, n, void 0, r === void 0 ? null : r));
}
function pw(t, e, n, r) {
  var i = ml();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (Yi !== null) {
    var a = Yi.memoizedState;
    if (((s = a.destroy), r !== null && Q9(r, a.deps))) {
      i.memoizedState = Ig(e, n, s, r);
      return;
    }
  }
  (li.flags |= t), (i.memoizedState = Ig(1 | e, n, s, r));
}
function Ck(t, e) {
  return Wv(8390656, 8, t, e);
}
function t7(t, e) {
  return pw(2048, 8, t, e);
}
function o$(t, e) {
  return pw(4, 2, t, e);
}
function l$(t, e) {
  return pw(4, 4, t, e);
}
function u$(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function c$(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), pw(4, 4, u$.bind(null, e, t), n)
  );
}
function n7() {}
function f$(t, e) {
  var n = ml();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Q9(e, r[1])
    ? r[0]
    : ((n.memoizedState = [t, e]), t);
}
function d$(t, e) {
  var n = ml();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Q9(e, r[1])
    ? r[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function h$(t, e, n) {
  return dh & 21
    ? (au(n, e) || ((n = gF()), (li.lanes |= n), (hh |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (Ja = !0)), (t.memoizedState = n));
}
function Lne(t, e) {
  var n = gr;
  (gr = n !== 0 && 4 > n ? n : 4), t(!0);
  var r = d_.transition;
  d_.transition = {};
  try {
    t(!1), e();
  } finally {
    (gr = n), (d_.transition = r);
  }
}
function p$() {
  return ml().memoizedState;
}
function Bne(t, e, n) {
  var r = Yf(t);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    m$(t))
  )
    g$(e, n);
  else if (((n = WF(t, e, n, r)), n !== null)) {
    var i = Sa();
    ru(n, t, r, i), y$(n, e, r);
  }
}
function Fne(t, e, n) {
  var r = Yf(t),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (m$(t)) g$(e, i);
  else {
    var s = t.alternate;
    if (
      t.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var a = e.lastRenderedState,
          o = s(a, n);
        if (((i.hasEagerState = !0), (i.eagerState = o), au(o, a))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), q9(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = WF(t, e, i, r)),
      n !== null && ((i = Sa()), ru(n, t, r, i), y$(n, e, r));
  }
}
function m$(t) {
  var e = t.alternate;
  return t === li || (e !== null && e === li);
}
function g$(t, e) {
  ng = Ub = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function y$(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), D9(t, n);
  }
}
var jb = {
    readContext: pl,
    useCallback: Ws,
    useContext: Ws,
    useEffect: Ws,
    useImperativeHandle: Ws,
    useInsertionEffect: Ws,
    useLayoutEffect: Ws,
    useMemo: Ws,
    useReducer: Ws,
    useRef: Ws,
    useState: Ws,
    useDebugValue: Ws,
    useDeferredValue: Ws,
    useTransition: Ws,
    useMutableSource: Ws,
    useSyncExternalStore: Ws,
    useId: Ws,
    unstable_isNewReconciler: !1,
  },
  $ne = {
    readContext: pl,
    useCallback: function (t, e) {
      return (ku().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: pl,
    useEffect: Ck,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        Wv(4194308, 4, u$.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return Wv(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return Wv(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = ku();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var r = ku();
      return (
        (e = n !== void 0 ? n(e) : e),
        (r.memoizedState = r.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (r.queue = t),
        (t = t.dispatch = Bne.bind(null, li, t)),
        [r.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = ku();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: Ak,
    useDebugValue: n7,
    useDeferredValue: function (t) {
      return (ku().memoizedState = t);
    },
    useTransition: function () {
      var t = Ak(!1),
        e = t[0];
      return (t = Lne.bind(null, t[1])), (ku().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var r = li,
        i = ku();
      if (Kr) {
        if (n === void 0) throw Error(Qe(407));
        n = n();
      } else {
        if (((n = e()), Ss === null)) throw Error(Qe(349));
        dh & 30 || t$(r, e, n);
      }
      i.memoizedState = n;
      var s = { value: n, getSnapshot: e };
      return (
        (i.queue = s),
        Ck(r$.bind(null, r, s, t), [t]),
        (r.flags |= 2048),
        Ig(9, n$.bind(null, r, s, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = ku(),
        e = Ss.identifierPrefix;
      if (Kr) {
        var n = Lc,
          r = Mc;
        (n = (r & ~(1 << (32 - nu(r) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = Cg++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = Mne++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  Une = {
    readContext: pl,
    useCallback: f$,
    useContext: pl,
    useEffect: t7,
    useImperativeHandle: c$,
    useInsertionEffect: o$,
    useLayoutEffect: l$,
    useMemo: d$,
    useReducer: h_,
    useRef: a$,
    useState: function () {
      return h_(kg);
    },
    useDebugValue: n7,
    useDeferredValue: function (t) {
      var e = ml();
      return h$(e, Yi.memoizedState, t);
    },
    useTransition: function () {
      var t = h_(kg)[0],
        e = ml().memoizedState;
      return [t, e];
    },
    useMutableSource: JF,
    useSyncExternalStore: e$,
    useId: p$,
    unstable_isNewReconciler: !1,
  },
  jne = {
    readContext: pl,
    useCallback: f$,
    useContext: pl,
    useEffect: t7,
    useImperativeHandle: c$,
    useInsertionEffect: o$,
    useLayoutEffect: l$,
    useMemo: d$,
    useReducer: p_,
    useRef: a$,
    useState: function () {
      return p_(kg);
    },
    useDebugValue: n7,
    useDeferredValue: function (t) {
      var e = ml();
      return Yi === null ? (e.memoizedState = t) : h$(e, Yi.memoizedState, t);
    },
    useTransition: function () {
      var t = p_(kg)[0],
        e = ml().memoizedState;
      return [t, e];
    },
    useMutableSource: JF,
    useSyncExternalStore: e$,
    useId: p$,
    unstable_isNewReconciler: !1,
  };
function I0(t, e) {
  try {
    var n = "",
      r = e;
    do (n += mte(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: t, source: e, stack: i, digest: null };
}
function m_(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function U4(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var Hne = typeof WeakMap == "function" ? WeakMap : Map;
function v$(t, e, n) {
  (n = $c(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = e.value;
  return (
    (n.callback = function () {
      zb || ((zb = !0), (Z4 = r)), U4(t, e);
    }),
    n
  );
}
function b$(t, e, n) {
  (n = $c(-1, n)), (n.tag = 3);
  var r = t.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        U4(t, e);
      });
  }
  var s = t.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        U4(t, e),
          typeof r != "function" &&
            (Zf === null ? (Zf = new Set([this])) : Zf.add(this));
        var a = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: a !== null ? a : "",
        });
      }),
    n
  );
}
function kk(t, e, n) {
  var r = t.pingCache;
  if (r === null) {
    r = t.pingCache = new Hne();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(n) || (i.add(n), (t = nre.bind(null, t, e, n)), e.then(t, t));
}
function Ik(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function Ok(t, e, n, r, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = $c(-1, 1)), (e.tag = 2), Xf(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var zne = rf.ReactCurrentOwner,
  Ja = !1;
function ga(t, e, n, r) {
  e.child = t === null ? YF(e, null, n, r) : C0(e, t.child, n, r);
}
function Pk(t, e, n, r, i) {
  n = n.render;
  var s = e.ref;
  return (
    i0(e, i),
    (r = J9(t, e, n, r, s, i)),
    (n = e7()),
    t !== null && !Ja
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        qc(t, e, i))
      : (Kr && n && j9(e), (e.flags |= 1), ga(t, e, r, i), e.child)
  );
}
function Nk(t, e, n, r, i) {
  if (t === null) {
    var s = n.type;
    return typeof s == "function" &&
      !c7(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), w$(t, e, s, r, i))
      : ((t = Zv(n.type, null, r, e, e.mode, i)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((s = t.child), !(t.lanes & i))) {
    var a = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : _g), n(a, r) && t.ref === e.ref)
    )
      return qc(t, e, i);
  }
  return (
    (e.flags |= 1),
    (t = Qf(s, r)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function w$(t, e, n, r, i) {
  if (t !== null) {
    var s = t.memoizedProps;
    if (_g(s, r) && t.ref === e.ref)
      if (((Ja = !1), (e.pendingProps = r = s), (t.lanes & i) !== 0))
        t.flags & 131072 && (Ja = !0);
      else return (e.lanes = t.lanes), qc(t, e, i);
  }
  return j4(t, e, n, r, i);
}
function _$(t, e, n) {
  var r = e.pendingProps,
    i = r.children,
    s = t !== null ? t.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Rr(Vp, So),
        (So |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = s !== null ? s.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Rr(Vp, So),
          (So |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        Rr(Vp, So),
        (So |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | n), (e.memoizedState = null)) : (r = n),
      Rr(Vp, So),
      (So |= r);
  return ga(t, e, i, n), e.child;
}
function E$(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function j4(t, e, n, r, i) {
  var s = no(n) ? ch : sa.current;
  return (
    (s = S0(e, s)),
    i0(e, i),
    (n = J9(t, e, n, r, s, i)),
    (r = e7()),
    t !== null && !Ja
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        qc(t, e, i))
      : (Kr && r && j9(e), (e.flags |= 1), ga(t, e, n, i), e.child)
  );
}
function Dk(t, e, n, r, i) {
  if (no(n)) {
    var s = !0;
    Db(e);
  } else s = !1;
  if ((i0(e, i), e.stateNode === null))
    qv(t, e), XF(e, n, r), $4(e, n, r, i), (r = !0);
  else if (t === null) {
    var a = e.stateNode,
      o = e.memoizedProps;
    a.props = o;
    var l = a.context,
      u = n.contextType;
    typeof u == "object" && u !== null
      ? (u = pl(u))
      : ((u = no(n) ? ch : sa.current), (u = S0(e, u)));
    var f = n.getDerivedStateFromProps,
      c =
        typeof f == "function" ||
        typeof a.getSnapshotBeforeUpdate == "function";
    c ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((o !== r || l !== u) && Tk(e, a, r, u)),
      (Pf = !1);
    var d = e.memoizedState;
    (a.state = d),
      Fb(e, r, a, i),
      (l = e.memoizedState),
      o !== r || d !== l || to.current || Pf
        ? (typeof f == "function" && (F4(e, n, f, r), (l = e.memoizedState)),
          (o = Pf || xk(e, n, o, r, d, l, u))
            ? (c ||
                (typeof a.UNSAFE_componentWillMount != "function" &&
                  typeof a.componentWillMount != "function") ||
                (typeof a.componentWillMount == "function" &&
                  a.componentWillMount(),
                typeof a.UNSAFE_componentWillMount == "function" &&
                  a.UNSAFE_componentWillMount()),
              typeof a.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (a.props = r),
          (a.state = l),
          (a.context = u),
          (r = o))
        : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (a = e.stateNode),
      qF(t, e),
      (o = e.memoizedProps),
      (u = e.type === e.elementType ? o : zl(e.type, o)),
      (a.props = u),
      (c = e.pendingProps),
      (d = a.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = pl(l))
        : ((l = no(n) ? ch : sa.current), (l = S0(e, l)));
    var p = n.getDerivedStateFromProps;
    (f =
      typeof p == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function") ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((o !== c || d !== l) && Tk(e, a, r, l)),
      (Pf = !1),
      (d = e.memoizedState),
      (a.state = d),
      Fb(e, r, a, i);
    var m = e.memoizedState;
    o !== c || d !== m || to.current || Pf
      ? (typeof p == "function" && (F4(e, n, p, r), (m = e.memoizedState)),
        (u = Pf || xk(e, n, u, r, d, m, l) || !1)
          ? (f ||
              (typeof a.UNSAFE_componentWillUpdate != "function" &&
                typeof a.componentWillUpdate != "function") ||
              (typeof a.componentWillUpdate == "function" &&
                a.componentWillUpdate(r, m, l),
              typeof a.UNSAFE_componentWillUpdate == "function" &&
                a.UNSAFE_componentWillUpdate(r, m, l)),
            typeof a.componentDidUpdate == "function" && (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof a.componentDidUpdate != "function" ||
              (o === t.memoizedProps && d === t.memoizedState) ||
              (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate != "function" ||
              (o === t.memoizedProps && d === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = m)),
        (a.props = r),
        (a.state = m),
        (a.context = l),
        (r = u))
      : (typeof a.componentDidUpdate != "function" ||
          (o === t.memoizedProps && d === t.memoizedState) ||
          (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" ||
          (o === t.memoizedProps && d === t.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return H4(t, e, n, r, s, i);
}
function H4(t, e, n, r, i, s) {
  E$(t, e);
  var a = (e.flags & 128) !== 0;
  if (!r && !a) return i && vk(e, n, !1), qc(t, e, s);
  (r = e.stateNode), (zne.current = e);
  var o =
    a && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    t !== null && a
      ? ((e.child = C0(e, t.child, null, s)), (e.child = C0(e, null, o, s)))
      : ga(t, e, o, s),
    (e.memoizedState = r.state),
    i && vk(e, n, !0),
    e.child
  );
}
function x$(t) {
  var e = t.stateNode;
  e.pendingContext
    ? yk(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && yk(t, e.context, !1),
    X9(t, e.containerInfo);
}
function Rk(t, e, n, r, i) {
  return A0(), z9(i), (e.flags |= 256), ga(t, e, n, r), e.child;
}
var z4 = { dehydrated: null, treeContext: null, retryLane: 0 };
function V4(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function T$(t, e, n) {
  var r = e.pendingProps,
    i = ii.current,
    s = !1,
    a = (e.flags & 128) !== 0,
    o;
  if (
    ((o = a) ||
      (o = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    o
      ? ((s = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (i |= 1),
    Rr(ii, i & 1),
    t === null)
  )
    return (
      L4(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((a = r.children),
          (t = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (a = { mode: "hidden", children: a }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = a))
                : (s = yw(a, r, 0, null)),
              (t = ah(t, r, n, null)),
              (s.return = e),
              (t.return = e),
              (s.sibling = t),
              (e.child = s),
              (e.child.memoizedState = V4(n)),
              (e.memoizedState = z4),
              t)
            : r7(e, a))
    );
  if (((i = t.memoizedState), i !== null && ((o = i.dehydrated), o !== null)))
    return Vne(t, e, a, r, o, i, n);
  if (s) {
    (s = r.fallback), (a = e.mode), (i = t.child), (o = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(a & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = Qf(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      o !== null ? (s = Qf(o, s)) : ((s = ah(s, a, n, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (a = t.child.memoizedState),
      (a =
        a === null
          ? V4(n)
          : {
              baseLanes: a.baseLanes | n,
              cachePool: null,
              transitions: a.transitions,
            }),
      (s.memoizedState = a),
      (s.childLanes = t.childLanes & ~n),
      (e.memoizedState = z4),
      r
    );
  }
  return (
    (s = t.child),
    (t = s.sibling),
    (r = Qf(s, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = n),
    (r.return = e),
    (r.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function r7(t, e) {
  return (
    (e = yw({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function Z2(t, e, n, r) {
  return (
    r !== null && z9(r),
    C0(e, t.child, null, n),
    (t = r7(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function Vne(t, e, n, r, i, s, a) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (r = m_(Error(Qe(422)))), Z2(t, e, a, r))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((s = r.fallback),
        (i = e.mode),
        (r = yw({ mode: "visible", children: r.children }, i, 0, null)),
        (s = ah(s, i, a, null)),
        (s.flags |= 2),
        (r.return = e),
        (s.return = e),
        (r.sibling = s),
        (e.child = r),
        e.mode & 1 && C0(e, t.child, null, a),
        (e.child.memoizedState = V4(a)),
        (e.memoizedState = z4),
        s);
  if (!(e.mode & 1)) return Z2(t, e, a, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var o = r.dgst;
    return (
      (r = o), (s = Error(Qe(419))), (r = m_(s, r, void 0)), Z2(t, e, a, r)
    );
  }
  if (((o = (a & t.childLanes) !== 0), Ja || o)) {
    if (((r = Ss), r !== null)) {
      switch (a & -a) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | a) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), Wc(t, i), ru(r, t, i, -1));
    }
    return u7(), (r = m_(Error(Qe(421)))), Z2(t, e, a, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = rre.bind(null, t)),
      (i._reactRetry = e),
      null)
    : ((t = s.treeContext),
      (Oo = Kf(i.nextSibling)),
      (Do = e),
      (Kr = !0),
      (Xl = null),
      t !== null &&
        ((ll[ul++] = Mc),
        (ll[ul++] = Lc),
        (ll[ul++] = fh),
        (Mc = t.id),
        (Lc = t.overflow),
        (fh = e)),
      (e = r7(e, r.children)),
      (e.flags |= 4096),
      e);
}
function Mk(t, e, n) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), B4(t.return, e, n);
}
function g_(t, e, n, r, i) {
  var s = t.memoizedState;
  s === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i));
}
function S$(t, e, n) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((ga(t, e, r.children, n), (r = ii.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && Mk(t, n, e);
        else if (t.tag === 19) Mk(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    r &= 1;
  }
  if ((Rr(ii, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = e.child, i = null; n !== null; )
          (t = n.alternate),
            t !== null && $b(t) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = e.child), (e.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          g_(e, !1, i, n, s);
        break;
      case "backwards":
        for (n = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && $b(t) === null)) {
            e.child = i;
            break;
          }
          (t = i.sibling), (i.sibling = n), (n = i), (i = t);
        }
        g_(e, !0, n, null, s);
        break;
      case "together":
        g_(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function qv(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function qc(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (hh |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(Qe(153));
  if (e.child !== null) {
    for (
      t = e.child, n = Qf(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = Qf(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function Gne(t, e, n) {
  switch (e.tag) {
    case 3:
      x$(e), A0();
      break;
    case 5:
      QF(e);
      break;
    case 1:
      no(e.type) && Db(e);
      break;
    case 4:
      X9(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      Rr(Lb, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Rr(ii, ii.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? T$(t, e, n)
          : (Rr(ii, ii.current & 1),
            (t = qc(t, e, n)),
            t !== null ? t.sibling : null);
      Rr(ii, ii.current & 1);
      break;
    case 19:
      if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (r) return S$(t, e, n);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        Rr(ii, ii.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), _$(t, e, n);
  }
  return qc(t, e, n);
}
var A$, G4, C$, k$;
A$ = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
G4 = function () {};
C$ = function (t, e, n, r) {
  var i = t.memoizedProps;
  if (i !== r) {
    (t = e.stateNode), Xd(Hu.current);
    var s = null;
    switch (n) {
      case "input":
        (i = h4(t, i)), (r = h4(t, r)), (s = []);
        break;
      case "select":
        (i = ui({}, i, { value: void 0 })),
          (r = ui({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = g4(t, i)), (r = g4(t, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (t.onclick = Pb);
    }
    v4(n, r);
    var a;
    n = null;
    for (u in i)
      if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
        if (u === "style") {
          var o = i[u];
          for (a in o) o.hasOwnProperty(a) && (n || (n = {}), (n[a] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (pg.hasOwnProperty(u)
              ? s || (s = [])
              : (s = s || []).push(u, null));
    for (u in r) {
      var l = r[u];
      if (
        ((o = i?.[u]),
        r.hasOwnProperty(u) && l !== o && (l != null || o != null))
      )
        if (u === "style")
          if (o) {
            for (a in o)
              !o.hasOwnProperty(a) ||
                (l && l.hasOwnProperty(a)) ||
                (n || (n = {}), (n[a] = ""));
            for (a in l)
              l.hasOwnProperty(a) &&
                o[a] !== l[a] &&
                (n || (n = {}), (n[a] = l[a]));
          } else n || (s || (s = []), s.push(u, n)), (n = l);
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (o = o ? o.__html : void 0),
              l != null && o !== l && (s = s || []).push(u, l))
            : u === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(u, "" + l)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (pg.hasOwnProperty(u)
                ? (l != null && u === "onScroll" && Fr("scroll", t),
                  s || o === l || (s = []))
                : (s = s || []).push(u, l));
    }
    n && (s = s || []).push("style", n);
    var u = s;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
k$ = function (t, e, n, r) {
  n !== r && (e.flags |= 4);
};
function im(t, e) {
  if (!Kr)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (r.sibling = null);
    }
}
function qs(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0;
  if (e)
    for (var i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling);
  else
    for (i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = t),
        (i = i.sibling);
  return (t.subtreeFlags |= r), (t.childLanes = n), e;
}
function Wne(t, e, n) {
  var r = e.pendingProps;
  switch ((H9(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return qs(e), null;
    case 1:
      return no(e.type) && Nb(), qs(e), null;
    case 3:
      return (
        (r = e.stateNode),
        k0(),
        zr(to),
        zr(sa),
        Y9(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (t === null || t.child === null) &&
          (K2(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Xl !== null && (J4(Xl), (Xl = null)))),
        G4(t, e),
        qs(e),
        null
      );
    case 5:
      Z9(e);
      var i = Xd(Ag.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        C$(t, e, n, r, i),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(Qe(166));
          return qs(e), null;
        }
        if (((t = Xd(Hu.current)), K2(e))) {
          (r = e.stateNode), (n = e.type);
          var s = e.memoizedProps;
          switch (((r[Ru] = e), (r[Tg] = s), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              Fr("cancel", r), Fr("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Fr("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < Rm.length; i++) Fr(Rm[i], r);
              break;
            case "source":
              Fr("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Fr("error", r), Fr("load", r);
              break;
            case "details":
              Fr("toggle", r);
              break;
            case "input":
              VC(r, s), Fr("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                Fr("invalid", r);
              break;
            case "textarea":
              WC(r, s), Fr("invalid", r);
          }
          v4(n, s), (i = null);
          for (var a in s)
            if (s.hasOwnProperty(a)) {
              var o = s[a];
              a === "children"
                ? typeof o == "string"
                  ? r.textContent !== o &&
                    (s.suppressHydrationWarning !== !0 &&
                      q2(r.textContent, o, t),
                    (i = ["children", o]))
                  : typeof o == "number" &&
                    r.textContent !== "" + o &&
                    (s.suppressHydrationWarning !== !0 &&
                      q2(r.textContent, o, t),
                    (i = ["children", "" + o]))
                : pg.hasOwnProperty(a) &&
                  o != null &&
                  a === "onScroll" &&
                  Fr("scroll", r);
            }
          switch (n) {
            case "input":
              $2(r), GC(r, s, !0);
              break;
            case "textarea":
              $2(r), qC(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = Pb);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (a = i.nodeType === 9 ? i : i.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = tF(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = a.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof r.is == "string"
                ? (t = a.createElement(n, { is: r.is }))
                : ((t = a.createElement(n)),
                  n === "select" &&
                    ((a = t),
                    r.multiple
                      ? (a.multiple = !0)
                      : r.size && (a.size = r.size)))
              : (t = a.createElementNS(t, n)),
            (t[Ru] = e),
            (t[Tg] = r),
            A$(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((a = b4(n, r)), n)) {
              case "dialog":
                Fr("cancel", t), Fr("close", t), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Fr("load", t), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < Rm.length; i++) Fr(Rm[i], t);
                i = r;
                break;
              case "source":
                Fr("error", t), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Fr("error", t), Fr("load", t), (i = r);
                break;
              case "details":
                Fr("toggle", t), (i = r);
                break;
              case "input":
                VC(t, r), (i = h4(t, r)), Fr("invalid", t);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = ui({}, r, { value: void 0 })),
                  Fr("invalid", t);
                break;
              case "textarea":
                WC(t, r), (i = g4(t, r)), Fr("invalid", t);
                break;
              default:
                i = r;
            }
            v4(n, i), (o = i);
            for (s in o)
              if (o.hasOwnProperty(s)) {
                var l = o[s];
                s === "style"
                  ? iF(t, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && nF(t, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && mg(t, l)
                    : typeof l == "number" && mg(t, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (pg.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Fr("scroll", t)
                      : l != null && C9(t, s, l, a));
              }
            switch (n) {
              case "input":
                $2(t), GC(t, r, !1);
                break;
              case "textarea":
                $2(t), qC(t);
                break;
              case "option":
                r.value != null && t.setAttribute("value", "" + sd(r.value));
                break;
              case "select":
                (t.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? e0(t, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      e0(t, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (t.onclick = Pb);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return qs(e), null;
    case 6:
      if (t && e.stateNode != null) k$(t, e, t.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(Qe(166));
        if (((n = Xd(Ag.current)), Xd(Hu.current), K2(e))) {
          if (
            ((r = e.stateNode),
            (n = e.memoizedProps),
            (r[Ru] = e),
            (s = r.nodeValue !== n) && ((t = Do), t !== null))
          )
            switch (t.tag) {
              case 3:
                q2(r.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  q2(r.nodeValue, n, (t.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Ru] = e),
            (e.stateNode = r);
      }
      return qs(e), null;
    case 13:
      if (
        (zr(ii),
        (r = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (Kr && Oo !== null && e.mode & 1 && !(e.flags & 128))
          GF(), A0(), (e.flags |= 98560), (s = !1);
        else if (((s = K2(e)), r !== null && r.dehydrated !== null)) {
          if (t === null) {
            if (!s) throw Error(Qe(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Qe(317));
            s[Ru] = e;
          } else
            A0(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          qs(e), (s = !1);
        } else Xl !== null && (J4(Xl), (Xl = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((r = r !== null),
          r !== (t !== null && t.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || ii.current & 1 ? es === 0 && (es = 3) : u7())),
          e.updateQueue !== null && (e.flags |= 4),
          qs(e),
          null);
    case 4:
      return (
        k0(), G4(t, e), t === null && Eg(e.stateNode.containerInfo), qs(e), null
      );
    case 10:
      return W9(e.type._context), qs(e), null;
    case 17:
      return no(e.type) && Nb(), qs(e), null;
    case 19:
      if ((zr(ii), (s = e.memoizedState), s === null)) return qs(e), null;
      if (((r = (e.flags & 128) !== 0), (a = s.rendering), a === null))
        if (r) im(s, !1);
        else {
          if (es !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((a = $b(t)), a !== null)) {
                for (
                  e.flags |= 128,
                    im(s, !1),
                    r = a.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = n,
                    n = e.child;
                  n !== null;

                )
                  (s = n),
                    (t = r),
                    (s.flags &= 14680066),
                    (a = s.alternate),
                    a === null
                      ? ((s.childLanes = 0),
                        (s.lanes = t),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = a.childLanes),
                        (s.lanes = a.lanes),
                        (s.child = a.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = a.memoizedProps),
                        (s.memoizedState = a.memoizedState),
                        (s.updateQueue = a.updateQueue),
                        (s.type = a.type),
                        (t = a.dependencies),
                        (s.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return Rr(ii, (ii.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          s.tail !== null &&
            Ii() > O0 &&
            ((e.flags |= 128), (r = !0), im(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((t = $b(a)), t !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              im(s, !0),
              s.tail === null && s.tailMode === "hidden" && !a.alternate && !Kr)
            )
              return qs(e), null;
          } else
            2 * Ii() - s.renderingStartTime > O0 &&
              n !== 1073741824 &&
              ((e.flags |= 128), (r = !0), im(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((a.sibling = e.child), (e.child = a))
          : ((n = s.last),
            n !== null ? (n.sibling = a) : (e.child = a),
            (s.last = a));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Ii()),
          (e.sibling = null),
          (n = ii.current),
          Rr(ii, r ? (n & 1) | 2 : n & 1),
          e)
        : (qs(e), null);
    case 22:
    case 23:
      return (
        l7(),
        (r = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? So & 1073741824 && (qs(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : qs(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Qe(156, e.tag));
}
function qne(t, e) {
  switch ((H9(e), e.tag)) {
    case 1:
      return (
        no(e.type) && Nb(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        k0(),
        zr(to),
        zr(sa),
        Y9(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return Z9(e), null;
    case 13:
      if (
        (zr(ii), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Qe(340));
        A0();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return zr(ii), null;
    case 4:
      return k0(), null;
    case 10:
      return W9(e.type._context), null;
    case 22:
    case 23:
      return l7(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Y2 = !1,
  Qs = !1,
  Kne = typeof WeakSet == "function" ? WeakSet : Set,
  Ct = null;
function zp(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        wi(t, e, r);
      }
    else n.current = null;
}
function W4(t, e, n) {
  try {
    n();
  } catch (r) {
    wi(t, e, r);
  }
}
var Lk = !1;
function Xne(t, e) {
  if (((I4 = kb), (t = NF()), U9(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var a = 0,
            o = -1,
            l = -1,
            u = 0,
            f = 0,
            c = t,
            d = null;
          t: for (;;) {
            for (
              var p;
              c !== n || (i !== 0 && c.nodeType !== 3) || (o = a + i),
                c !== s || (r !== 0 && c.nodeType !== 3) || (l = a + r),
                c.nodeType === 3 && (a += c.nodeValue.length),
                (p = c.firstChild) !== null;

            )
              (d = c), (c = p);
            for (;;) {
              if (c === t) break t;
              if (
                (d === n && ++u === i && (o = a),
                d === s && ++f === r && (l = a),
                (p = c.nextSibling) !== null)
              )
                break;
              (c = d), (d = c.parentNode);
            }
            c = p;
          }
          n = o === -1 || l === -1 ? null : { start: o, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    O4 = { focusedElem: t, selectionRange: n }, kb = !1, Ct = e;
    Ct !== null;

  )
    if (((e = Ct), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (Ct = t);
    else
      for (; Ct !== null; ) {
        e = Ct;
        try {
          var m = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (m !== null) {
                  var g = m.memoizedProps,
                    w = m.memoizedState,
                    y = e.stateNode,
                    v = y.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? g : zl(e.type, g),
                      w
                    );
                  y.__reactInternalSnapshotBeforeUpdate = v;
                }
                break;
              case 3:
                var E = e.stateNode.containerInfo;
                E.nodeType === 1
                  ? (E.textContent = "")
                  : E.nodeType === 9 &&
                    E.documentElement &&
                    E.removeChild(E.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Qe(163));
            }
        } catch (S) {
          wi(e, e.return, S);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (Ct = t);
          break;
        }
        Ct = e.return;
      }
  return (m = Lk), (Lk = !1), m;
}
function rg(t, e, n) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & t) === t) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && W4(e, n, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function mw(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== e);
  }
}
function q4(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function I$(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), I$(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[Ru],
        delete e[Tg],
        delete e[D4],
        delete e[Pne],
        delete e[Nne])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function O$(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function Bk(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || O$(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function K4(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = Pb));
  else if (r !== 4 && ((t = t.child), t !== null))
    for (K4(t, e, n), t = t.sibling; t !== null; ) K4(t, e, n), (t = t.sibling);
}
function X4(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (r !== 4 && ((t = t.child), t !== null))
    for (X4(t, e, n), t = t.sibling; t !== null; ) X4(t, e, n), (t = t.sibling);
}
var Os = null,
  Gl = !1;
function wf(t, e, n) {
  for (n = n.child; n !== null; ) P$(t, e, n), (n = n.sibling);
}
function P$(t, e, n) {
  if (ju && typeof ju.onCommitFiberUnmount == "function")
    try {
      ju.onCommitFiberUnmount(ow, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Qs || zp(n, e);
    case 6:
      var r = Os,
        i = Gl;
      (Os = null),
        wf(t, e, n),
        (Os = r),
        (Gl = i),
        Os !== null &&
          (Gl
            ? ((t = Os),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Os.removeChild(n.stateNode));
      break;
    case 18:
      Os !== null &&
        (Gl
          ? ((t = Os),
            (n = n.stateNode),
            t.nodeType === 8
              ? u_(t.parentNode, n)
              : t.nodeType === 1 && u_(t, n),
            bg(t))
          : u_(Os, n.stateNode));
      break;
    case 4:
      (r = Os),
        (i = Gl),
        (Os = n.stateNode.containerInfo),
        (Gl = !0),
        wf(t, e, n),
        (Os = r),
        (Gl = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Qs &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            a = s.destroy;
          (s = s.tag),
            a !== void 0 && (s & 2 || s & 4) && W4(n, e, a),
            (i = i.next);
        } while (i !== r);
      }
      wf(t, e, n);
      break;
    case 1:
      if (
        !Qs &&
        (zp(n, e),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (o) {
          wi(n, e, o);
        }
      wf(t, e, n);
      break;
    case 21:
      wf(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((Qs = (r = Qs) || n.memoizedState !== null), wf(t, e, n), (Qs = r))
        : wf(t, e, n);
      break;
    default:
      wf(t, e, n);
  }
}
function Fk(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new Kne()),
      e.forEach(function (r) {
        var i = ire.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function Rl(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var s = t,
          a = e,
          o = a;
        e: for (; o !== null; ) {
          switch (o.tag) {
            case 5:
              (Os = o.stateNode), (Gl = !1);
              break e;
            case 3:
              (Os = o.stateNode.containerInfo), (Gl = !0);
              break e;
            case 4:
              (Os = o.stateNode.containerInfo), (Gl = !0);
              break e;
          }
          o = o.return;
        }
        if (Os === null) throw Error(Qe(160));
        P$(s, a, i), (Os = null), (Gl = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (u) {
        wi(i, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) N$(e, t), (e = e.sibling);
}
function N$(t, e) {
  var n = t.alternate,
    r = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Rl(e, t), xu(t), r & 4)) {
        try {
          rg(3, t, t.return), mw(3, t);
        } catch (g) {
          wi(t, t.return, g);
        }
        try {
          rg(5, t, t.return);
        } catch (g) {
          wi(t, t.return, g);
        }
      }
      break;
    case 1:
      Rl(e, t), xu(t), r & 512 && n !== null && zp(n, n.return);
      break;
    case 5:
      if (
        (Rl(e, t),
        xu(t),
        r & 512 && n !== null && zp(n, n.return),
        t.flags & 32)
      ) {
        var i = t.stateNode;
        try {
          mg(i, "");
        } catch (g) {
          wi(t, t.return, g);
        }
      }
      if (r & 4 && ((i = t.stateNode), i != null)) {
        var s = t.memoizedProps,
          a = n !== null ? n.memoizedProps : s,
          o = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            o === "input" && s.type === "radio" && s.name != null && JB(i, s),
              b4(o, a);
            var u = b4(o, s);
            for (a = 0; a < l.length; a += 2) {
              var f = l[a],
                c = l[a + 1];
              f === "style"
                ? iF(i, c)
                : f === "dangerouslySetInnerHTML"
                ? nF(i, c)
                : f === "children"
                ? mg(i, c)
                : C9(i, f, c, u);
            }
            switch (o) {
              case "input":
                p4(i, s);
                break;
              case "textarea":
                eF(i, s);
                break;
              case "select":
                var d = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var p = s.value;
                p != null
                  ? e0(i, !!s.multiple, p, !1)
                  : d !== !!s.multiple &&
                    (s.defaultValue != null
                      ? e0(i, !!s.multiple, s.defaultValue, !0)
                      : e0(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[Tg] = s;
          } catch (g) {
            wi(t, t.return, g);
          }
      }
      break;
    case 6:
      if ((Rl(e, t), xu(t), r & 4)) {
        if (t.stateNode === null) throw Error(Qe(162));
        (i = t.stateNode), (s = t.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (g) {
          wi(t, t.return, g);
        }
      }
      break;
    case 3:
      if (
        (Rl(e, t), xu(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          bg(e.containerInfo);
        } catch (g) {
          wi(t, t.return, g);
        }
      break;
    case 4:
      Rl(e, t), xu(t);
      break;
    case 13:
      Rl(e, t),
        xu(t),
        (i = t.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (a7 = Ii())),
        r & 4 && Fk(t);
      break;
    case 22:
      if (
        ((f = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((Qs = (u = Qs) || f), Rl(e, t), (Qs = u)) : Rl(e, t),
        xu(t),
        r & 8192)
      ) {
        if (
          ((u = t.memoizedState !== null),
          (t.stateNode.isHidden = u) && !f && t.mode & 1)
        )
          for (Ct = t, f = t.child; f !== null; ) {
            for (c = Ct = f; Ct !== null; ) {
              switch (((d = Ct), (p = d.child), d.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  rg(4, d, d.return);
                  break;
                case 1:
                  zp(d, d.return);
                  var m = d.stateNode;
                  if (typeof m.componentWillUnmount == "function") {
                    (r = d), (n = d.return);
                    try {
                      (e = r),
                        (m.props = e.memoizedProps),
                        (m.state = e.memoizedState),
                        m.componentWillUnmount();
                    } catch (g) {
                      wi(r, n, g);
                    }
                  }
                  break;
                case 5:
                  zp(d, d.return);
                  break;
                case 22:
                  if (d.memoizedState !== null) {
                    Uk(c);
                    continue;
                  }
              }
              p !== null ? ((p.return = d), (Ct = p)) : Uk(c);
            }
            f = f.sibling;
          }
        e: for (f = null, c = t; ; ) {
          if (c.tag === 5) {
            if (f === null) {
              f = c;
              try {
                (i = c.stateNode),
                  u
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((o = c.stateNode),
                      (l = c.memoizedProps.style),
                      (a =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (o.style.display = rF("display", a)));
              } catch (g) {
                wi(t, t.return, g);
              }
            }
          } else if (c.tag === 6) {
            if (f === null)
              try {
                c.stateNode.nodeValue = u ? "" : c.memoizedProps;
              } catch (g) {
                wi(t, t.return, g);
              }
          } else if (
            ((c.tag !== 22 && c.tag !== 23) ||
              c.memoizedState === null ||
              c === t) &&
            c.child !== null
          ) {
            (c.child.return = c), (c = c.child);
            continue;
          }
          if (c === t) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === t) break e;
            f === c && (f = null), (c = c.return);
          }
          f === c && (f = null), (c.sibling.return = c.return), (c = c.sibling);
        }
      }
      break;
    case 19:
      Rl(e, t), xu(t), r & 4 && Fk(t);
      break;
    case 21:
      break;
    default:
      Rl(e, t), xu(t);
  }
}
function xu(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (O$(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(Qe(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (mg(i, ""), (r.flags &= -33));
          var s = Bk(t);
          X4(t, s, i);
          break;
        case 3:
        case 4:
          var a = r.stateNode.containerInfo,
            o = Bk(t);
          K4(t, o, a);
          break;
        default:
          throw Error(Qe(161));
      }
    } catch (l) {
      wi(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function Zne(t, e, n) {
  (Ct = t), D$(t);
}
function D$(t, e, n) {
  for (var r = (t.mode & 1) !== 0; Ct !== null; ) {
    var i = Ct,
      s = i.child;
    if (i.tag === 22 && r) {
      var a = i.memoizedState !== null || Y2;
      if (!a) {
        var o = i.alternate,
          l = (o !== null && o.memoizedState !== null) || Qs;
        o = Y2;
        var u = Qs;
        if (((Y2 = a), (Qs = l) && !u))
          for (Ct = i; Ct !== null; )
            (a = Ct),
              (l = a.child),
              a.tag === 22 && a.memoizedState !== null
                ? jk(i)
                : l !== null
                ? ((l.return = a), (Ct = l))
                : jk(i);
        for (; s !== null; ) (Ct = s), D$(s), (s = s.sibling);
        (Ct = i), (Y2 = o), (Qs = u);
      }
      $k(t);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (Ct = s)) : $k(t);
  }
}
function $k(t) {
  for (; Ct !== null; ) {
    var e = Ct;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Qs || mw(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !Qs)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : zl(e.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && Ek(e, s, r);
              break;
            case 3:
              var a = e.updateQueue;
              if (a !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                Ek(e, a, n);
              }
              break;
            case 5:
              var o = e.stateNode;
              if (n === null && e.flags & 4) {
                n = o;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var f = u.memoizedState;
                  if (f !== null) {
                    var c = f.dehydrated;
                    c !== null && bg(c);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Qe(163));
          }
        Qs || (e.flags & 512 && q4(e));
      } catch (d) {
        wi(e, e.return, d);
      }
    }
    if (e === t) {
      Ct = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (Ct = n);
      break;
    }
    Ct = e.return;
  }
}
function Uk(t) {
  for (; Ct !== null; ) {
    var e = Ct;
    if (e === t) {
      Ct = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (Ct = n);
      break;
    }
    Ct = e.return;
  }
}
function jk(t) {
  for (; Ct !== null; ) {
    var e = Ct;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            mw(4, e);
          } catch (l) {
            wi(e, n, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              wi(e, i, l);
            }
          }
          var s = e.return;
          try {
            q4(e);
          } catch (l) {
            wi(e, s, l);
          }
          break;
        case 5:
          var a = e.return;
          try {
            q4(e);
          } catch (l) {
            wi(e, a, l);
          }
      }
    } catch (l) {
      wi(e, e.return, l);
    }
    if (e === t) {
      Ct = null;
      break;
    }
    var o = e.sibling;
    if (o !== null) {
      (o.return = e.return), (Ct = o);
      break;
    }
    Ct = e.return;
  }
}
var Yne = Math.ceil,
  Hb = rf.ReactCurrentDispatcher,
  i7 = rf.ReactCurrentOwner,
  hl = rf.ReactCurrentBatchConfig,
  rr = 0,
  Ss = null,
  Ui = null,
  Ds = 0,
  So = 0,
  Vp = gd(0),
  es = 0,
  Og = null,
  hh = 0,
  gw = 0,
  s7 = 0,
  ig = null,
  Za = null,
  a7 = 0,
  O0 = 1 / 0,
  Sc = null,
  zb = !1,
  Z4 = null,
  Zf = null,
  Q2 = !1,
  jf = null,
  Vb = 0,
  sg = 0,
  Y4 = null,
  Kv = -1,
  Xv = 0;
function Sa() {
  return rr & 6 ? Ii() : Kv !== -1 ? Kv : (Kv = Ii());
}
function Yf(t) {
  return t.mode & 1
    ? rr & 2 && Ds !== 0
      ? Ds & -Ds
      : Rne.transition !== null
      ? (Xv === 0 && (Xv = gF()), Xv)
      : ((t = gr),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : xF(t.type))),
        t)
    : 1;
}
function ru(t, e, n, r) {
  if (50 < sg) throw ((sg = 0), (Y4 = null), Error(Qe(185)));
  hy(t, n, r),
    (!(rr & 2) || t !== Ss) &&
      (t === Ss && (!(rr & 2) && (gw |= n), es === 4 && Bf(t, Ds)),
      ro(t, r),
      n === 1 && rr === 0 && !(e.mode & 1) && ((O0 = Ii() + 500), dw && yd()));
}
function ro(t, e) {
  var n = t.callbackNode;
  Rte(t, e);
  var r = Cb(t, t === Ss ? Ds : 0);
  if (r === 0)
    n !== null && ZC(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = r & -r), t.callbackPriority !== e)) {
    if ((n != null && ZC(n), e === 1))
      t.tag === 0 ? Dne(Hk.bind(null, t)) : HF(Hk.bind(null, t)),
        Ine(function () {
          !(rr & 6) && yd();
        }),
        (n = null);
    else {
      switch (yF(r)) {
        case 1:
          n = N9;
          break;
        case 4:
          n = pF;
          break;
        case 16:
          n = Ab;
          break;
        case 536870912:
          n = mF;
          break;
        default:
          n = Ab;
      }
      n = j$(n, R$.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function R$(t, e) {
  if (((Kv = -1), (Xv = 0), rr & 6)) throw Error(Qe(327));
  var n = t.callbackNode;
  if (s0() && t.callbackNode !== n) return null;
  var r = Cb(t, t === Ss ? Ds : 0);
  if (r === 0) return null;
  if (r & 30 || r & t.expiredLanes || e) e = Gb(t, r);
  else {
    e = r;
    var i = rr;
    rr |= 2;
    var s = L$();
    (Ss !== t || Ds !== e) && ((Sc = null), (O0 = Ii() + 500), sh(t, e));
    do
      try {
        ere();
        break;
      } catch (o) {
        M$(t, o);
      }
    while (1);
    G9(),
      (Hb.current = s),
      (rr = i),
      Ui !== null ? (e = 0) : ((Ss = null), (Ds = 0), (e = es));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = T4(t)), i !== 0 && ((r = i), (e = Q4(t, i)))), e === 1)
    )
      throw ((n = Og), sh(t, 0), Bf(t, r), ro(t, Ii()), n);
    if (e === 6) Bf(t, r);
    else {
      if (
        ((i = t.current.alternate),
        !(r & 30) &&
          !Qne(i) &&
          ((e = Gb(t, r)),
          e === 2 && ((s = T4(t)), s !== 0 && ((r = s), (e = Q4(t, s)))),
          e === 1))
      )
        throw ((n = Og), sh(t, 0), Bf(t, r), ro(t, Ii()), n);
      switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(Qe(345));
        case 2:
          jd(t, Za, Sc);
          break;
        case 3:
          if (
            (Bf(t, r), (r & 130023424) === r && ((e = a7 + 500 - Ii()), 10 < e))
          ) {
            if (Cb(t, 0) !== 0) break;
            if (((i = t.suspendedLanes), (i & r) !== r)) {
              Sa(), (t.pingedLanes |= t.suspendedLanes & i);
              break;
            }
            t.timeoutHandle = N4(jd.bind(null, t, Za, Sc), e);
            break;
          }
          jd(t, Za, Sc);
          break;
        case 4:
          if ((Bf(t, r), (r & 4194240) === r)) break;
          for (e = t.eventTimes, i = -1; 0 < r; ) {
            var a = 31 - nu(r);
            (s = 1 << a), (a = e[a]), a > i && (i = a), (r &= ~s);
          }
          if (
            ((r = i),
            (r = Ii() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * Yne(r / 1960)) - r),
            10 < r)
          ) {
            t.timeoutHandle = N4(jd.bind(null, t, Za, Sc), r);
            break;
          }
          jd(t, Za, Sc);
          break;
        case 5:
          jd(t, Za, Sc);
          break;
        default:
          throw Error(Qe(329));
      }
    }
  }
  return ro(t, Ii()), t.callbackNode === n ? R$.bind(null, t) : null;
}
function Q4(t, e) {
  var n = ig;
  return (
    t.current.memoizedState.isDehydrated && (sh(t, e).flags |= 256),
    (t = Gb(t, e)),
    t !== 2 && ((e = Za), (Za = n), e !== null && J4(e)),
    t
  );
}
function J4(t) {
  Za === null ? (Za = t) : Za.push.apply(Za, t);
}
function Qne(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!au(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Bf(t, e) {
  for (
    e &= ~s7,
      e &= ~gw,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - nu(e),
      r = 1 << n;
    (t[n] = -1), (e &= ~r);
  }
}
function Hk(t) {
  if (rr & 6) throw Error(Qe(327));
  s0();
  var e = Cb(t, 0);
  if (!(e & 1)) return ro(t, Ii()), null;
  var n = Gb(t, e);
  if (t.tag !== 0 && n === 2) {
    var r = T4(t);
    r !== 0 && ((e = r), (n = Q4(t, r)));
  }
  if (n === 1) throw ((n = Og), sh(t, 0), Bf(t, e), ro(t, Ii()), n);
  if (n === 6) throw Error(Qe(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    jd(t, Za, Sc),
    ro(t, Ii()),
    null
  );
}
function o7(t, e) {
  var n = rr;
  rr |= 1;
  try {
    return t(e);
  } finally {
    (rr = n), rr === 0 && ((O0 = Ii() + 500), dw && yd());
  }
}
function ph(t) {
  jf !== null && jf.tag === 0 && !(rr & 6) && s0();
  var e = rr;
  rr |= 1;
  var n = hl.transition,
    r = gr;
  try {
    if (((hl.transition = null), (gr = 1), t)) return t();
  } finally {
    (gr = r), (hl.transition = n), (rr = e), !(rr & 6) && yd();
  }
}
function l7() {
  (So = Vp.current), zr(Vp);
}
function sh(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), kne(n)), Ui !== null))
    for (n = Ui.return; n !== null; ) {
      var r = n;
      switch ((H9(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && Nb();
          break;
        case 3:
          k0(), zr(to), zr(sa), Y9();
          break;
        case 5:
          Z9(r);
          break;
        case 4:
          k0();
          break;
        case 13:
          zr(ii);
          break;
        case 19:
          zr(ii);
          break;
        case 10:
          W9(r.type._context);
          break;
        case 22:
        case 23:
          l7();
      }
      n = n.return;
    }
  if (
    ((Ss = t),
    (Ui = t = Qf(t.current, null)),
    (Ds = So = e),
    (es = 0),
    (Og = null),
    (s7 = gw = hh = 0),
    (Za = ig = null),
    Kd !== null)
  ) {
    for (e = 0; e < Kd.length; e++)
      if (((n = Kd[e]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          s = n.pending;
        if (s !== null) {
          var a = s.next;
          (s.next = i), (r.next = a);
        }
        n.pending = r;
      }
    Kd = null;
  }
  return t;
}
function M$(t, e) {
  do {
    var n = Ui;
    try {
      if ((G9(), (Gv.current = jb), Ub)) {
        for (var r = li.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        Ub = !1;
      }
      if (
        ((dh = 0),
        (bs = Yi = li = null),
        (ng = !1),
        (Cg = 0),
        (i7.current = null),
        n === null || n.return === null)
      ) {
        (es = 1), (Og = e), (Ui = null);
        break;
      }
      e: {
        var s = t,
          a = n.return,
          o = n,
          l = e;
        if (
          ((e = Ds),
          (o.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            f = o,
            c = f.tag;
          if (!(f.mode & 1) && (c === 0 || c === 11 || c === 15)) {
            var d = f.alternate;
            d
              ? ((f.updateQueue = d.updateQueue),
                (f.memoizedState = d.memoizedState),
                (f.lanes = d.lanes))
              : ((f.updateQueue = null), (f.memoizedState = null));
          }
          var p = Ik(a);
          if (p !== null) {
            (p.flags &= -257),
              Ok(p, a, o, s, e),
              p.mode & 1 && kk(s, u, e),
              (e = p),
              (l = u);
            var m = e.updateQueue;
            if (m === null) {
              var g = new Set();
              g.add(l), (e.updateQueue = g);
            } else m.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              kk(s, u, e), u7();
              break e;
            }
            l = Error(Qe(426));
          }
        } else if (Kr && o.mode & 1) {
          var w = Ik(a);
          if (w !== null) {
            !(w.flags & 65536) && (w.flags |= 256),
              Ok(w, a, o, s, e),
              z9(I0(l, o));
            break e;
          }
        }
        (s = l = I0(l, o)),
          es !== 4 && (es = 2),
          ig === null ? (ig = [s]) : ig.push(s),
          (s = a);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var y = v$(s, l, e);
              _k(s, y);
              break e;
            case 1:
              o = l;
              var v = s.type,
                E = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof v.getDerivedStateFromError == "function" ||
                  (E !== null &&
                    typeof E.componentDidCatch == "function" &&
                    (Zf === null || !Zf.has(E))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var S = b$(s, o, e);
                _k(s, S);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      F$(n);
    } catch (D) {
      (e = D), Ui === n && n !== null && (Ui = n = n.return);
      continue;
    }
    break;
  } while (1);
}
function L$() {
  var t = Hb.current;
  return (Hb.current = jb), t === null ? jb : t;
}
function u7() {
  (es === 0 || es === 3 || es === 2) && (es = 4),
    Ss === null || (!(hh & 268435455) && !(gw & 268435455)) || Bf(Ss, Ds);
}
function Gb(t, e) {
  var n = rr;
  rr |= 2;
  var r = L$();
  (Ss !== t || Ds !== e) && ((Sc = null), sh(t, e));
  do
    try {
      Jne();
      break;
    } catch (i) {
      M$(t, i);
    }
  while (1);
  if ((G9(), (rr = n), (Hb.current = r), Ui !== null)) throw Error(Qe(261));
  return (Ss = null), (Ds = 0), es;
}
function Jne() {
  for (; Ui !== null; ) B$(Ui);
}
function ere() {
  for (; Ui !== null && !Ste(); ) B$(Ui);
}
function B$(t) {
  var e = U$(t.alternate, t, So);
  (t.memoizedProps = t.pendingProps),
    e === null ? F$(t) : (Ui = e),
    (i7.current = null);
}
function F$(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = qne(n, e)), n !== null)) {
        (n.flags &= 32767), (Ui = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (es = 6), (Ui = null);
        return;
      }
    } else if (((n = Wne(n, e, So)), n !== null)) {
      Ui = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ui = e;
      return;
    }
    Ui = e = t;
  } while (e !== null);
  es === 0 && (es = 5);
}
function jd(t, e, n) {
  var r = gr,
    i = hl.transition;
  try {
    (hl.transition = null), (gr = 1), tre(t, e, n, r);
  } finally {
    (hl.transition = i), (gr = r);
  }
  return null;
}
function tre(t, e, n, r) {
  do s0();
  while (jf !== null);
  if (rr & 6) throw Error(Qe(327));
  n = t.finishedWork;
  var i = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(Qe(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (Mte(t, s),
    t === Ss && ((Ui = Ss = null), (Ds = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Q2 ||
      ((Q2 = !0),
      j$(Ab, function () {
        return s0(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = hl.transition), (hl.transition = null);
    var a = gr;
    gr = 1;
    var o = rr;
    (rr |= 4),
      (i7.current = null),
      Xne(t, n),
      N$(n, t),
      _ne(O4),
      (kb = !!I4),
      (O4 = I4 = null),
      (t.current = n),
      Zne(n),
      Ate(),
      (rr = o),
      (gr = a),
      (hl.transition = s);
  } else t.current = n;
  if (
    (Q2 && ((Q2 = !1), (jf = t), (Vb = i)),
    (s = t.pendingLanes),
    s === 0 && (Zf = null),
    Ite(n.stateNode),
    ro(t, Ii()),
    e !== null)
  )
    for (r = t.onRecoverableError, n = 0; n < e.length; n++)
      (i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (zb) throw ((zb = !1), (t = Z4), (Z4 = null), t);
  return (
    Vb & 1 && t.tag !== 0 && s0(),
    (s = t.pendingLanes),
    s & 1 ? (t === Y4 ? sg++ : ((sg = 0), (Y4 = t))) : (sg = 0),
    yd(),
    null
  );
}
function s0() {
  if (jf !== null) {
    var t = yF(Vb),
      e = hl.transition,
      n = gr;
    try {
      if (((hl.transition = null), (gr = 16 > t ? 16 : t), jf === null))
        var r = !1;
      else {
        if (((t = jf), (jf = null), (Vb = 0), rr & 6)) throw Error(Qe(331));
        var i = rr;
        for (rr |= 4, Ct = t.current; Ct !== null; ) {
          var s = Ct,
            a = s.child;
          if (Ct.flags & 16) {
            var o = s.deletions;
            if (o !== null) {
              for (var l = 0; l < o.length; l++) {
                var u = o[l];
                for (Ct = u; Ct !== null; ) {
                  var f = Ct;
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      rg(8, f, s);
                  }
                  var c = f.child;
                  if (c !== null) (c.return = f), (Ct = c);
                  else
                    for (; Ct !== null; ) {
                      f = Ct;
                      var d = f.sibling,
                        p = f.return;
                      if ((I$(f), f === u)) {
                        Ct = null;
                        break;
                      }
                      if (d !== null) {
                        (d.return = p), (Ct = d);
                        break;
                      }
                      Ct = p;
                    }
                }
              }
              var m = s.alternate;
              if (m !== null) {
                var g = m.child;
                if (g !== null) {
                  m.child = null;
                  do {
                    var w = g.sibling;
                    (g.sibling = null), (g = w);
                  } while (g !== null);
                }
              }
              Ct = s;
            }
          }
          if (s.subtreeFlags & 2064 && a !== null) (a.return = s), (Ct = a);
          else
            e: for (; Ct !== null; ) {
              if (((s = Ct), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    rg(9, s, s.return);
                }
              var y = s.sibling;
              if (y !== null) {
                (y.return = s.return), (Ct = y);
                break e;
              }
              Ct = s.return;
            }
        }
        var v = t.current;
        for (Ct = v; Ct !== null; ) {
          a = Ct;
          var E = a.child;
          if (a.subtreeFlags & 2064 && E !== null) (E.return = a), (Ct = E);
          else
            e: for (a = v; Ct !== null; ) {
              if (((o = Ct), o.flags & 2048))
                try {
                  switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                      mw(9, o);
                  }
                } catch (D) {
                  wi(o, o.return, D);
                }
              if (o === a) {
                Ct = null;
                break e;
              }
              var S = o.sibling;
              if (S !== null) {
                (S.return = o.return), (Ct = S);
                break e;
              }
              Ct = o.return;
            }
        }
        if (
          ((rr = i), yd(), ju && typeof ju.onPostCommitFiberRoot == "function")
        )
          try {
            ju.onPostCommitFiberRoot(ow, t);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (gr = n), (hl.transition = e);
    }
  }
  return !1;
}
function zk(t, e, n) {
  (e = I0(n, e)),
    (e = v$(t, e, 1)),
    (t = Xf(t, e, 1)),
    (e = Sa()),
    t !== null && (hy(t, 1, e), ro(t, e));
}
function wi(t, e, n) {
  if (t.tag === 3) zk(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        zk(e, t, n);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Zf === null || !Zf.has(r)))
        ) {
          (t = I0(n, t)),
            (t = b$(e, t, 1)),
            (e = Xf(e, t, 1)),
            (t = Sa()),
            e !== null && (hy(e, 1, t), ro(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function nre(t, e, n) {
  var r = t.pingCache;
  r !== null && r.delete(e),
    (e = Sa()),
    (t.pingedLanes |= t.suspendedLanes & n),
    Ss === t &&
      (Ds & n) === n &&
      (es === 4 || (es === 3 && (Ds & 130023424) === Ds && 500 > Ii() - a7)
        ? sh(t, 0)
        : (s7 |= n)),
    ro(t, e);
}
function $$(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = H2), (H2 <<= 1), !(H2 & 130023424) && (H2 = 4194304))
      : (e = 1));
  var n = Sa();
  (t = Wc(t, e)), t !== null && (hy(t, e, n), ro(t, n));
}
function rre(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), $$(t, n);
}
function ire(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        i = t.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = t.stateNode;
      break;
    default:
      throw Error(Qe(314));
  }
  r !== null && r.delete(e), $$(t, n);
}
var U$;
U$ = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || to.current) Ja = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (Ja = !1), Gne(t, e, n);
      Ja = !!(t.flags & 131072);
    }
  else (Ja = !1), Kr && e.flags & 1048576 && zF(e, Mb, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      qv(t, e), (t = e.pendingProps);
      var i = S0(e, sa.current);
      i0(e, n), (i = J9(null, e, r, t, i, n));
      var s = e7();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            no(r) ? ((s = !0), Db(e)) : (s = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            K9(e),
            (i.updater = hw),
            (e.stateNode = i),
            (i._reactInternals = e),
            $4(e, r, t, n),
            (e = H4(null, e, r, !0, s, n)))
          : ((e.tag = 0), Kr && s && j9(e), ga(null, e, i, n), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (qv(t, e),
          (t = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = are(r)),
          (t = zl(r, t)),
          i)
        ) {
          case 0:
            e = j4(null, e, r, t, n);
            break e;
          case 1:
            e = Dk(null, e, r, t, n);
            break e;
          case 11:
            e = Pk(null, e, r, t, n);
            break e;
          case 14:
            e = Nk(null, e, r, zl(r.type, t), n);
            break e;
        }
        throw Error(Qe(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : zl(r, i)),
        j4(t, e, r, i, n)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : zl(r, i)),
        Dk(t, e, r, i, n)
      );
    case 3:
      e: {
        if ((x$(e), t === null)) throw Error(Qe(387));
        (r = e.pendingProps),
          (s = e.memoizedState),
          (i = s.element),
          qF(t, e),
          Fb(e, r, null, n);
        var a = e.memoizedState;
        if (((r = a.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: a.cache,
              pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
              transitions: a.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (i = I0(Error(Qe(423)), e)), (e = Rk(t, e, r, n, i));
            break e;
          } else if (r !== i) {
            (i = I0(Error(Qe(424)), e)), (e = Rk(t, e, r, n, i));
            break e;
          } else
            for (
              Oo = Kf(e.stateNode.containerInfo.firstChild),
                Do = e,
                Kr = !0,
                Xl = null,
                n = YF(e, null, r, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((A0(), r === i)) {
            e = qc(t, e, n);
            break e;
          }
          ga(t, e, r, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        QF(e),
        t === null && L4(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = t !== null ? t.memoizedProps : null),
        (a = i.children),
        P4(r, i) ? (a = null) : s !== null && P4(r, s) && (e.flags |= 32),
        E$(t, e),
        ga(t, e, a, n),
        e.child
      );
    case 6:
      return t === null && L4(e), null;
    case 13:
      return T$(t, e, n);
    case 4:
      return (
        X9(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        t === null ? (e.child = C0(e, null, r, n)) : ga(t, e, r, n),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : zl(r, i)),
        Pk(t, e, r, i, n)
      );
    case 7:
      return ga(t, e, e.pendingProps, n), e.child;
    case 8:
      return ga(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return ga(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (a = i.value),
          Rr(Lb, r._currentValue),
          (r._currentValue = a),
          s !== null)
        )
          if (au(s.value, a)) {
            if (s.children === i.children && !to.current) {
              e = qc(t, e, n);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var o = s.dependencies;
              if (o !== null) {
                a = s.child;
                for (var l = o.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = $c(-1, n & -n)), (l.tag = 2);
                      var u = s.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var f = u.pending;
                        f === null
                          ? (l.next = l)
                          : ((l.next = f.next), (f.next = l)),
                          (u.pending = l);
                      }
                    }
                    (s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      B4(s.return, n, e),
                      (o.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) a = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((a = s.return), a === null)) throw Error(Qe(341));
                (a.lanes |= n),
                  (o = a.alternate),
                  o !== null && (o.lanes |= n),
                  B4(a, n, e),
                  (a = s.sibling);
              } else a = s.child;
              if (a !== null) a.return = s;
              else
                for (a = s; a !== null; ) {
                  if (a === e) {
                    a = null;
                    break;
                  }
                  if (((s = a.sibling), s !== null)) {
                    (s.return = a.return), (a = s);
                    break;
                  }
                  a = a.return;
                }
              s = a;
            }
        ga(t, e, i.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        i0(e, n),
        (i = pl(i)),
        (r = r(i)),
        (e.flags |= 1),
        ga(t, e, r, n),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = zl(r, e.pendingProps)),
        (i = zl(r.type, i)),
        Nk(t, e, r, i, n)
      );
    case 15:
      return w$(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : zl(r, i)),
        qv(t, e),
        (e.tag = 1),
        no(r) ? ((t = !0), Db(e)) : (t = !1),
        i0(e, n),
        XF(e, r, i),
        $4(e, r, i, n),
        H4(null, e, r, !0, t, n)
      );
    case 19:
      return S$(t, e, n);
    case 22:
      return _$(t, e, n);
  }
  throw Error(Qe(156, e.tag));
};
function j$(t, e) {
  return hF(t, e);
}
function sre(t, e, n, r) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function cl(t, e, n, r) {
  return new sre(t, e, n, r);
}
function c7(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function are(t) {
  if (typeof t == "function") return c7(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === I9)) return 11;
    if (t === O9) return 14;
  }
  return 2;
}
function Qf(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = cl(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function Zv(t, e, n, r, i, s) {
  var a = 2;
  if (((r = t), typeof t == "function")) c7(t) && (a = 1);
  else if (typeof t == "string") a = 5;
  else
    e: switch (t) {
      case Rp:
        return ah(n.children, i, s, e);
      case k9:
        (a = 8), (i |= 8);
        break;
      case u4:
        return (
          (t = cl(12, n, e, i | 2)), (t.elementType = u4), (t.lanes = s), t
        );
      case c4:
        return (t = cl(13, n, e, i)), (t.elementType = c4), (t.lanes = s), t;
      case f4:
        return (t = cl(19, n, e, i)), (t.elementType = f4), (t.lanes = s), t;
      case ZB:
        return yw(n, i, s, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case KB:
              a = 10;
              break e;
            case XB:
              a = 9;
              break e;
            case I9:
              a = 11;
              break e;
            case O9:
              a = 14;
              break e;
            case Of:
              (a = 16), (r = null);
              break e;
          }
        throw Error(Qe(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = cl(a, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = s), e
  );
}
function ah(t, e, n, r) {
  return (t = cl(7, t, r, e)), (t.lanes = n), t;
}
function yw(t, e, n, r) {
  return (
    (t = cl(22, t, r, e)),
    (t.elementType = ZB),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function y_(t, e, n) {
  return (t = cl(6, t, null, e)), (t.lanes = n), t;
}
function v_(t, e, n) {
  return (
    (e = cl(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function ore(t, e, n, r, i) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Q3(0)),
    (this.expirationTimes = Q3(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Q3(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function f7(t, e, n, r, i, s, a, o, l) {
  return (
    (t = new ore(t, e, n, o, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = cl(3, null, null, e)),
    (t.current = s),
    (s.stateNode = t),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    K9(s),
    t
  );
}
function lre(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Dp,
    key: r == null ? null : "" + r,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function H$(t) {
  if (!t) return ad;
  t = t._reactInternals;
  e: {
    if (Nh(t) !== t || t.tag !== 1) throw Error(Qe(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (no(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Qe(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (no(n)) return jF(t, n, e);
  }
  return e;
}
function z$(t, e, n, r, i, s, a, o, l) {
  return (
    (t = f7(n, r, !0, t, i, s, a, o, l)),
    (t.context = H$(null)),
    (n = t.current),
    (r = Sa()),
    (i = Yf(n)),
    (s = $c(r, i)),
    (s.callback = e ?? null),
    Xf(n, s, i),
    (t.current.lanes = i),
    hy(t, i, r),
    ro(t, r),
    t
  );
}
function vw(t, e, n, r) {
  var i = e.current,
    s = Sa(),
    a = Yf(i);
  return (
    (n = H$(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = $c(s, a)),
    (e.payload = { element: t }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (t = Xf(i, e, a)),
    t !== null && (ru(t, i, a, s), Vv(t, i, a)),
    a
  );
}
function Wb(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function Vk(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function d7(t, e) {
  Vk(t, e), (t = t.alternate) && Vk(t, e);
}
function ure() {
  return null;
}
var V$ =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function h7(t) {
  this._internalRoot = t;
}
bw.prototype.render = h7.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(Qe(409));
  vw(t, e, null, null);
};
bw.prototype.unmount = h7.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    ph(function () {
      vw(null, t, null, null);
    }),
      (e[Gc] = null);
  }
};
function bw(t) {
  this._internalRoot = t;
}
bw.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = wF();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < Lf.length && e !== 0 && e < Lf[n].priority; n++);
    Lf.splice(n, 0, t), n === 0 && EF(t);
  }
};
function p7(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function ww(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function Gk() {}
function cre(t, e, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var u = Wb(a);
        s.call(u);
      };
    }
    var a = z$(e, r, t, 0, null, !1, !1, "", Gk);
    return (
      (t._reactRootContainer = a),
      (t[Gc] = a.current),
      Eg(t.nodeType === 8 ? t.parentNode : t),
      ph(),
      a
    );
  }
  for (; (i = t.lastChild); ) t.removeChild(i);
  if (typeof r == "function") {
    var o = r;
    r = function () {
      var u = Wb(l);
      o.call(u);
    };
  }
  var l = f7(t, 0, !1, null, null, !1, !1, "", Gk);
  return (
    (t._reactRootContainer = l),
    (t[Gc] = l.current),
    Eg(t.nodeType === 8 ? t.parentNode : t),
    ph(function () {
      vw(e, l, n, r);
    }),
    l
  );
}
function _w(t, e, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
    var a = s;
    if (typeof i == "function") {
      var o = i;
      i = function () {
        var l = Wb(a);
        o.call(l);
      };
    }
    vw(e, a, t, i);
  } else a = cre(n, e, t, i, r);
  return Wb(a);
}
vF = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = Dm(e.pendingLanes);
        n !== 0 &&
          (D9(e, n | 1), ro(e, Ii()), !(rr & 6) && ((O0 = Ii() + 500), yd()));
      }
      break;
    case 13:
      ph(function () {
        var r = Wc(t, 1);
        if (r !== null) {
          var i = Sa();
          ru(r, t, 1, i);
        }
      }),
        d7(t, 1);
  }
};
R9 = function (t) {
  if (t.tag === 13) {
    var e = Wc(t, 134217728);
    if (e !== null) {
      var n = Sa();
      ru(e, t, 134217728, n);
    }
    d7(t, 134217728);
  }
};
bF = function (t) {
  if (t.tag === 13) {
    var e = Yf(t),
      n = Wc(t, e);
    if (n !== null) {
      var r = Sa();
      ru(n, t, e, r);
    }
    d7(t, e);
  }
};
wF = function () {
  return gr;
};
_F = function (t, e) {
  var n = gr;
  try {
    return (gr = t), e();
  } finally {
    gr = n;
  }
};
_4 = function (t, e, n) {
  switch (e) {
    case "input":
      if ((p4(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var r = n[e];
          if (r !== t && r.form === t.form) {
            var i = fw(r);
            if (!i) throw Error(Qe(90));
            QB(r), p4(r, i);
          }
        }
      }
      break;
    case "textarea":
      eF(t, n);
      break;
    case "select":
      (e = n.value), e != null && e0(t, !!n.multiple, e, !1);
  }
};
oF = o7;
lF = ph;
var fre = { usingClientEntryPoint: !1, Events: [my, Fp, fw, sF, aF, o7] },
  sm = {
    findFiberByHostInstance: qd,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  dre = {
    bundleType: sm.bundleType,
    version: sm.version,
    rendererPackageName: sm.rendererPackageName,
    rendererConfig: sm.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: rf.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = fF(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: sm.findFiberByHostInstance || ure,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var J2 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!J2.isDisabled && J2.supportsFiber)
    try {
      (ow = J2.inject(dre)), (ju = J2);
    } catch {}
}
Mo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fre;
Mo.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!p7(e)) throw Error(Qe(200));
  return lre(t, e, null, n);
};
Mo.createRoot = function (t, e) {
  if (!p7(t)) throw Error(Qe(299));
  var n = !1,
    r = "",
    i = V$;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = f7(t, 1, !1, null, null, n, !1, r, i)),
    (t[Gc] = e.current),
    Eg(t.nodeType === 8 ? t.parentNode : t),
    new h7(e)
  );
};
Mo.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(Qe(188))
      : ((t = Object.keys(t).join(",")), Error(Qe(268, t)));
  return (t = fF(e)), (t = t === null ? null : t.stateNode), t;
};
Mo.flushSync = function (t) {
  return ph(t);
};
Mo.hydrate = function (t, e, n) {
  if (!ww(e)) throw Error(Qe(200));
  return _w(null, t, e, !0, n);
};
Mo.hydrateRoot = function (t, e, n) {
  if (!p7(t)) throw Error(Qe(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = "",
    a = V$;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (a = n.onRecoverableError)),
    (e = z$(e, null, t, 1, n ?? null, i, !1, s, a)),
    (t[Gc] = e.current),
    Eg(t),
    r)
  )
    for (t = 0; t < r.length; t++)
      (n = r[t]),
        (i = n._getVersion),
        (i = i(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, i])
          : e.mutableSourceEagerHydrationData.push(n, i);
  return new bw(e);
};
Mo.render = function (t, e, n) {
  if (!ww(e)) throw Error(Qe(200));
  return _w(null, t, e, !1, n);
};
Mo.unmountComponentAtNode = function (t) {
  if (!ww(t)) throw Error(Qe(40));
  return t._reactRootContainer
    ? (ph(function () {
        _w(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[Gc] = null);
        });
      }),
      !0)
    : !1;
};
Mo.unstable_batchedUpdates = o7;
Mo.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
  if (!ww(n)) throw Error(Qe(200));
  if (t == null || t._reactInternals === void 0) throw Error(Qe(38));
  return _w(t, e, n, !1, r);
};
Mo.version = "18.2.0-next-9e3b772b8-20220608";
function G$() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(G$);
    } catch (t) {
      console.error(t);
    }
}
G$(), (zB.exports = Mo);
var W$ = zB.exports;
const Mm = oa(W$);
var Wk = W$;
(o4.createRoot = Wk.createRoot), (o4.hydrateRoot = Wk.hydrateRoot);
const hre = "modulepreload",
  pre = function (t) {
    return "/" + t;
  },
  qk = {},
  qe = function (e, n, r) {
    if (!n || n.length === 0) return e();
    const i = document.getElementsByTagName("link");
    return Promise.all(
      n.map((s) => {
        if (((s = pre(s)), s in qk)) return;
        qk[s] = !0;
        const a = s.endsWith(".css"),
          o = a ? '[rel="stylesheet"]' : "";
        if (!!r)
          for (let f = i.length - 1; f >= 0; f--) {
            const c = i[f];
            if (c.href === s && (!a || c.rel === "stylesheet")) return;
          }
        else if (document.querySelector(`link[href="${s}"]${o}`)) return;
        const u = document.createElement("link");
        if (
          ((u.rel = a ? "stylesheet" : hre),
          a || ((u.as = "script"), (u.crossOrigin = "")),
          (u.href = s),
          document.head.appendChild(u),
          a)
        )
          return new Promise((f, c) => {
            u.addEventListener("load", f),
              u.addEventListener("error", () =>
                c(new Error(`Unable to preload CSS for ${s}`))
              );
          });
      })
    )
      .then(() => e())
      .catch((s) => {
        const a = new Event("vite:preloadError", { cancelable: !0 });
        if (((a.payload = s), window.dispatchEvent(a), !a.defaultPrevented))
          throw s;
      });
  };
/**
 * @remix-run/router v1.13.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Pg() {
  return (
    (Pg = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Pg.apply(this, arguments)
  );
}
var Hf;
(function (t) {
  (t.Pop = "POP"), (t.Push = "PUSH"), (t.Replace = "REPLACE");
})(Hf || (Hf = {}));
const Kk = "popstate";
function mre(t) {
  t === void 0 && (t = {});
  function e(r, i) {
    let { pathname: s, search: a, hash: o } = r.location;
    return eE(
      "",
      { pathname: s, search: a, hash: o },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || "default"
    );
  }
  function n(r, i) {
    return typeof i == "string" ? i : qb(i);
  }
  return yre(e, n, null, t);
}
function Hi(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
function m7(t, e) {
  if (!t) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function gre() {
  return Math.random().toString(36).substr(2, 8);
}
function Xk(t, e) {
  return { usr: t.state, key: t.key, idx: e };
}
function eE(t, e, n, r) {
  return (
    n === void 0 && (n = null),
    Pg(
      { pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" },
      typeof e == "string" ? u1(e) : e,
      { state: n, key: (e && e.key) || r || gre() }
    )
  );
}
function qb(t) {
  let { pathname: e = "/", search: n = "", hash: r = "" } = t;
  return (
    n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n),
    r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r),
    e
  );
}
function u1(t) {
  let e = {};
  if (t) {
    let n = t.indexOf("#");
    n >= 0 && ((e.hash = t.substr(n)), (t = t.substr(0, n)));
    let r = t.indexOf("?");
    r >= 0 && ((e.search = t.substr(r)), (t = t.substr(0, r))),
      t && (e.pathname = t);
  }
  return e;
}
function yre(t, e, n, r) {
  r === void 0 && (r = {});
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    a = i.history,
    o = Hf.Pop,
    l = null,
    u = f();
  u == null && ((u = 0), a.replaceState(Pg({}, a.state, { idx: u }), ""));
  function f() {
    return (a.state || { idx: null }).idx;
  }
  function c() {
    o = Hf.Pop;
    let w = f(),
      y = w == null ? null : w - u;
    (u = w), l && l({ action: o, location: g.location, delta: y });
  }
  function d(w, y) {
    o = Hf.Push;
    let v = eE(g.location, w, y);
    n && n(v, w), (u = f() + 1);
    let E = Xk(v, u),
      S = g.createHref(v);
    try {
      a.pushState(E, "", S);
    } catch (D) {
      if (D instanceof DOMException && D.name === "DataCloneError") throw D;
      i.location.assign(S);
    }
    s && l && l({ action: o, location: g.location, delta: 1 });
  }
  function p(w, y) {
    o = Hf.Replace;
    let v = eE(g.location, w, y);
    n && n(v, w), (u = f());
    let E = Xk(v, u),
      S = g.createHref(v);
    a.replaceState(E, "", S),
      s && l && l({ action: o, location: g.location, delta: 0 });
  }
  function m(w) {
    let y = i.location.origin !== "null" ? i.location.origin : i.location.href,
      v = typeof w == "string" ? w : qb(w);
    return (
      Hi(
        y,
        "No window.location.(origin|href) available to create URL for href: " +
          v
      ),
      new URL(v, y)
    );
  }
  let g = {
    get action() {
      return o;
    },
    get location() {
      return t(i, a);
    },
    listen(w) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(Kk, c),
        (l = w),
        () => {
          i.removeEventListener(Kk, c), (l = null);
        }
      );
    },
    createHref(w) {
      return e(i, w);
    },
    createURL: m,
    encodeLocation(w) {
      let y = m(w);
      return { pathname: y.pathname, search: y.search, hash: y.hash };
    },
    push: d,
    replace: p,
    go(w) {
      return a.go(w);
    },
  };
  return g;
}
var Zk;
(function (t) {
  (t.data = "data"),
    (t.deferred = "deferred"),
    (t.redirect = "redirect"),
    (t.error = "error");
})(Zk || (Zk = {}));
function vre(t, e, n) {
  n === void 0 && (n = "/");
  let r = typeof e == "string" ? u1(e) : e,
    i = g7(r.pathname || "/", n);
  if (i == null) return null;
  let s = q$(t);
  bre(s);
  let a = null;
  for (let o = 0; a == null && o < s.length; ++o) a = kre(s[o], Pre(i));
  return a;
}
function q$(t, e, n, r) {
  e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let i = (s, a, o) => {
    let l = {
      relativePath: o === void 0 ? s.path || "" : o,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (Hi(
        l.relativePath.startsWith(r),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (l.relativePath = l.relativePath.slice(r.length)));
    let u = Jf([r, l.relativePath]),
      f = n.concat(l);
    s.children &&
      s.children.length > 0 &&
      (Hi(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + u + '".')
      ),
      q$(s.children, e, f, u)),
      !(s.path == null && !s.index) &&
        e.push({ path: u, score: Are(u, s.index), routesMeta: f });
  };
  return (
    t.forEach((s, a) => {
      var o;
      if (s.path === "" || !((o = s.path) != null && o.includes("?"))) i(s, a);
      else for (let l of K$(s.path)) i(s, a, l);
    }),
    e
  );
}
function K$(t) {
  let e = t.split("/");
  if (e.length === 0) return [];
  let [n, ...r] = e,
    i = n.endsWith("?"),
    s = n.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let a = K$(r.join("/")),
    o = [];
  return (
    o.push(...a.map((l) => (l === "" ? s : [s, l].join("/")))),
    i && o.push(...a),
    o.map((l) => (t.startsWith("/") && l === "" ? "/" : l))
  );
}
function bre(t) {
  t.sort((e, n) =>
    e.score !== n.score
      ? n.score - e.score
      : Cre(
          e.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  );
}
const wre = /^:\w+$/,
  _re = 3,
  Ere = 2,
  xre = 1,
  Tre = 10,
  Sre = -2,
  Yk = (t) => t === "*";
function Are(t, e) {
  let n = t.split("/"),
    r = n.length;
  return (
    n.some(Yk) && (r += Sre),
    e && (r += Ere),
    n
      .filter((i) => !Yk(i))
      .reduce((i, s) => i + (wre.test(s) ? _re : s === "" ? xre : Tre), r)
  );
}
function Cre(t, e) {
  return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i])
    ? t[t.length - 1] - e[e.length - 1]
    : 0;
}
function kre(t, e) {
  let { routesMeta: n } = t,
    r = {},
    i = "/",
    s = [];
  for (let a = 0; a < n.length; ++a) {
    let o = n[a],
      l = a === n.length - 1,
      u = i === "/" ? e : e.slice(i.length) || "/",
      f = Ire(
        { path: o.relativePath, caseSensitive: o.caseSensitive, end: l },
        u
      );
    if (!f) return null;
    Object.assign(r, f.params);
    let c = o.route;
    s.push({
      params: r,
      pathname: Jf([i, f.pathname]),
      pathnameBase: Mre(Jf([i, f.pathnameBase])),
      route: c,
    }),
      f.pathnameBase !== "/" && (i = Jf([i, f.pathnameBase]));
  }
  return s;
}
function Ire(t, e) {
  typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 });
  let [n, r] = Ore(t.path, t.caseSensitive, t.end),
    i = e.match(n);
  if (!i) return null;
  let s = i[0],
    a = s.replace(/(.)\/+$/, "$1"),
    o = i.slice(1);
  return {
    params: r.reduce((u, f, c) => {
      let { paramName: d, isOptional: p } = f;
      if (d === "*") {
        let g = o[c] || "";
        a = s.slice(0, s.length - g.length).replace(/(.)\/+$/, "$1");
      }
      const m = o[c];
      return p && !m ? (u[d] = void 0) : (u[d] = Nre(m || "", d)), u;
    }, {}),
    pathname: s,
    pathnameBase: a,
    pattern: t,
  };
}
function Ore(t, e, n) {
  e === void 0 && (e = !1),
    n === void 0 && (n = !0),
    m7(
      t === "*" || !t.endsWith("*") || t.endsWith("/*"),
      'Route path "' +
        t +
        '" will be treated as if it were ' +
        ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')
    );
  let r = [],
    i =
      "^" +
      t
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:(\w+)(\?)?/g,
          (a, o, l) => (
            r.push({ paramName: o, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    t.endsWith("*")
      ? (r.push({ paramName: "*" }),
        (i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : n
      ? (i += "\\/*$")
      : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, e ? void 0 : "i"), r]
  );
}
function Pre(t) {
  try {
    return decodeURI(t);
  } catch (e) {
    return (
      m7(
        !1,
        'The URL path "' +
          t +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      t
    );
  }
}
function Nre(t, e) {
  try {
    return decodeURIComponent(t);
  } catch (n) {
    return (
      m7(
        !1,
        'The value for the URL param "' +
          e +
          '" will not be decoded because' +
          (' the string "' +
            t +
            '" is a malformed URL segment. This is probably') +
          (" due to a bad percent encoding (" + n + ").")
      ),
      t
    );
  }
}
function g7(t, e) {
  if (e === "/") return t;
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
  let n = e.endsWith("/") ? e.length - 1 : e.length,
    r = t.charAt(n);
  return r && r !== "/" ? null : t.slice(n) || "/";
}
function Dre(t, e) {
  e === void 0 && (e = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = "",
  } = typeof t == "string" ? u1(t) : t;
  return {
    pathname: n ? (n.startsWith("/") ? n : Rre(n, e)) : e,
    search: Lre(r),
    hash: Bre(i),
  };
}
function Rre(t, e) {
  let n = e.replace(/\/+$/, "").split("/");
  return (
    t.split("/").forEach((i) => {
      i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
    }),
    n.length > 1 ? n.join("/") : "/"
  );
}
function b_(t, e, n, r) {
  return (
    "Cannot include a '" +
    t +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(r) +
      "].  Please separate it out to the ") +
    ("`to." + n + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function X$(t) {
  return t.filter(
    (e, n) => n === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function Z$(t, e, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof t == "string"
    ? (i = u1(t))
    : ((i = Pg({}, t)),
      Hi(
        !i.pathname || !i.pathname.includes("?"),
        b_("?", "pathname", "search", i)
      ),
      Hi(
        !i.pathname || !i.pathname.includes("#"),
        b_("#", "pathname", "hash", i)
      ),
      Hi(!i.search || !i.search.includes("#"), b_("#", "search", "hash", i)));
  let s = t === "" || i.pathname === "",
    a = s ? "/" : i.pathname,
    o;
  if (a == null) o = n;
  else if (r) {
    let c = e[e.length - 1].replace(/^\//, "").split("/");
    if (a.startsWith("..")) {
      let d = a.split("/");
      for (; d[0] === ".."; ) d.shift(), c.pop();
      i.pathname = d.join("/");
    }
    o = "/" + c.join("/");
  } else {
    let c = e.length - 1;
    if (a.startsWith("..")) {
      let d = a.split("/");
      for (; d[0] === ".."; ) d.shift(), (c -= 1);
      i.pathname = d.join("/");
    }
    o = c >= 0 ? e[c] : "/";
  }
  let l = Dre(i, o),
    u = a && a !== "/" && a.endsWith("/"),
    f = (s || a === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (u || f) && (l.pathname += "/"), l;
}
const Jf = (t) => t.join("/").replace(/\/\/+/g, "/"),
  Mre = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
  Lre = (t) => (!t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t),
  Bre = (t) => (!t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t);
function Fre(t) {
  return (
    t != null &&
    typeof t.status == "number" &&
    typeof t.statusText == "string" &&
    typeof t.internal == "boolean" &&
    "data" in t
  );
}
const Y$ = ["post", "put", "patch", "delete"];
new Set(Y$);
const $re = ["get", ...Y$];
new Set($re);
/**
 * React Router v6.20.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Kb() {
  return (
    (Kb = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Kb.apply(this, arguments)
  );
}
const y7 = Z.createContext(null),
  Ure = Z.createContext(null),
  c1 = Z.createContext(null),
  Ew = Z.createContext(null),
  vd = Z.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  Q$ = Z.createContext(null);
function jre(t, e) {
  let { relative: n } = e === void 0 ? {} : e;
  yy() || Hi(!1);
  let { basename: r, navigator: i } = Z.useContext(c1),
    { hash: s, pathname: a, search: o } = eU(t, { relative: n }),
    l = a;
  return (
    r !== "/" && (l = a === "/" ? r : Jf([r, a])),
    i.createHref({ pathname: l, search: o, hash: s })
  );
}
function yy() {
  return Z.useContext(Ew) != null;
}
function vy() {
  return yy() || Hi(!1), Z.useContext(Ew).location;
}
function J$(t) {
  Z.useContext(c1).static || Z.useLayoutEffect(t);
}
function Hre() {
  let { isDataRoute: t } = Z.useContext(vd);
  return t ? nie() : zre();
}
function zre() {
  yy() || Hi(!1);
  let t = Z.useContext(y7),
    { basename: e, navigator: n } = Z.useContext(c1),
    { matches: r } = Z.useContext(vd),
    { pathname: i } = vy(),
    s = JSON.stringify(X$(r).map((l) => l.pathnameBase)),
    a = Z.useRef(!1);
  return (
    J$(() => {
      a.current = !0;
    }),
    Z.useCallback(
      function (l, u) {
        if ((u === void 0 && (u = {}), !a.current)) return;
        if (typeof l == "number") {
          n.go(l);
          return;
        }
        let f = Z$(l, JSON.parse(s), i, u.relative === "path");
        t == null &&
          e !== "/" &&
          (f.pathname = f.pathname === "/" ? e : Jf([e, f.pathname])),
          (u.replace ? n.replace : n.push)(f, u.state, u);
      },
      [e, n, s, i, t]
    )
  );
}
function Vre() {
  let { matches: t } = Z.useContext(vd),
    e = t[t.length - 1];
  return e ? e.params : {};
}
function eU(t, e) {
  let { relative: n } = e === void 0 ? {} : e,
    { matches: r } = Z.useContext(vd),
    { pathname: i } = vy(),
    s = JSON.stringify(X$(r).map((a) => a.pathnameBase));
  return Z.useMemo(() => Z$(t, JSON.parse(s), i, n === "path"), [t, s, i, n]);
}
function Gre(t, e) {
  return Wre(t, e);
}
function Wre(t, e, n) {
  yy() || Hi(!1);
  let { navigator: r } = Z.useContext(c1),
    { matches: i } = Z.useContext(vd),
    s = i[i.length - 1],
    a = s ? s.params : {};
  s && s.pathname;
  let o = s ? s.pathnameBase : "/";
  s && s.route;
  let l = vy(),
    u;
  if (e) {
    var f;
    let g = typeof e == "string" ? u1(e) : e;
    o === "/" || ((f = g.pathname) != null && f.startsWith(o)) || Hi(!1),
      (u = g);
  } else u = l;
  let c = u.pathname || "/",
    d = o === "/" ? c : c.slice(o.length) || "/",
    p = vre(t, { pathname: d }),
    m = Yre(
      p &&
        p.map((g) =>
          Object.assign({}, g, {
            params: Object.assign({}, a, g.params),
            pathname: Jf([
              o,
              r.encodeLocation
                ? r.encodeLocation(g.pathname).pathname
                : g.pathname,
            ]),
            pathnameBase:
              g.pathnameBase === "/"
                ? o
                : Jf([
                    o,
                    r.encodeLocation
                      ? r.encodeLocation(g.pathnameBase).pathname
                      : g.pathnameBase,
                  ]),
          })
        ),
      i,
      n
    );
  return e && m
    ? Z.createElement(
        Ew.Provider,
        {
          value: {
            location: Kb(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              u
            ),
            navigationType: Hf.Pop,
          },
        },
        m
      )
    : m;
}
function qre() {
  let t = tie(),
    e = Fre(t)
      ? t.status + " " + t.statusText
      : t instanceof Error
      ? t.message
      : JSON.stringify(t),
    n = t instanceof Error ? t.stack : null,
    i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" },
    s = null;
  return Z.createElement(
    Z.Fragment,
    null,
    Z.createElement("h2", null, "Unexpected Application Error!"),
    Z.createElement("h3", { style: { fontStyle: "italic" } }, e),
    n ? Z.createElement("pre", { style: i }, n) : null,
    s
  );
}
const Kre = Z.createElement(qre, null);
class Xre extends Z.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, n) {
    return n.location !== e.location ||
      (n.revalidation !== "idle" && e.revalidation === "idle")
      ? { error: e.error, location: e.location, revalidation: e.revalidation }
      : {
          error: e.error || n.error,
          location: n.location,
          revalidation: e.revalidation || n.revalidation,
        };
  }
  componentDidCatch(e, n) {
    console.error(
      "React Router caught the following error during render",
      e,
      n
    );
  }
  render() {
    return this.state.error
      ? Z.createElement(
          vd.Provider,
          { value: this.props.routeContext },
          Z.createElement(Q$.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function Zre(t) {
  let { routeContext: e, match: n, children: r } = t,
    i = Z.useContext(y7);
  return (
    i &&
      i.static &&
      i.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    Z.createElement(vd.Provider, { value: e }, r)
  );
}
function Yre(t, e, n) {
  var r;
  if ((e === void 0 && (e = []), n === void 0 && (n = null), t == null)) {
    var i;
    if ((i = n) != null && i.errors) t = n.matches;
    else return null;
  }
  let s = t,
    a = (r = n) == null ? void 0 : r.errors;
  if (a != null) {
    let o = s.findIndex((l) => l.route.id && a?.[l.route.id]);
    o >= 0 || Hi(!1), (s = s.slice(0, Math.min(s.length, o + 1)));
  }
  return s.reduceRight((o, l, u) => {
    let f = l.route.id ? a?.[l.route.id] : null,
      c = null;
    n && (c = l.route.errorElement || Kre);
    let d = e.concat(s.slice(0, u + 1)),
      p = () => {
        let m;
        return (
          f
            ? (m = c)
            : l.route.Component
            ? (m = Z.createElement(l.route.Component, null))
            : l.route.element
            ? (m = l.route.element)
            : (m = o),
          Z.createElement(Zre, {
            match: l,
            routeContext: { outlet: o, matches: d, isDataRoute: n != null },
            children: m,
          })
        );
      };
    return n && (l.route.ErrorBoundary || l.route.errorElement || u === 0)
      ? Z.createElement(Xre, {
          location: n.location,
          revalidation: n.revalidation,
          component: c,
          error: f,
          children: p(),
          routeContext: { outlet: null, matches: d, isDataRoute: !0 },
        })
      : p();
  }, null);
}
var tU = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      t
    );
  })(tU || {}),
  Xb = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseLoaderData = "useLoaderData"),
      (t.UseActionData = "useActionData"),
      (t.UseRouteError = "useRouteError"),
      (t.UseNavigation = "useNavigation"),
      (t.UseRouteLoaderData = "useRouteLoaderData"),
      (t.UseMatches = "useMatches"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      (t.UseRouteId = "useRouteId"),
      t
    );
  })(Xb || {});
function Qre(t) {
  let e = Z.useContext(y7);
  return e || Hi(!1), e;
}
function Jre(t) {
  let e = Z.useContext(Ure);
  return e || Hi(!1), e;
}
function eie(t) {
  let e = Z.useContext(vd);
  return e || Hi(!1), e;
}
function nU(t) {
  let e = eie(),
    n = e.matches[e.matches.length - 1];
  return n.route.id || Hi(!1), n.route.id;
}
function tie() {
  var t;
  let e = Z.useContext(Q$),
    n = Jre(Xb.UseRouteError),
    r = nU(Xb.UseRouteError);
  return e || ((t = n.errors) == null ? void 0 : t[r]);
}
function nie() {
  let { router: t } = Qre(tU.UseNavigateStable),
    e = nU(Xb.UseNavigateStable),
    n = Z.useRef(!1);
  return (
    J$(() => {
      n.current = !0;
    }),
    Z.useCallback(
      function (i, s) {
        s === void 0 && (s = {}),
          n.current &&
            (typeof i == "number"
              ? t.navigate(i)
              : t.navigate(i, Kb({ fromRouteId: e }, s)));
      },
      [t, e]
    )
  );
}
function Li(t) {
  Hi(!1);
}
function rie(t) {
  let {
    basename: e = "/",
    children: n = null,
    location: r,
    navigationType: i = Hf.Pop,
    navigator: s,
    static: a = !1,
  } = t;
  yy() && Hi(!1);
  let o = e.replace(/^\/*/, "/"),
    l = Z.useMemo(() => ({ basename: o, navigator: s, static: a }), [o, s, a]);
  typeof r == "string" && (r = u1(r));
  let {
      pathname: u = "/",
      search: f = "",
      hash: c = "",
      state: d = null,
      key: p = "default",
    } = r,
    m = Z.useMemo(() => {
      let g = g7(u, o);
      return g == null
        ? null
        : {
            location: { pathname: g, search: f, hash: c, state: d, key: p },
            navigationType: i,
          };
    }, [o, u, f, c, d, p, i]);
  return m == null
    ? null
    : Z.createElement(
        c1.Provider,
        { value: l },
        Z.createElement(Ew.Provider, { children: n, value: m })
      );
}
function iie(t) {
  let { children: e, location: n } = t;
  return Gre(tE(e), n);
}
new Promise(() => {});
function tE(t, e) {
  e === void 0 && (e = []);
  let n = [];
  return (
    Z.Children.forEach(t, (r, i) => {
      if (!Z.isValidElement(r)) return;
      let s = [...e, i];
      if (r.type === Z.Fragment) {
        n.push.apply(n, tE(r.props.children, s));
        return;
      }
      r.type !== Li && Hi(!1), !r.props.index || !r.props.children || Hi(!1);
      let a = {
        id: r.props.id || s.join("-"),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary:
          r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      };
      r.props.children && (a.children = tE(r.props.children, s)), n.push(a);
    }),
    n
  );
}
/**
 * React Router DOM v6.20.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function nE() {
  return (
    (nE = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    nE.apply(this, arguments)
  );
}
function sie(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function aie(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
function oie(t, e) {
  return t.button === 0 && (!e || e === "_self") && !aie(t);
}
const lie = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "unstable_viewTransition",
  ],
  uie = "startTransition",
  Qk = rte[uie];
function cie(t) {
  let { basename: e, children: n, future: r, window: i } = t,
    s = Z.useRef();
  s.current == null && (s.current = mre({ window: i, v5Compat: !0 }));
  let a = s.current,
    [o, l] = Z.useState({ action: a.action, location: a.location }),
    { v7_startTransition: u } = r || {},
    f = Z.useCallback(
      (c) => {
        u && Qk ? Qk(() => l(c)) : l(c);
      },
      [l, u]
    );
  return (
    Z.useLayoutEffect(() => a.listen(f), [a, f]),
    Z.createElement(rie, {
      basename: e,
      children: n,
      location: o.location,
      navigationType: o.action,
      navigator: a,
    })
  );
}
const fie =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  die = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  rU = Z.forwardRef(function (e, n) {
    let {
        onClick: r,
        relative: i,
        reloadDocument: s,
        replace: a,
        state: o,
        target: l,
        to: u,
        preventScrollReset: f,
        unstable_viewTransition: c,
      } = e,
      d = sie(e, lie),
      { basename: p } = Z.useContext(c1),
      m,
      g = !1;
    if (typeof u == "string" && die.test(u) && ((m = u), fie))
      try {
        let E = new URL(window.location.href),
          S = u.startsWith("//") ? new URL(E.protocol + u) : new URL(u),
          D = g7(S.pathname, p);
        S.origin === E.origin && D != null
          ? (u = D + S.search + S.hash)
          : (g = !0);
      } catch {}
    let w = jre(u, { relative: i }),
      y = hie(u, {
        replace: a,
        state: o,
        target: l,
        preventScrollReset: f,
        relative: i,
        unstable_viewTransition: c,
      });
    function v(E) {
      r && r(E), E.defaultPrevented || y(E);
    }
    return Z.createElement(
      "a",
      nE({}, d, { href: m || w, onClick: g || s ? r : v, ref: n, target: l })
    );
  });
var Jk;
(function (t) {
  (t.UseScrollRestoration = "useScrollRestoration"),
    (t.UseSubmit = "useSubmit"),
    (t.UseSubmitFetcher = "useSubmitFetcher"),
    (t.UseFetcher = "useFetcher"),
    (t.useViewTransitionState = "useViewTransitionState");
})(Jk || (Jk = {}));
var eI;
(function (t) {
  (t.UseFetcher = "useFetcher"),
    (t.UseFetchers = "useFetchers"),
    (t.UseScrollRestoration = "useScrollRestoration");
})(eI || (eI = {}));
function hie(t, e) {
  let {
      target: n,
      replace: r,
      state: i,
      preventScrollReset: s,
      relative: a,
      unstable_viewTransition: o,
    } = e === void 0 ? {} : e,
    l = Hre(),
    u = vy(),
    f = eU(t, { relative: a });
  return Z.useCallback(
    (c) => {
      if (oie(c, n)) {
        c.preventDefault();
        let d = r !== void 0 ? r : qb(u) === qb(f);
        l(t, {
          replace: d,
          state: i,
          preventScrollReset: s,
          relative: a,
          unstable_viewTransition: o,
        });
      }
    },
    [u, l, f, r, i, n, t, s, a, o]
  );
}
function pie(t) {
  if (Array.isArray(t)) return t;
}
function mie(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function rE(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function iU(t, e) {
  if (t) {
    if (typeof t == "string") return rE(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return rE(t, e);
  }
}
function gie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yie(t, e) {
  return pie(t) || mie(t, e) || iU(t, e) || gie();
}
function Js(t) {
  "@babel/helpers - typeof";
  return (
    (Js =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Js(t)
  );
}
function ji() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  if (e) {
    for (var r = [], i = 0; i < e.length; i++) {
      var s = e[i];
      if (s) {
        var a = Js(s);
        if (a === "string" || a === "number") r.push(s);
        else if (a === "object") {
          var o = Array.isArray(s)
            ? s
            : Object.entries(s).map(function (l) {
                var u = yie(l, 2),
                  f = u[0],
                  c = u[1];
                return c ? f : null;
              });
          r = o.length
            ? r.concat(
                o.filter(function (l) {
                  return !!l;
                })
              )
            : r;
        }
      }
    }
    return r.join(" ");
  }
}
function v7(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function vie(t, e) {
  if (Js(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Js(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function sU(t) {
  var e = vie(t, "string");
  return Js(e) === "symbol" ? e : String(e);
}
function tI(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, sU(r.key), r);
  }
}
function b7(t, e, n) {
  return (
    e && tI(t.prototype, e),
    n && tI(t, n),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    t
  );
}
function w7(t, e, n) {
  return (
    (e = sU(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function w_(t, e) {
  var n = (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (!n) {
    if (
      Array.isArray(t) ||
      (n = bie(t)) ||
      (e && t && typeof t.length == "number")
    ) {
      n && (t = n);
      var r = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
        },
        e: function (u) {
          throw u;
        },
        f: i,
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0,
    a = !1,
    o;
  return {
    s: function () {
      n = n.call(t);
    },
    n: function () {
      var u = n.next();
      return (s = u.done), u;
    },
    e: function (u) {
      (a = !0), (o = u);
    },
    f: function () {
      try {
        !s && n.return != null && n.return();
      } finally {
        if (a) throw o;
      }
    },
  };
}
function bie(t, e) {
  if (t) {
    if (typeof t == "string") return nI(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return nI(t, e);
  }
}
function nI(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
var it = (function () {
  function t() {
    v7(this, t);
  }
  return (
    b7(t, null, [
      {
        key: "innerWidth",
        value: function (n) {
          if (n) {
            var r = n.offsetWidth,
              i = getComputedStyle(n);
            return (
              (r += parseFloat(i.paddingLeft) + parseFloat(i.paddingRight)), r
            );
          }
          return 0;
        },
      },
      {
        key: "width",
        value: function (n) {
          if (n) {
            var r = n.offsetWidth,
              i = getComputedStyle(n);
            return (
              (r -= parseFloat(i.paddingLeft) + parseFloat(i.paddingRight)), r
            );
          }
          return 0;
        },
      },
      {
        key: "getBrowserLanguage",
        value: function () {
          return (
            navigator.userLanguage ||
            (navigator.languages &&
              navigator.languages.length &&
              navigator.languages[0]) ||
            navigator.language ||
            navigator.browserLanguage ||
            navigator.systemLanguage ||
            "en"
          );
        },
      },
      {
        key: "getWindowScrollTop",
        value: function () {
          var n = document.documentElement;
          return (window.pageYOffset || n.scrollTop) - (n.clientTop || 0);
        },
      },
      {
        key: "getWindowScrollLeft",
        value: function () {
          var n = document.documentElement;
          return (window.pageXOffset || n.scrollLeft) - (n.clientLeft || 0);
        },
      },
      {
        key: "getOuterWidth",
        value: function (n, r) {
          if (n) {
            var i = n.offsetWidth || n.getBoundingClientRect().width;
            if (r) {
              var s = getComputedStyle(n);
              i += parseFloat(s.marginLeft) + parseFloat(s.marginRight);
            }
            return i;
          }
          return 0;
        },
      },
      {
        key: "getOuterHeight",
        value: function (n, r) {
          if (n) {
            var i = n.offsetHeight || n.getBoundingClientRect().height;
            if (r) {
              var s = getComputedStyle(n);
              i += parseFloat(s.marginTop) + parseFloat(s.marginBottom);
            }
            return i;
          }
          return 0;
        },
      },
      {
        key: "getClientHeight",
        value: function (n, r) {
          if (n) {
            var i = n.clientHeight;
            if (r) {
              var s = getComputedStyle(n);
              i += parseFloat(s.marginTop) + parseFloat(s.marginBottom);
            }
            return i;
          }
          return 0;
        },
      },
      {
        key: "getClientWidth",
        value: function (n, r) {
          if (n) {
            var i = n.clientWidth;
            if (r) {
              var s = getComputedStyle(n);
              i += parseFloat(s.marginLeft) + parseFloat(s.marginRight);
            }
            return i;
          }
          return 0;
        },
      },
      {
        key: "getViewport",
        value: function () {
          var n = window,
            r = document,
            i = r.documentElement,
            s = r.getElementsByTagName("body")[0],
            a = n.innerWidth || i.clientWidth || s.clientWidth,
            o = n.innerHeight || i.clientHeight || s.clientHeight;
          return { width: a, height: o };
        },
      },
      {
        key: "getOffset",
        value: function (n) {
          if (n) {
            var r = n.getBoundingClientRect();
            return {
              top:
                r.top +
                (window.pageYOffset ||
                  document.documentElement.scrollTop ||
                  document.body.scrollTop ||
                  0),
              left:
                r.left +
                (window.pageXOffset ||
                  document.documentElement.scrollLeft ||
                  document.body.scrollLeft ||
                  0),
            };
          }
          return { top: "auto", left: "auto" };
        },
      },
      {
        key: "index",
        value: function (n) {
          if (n)
            for (
              var r = n.parentNode.childNodes, i = 0, s = 0;
              s < r.length;
              s++
            ) {
              if (r[s] === n) return i;
              r[s].nodeType === 1 && i++;
            }
          return -1;
        },
      },
      {
        key: "addMultipleClasses",
        value: function (n, r) {
          if (n && r)
            if (n.classList)
              for (var i = r.split(" "), s = 0; s < i.length; s++)
                n.classList.add(i[s]);
            else
              for (var a = r.split(" "), o = 0; o < a.length; o++)
                n.className += " " + a[o];
        },
      },
      {
        key: "removeMultipleClasses",
        value: function (n, r) {
          if (n && r)
            if (n.classList)
              for (var i = r.split(" "), s = 0; s < i.length; s++)
                n.classList.remove(i[s]);
            else
              for (var a = r.split(" "), o = 0; o < a.length; o++)
                n.className = n.className.replace(
                  new RegExp(
                    "(^|\\b)" + a[o].split(" ").join("|") + "(\\b|$)",
                    "gi"
                  ),
                  " "
                );
        },
      },
      {
        key: "addClass",
        value: function (n, r) {
          n &&
            r &&
            (n.classList ? n.classList.add(r) : (n.className += " " + r));
        },
      },
      {
        key: "removeClass",
        value: function (n, r) {
          n &&
            r &&
            (n.classList
              ? n.classList.remove(r)
              : (n.className = n.className.replace(
                  new RegExp(
                    "(^|\\b)" + r.split(" ").join("|") + "(\\b|$)",
                    "gi"
                  ),
                  " "
                )));
        },
      },
      {
        key: "hasClass",
        value: function (n, r) {
          return n
            ? n.classList
              ? n.classList.contains(r)
              : new RegExp("(^| )" + r + "( |$)", "gi").test(n.className)
            : !1;
        },
      },
      {
        key: "find",
        value: function (n, r) {
          return n ? Array.from(n.querySelectorAll(r)) : [];
        },
      },
      {
        key: "findSingle",
        value: function (n, r) {
          return n ? n.querySelector(r) : null;
        },
      },
      {
        key: "getHeight",
        value: function (n) {
          if (n) {
            var r = n.offsetHeight,
              i = getComputedStyle(n);
            return (
              (r -=
                parseFloat(i.paddingTop) +
                parseFloat(i.paddingBottom) +
                parseFloat(i.borderTopWidth) +
                parseFloat(i.borderBottomWidth)),
              r
            );
          }
          return 0;
        },
      },
      {
        key: "getWidth",
        value: function (n) {
          if (n) {
            var r = n.offsetWidth,
              i = getComputedStyle(n);
            return (
              (r -=
                parseFloat(i.paddingLeft) +
                parseFloat(i.paddingRight) +
                parseFloat(i.borderLeftWidth) +
                parseFloat(i.borderRightWidth)),
              r
            );
          }
          return 0;
        },
      },
      {
        key: "alignOverlay",
        value: function (n, r, i) {
          var s =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
          n &&
            r &&
            (i === "self"
              ? this.relativePosition(n, r)
              : (s && (n.style.minWidth = t.getOuterWidth(r) + "px"),
                this.absolutePosition(n, r)));
        },
      },
      {
        key: "absolutePosition",
        value: function (n, r) {
          if (n) {
            var i = n.offsetParent
                ? { width: n.offsetWidth, height: n.offsetHeight }
                : this.getHiddenElementDimensions(n),
              s = i.height,
              a = i.width,
              o = r.offsetHeight,
              l = r.offsetWidth,
              u = r.getBoundingClientRect(),
              f = this.getWindowScrollTop(),
              c = this.getWindowScrollLeft(),
              d = this.getViewport(),
              p,
              m;
            u.top + o + s > d.height
              ? ((p = u.top + f - s),
                p < 0 && (p = f),
                (n.style.transformOrigin = "bottom"))
              : ((p = o + u.top + f), (n.style.transformOrigin = "top")),
              u.left + l + a > d.width
                ? (m = Math.max(0, u.left + c + l - a))
                : (m = u.left + c),
              (n.style.top = p + "px"),
              (n.style.left = m + "px");
          }
        },
      },
      {
        key: "relativePosition",
        value: function (n, r) {
          if (n) {
            var i = n.offsetParent
                ? { width: n.offsetWidth, height: n.offsetHeight }
                : this.getHiddenElementDimensions(n),
              s = r.offsetHeight,
              a = r.getBoundingClientRect(),
              o = this.getViewport(),
              l,
              u;
            a.top + s + i.height > o.height
              ? ((l = -1 * i.height),
                a.top + l < 0 && (l = -1 * a.top),
                (n.style.transformOrigin = "bottom"))
              : ((l = s), (n.style.transformOrigin = "top")),
              i.width > o.width
                ? (u = a.left * -1)
                : a.left + i.width > o.width
                ? (u = (a.left + i.width - o.width) * -1)
                : (u = 0),
              (n.style.top = l + "px"),
              (n.style.left = u + "px");
          }
        },
      },
      {
        key: "flipfitCollision",
        value: function (n, r) {
          var i = this,
            s =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : "left top",
            a =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : "left bottom",
            o = arguments.length > 4 ? arguments[4] : void 0;
          if (n && r) {
            var l = r.getBoundingClientRect(),
              u = this.getViewport(),
              f = s.split(" "),
              c = a.split(" "),
              d = function (y, v) {
                return v
                  ? +y.substring(y.search(/(\+|-)/g)) || 0
                  : y.substring(0, y.search(/(\+|-)/g)) || y;
              },
              p = {
                my: {
                  x: d(f[0]),
                  y: d(f[1] || f[0]),
                  offsetX: d(f[0], !0),
                  offsetY: d(f[1] || f[0], !0),
                },
                at: {
                  x: d(c[0]),
                  y: d(c[1] || c[0]),
                  offsetX: d(c[0], !0),
                  offsetY: d(c[1] || c[0], !0),
                },
              },
              m = {
                left: function () {
                  var y = p.my.offsetX + p.at.offsetX;
                  return (
                    y +
                    l.left +
                    (p.my.x === "left"
                      ? 0
                      : -1 *
                        (p.my.x === "center"
                          ? i.getOuterWidth(n) / 2
                          : i.getOuterWidth(n)))
                  );
                },
                top: function () {
                  var y = p.my.offsetY + p.at.offsetY;
                  return (
                    y +
                    l.top +
                    (p.my.y === "top"
                      ? 0
                      : -1 *
                        (p.my.y === "center"
                          ? i.getOuterHeight(n) / 2
                          : i.getOuterHeight(n)))
                  );
                },
              },
              g = {
                count: { x: 0, y: 0 },
                left: function () {
                  var y = m.left(),
                    v = t.getWindowScrollLeft();
                  (n.style.left = y + v + "px"),
                    this.count.x === 2
                      ? ((n.style.left = v + "px"), (this.count.x = 0))
                      : y < 0 &&
                        (this.count.x++,
                        (p.my.x = "left"),
                        (p.at.x = "right"),
                        (p.my.offsetX *= -1),
                        (p.at.offsetX *= -1),
                        this.right());
                },
                right: function () {
                  var y = m.left() + t.getOuterWidth(r),
                    v = t.getWindowScrollLeft();
                  (n.style.left = y + v + "px"),
                    this.count.x === 2
                      ? ((n.style.left =
                          u.width - t.getOuterWidth(n) + v + "px"),
                        (this.count.x = 0))
                      : y + t.getOuterWidth(n) > u.width &&
                        (this.count.x++,
                        (p.my.x = "right"),
                        (p.at.x = "left"),
                        (p.my.offsetX *= -1),
                        (p.at.offsetX *= -1),
                        this.left());
                },
                top: function () {
                  var y = m.top(),
                    v = t.getWindowScrollTop();
                  (n.style.top = y + v + "px"),
                    this.count.y === 2
                      ? ((n.style.left = v + "px"), (this.count.y = 0))
                      : y < 0 &&
                        (this.count.y++,
                        (p.my.y = "top"),
                        (p.at.y = "bottom"),
                        (p.my.offsetY *= -1),
                        (p.at.offsetY *= -1),
                        this.bottom());
                },
                bottom: function () {
                  var y = m.top() + t.getOuterHeight(r),
                    v = t.getWindowScrollTop();
                  (n.style.top = y + v + "px"),
                    this.count.y === 2
                      ? ((n.style.left =
                          u.height - t.getOuterHeight(n) + v + "px"),
                        (this.count.y = 0))
                      : y + t.getOuterHeight(r) > u.height &&
                        (this.count.y++,
                        (p.my.y = "bottom"),
                        (p.at.y = "top"),
                        (p.my.offsetY *= -1),
                        (p.at.offsetY *= -1),
                        this.top());
                },
                center: function (y) {
                  if (y === "y") {
                    var v = m.top() + t.getOuterHeight(r) / 2;
                    (n.style.top = v + t.getWindowScrollTop() + "px"),
                      v < 0
                        ? this.bottom()
                        : v + t.getOuterHeight(r) > u.height && this.top();
                  } else {
                    var E = m.left() + t.getOuterWidth(r) / 2;
                    (n.style.left = E + t.getWindowScrollLeft() + "px"),
                      E < 0
                        ? this.left()
                        : E + t.getOuterWidth(n) > u.width && this.right();
                  }
                },
              };
            g[p.at.x]("x"), g[p.at.y]("y"), this.isFunction(o) && o(p);
          }
        },
      },
      {
        key: "findCollisionPosition",
        value: function (n) {
          if (n) {
            var r = n === "top" || n === "bottom",
              i = n === "left" ? "right" : "left",
              s = n === "top" ? "bottom" : "top";
            return r
              ? { axis: "y", my: "center ".concat(s), at: "center ".concat(n) }
              : {
                  axis: "x",
                  my: "".concat(i, " center"),
                  at: "".concat(n, " center"),
                };
          }
        },
      },
      {
        key: "getParents",
        value: function (n) {
          var r =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          return n.parentNode === null
            ? r
            : this.getParents(n.parentNode, r.concat([n.parentNode]));
        },
      },
      {
        key: "getScrollableParents",
        value: function (n) {
          var r = [];
          if (n) {
            var i = this.getParents(n),
              s = /(auto|scroll)/,
              a = function (y) {
                var v = y ? getComputedStyle(y) : null;
                return (
                  v &&
                  (s.test(v.getPropertyValue("overflow")) ||
                    s.test(v.getPropertyValue("overflowX")) ||
                    s.test(v.getPropertyValue("overflowY")))
                );
              },
              o = w_(i),
              l;
            try {
              for (o.s(); !(l = o.n()).done; ) {
                var u = l.value,
                  f = u.nodeType === 1 && u.dataset.scrollselectors;
                if (f) {
                  var c = f.split(","),
                    d = w_(c),
                    p;
                  try {
                    for (d.s(); !(p = d.n()).done; ) {
                      var m = p.value,
                        g = this.findSingle(u, m);
                      g && a(g) && r.push(g);
                    }
                  } catch (w) {
                    d.e(w);
                  } finally {
                    d.f();
                  }
                }
                u.nodeType !== 9 && a(u) && r.push(u);
              }
            } catch (w) {
              o.e(w);
            } finally {
              o.f();
            }
          }
          return r;
        },
      },
      {
        key: "getHiddenElementOuterHeight",
        value: function (n) {
          if (n) {
            (n.style.visibility = "hidden"), (n.style.display = "block");
            var r = n.offsetHeight;
            return (
              (n.style.display = "none"), (n.style.visibility = "visible"), r
            );
          }
          return 0;
        },
      },
      {
        key: "getHiddenElementOuterWidth",
        value: function (n) {
          if (n) {
            (n.style.visibility = "hidden"), (n.style.display = "block");
            var r = n.offsetWidth;
            return (
              (n.style.display = "none"), (n.style.visibility = "visible"), r
            );
          }
          return 0;
        },
      },
      {
        key: "getHiddenElementDimensions",
        value: function (n) {
          var r = {};
          return (
            n &&
              ((n.style.visibility = "hidden"),
              (n.style.display = "block"),
              (r.width = n.offsetWidth),
              (r.height = n.offsetHeight),
              (n.style.display = "none"),
              (n.style.visibility = "visible")),
            r
          );
        },
      },
      {
        key: "fadeIn",
        value: function (n, r) {
          if (n) {
            n.style.opacity = 0;
            var i = +new Date(),
              s = 0,
              a = function o() {
                (s = +n.style.opacity + (new Date().getTime() - i) / r),
                  (n.style.opacity = s),
                  (i = +new Date()),
                  +s < 1 &&
                    ((window.requestAnimationFrame &&
                      requestAnimationFrame(o)) ||
                      setTimeout(o, 16));
              };
            a();
          }
        },
      },
      {
        key: "fadeOut",
        value: function (n, r) {
          if (n)
            var i = 1,
              s = 50,
              a = s / r,
              o = setInterval(function () {
                (i -= a),
                  i <= 0 && ((i = 0), clearInterval(o)),
                  (n.style.opacity = i);
              }, s);
        },
      },
      {
        key: "getUserAgent",
        value: function () {
          return navigator.userAgent;
        },
      },
      {
        key: "isIOS",
        value: function () {
          return (
            /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
          );
        },
      },
      {
        key: "isAndroid",
        value: function () {
          return /(android)/i.test(navigator.userAgent);
        },
      },
      {
        key: "isTouchDevice",
        value: function () {
          return (
            "ontouchstart" in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
          );
        },
      },
      {
        key: "isFunction",
        value: function (n) {
          return !!(n && n.constructor && n.call && n.apply);
        },
      },
      {
        key: "appendChild",
        value: function (n, r) {
          if (this.isElement(r)) r.appendChild(n);
          else if (r.el && r.el.nativeElement)
            r.el.nativeElement.appendChild(n);
          else throw new Error("Cannot append " + r + " to " + n);
        },
      },
      {
        key: "removeChild",
        value: function (n, r) {
          if (this.isElement(r)) r.removeChild(n);
          else if (r.el && r.el.nativeElement)
            r.el.nativeElement.removeChild(n);
          else throw new Error("Cannot remove " + n + " from " + r);
        },
      },
      {
        key: "isElement",
        value: function (n) {
          return (typeof HTMLElement > "u" ? "undefined" : Js(HTMLElement)) ===
            "object"
            ? n instanceof HTMLElement
            : n &&
                Js(n) === "object" &&
                n !== null &&
                n.nodeType === 1 &&
                typeof n.nodeName == "string";
        },
      },
      {
        key: "scrollInView",
        value: function (n, r) {
          var i = getComputedStyle(n).getPropertyValue("borderTopWidth"),
            s = i ? parseFloat(i) : 0,
            a = getComputedStyle(n).getPropertyValue("paddingTop"),
            o = a ? parseFloat(a) : 0,
            l = n.getBoundingClientRect(),
            u = r.getBoundingClientRect(),
            f =
              u.top +
              document.body.scrollTop -
              (l.top + document.body.scrollTop) -
              s -
              o,
            c = n.scrollTop,
            d = n.clientHeight,
            p = this.getOuterHeight(r);
          f < 0
            ? (n.scrollTop = c + f)
            : f + p > d && (n.scrollTop = c + f - d + p);
        },
      },
      {
        key: "clearSelection",
        value: function () {
          if (window.getSelection)
            window.getSelection().empty
              ? window.getSelection().empty()
              : window.getSelection().removeAllRanges &&
                window.getSelection().rangeCount > 0 &&
                window.getSelection().getRangeAt(0).getClientRects().length >
                  0 &&
                window.getSelection().removeAllRanges();
          else if (document.selection && document.selection.empty)
            try {
              document.selection.empty();
            } catch {}
        },
      },
      {
        key: "calculateScrollbarWidth",
        value: function (n) {
          if (n) {
            var r = getComputedStyle(n);
            return (
              n.offsetWidth -
              n.clientWidth -
              parseFloat(r.borderLeftWidth) -
              parseFloat(r.borderRightWidth)
            );
          } else {
            if (this.calculatedScrollbarWidth != null)
              return this.calculatedScrollbarWidth;
            var i = document.createElement("div");
            (i.className = "p-scrollbar-measure"), document.body.appendChild(i);
            var s = i.offsetWidth - i.clientWidth;
            return (
              document.body.removeChild(i),
              (this.calculatedScrollbarWidth = s),
              s
            );
          }
        },
      },
      {
        key: "getBrowser",
        value: function () {
          if (!this.browser) {
            var n = this.resolveUserAgent();
            (this.browser = {}),
              n.browser &&
                ((this.browser[n.browser] = !0),
                (this.browser.version = n.version)),
              this.browser.chrome
                ? (this.browser.webkit = !0)
                : this.browser.webkit && (this.browser.safari = !0);
          }
          return this.browser;
        },
      },
      {
        key: "resolveUserAgent",
        value: function () {
          var n = navigator.userAgent.toLowerCase(),
            r =
              /(chrome)[ ]([\w.]+)/.exec(n) ||
              /(webkit)[ ]([\w.]+)/.exec(n) ||
              /(opera)(?:.*version|)[ ]([\w.]+)/.exec(n) ||
              /(msie) ([\w.]+)/.exec(n) ||
              (n.indexOf("compatible") < 0 &&
                /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n)) ||
              [];
          return { browser: r[1] || "", version: r[2] || "0" };
        },
      },
      {
        key: "isVisible",
        value: function (n) {
          return (
            n &&
            (n.clientHeight !== 0 ||
              n.getClientRects().length !== 0 ||
              getComputedStyle(n).display !== "none")
          );
        },
      },
      {
        key: "isExist",
        value: function (n) {
          return n !== null && typeof n < "u" && n.nodeName && n.parentNode;
        },
      },
      {
        key: "hasDOM",
        value: function () {
          return !!(
            typeof window < "u" &&
            window.document &&
            window.document.createElement
          );
        },
      },
      {
        key: "getFocusableElements",
        value: function (n) {
          var r =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : "",
            i = t.find(
              n,
              'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])'
                .concat(
                  r,
                  `,
                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(
                  r,
                  `,
                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(
                  r,
                  `,
                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(
                  r,
                  `,
                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(
                  r,
                  `,
                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(
                  r,
                  `,
                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`
                )
                .concat(r)
            ),
            s = [],
            a = w_(i),
            o;
          try {
            for (a.s(); !(o = a.n()).done; ) {
              var l = o.value;
              getComputedStyle(l).display !== "none" &&
                getComputedStyle(l).visibility !== "hidden" &&
                s.push(l);
            }
          } catch (u) {
            a.e(u);
          } finally {
            a.f();
          }
          return s;
        },
      },
      {
        key: "getFirstFocusableElement",
        value: function (n, r) {
          var i = t.getFocusableElements(n, r);
          return i.length > 0 ? i[0] : null;
        },
      },
      {
        key: "getLastFocusableElement",
        value: function (n, r) {
          var i = t.getFocusableElements(n, r);
          return i.length > 0 ? i[i.length - 1] : null;
        },
      },
      {
        key: "focus",
        value: function (n, r) {
          var i = r === void 0 ? !0 : !r;
          n && document.activeElement !== n && n.focus({ preventScroll: i });
        },
      },
      {
        key: "getCursorOffset",
        value: function (n, r, i, s) {
          if (n) {
            var a = getComputedStyle(n),
              o = document.createElement("div");
            (o.style.position = "absolute"),
              (o.style.top = "0px"),
              (o.style.left = "0px"),
              (o.style.visibility = "hidden"),
              (o.style.pointerEvents = "none"),
              (o.style.overflow = a.overflow),
              (o.style.width = a.width),
              (o.style.height = a.height),
              (o.style.padding = a.padding),
              (o.style.border = a.border),
              (o.style.overflowWrap = a.overflowWrap),
              (o.style.whiteSpace = a.whiteSpace),
              (o.style.lineHeight = a.lineHeight),
              (o.innerHTML = r.replace(/\r\n|\r|\n/g, "<br />"));
            var l = document.createElement("span");
            (l.textContent = s), o.appendChild(l);
            var u = document.createTextNode(i);
            o.appendChild(u), document.body.appendChild(o);
            var f = l.offsetLeft,
              c = l.offsetTop,
              d = l.clientHeight;
            return (
              document.body.removeChild(o),
              {
                left: Math.abs(f - n.scrollLeft),
                top: Math.abs(c - n.scrollTop) + d,
              }
            );
          }
          return { top: "auto", left: "auto" };
        },
      },
      {
        key: "invokeElementMethod",
        value: function (n, r, i) {
          n[r].apply(n, i);
        },
      },
      {
        key: "isClickable",
        value: function (n) {
          var r = n.nodeName,
            i = n.parentElement && n.parentElement.nodeName;
          return (
            r === "INPUT" ||
            r === "TEXTAREA" ||
            r === "BUTTON" ||
            r === "A" ||
            i === "INPUT" ||
            i === "TEXTAREA" ||
            i === "BUTTON" ||
            i === "A" ||
            this.hasClass(n, "p-button") ||
            this.hasClass(n.parentElement, "p-button") ||
            this.hasClass(n.parentElement, "p-checkbox") ||
            this.hasClass(n.parentElement, "p-radiobutton")
          );
        },
      },
      {
        key: "applyStyle",
        value: function (n, r) {
          if (typeof r == "string") n.style.cssText = this.style;
          else for (var i in this.style) n.style[i] = r[i];
        },
      },
      {
        key: "exportCSV",
        value: function (n, r) {
          var i = new Blob([n], { type: "application/csv;charset=utf-8;" });
          if (window.navigator.msSaveOrOpenBlob)
            navigator.msSaveOrOpenBlob(i, r + ".csv");
          else {
            var s = t.saveAs({ name: r + ".csv", src: URL.createObjectURL(i) });
            s ||
              ((n = "data:text/csv;charset=utf-8," + n),
              window.open(encodeURI(n)));
          }
        },
      },
      {
        key: "saveAs",
        value: function (n) {
          if (n) {
            var r = document.createElement("a");
            if (r.download !== void 0) {
              var i = n.name,
                s = n.src;
              return (
                r.setAttribute("href", s),
                r.setAttribute("download", i),
                (r.style.display = "none"),
                document.body.appendChild(r),
                r.click(),
                document.body.removeChild(r),
                !0
              );
            }
          }
          return !1;
        },
      },
      {
        key: "createInlineStyle",
        value: function (n) {
          var r = document.createElement("style");
          try {
            n || (n = {}.REACT_APP_CSS_NONCE);
          } catch {}
          return (
            n && r.setAttribute("nonce", n), document.head.appendChild(r), r
          );
        },
      },
      {
        key: "removeInlineStyle",
        value: function (n) {
          if (this.isExist(n)) {
            try {
              document.head.removeChild(n);
            } catch {}
            n = null;
          }
          return n;
        },
      },
      {
        key: "getTargetElement",
        value: function (n) {
          if (!n) return null;
          if (n === "document") return document;
          if (n === "window") return window;
          if (Js(n) === "object" && n.hasOwnProperty("current"))
            return this.isExist(n.current) ? n.current : null;
          var r = function (a) {
              return !!(a && a.constructor && a.call && a.apply);
            },
            i = r(n) ? n() : n;
          return (i && i.nodeType === 9) || this.isExist(i) ? i : null;
        },
      },
      {
        key: "getAttributeNames",
        value: function (n) {
          var r, i, s;
          for (i = [], s = n.attributes, r = 0; r < s.length; ++r)
            i.push(s[r].nodeName);
          return i.sort(), i;
        },
      },
      {
        key: "isEqualElement",
        value: function (n, r) {
          var i, s, a, o, l;
          if (
            ((i = t.getAttributeNames(n)),
            (s = t.getAttributeNames(r)),
            i.join(",") !== s.join(","))
          )
            return !1;
          for (var u = 0; u < i.length; ++u)
            if (((a = i[u]), a === "style"))
              for (
                var f = n.style,
                  c = r.style,
                  d = /^\d+$/,
                  p = 0,
                  m = Object.keys(f);
                p < m.length;
                p++
              ) {
                var g = m[p];
                if (!d.test(g) && f[g] !== c[g]) return !1;
              }
            else if (n.getAttribute(a) !== r.getAttribute(a)) return !1;
          for (
            o = n.firstChild, l = r.firstChild;
            o && l;
            o = o.nextSibling, l = l.nextSibling
          ) {
            if (o.nodeType !== l.nodeType) return !1;
            if (o.nodeType === 1) {
              if (!t.isEqualElement(o, l)) return !1;
            } else if (o.nodeValue !== l.nodeValue) return !1;
          }
          return !(o || l);
        },
      },
    ]),
    t
  );
})();
w7(it, "DATA_PROPS", ["data-"]);
w7(it, "ARIA_PROPS", ["aria", "focus-target"]);
function wie() {
  var t = new Map();
  return {
    on: function (n, r) {
      var i = t.get(n);
      i ? i.push(r) : (i = [r]), t.set(n, i);
    },
    off: function (n, r) {
      var i = t.get(n);
      i && i.splice(i.indexOf(r) >>> 0, 1);
    },
    emit: function (n, r) {
      var i = t.get(n);
      i &&
        i.slice().forEach(function (s) {
          return s(r);
        });
    },
  };
}
function _ie(t) {
  if (Array.isArray(t)) return rE(t);
}
function Eie(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function xie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function aU(t) {
  return _ie(t) || Eie(t) || iU(t) || xie();
}
var Vn = (function () {
  function t() {
    v7(this, t);
  }
  return (
    b7(t, null, [
      {
        key: "equals",
        value: function (n, r, i) {
          return i && n && Js(n) === "object" && r && Js(r) === "object"
            ? this.resolveFieldData(n, i) === this.resolveFieldData(r, i)
            : this.deepEquals(n, r);
        },
      },
      {
        key: "deepEquals",
        value: function (n, r) {
          if (n === r) return !0;
          if (n && r && Js(n) == "object" && Js(r) == "object") {
            var i = Array.isArray(n),
              s = Array.isArray(r),
              a,
              o,
              l;
            if (i && s) {
              if (((o = n.length), o !== r.length)) return !1;
              for (a = o; a-- !== 0; )
                if (!this.deepEquals(n[a], r[a])) return !1;
              return !0;
            }
            if (i !== s) return !1;
            var u = n instanceof Date,
              f = r instanceof Date;
            if (u !== f) return !1;
            if (u && f) return n.getTime() === r.getTime();
            var c = n instanceof RegExp,
              d = r instanceof RegExp;
            if (c !== d) return !1;
            if (c && d) return n.toString() === r.toString();
            var p = Object.keys(n);
            if (((o = p.length), o !== Object.keys(r).length)) return !1;
            for (a = o; a-- !== 0; )
              if (!Object.prototype.hasOwnProperty.call(r, p[a])) return !1;
            for (a = o; a-- !== 0; )
              if (((l = p[a]), !this.deepEquals(n[l], r[l]))) return !1;
            return !0;
          }
          return n !== n && r !== r;
        },
      },
      {
        key: "resolveFieldData",
        value: function (n, r) {
          if (n && Object.keys(n).length && r) {
            if (this.isFunction(r)) return r(n);
            if (t.isNotEmpty(n[r])) return n[r];
            if (r.indexOf(".") === -1) return n[r];
            for (var i = r.split("."), s = n, a = 0, o = i.length; a < o; ++a) {
              if (s == null) return null;
              s = s[i[a]];
            }
            return s;
          } else return null;
        },
      },
      {
        key: "isFunction",
        value: function (n) {
          return !!(n && n.constructor && n.call && n.apply);
        },
      },
      {
        key: "isLetter",
        value: function (n) {
          return (
            n && (n.toUpperCase() != n.toLowerCase() || n.codePointAt(0) > 127)
          );
        },
      },
      {
        key: "findDiffKeys",
        value: function (n, r) {
          return !n || !r
            ? {}
            : Object.keys(n)
                .filter(function (i) {
                  return !r.hasOwnProperty(i);
                })
                .reduce(function (i, s) {
                  return (i[s] = n[s]), i;
                }, {});
        },
      },
      {
        key: "reduceKeys",
        value: function (n, r) {
          var i = {};
          return (
            !n ||
              !r ||
              r.length === 0 ||
              Object.keys(n)
                .filter(function (s) {
                  return r.some(function (a) {
                    return s.startsWith(a);
                  });
                })
                .forEach(function (s) {
                  (i[s] = n[s]), delete n[s];
                }),
            i
          );
        },
      },
      {
        key: "reorderArray",
        value: function (n, r, i) {
          var s;
          if (n && r !== i) {
            if (i >= n.length) for (s = i - n.length; s-- + 1; ) n.push(void 0);
            n.splice(i, 0, n.splice(r, 1)[0]);
          }
        },
      },
      {
        key: "findIndexInList",
        value: function (n, r, i) {
          var s = this;
          return r
            ? i
              ? r.findIndex(function (a) {
                  return s.equals(a, n, i);
                })
              : r.findIndex(function (a) {
                  return a === n;
                })
            : -1;
        },
      },
      {
        key: "getJSXElement",
        value: function (n) {
          for (
            var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1;
            s < r;
            s++
          )
            i[s - 1] = arguments[s];
          return this.isFunction(n) ? n.apply(void 0, i) : n;
        },
      },
      {
        key: "getPropValue",
        value: function (n) {
          for (
            var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1;
            s < r;
            s++
          )
            i[s - 1] = arguments[s];
          var a = i;
          return (
            i && i.length === 1 && (a = i[0]),
            this.isFunction(n) ? n.apply(void 0, aU(a)) : n
          );
        },
      },
      {
        key: "getRefElement",
        value: function (n) {
          return n
            ? Js(n) === "object" && n.hasOwnProperty("current")
              ? n.current
              : n
            : null;
        },
      },
      {
        key: "combinedRefs",
        value: function (n, r) {
          n &&
            r &&
            (typeof r == "function" ? r(n.current) : (r.current = n.current));
        },
      },
      {
        key: "removeAccents",
        value: function (n) {
          return (
            n &&
              n.search(/[\xC0-\xFF]/g) > -1 &&
              (n = n
                .replace(/[\xC0-\xC5]/g, "A")
                .replace(/[\xC6]/g, "AE")
                .replace(/[\xC7]/g, "C")
                .replace(/[\xC8-\xCB]/g, "E")
                .replace(/[\xCC-\xCF]/g, "I")
                .replace(/[\xD0]/g, "D")
                .replace(/[\xD1]/g, "N")
                .replace(/[\xD2-\xD6\xD8]/g, "O")
                .replace(/[\xD9-\xDC]/g, "U")
                .replace(/[\xDD]/g, "Y")
                .replace(/[\xDE]/g, "P")
                .replace(/[\xE0-\xE5]/g, "a")
                .replace(/[\xE6]/g, "ae")
                .replace(/[\xE7]/g, "c")
                .replace(/[\xE8-\xEB]/g, "e")
                .replace(/[\xEC-\xEF]/g, "i")
                .replace(/[\xF1]/g, "n")
                .replace(/[\xF2-\xF6\xF8]/g, "o")
                .replace(/[\xF9-\xFC]/g, "u")
                .replace(/[\xFE]/g, "p")
                .replace(/[\xFD\xFF]/g, "y")),
            n
          );
        },
      },
      {
        key: "isEmpty",
        value: function (n) {
          return (
            n == null ||
            n === "" ||
            (Array.isArray(n) && n.length === 0) ||
            (!(n instanceof Date) &&
              Js(n) === "object" &&
              Object.keys(n).length === 0)
          );
        },
      },
      {
        key: "isNotEmpty",
        value: function (n) {
          return !this.isEmpty(n);
        },
      },
      {
        key: "sort",
        value: function (n, r) {
          var i =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : 1,
            s = arguments.length > 3 ? arguments[3] : void 0,
            a =
              arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : 1,
            o = t.compare(n, r, s, i),
            l = i;
          return (t.isEmpty(n) || t.isEmpty(r)) && (l = a === 1 ? i : a), l * o;
        },
      },
      {
        key: "compare",
        value: function (n, r, i) {
          var s =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : 1,
            a = -1,
            o = t.isEmpty(n),
            l = t.isEmpty(r);
          return (
            o && l
              ? (a = 0)
              : o
              ? (a = s)
              : l
              ? (a = -s)
              : typeof n == "string" && typeof r == "string"
              ? (a = n.localeCompare(r, i, { numeric: !0 }))
              : (a = n < r ? -1 : n > r ? 1 : 0),
            a
          );
        },
      },
    ]),
    t
  );
})();
function iE() {
  return (
    (iE = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    iE.apply(this, arguments)
  );
}
function rI(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function Tie(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? rI(Object(n), !0).forEach(function (r) {
          w7(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : rI(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
var oU = (function () {
    function t() {
      v7(this, t);
    }
    return (
      b7(t, null, [
        {
          key: "getJSXIcon",
          value: function (n) {
            var r =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {},
              i =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {},
              s = null;
            if (n !== null) {
              var a = Js(n),
                o = ji(r.className, a === "string" && n);
              if (
                ((s = Z.createElement("span", iE({}, r, { className: o }))),
                a !== "string")
              ) {
                var l = Tie({ iconProps: r, element: s }, i);
                return Vn.getJSXElement(n, l);
              }
            }
            return s;
          },
        },
      ]),
      t
    );
  })(),
  iI = 0;
function lU() {
  var t =
    arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pr_id_";
  return iI++, "".concat(t).concat(iI);
}
function Sie() {
  var t = [],
    e = function (o, l) {
      var u =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 999,
        f = i(o, l, u),
        c = f.value + (f.key === o ? 0 : u) + 1;
      return t.push({ key: o, value: c }), c;
    },
    n = function (o) {
      t = t.filter(function (l) {
        return l.value !== o;
      });
    },
    r = function (o, l) {
      return i(o, l).value;
    },
    i = function (o, l) {
      var u =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return (
        aU(t)
          .reverse()
          .find(function (f) {
            return l ? !0 : f.key === o;
          }) || { key: o, value: u }
      );
    },
    s = function (o) {
      return (o && parseInt(o.style.zIndex, 10)) || 0;
    };
  return {
    get: s,
    set: function (o, l, u, f) {
      l && (l.style.zIndex = String(e(o, u, f)));
    },
    clear: function (o) {
      o && (n(wa.get(o)), (o.style.zIndex = ""));
    },
    getCurrent: function (o, l) {
      return r(o, l);
    },
  };
}
var wa = Sie(),
  Ks = Object.freeze({
    STARTS_WITH: "startsWith",
    CONTAINS: "contains",
    NOT_CONTAINS: "notContains",
    ENDS_WITH: "endsWith",
    EQUALS: "equals",
    NOT_EQUALS: "notEquals",
    IN: "in",
    LESS_THAN: "lt",
    LESS_THAN_OR_EQUAL_TO: "lte",
    GREATER_THAN: "gt",
    GREATER_THAN_OR_EQUAL_TO: "gte",
    BETWEEN: "between",
    DATE_IS: "dateIs",
    DATE_IS_NOT: "dateIsNot",
    DATE_BEFORE: "dateBefore",
    DATE_AFTER: "dateAfter",
    CUSTOM: "custom",
  }),
  PNe = Object.freeze({ AND: "and", OR: "or" });
function sI(t, e) {
  var n = (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (!n) {
    if (
      Array.isArray(t) ||
      (n = Aie(t)) ||
      (e && t && typeof t.length == "number")
    ) {
      n && (t = n);
      var r = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
        },
        e: function (u) {
          throw u;
        },
        f: i,
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0,
    a = !1,
    o;
  return {
    s: function () {
      n = n.call(t);
    },
    n: function () {
      var u = n.next();
      return (s = u.done), u;
    },
    e: function (u) {
      (a = !0), (o = u);
    },
    f: function () {
      try {
        !s && n.return != null && n.return();
      } finally {
        if (a) throw o;
      }
    },
  };
}
function Aie(t, e) {
  if (t) {
    if (typeof t == "string") return aI(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return aI(t, e);
  }
}
function aI(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
var NNe = {
  filter: function (e, n, r, i, s) {
    var a = [];
    if (!e) return a;
    var o = sI(e),
      l;
    try {
      for (o.s(); !(l = o.n()).done; ) {
        var u = l.value;
        if (typeof u == "string") {
          if (this.filters[i](u, r, s)) {
            a.push(u);
            continue;
          }
        } else {
          var f = sI(n),
            c;
          try {
            for (f.s(); !(c = f.n()).done; ) {
              var d = c.value,
                p = Vn.resolveFieldData(u, d);
              if (this.filters[i](p, r, s)) {
                a.push(u);
                break;
              }
            }
          } catch (m) {
            f.e(m);
          } finally {
            f.f();
          }
        }
      }
    } catch (m) {
      o.e(m);
    } finally {
      o.f();
    }
    return a;
  },
  filters: {
    startsWith: function (e, n, r) {
      if (n == null || n.trim() === "") return !0;
      if (e == null) return !1;
      var i = Vn.removeAccents(n.toString()).toLocaleLowerCase(r),
        s = Vn.removeAccents(e.toString()).toLocaleLowerCase(r);
      return s.slice(0, i.length) === i;
    },
    contains: function (e, n, r) {
      if (n == null || (typeof n == "string" && n.trim() === "")) return !0;
      if (e == null) return !1;
      var i = Vn.removeAccents(n.toString()).toLocaleLowerCase(r),
        s = Vn.removeAccents(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(i) !== -1;
    },
    notContains: function (e, n, r) {
      if (n == null || (typeof n == "string" && n.trim() === "")) return !0;
      if (e == null) return !1;
      var i = Vn.removeAccents(n.toString()).toLocaleLowerCase(r),
        s = Vn.removeAccents(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(i) === -1;
    },
    endsWith: function (e, n, r) {
      if (n == null || n.trim() === "") return !0;
      if (e == null) return !1;
      var i = Vn.removeAccents(n.toString()).toLocaleLowerCase(r),
        s = Vn.removeAccents(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(i, s.length - i.length) !== -1;
    },
    equals: function (e, n, r) {
      return n == null || (typeof n == "string" && n.trim() === "")
        ? !0
        : e == null
        ? !1
        : e.getTime && n.getTime
        ? e.getTime() === n.getTime()
        : Vn.removeAccents(e.toString()).toLocaleLowerCase(r) ===
          Vn.removeAccents(n.toString()).toLocaleLowerCase(r);
    },
    notEquals: function (e, n, r) {
      return n == null || (typeof n == "string" && n.trim() === "")
        ? !1
        : e == null
        ? !0
        : e.getTime && n.getTime
        ? e.getTime() !== n.getTime()
        : Vn.removeAccents(e.toString()).toLocaleLowerCase(r) !==
          Vn.removeAccents(n.toString()).toLocaleLowerCase(r);
    },
    in: function (e, n) {
      if (n == null || n.length === 0) return !0;
      for (var r = 0; r < n.length; r++) if (Vn.equals(e, n[r])) return !0;
      return !1;
    },
    between: function (e, n) {
      return n == null || n[0] == null || n[1] == null
        ? !0
        : e == null
        ? !1
        : e.getTime
        ? n[0].getTime() <= e.getTime() && e.getTime() <= n[1].getTime()
        : n[0] <= e && e <= n[1];
    },
    lt: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.getTime && n.getTime
        ? e.getTime() < n.getTime()
        : e < n;
    },
    lte: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.getTime && n.getTime
        ? e.getTime() <= n.getTime()
        : e <= n;
    },
    gt: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.getTime && n.getTime
        ? e.getTime() > n.getTime()
        : e > n;
    },
    gte: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.getTime && n.getTime
        ? e.getTime() >= n.getTime()
        : e >= n;
    },
    dateIs: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.toDateString() === n.toDateString();
    },
    dateIsNot: function (e, n) {
      return n == null
        ? !0
        : e == null
        ? !1
        : e.toDateString() !== n.toDateString();
    },
    dateBefore: function (e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime() < n.getTime();
    },
    dateAfter: function (e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime() > n.getTime();
    },
  },
  register: function (e, n) {
    this.filters[e] = n;
  },
};
function Ng(t) {
  "@babel/helpers - typeof";
  return (
    (Ng =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Ng(t)
  );
}
function Cie(t, e) {
  if (Ng(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Ng(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function uU(t) {
  var e = Cie(t, "string");
  return Ng(e) === "symbol" ? e : String(e);
}
function rc(t, e, n) {
  return (
    (e = uU(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function oI(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, uU(r.key), r);
  }
}
function kie(t, e, n) {
  return (
    e && oI(t.prototype, e),
    n && oI(t, n),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    t
  );
}
function Iie(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var Lr = kie(function t() {
  Iie(this, t);
});
rc(Lr, "ripple", !1);
rc(Lr, "inputStyle", "outlined");
rc(Lr, "locale", "en");
rc(Lr, "appendTo", null);
rc(Lr, "cssTransition", !0);
rc(Lr, "autoZIndex", !0);
rc(Lr, "nonce", null);
rc(Lr, "nullSortOrder", 1);
rc(Lr, "zIndex", {
  modal: 1100,
  overlay: 1e3,
  menu: 1e3,
  tooltip: 1100,
  toast: 1200,
});
rc(Lr, "filterMatchModeOptions", {
  text: [
    Ks.STARTS_WITH,
    Ks.CONTAINS,
    Ks.NOT_CONTAINS,
    Ks.ENDS_WITH,
    Ks.EQUALS,
    Ks.NOT_EQUALS,
  ],
  numeric: [
    Ks.EQUALS,
    Ks.NOT_EQUALS,
    Ks.LESS_THAN,
    Ks.LESS_THAN_OR_EQUAL_TO,
    Ks.GREATER_THAN,
    Ks.GREATER_THAN_OR_EQUAL_TO,
  ],
  date: [Ks.DATE_IS, Ks.DATE_IS_NOT, Ks.DATE_BEFORE, Ks.DATE_AFTER],
});
var Oie = {
  en: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    filter: "Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    custom: "Custom",
    clear: "Clear",
    close: "Close",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    dayNames: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    monthNamesShort: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No available options",
    emptyMessage: "No results found",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      pageLabel: "Page",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      previousPageLabel: "Previous Page",
      selectLabel: "Select",
      unselectLabel: "Unselect",
      expandLabel: "Expand",
      collapseLabel: "Collapse",
    },
  },
};
function Zb(t, e) {
  var n = e || Lr.locale;
  try {
    return cU(n)[t];
  } catch {
    throw new Error(
      "The "
        .concat(t, " option is not found in the current locale('")
        .concat(n, "').")
    );
  }
}
function DNe(t) {
  var e = Lr.locale;
  try {
    return cU(e).aria[t];
  } catch {
    throw new Error(
      "The "
        .concat(t, " option is not found in the current locale('")
        .concat(e, "').")
    );
  }
}
function cU(t) {
  var e = t || Lr.locale;
  return Oie[e];
}
var fU = function (e) {
    var n = Z.useRef(void 0);
    return (
      Z.useEffect(function () {
        n.current = e;
      }),
      n.current
    );
  },
  f1 = function (e) {
    return Z.useEffect(e, []);
  },
  zu = function (e, n) {
    var r = Z.useRef(!1);
    return Z.useEffect(function () {
      if (!r.current) {
        r.current = !0;
        return;
      }
      return e && e();
    }, n);
  },
  bl = function (e) {
    return Z.useEffect(function () {
      return e;
    }, []);
  },
  Gd = function (e) {
    var n = e.target,
      r = n === void 0 ? "document" : n,
      i = e.type,
      s = e.listener,
      a = e.options,
      o = e.when,
      l = o === void 0 ? !0 : o,
      u = Z.useRef(null),
      f = Z.useRef(null),
      c = fU(a),
      d = function () {
        var g =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Vn.isNotEmpty(g.target) &&
          (p(), (g.when || l) && (u.current = it.getTargetElement(g.target))),
          !f.current &&
            u.current &&
            ((f.current = function (w) {
              return s && s(w);
            }),
            u.current.addEventListener(i, f.current, a));
      },
      p = function () {
        f.current &&
          (u.current.removeEventListener(i, f.current, a), (f.current = null));
      };
    return (
      Z.useEffect(
        function () {
          l ? (u.current = it.getTargetElement(r)) : (p(), (u.current = null));
        },
        [r, l]
      ),
      Z.useEffect(
        function () {
          f.current && (f.current !== s || c !== a) && (p(), l && d());
        },
        [s, a]
      ),
      bl(function () {
        p();
      }),
      [d, p]
    );
  };
function Pie(t) {
  if (Array.isArray(t)) return t;
}
function Nie(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function lI(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function Die(t, e) {
  if (t) {
    if (typeof t == "string") return lI(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return lI(t, e);
  }
}
function Rie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function __(t, e) {
  return Pie(t) || Nie(t, e) || Die(t, e) || Rie();
}
var dU = function (e) {
    var n = e.target,
      r = e.listener,
      i = e.options,
      s = e.when,
      a = s === void 0 ? !0 : s,
      o = Z.useRef(null),
      l = Z.useRef(null),
      u = Z.useRef([]),
      f = fU(i),
      c = function () {
        var m =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (
          (Vn.isNotEmpty(m.target) &&
            (d(), (m.when || a) && (o.current = it.getTargetElement(m.target))),
          !l.current && o.current)
        ) {
          var g = (u.current = it.getScrollableParents(o.current));
          (l.current = function (w) {
            return r && r(w);
          }),
            g.forEach(function (w) {
              return w.addEventListener("scroll", l.current, i);
            });
        }
      },
      d = function () {
        if (l.current) {
          var m = u.current;
          m.forEach(function (g) {
            return g.removeEventListener("scroll", l.current, i);
          }),
            (l.current = null);
        }
      };
    return (
      Z.useEffect(
        function () {
          a ? (o.current = it.getTargetElement(n)) : (d(), (o.current = null));
        },
        [n, a]
      ),
      Z.useEffect(
        function () {
          l.current && (l.current !== r || f !== i) && (d(), a && c());
        },
        [r, i]
      ),
      bl(function () {
        d();
      }),
      [c, d]
    );
  },
  hU = function (e) {
    var n = e.listener;
    return Gd({ target: "window", type: "resize", listener: n });
  },
  Mie = function (e) {
    var n = e.target,
      r = e.overlay,
      i = e.listener,
      s = e.when,
      a = s === void 0 ? !0 : s,
      o = Z.useRef(null),
      l = Z.useRef(null),
      u = Gd({
        type: "click",
        listener: function (A) {
          i && i(A, { type: "outside", valid: A.which !== 3 && D(A) });
        },
      }),
      f = __(u, 2),
      c = f[0],
      d = f[1],
      p = hU({
        listener: function (A) {
          i && i(A, { type: "resize", valid: !it.isTouchDevice() });
        },
      }),
      m = __(p, 2),
      g = m[0],
      w = m[1],
      y = dU({
        target: o,
        listener: function (A) {
          i && i(A, { type: "scroll", valid: !0 });
        },
      }),
      v = __(y, 2),
      E = v[0],
      S = v[1],
      D = function (A) {
        return (
          o.current &&
          !(
            o.current.isSameNode(A.target) ||
            o.current.contains(A.target) ||
            (l.current && l.current.contains(A.target))
          )
        );
      },
      P = function () {
        c(), g(), E();
      },
      x = function () {
        d(), w(), S();
      };
    return (
      Z.useEffect(
        function () {
          a
            ? ((o.current = it.getTargetElement(n)),
              (l.current = it.getTargetElement(r)))
            : (x(), (o.current = l.current = null));
        },
        [n, r, a]
      ),
      Z.useEffect(
        function () {
          x();
        },
        [a]
      ),
      bl(function () {
        x();
      }),
      [P, x]
    );
  },
  Lie = function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
      r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
      i = Z.useRef(null),
      s = Z.useRef(null),
      a = Z.useCallback(
        function () {
          return clearTimeout(i.current);
        },
        [i.current]
      );
    return (
      Z.useEffect(function () {
        s.current = e;
      }),
      Z.useEffect(
        function () {
          function o() {
            s.current();
          }
          if (r) return (i.current = setTimeout(o, n)), a;
          a();
        },
        [n, r]
      ),
      bl(function () {
        a();
      }),
      [a]
    );
  },
  mh = Z.memo(
    Z.forwardRef(function () {
      var t = Z.useRef(null),
        e = Z.useRef(null),
        n = function () {
          return t.current && t.current.parentElement;
        },
        r = function () {
          e.current &&
            (e.current.addEventListener("mousedown", a),
            it.isTouchDevice() && e.current.addEventListener("touchstart", s));
        },
        i = function () {
          e.current &&
            (e.current.removeEventListener("mousedown", a),
            it.isTouchDevice() &&
              e.current.removeEventListener("touchstart", s));
        },
        s = function (f) {
          var c = it.getOffset(e.current),
            d =
              f.targetTouches[0].pageX -
              c.left +
              document.body.scrollTop -
              it.getWidth(t.current) / 2,
            p =
              f.targetTouches[0].pageY -
              c.top +
              document.body.scrollLeft -
              it.getHeight(t.current) / 2;
          o(d, p);
        },
        a = function (f) {
          if (!it.isTouchDevice()) {
            var c = it.getOffset(e.current),
              d =
                f.pageX -
                c.left +
                document.body.scrollTop -
                it.getWidth(t.current) / 2,
              p =
                f.pageY -
                c.top +
                document.body.scrollLeft -
                it.getHeight(t.current) / 2;
            o(d, p);
          }
        },
        o = function (f, c) {
          if (
            !(
              !t.current || getComputedStyle(t.current, null).display === "none"
            )
          ) {
            if (
              (it.removeClass(t.current, "p-ink-active"),
              !it.getHeight(t.current) && !it.getWidth(t.current))
            ) {
              var d = Math.max(
                it.getOuterWidth(e.current),
                it.getOuterHeight(e.current)
              );
              (t.current.style.height = d + "px"),
                (t.current.style.width = d + "px");
            }
            (t.current.style.top = c + "px"),
              (t.current.style.left = f + "px"),
              it.addClass(t.current, "p-ink-active");
          }
        },
        l = function (f) {
          it.removeClass(f.currentTarget, "p-ink-active");
        };
      return (
        f1(function () {
          t.current && ((e.current = n()), r());
        }),
        zu(function () {
          t.current && !e.current && ((e.current = n()), r());
        }),
        bl(function () {
          t.current && ((e.current = null), i());
        }),
        Lr.ripple
          ? Z.createElement("span", {
              role: "presentation",
              ref: t,
              className: "p-ink",
              onAnimationEnd: l,
            })
          : null
      );
    })
  );
mh.displayName = "Ripple";
mh.defaultProps = { __TYPE: "Ripple" };
function Bie(t) {
  if (Array.isArray(t)) return t;
}
function Fie(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function uI(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function $ie(t, e) {
  if (t) {
    if (typeof t == "string") return uI(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return uI(t, e);
  }
}
function Uie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jie(t, e) {
  return Bie(t) || Fie(t, e) || $ie(t, e) || Uie();
}
var Dh = Z.memo(function (t) {
  var e = Z.useState(t.visible && it.hasDOM()),
    n = jie(e, 2),
    r = n[0],
    i = n[1];
  f1(function () {
    it.hasDOM() && !r && (i(!0), t.onMounted && t.onMounted());
  }),
    zu(
      function () {
        t.onMounted && t.onMounted();
      },
      [r]
    ),
    bl(function () {
      t.onUnmounted && t.onUnmounted();
    });
  var s = t.element || t.children;
  if (s && r) {
    var a = t.appendTo || Lr.appendTo || document.body;
    return a === "self" ? s : Mm.createPortal(s, a);
  }
  return null;
});
Dh.displayName = "Portal";
Dh.defaultProps = {
  __TYPE: "Portal",
  element: null,
  appendTo: null,
  visible: !1,
  onMounted: null,
  onUnmounted: null,
};
function sE() {
  return (
    (sE = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    sE.apply(this, arguments)
  );
}
function Dg(t) {
  "@babel/helpers - typeof";
  return (
    (Dg =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Dg(t)
  );
}
function Hie(t, e) {
  if (Dg(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Dg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function zie(t) {
  var e = Hie(t, "string");
  return Dg(e) === "symbol" ? e : String(e);
}
function Vie(t, e, n) {
  return (
    (e = zie(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function aE(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function Gie(t) {
  if (Array.isArray(t)) return aE(t);
}
function Wie(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function pU(t, e) {
  if (t) {
    if (typeof t == "string") return aE(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return aE(t, e);
  }
}
function qie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Kie(t) {
  return Gie(t) || Wie(t) || pU(t) || qie();
}
function Xie(t) {
  if (Array.isArray(t)) return t;
}
function Zie(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function Yie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function am(t, e) {
  return Xie(t) || Zie(t, e) || pU(t, e) || Yie();
}
var xw = Z.memo(
  Z.forwardRef(function (t, e) {
    var n = Z.useState(!1),
      r = am(n, 2),
      i = r[0],
      s = r[1],
      a = Z.useState(t.position),
      o = am(a, 2),
      l = o[0],
      u = o[1],
      f = Z.useState(""),
      c = am(f, 2),
      d = c[0],
      p = c[1],
      m = Z.useRef(null),
      g = Z.useRef(null),
      w = Z.useRef(null),
      y = Z.useRef(null),
      v = Z.useRef(!0),
      E = Z.useRef({}),
      S = Z.useRef(null),
      D = hU({
        listener: function (me) {
          !it.isTouchDevice() && Y(me);
        },
      }),
      P = am(D, 2),
      x = P[0],
      _ = P[1],
      A = dU({
        target: w.current,
        listener: function (me) {
          Y(me);
        },
        when: i,
      }),
      N = am(A, 2),
      M = N[0],
      T = N[1],
      O = function (me) {
        return !(t.content || B(me, "tooltip"));
      },
      I = function (me) {
        return !(t.content || B(me, "tooltip") || t.children);
      },
      k = function (me) {
        return B(me, "mousetrack") || t.mouseTrack;
      },
      L = function (me) {
        return B(me, "disabled") === "true" || R(me, "disabled") || t.disabled;
      },
      U = function (me) {
        return B(me, "showondisabled") || t.showOnDisabled;
      },
      $ = function () {
        return B(w.current, "autohide") || t.autoHide;
      },
      B = function (me, $e) {
        return R(me, "data-pr-".concat($e))
          ? me.getAttribute("data-pr-".concat($e))
          : null;
      },
      R = function (me, $e) {
        return me && me.hasAttribute($e);
      },
      V = function (me) {
        var $e = [B(me, "showevent") || t.showEvent],
          De = [B(me, "hideevent") || t.hideEvent];
        if (k(me)) ($e = ["mousemove"]), (De = ["mouseleave"]);
        else {
          var je = B(me, "event") || t.event;
          je === "focus" && (($e = ["focus"]), (De = ["blur"])),
            je === "both" &&
              (($e = ["focus", "mouseenter"]), (De = ["blur", "mouseleave"]));
        }
        return { showEvents: $e, hideEvents: De };
      },
      oe = function (me) {
        return B(me, "position") || l;
      },
      le = function (me) {
        var $e = B(me, "mousetracktop") || t.mouseTrackTop,
          De = B(me, "mousetrackleft") || t.mouseTrackLeft;
        return { top: $e, left: De };
      },
      fe = function (me, $e) {
        if (g.current) {
          var De = B(me, "tooltip") || t.content;
          De
            ? ((g.current.innerHTML = ""),
              g.current.appendChild(document.createTextNode(De)),
              $e())
            : t.children && $e();
        }
      },
      z = function (me) {
        fe(w.current, function () {
          var $e = S.current,
            De = $e.pageX,
            je = $e.pageY;
          t.autoZIndex &&
            !wa.get(m.current) &&
            wa.set(
              "tooltip",
              m.current,
              Lr.autoZIndex,
              t.baseZIndex || Lr.zIndex.tooltip
            ),
            (m.current.style.left = ""),
            (m.current.style.top = ""),
            $() && (m.current.style.pointerEvents = "none"),
            (k(w.current) || me == "mouse") &&
              !y.current &&
              (y.current = {
                width: it.getOuterWidth(m.current),
                height: it.getOuterHeight(m.current),
              }),
            Q(w.current, { x: De, y: je }, me);
        });
      },
      se = function (me) {
        w.current = me.currentTarget;
        var $e = L(w.current),
          De = I(U(w.current) && $e ? w.current.firstChild : w.current);
        if (!(De || $e))
          if (((S.current = me), i)) Ce("updateDelay", z);
          else {
            var je = ke(t.onBeforeShow, {
              originalEvent: me,
              target: w.current,
            });
            je &&
              Ce("showDelay", function () {
                s(!0), ke(t.onShow, { originalEvent: me, target: w.current });
              });
          }
      },
      Y = function (me) {
        if ((at(), i)) {
          var $e = ke(t.onBeforeHide, { originalEvent: me, target: w.current });
          $e &&
            Ce("hideDelay", function () {
              (!$() && v.current === !1) ||
                (wa.clear(m.current),
                it.removeClass(m.current, "p-tooltip-active"),
                s(!1),
                ke(t.onHide, { originalEvent: me, target: w.current }));
            });
        }
      },
      Q = function (me, $e, De) {
        var je = 0,
          lt = 0,
          Ke = De || l;
        if ((k(me) || Ke == "mouse") && $e) {
          var tt = {
            width: it.getOuterWidth(m.current),
            height: it.getOuterHeight(m.current),
          };
          (je = $e.x), (lt = $e.y);
          var jt = le(me),
            ct = jt.top,
            rt = jt.left;
          switch (Ke) {
            case "left":
              (je -= tt.width + rt), (lt -= tt.height / 2 - ct);
              break;
            case "right":
            case "mouse":
              (je += rt), (lt -= tt.height / 2 - ct);
              break;
            case "top":
              (je -= tt.width / 2 - rt), (lt -= tt.height + ct);
              break;
            case "bottom":
              (je -= tt.width / 2 - rt), (lt += ct);
              break;
          }
          je <= 0 || y.current.width > tt.width
            ? ((m.current.style.left = "0px"),
              (m.current.style.right =
                window.innerWidth - tt.width - je + "px"))
            : ((m.current.style.right = ""),
              (m.current.style.left = je + "px")),
            (m.current.style.top = lt + "px"),
            it.addClass(m.current, "p-tooltip-active");
        } else {
          var Dt = it.findCollisionPosition(Ke),
            Ht = B(me, "my") || t.my || Dt.my,
            Yt = B(me, "at") || t.at || Dt.at;
          (m.current.style.padding = "0px"),
            it.flipfitCollision(m.current, me, Ht, Yt, function (sr) {
              var Bt = sr.at,
                en = Bt.x,
                Tr = Bt.y,
                on = sr.my.x,
                Pt = t.at
                  ? en !== "center" && en !== on
                    ? en
                    : Tr
                  : sr.at["".concat(Dt.axis)];
              (m.current.style.padding = ""),
                u(Pt),
                ee(Pt),
                it.addClass(m.current, "p-tooltip-active");
            });
        }
      },
      ee = function (me) {
        if (m.current) {
          var $e = getComputedStyle(m.current);
          me === "left"
            ? (m.current.style.left =
                parseFloat($e.left) - parseFloat($e.paddingLeft) * 2 + "px")
            : me === "top" &&
              (m.current.style.top =
                parseFloat($e.top) - parseFloat($e.paddingTop) * 2 + "px");
        }
      },
      F = function () {
        $() || (v.current = !1);
      },
      te = function (me) {
        $() || ((v.current = !0), Y(me));
      },
      he = function (me) {
        if (me) {
          var $e = V(me),
            De = $e.showEvents,
            je = $e.hideEvents,
            lt = Rt(me);
          De.forEach(function (Ke) {
            return lt.addEventListener(Ke, se);
          }),
            je.forEach(function (Ke) {
              return lt.addEventListener(Ke, Y);
            });
        }
      },
      Te = function (me) {
        if (me) {
          var $e = V(me),
            De = $e.showEvents,
            je = $e.hideEvents,
            lt = Rt(me);
          De.forEach(function (Ke) {
            return lt.removeEventListener(Ke, se);
          }),
            je.forEach(function (Ke) {
              return lt.removeEventListener(Ke, Y);
            });
        }
      },
      Ce = function (me, $e) {
        at();
        var De = B(w.current, me.toLowerCase()) || t[me];
        De
          ? (E.current["".concat(me)] = setTimeout(function () {
              return $e();
            }, De))
          : $e();
      },
      ke = function (me) {
        if (me) {
          for (
            var $e = arguments.length,
              De = new Array($e > 1 ? $e - 1 : 0),
              je = 1;
            je < $e;
            je++
          )
            De[je - 1] = arguments[je];
          var lt = me.apply(void 0, De);
          return lt === void 0 && (lt = !0), lt;
        }
        return !0;
      },
      at = function () {
        Object.values(E.current).forEach(function (me) {
          return clearTimeout(me);
        });
      },
      Rt = function (me) {
        if (me) {
          if (U(me)) {
            if (me.hasWrapper) return me.parentElement;
            var $e = document.createElement("span");
            return (
              me.parentNode.insertBefore($e, me),
              $e.appendChild(me),
              (me.hasWrapper = !0),
              $e
            );
          } else if (me.hasWrapper) {
            var De;
            (De = me.parentElement).replaceWith.apply(
              De,
              Kie(me.parentElement.childNodes)
            ),
              delete me.hasWrapper;
          }
          return me;
        }
        return null;
      },
      Ft = function (me) {
        Ot(me), Nt(me);
      },
      Nt = function (me) {
        et(me || t.target, he);
      },
      Ot = function (me) {
        et(me || t.target, Te);
      },
      et = function (me, $e) {
        if (((me = Vn.getRefElement(me)), me))
          if (it.isElement(me)) $e(me);
          else {
            var De = function (lt) {
              var Ke = it.find(document, lt);
              Ke.forEach(function (tt) {
                $e(tt);
              });
            };
            me instanceof Array
              ? me.forEach(function (je) {
                  De(je);
                })
              : De(me);
          }
      };
    f1(function () {
      Nt(), i && w.current && L(w.current) && Y();
    }),
      zu(
        function () {
          return (
            Nt(),
            function () {
              Ot();
            }
          );
        },
        [se, Y, t.target]
      ),
      zu(
        function () {
          if (i) {
            var Re = oe(w.current),
              me = B(w.current, "classname");
            u(Re), p(me), z(Re), x(), M();
          } else
            u(t.position),
              p(""),
              (w.current = null),
              (y.current = null),
              (v.current = !0);
          return function () {
            _(), T();
          };
        },
        [i]
      ),
      zu(
        function () {
          i &&
            Ce("updateDelay", function () {
              fe(w.current, function () {
                Q(w.current);
              });
            });
        },
        [t.content]
      ),
      bl(function () {
        at(), Ot(), wa.clear(m.current);
      }),
      Z.useImperativeHandle(e, function () {
        return {
          props: t,
          updateTargetEvents: Ft,
          loadTargetEvents: Nt,
          unloadTargetEvents: Ot,
          show: se,
          hide: Y,
          getElement: function () {
            return m.current;
          },
          getTarget: function () {
            return w.current;
          },
        };
      });
    var st = function () {
      var me = Vn.findDiffKeys(t, xw.defaultProps),
        $e = ji(
          "p-tooltip p-component",
          Vie({}, "p-tooltip-".concat(l), !0),
          t.className,
          d
        ),
        De = O(w.current);
      return Z.createElement(
        "div",
        sE(
          {
            id: t.id,
            ref: m,
            className: $e,
            style: t.style,
            role: "tooltip",
            "aria-hidden": i,
          },
          me,
          { onMouseEnter: F, onMouseLeave: te }
        ),
        Z.createElement("div", { className: "p-tooltip-arrow" }),
        Z.createElement(
          "div",
          { ref: g, className: "p-tooltip-text" },
          De && t.children
        )
      );
    };
    if (i) {
      var vt = st();
      return Z.createElement(Dh, {
        element: vt,
        appendTo: t.appendTo,
        visible: !0,
      });
    }
    return null;
  })
);
xw.displayName = "Tooltip";
xw.defaultProps = {
  __TYPE: "Tooltip",
  appendTo: null,
  at: null,
  autoHide: !0,
  autoZIndex: !0,
  baseZIndex: 0,
  className: null,
  content: null,
  disabled: !1,
  event: null,
  hideDelay: 0,
  hideEvent: "mouseleave",
  id: null,
  mouseTrack: !1,
  mouseTrackLeft: 5,
  mouseTrackTop: 5,
  my: null,
  onBeforeHide: null,
  onBeforeShow: null,
  onHide: null,
  onShow: null,
  position: "right",
  showDelay: 0,
  showEvent: "mouseenter",
  showOnDisabled: !1,
  style: null,
  target: null,
  updateDelay: 0,
};
function Yb() {
  return (
    (Yb = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Yb.apply(this, arguments)
  );
}
function Rg(t) {
  "@babel/helpers - typeof";
  return (
    (Rg =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Rg(t)
  );
}
function Qie(t, e) {
  if (Rg(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Rg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Jie(t) {
  var e = Qie(t, "string");
  return Rg(e) === "symbol" ? e : String(e);
}
function cI(t, e, n) {
  return (
    (e = Jie(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
var iu = Z.memo(
  Z.forwardRef(function (t, e) {
    var n = Z.useRef(e);
    if (
      (Z.useEffect(
        function () {
          Vn.combinedRefs(n, e);
        },
        [n, e]
      ),
      t.visible === !1)
    )
      return null;
    var r = function () {
        var w = t.loading ? t.loadingIcon : t.icon,
          y = ji(
            "p-button-icon p-c",
            cI(
              { "p-button-loading-icon": t.loading },
              "p-button-icon-".concat(t.iconPos),
              t.label
            )
          );
        return oU.getJSXIcon(w, { className: y }, { props: t });
      },
      i = function () {
        return t.label
          ? Z.createElement(
              "span",
              { className: "p-button-label p-c" },
              t.label
            )
          : !t.children &&
              !t.label &&
              Z.createElement("span", {
                className: "p-button-label p-c",
                dangerouslySetInnerHTML: { __html: "&nbsp;" },
              });
      },
      s = function () {
        if (t.badge) {
          var w = ji("p-badge", t.badgeClassName);
          return Z.createElement("span", { className: w }, t.badge);
        }
        return null;
      },
      a = t.disabled || t.loading,
      o = !a || (t.tooltipOptions && t.tooltipOptions.showOnDisabled),
      l = Vn.isNotEmpty(t.tooltip) && o,
      u = Vn.findDiffKeys(t, iu.defaultProps),
      f = ji(
        "p-button p-component",
        t.className,
        cI(
          {
            "p-button-icon-only":
              (t.icon || (t.loading && t.loadingIcon)) &&
              !t.label &&
              !t.children,
            "p-button-vertical":
              (t.iconPos === "top" || t.iconPos === "bottom") && t.label,
            "p-disabled": a,
            "p-button-loading": t.loading,
            "p-button-loading-label-only": t.loading && !t.icon && t.label,
          },
          "p-button-loading-".concat(t.iconPos),
          t.loading && t.loadingIcon && t.label
        )
      ),
      c = r(),
      d = i(),
      p = s(),
      m = t.label ? t.label + (t.badge ? " " + t.badge : "") : t["aria-label"];
    return Z.createElement(
      Z.Fragment,
      null,
      Z.createElement(
        "button",
        Yb({ ref: n, "aria-label": m }, u, { className: f, disabled: a }),
        c,
        d,
        t.children,
        p,
        Z.createElement(mh, null)
      ),
      l &&
        Z.createElement(
          xw,
          Yb({ target: n, content: t.tooltip }, t.tooltipOptions)
        )
    );
  })
);
iu.displayName = "Button";
iu.defaultProps = {
  __TYPE: "Button",
  label: null,
  icon: null,
  iconPos: "left",
  badge: null,
  badgeClassName: null,
  tooltip: null,
  tooltipOptions: null,
  disabled: !1,
  loading: !1,
  loadingIcon: "pi pi-spinner pi-spin",
  visible: !0,
};
const ese = "/assets/headlogo.svg",
  gs = {
    dashboard: { label: "Dashboard", href: "/" },
    stakeCvg: { label: "CVG", href: "/stake/cvg" },
    stakeSdt: { label: "Stake DAO", href: "/stake/sdt" },
    stakeCvx: { label: "Convex", href: "/stake/cvx" },
    bond: { label: "Bonds", href: "/bond" },
    claim: { label: "Claim", href: "/claim" },
    lock: { label: "Lock", href: "/lock" },
    gauges: { label: "Gauges", href: "/gauges" },
    positions: { label: "Positions", href: "/positions" },
  };
function Mg({ address: t, size: e = 15, className: n = "" }) {
  return G.jsxs(G.Fragment, {
    children: [
      G.jsxs("span", {
        className: `hidden md:inline-block ${n || ""}`,
        children: [
          " ",
          t?.substring(0, e),
          "...",
          t?.substring(42 - e, 42),
          " ",
        ],
      }),
      G.jsxs("span", {
        className: `block md:hidden ${n || ""}`,
        children: [
          " ",
          t?.substring(0, e),
          "...",
          t?.substring(42 - e, 42),
          " ",
        ],
      }),
    ],
  });
}
var oE = function (t, e) {
  return (
    (oE =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r;
        }) ||
      function (n, r) {
        for (var i in r)
          Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }),
    oE(t, e)
  );
};
function Rh(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null"
    );
  oE(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
function tse(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(f) {
      try {
        u(r.next(f));
      } catch (c) {
        a(c);
      }
    }
    function l(f) {
      try {
        u(r.throw(f));
      } catch (c) {
        a(c);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(o, l);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function mU(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    a;
  return (
    (a = { next: o(0), throw: o(1), return: o(2) }),
    typeof Symbol == "function" &&
      (a[Symbol.iterator] = function () {
        return this;
      }),
    a
  );
  function o(u) {
    return function (f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; a && ((a = 0), u[0] && (n = 0)), n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              u[0] & 2
                ? i.return
                : u[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, u[1])).done)
        )
          return s;
        switch (((i = 0), s && (u = [u[0] & 2, s.value]), u[0])) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, (i = u[1]), (u = [0]);
            continue;
          case 7:
            (u = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((s = n.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || (u[1] > s[0] && u[1] < s[3]))) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = u);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (f) {
        (u = [6, f]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function P0(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    n = e && t[e],
    r = 0;
  if (n) return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return (
          t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function Kc(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n) return t;
  var r = n.call(t),
    i,
    s = [],
    a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}
function od(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) &&
        (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
  return t.concat(s || Array.prototype.slice.call(e));
}
function a0(t) {
  return this instanceof a0 ? ((this.v = t), this) : new a0(t);
}
function nse(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []),
    i,
    s = [];
  return (
    (i = {}),
    a("next"),
    a("throw"),
    a("return"),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function a(d) {
    r[d] &&
      (i[d] = function (p) {
        return new Promise(function (m, g) {
          s.push([d, p, m, g]) > 1 || o(d, p);
        });
      });
  }
  function o(d, p) {
    try {
      l(r[d](p));
    } catch (m) {
      c(s[0][3], m);
    }
  }
  function l(d) {
    d.value instanceof a0
      ? Promise.resolve(d.value.v).then(u, f)
      : c(s[0][2], d);
  }
  function u(d) {
    o("next", d);
  }
  function f(d) {
    o("throw", d);
  }
  function c(d, p) {
    d(p), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function rse(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    n;
  return e
    ? e.call(t)
    : ((t = typeof P0 == "function" ? P0(t) : t[Symbol.iterator]()),
      (n = {}),
      r("next"),
      r("throw"),
      r("return"),
      (n[Symbol.asyncIterator] = function () {
        return this;
      }),
      n);
  function r(s) {
    n[s] =
      t[s] &&
      function (a) {
        return new Promise(function (o, l) {
          (a = t[s](a)), i(o, l, a.done, a.value);
        });
      };
  }
  function i(s, a, o, l) {
    Promise.resolve(l).then(function (u) {
      s({ value: u, done: o });
    }, a);
  }
}
function _r(t) {
  return typeof t == "function";
}
function _7(t) {
  var e = function (r) {
      Error.call(r), (r.stack = new Error().stack);
    },
    n = t(e);
  return (
    (n.prototype = Object.create(Error.prototype)),
    (n.prototype.constructor = n),
    n
  );
}
var E_ = _7(function (t) {
  return function (n) {
    t(this),
      (this.message = n
        ? n.length +
          ` errors occurred during unsubscription:
` +
          n.map(function (r, i) {
            return i + 1 + ") " + r.toString();
          }).join(`
  `)
        : ""),
      (this.name = "UnsubscriptionError"),
      (this.errors = n);
  };
});
function lE(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var Tw = (function () {
    function t(e) {
      (this.initialTeardown = e),
        (this.closed = !1),
        (this._parentage = null),
        (this._finalizers = null);
    }
    return (
      (t.prototype.unsubscribe = function () {
        var e, n, r, i, s;
        if (!this.closed) {
          this.closed = !0;
          var a = this._parentage;
          if (a)
            if (((this._parentage = null), Array.isArray(a)))
              try {
                for (var o = P0(a), l = o.next(); !l.done; l = o.next()) {
                  var u = l.value;
                  u.remove(this);
                }
              } catch (g) {
                e = { error: g };
              } finally {
                try {
                  l && !l.done && (n = o.return) && n.call(o);
                } finally {
                  if (e) throw e.error;
                }
              }
            else a.remove(this);
          var f = this.initialTeardown;
          if (_r(f))
            try {
              f();
            } catch (g) {
              s = g instanceof E_ ? g.errors : [g];
            }
          var c = this._finalizers;
          if (c) {
            this._finalizers = null;
            try {
              for (var d = P0(c), p = d.next(); !p.done; p = d.next()) {
                var m = p.value;
                try {
                  fI(m);
                } catch (g) {
                  (s = s ?? []),
                    g instanceof E_
                      ? (s = od(od([], Kc(s)), Kc(g.errors)))
                      : s.push(g);
                }
              }
            } catch (g) {
              r = { error: g };
            } finally {
              try {
                p && !p.done && (i = d.return) && i.call(d);
              } finally {
                if (r) throw r.error;
              }
            }
          }
          if (s) throw new E_(s);
        }
      }),
      (t.prototype.add = function (e) {
        var n;
        if (e && e !== this)
          if (this.closed) fI(e);
          else {
            if (e instanceof t) {
              if (e.closed || e._hasParent(this)) return;
              e._addParent(this);
            }
            (this._finalizers =
              (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
          }
      }),
      (t.prototype._hasParent = function (e) {
        var n = this._parentage;
        return n === e || (Array.isArray(n) && n.includes(e));
      }),
      (t.prototype._addParent = function (e) {
        var n = this._parentage;
        this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
      }),
      (t.prototype._removeParent = function (e) {
        var n = this._parentage;
        n === e ? (this._parentage = null) : Array.isArray(n) && lE(n, e);
      }),
      (t.prototype.remove = function (e) {
        var n = this._finalizers;
        n && lE(n, e), e instanceof t && e._removeParent(this);
      }),
      (t.EMPTY = (function () {
        var e = new t();
        return (e.closed = !0), e;
      })()),
      t
    );
  })(),
  gU = Tw.EMPTY;
function yU(t) {
  return (
    t instanceof Tw ||
    (t && "closed" in t && _r(t.remove) && _r(t.add) && _r(t.unsubscribe))
  );
}
function fI(t) {
  _r(t) ? t() : t.unsubscribe();
}
var Mh = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1,
  },
  Qb = {
    setTimeout: function (t, e) {
      for (var n = [], r = 2; r < arguments.length; r++)
        n[r - 2] = arguments[r];
      var i = Qb.delegate;
      return i?.setTimeout
        ? i.setTimeout.apply(i, od([t, e], Kc(n)))
        : setTimeout.apply(void 0, od([t, e], Kc(n)));
    },
    clearTimeout: function (t) {
      var e = Qb.delegate;
      return (e?.clearTimeout || clearTimeout)(t);
    },
    delegate: void 0,
  };
function vU(t) {
  Qb.setTimeout(function () {
    var e = Mh.onUnhandledError;
    if (e) e(t);
    else throw t;
  });
}
function Jb() {}
var ise = (function () {
  return E7("C", void 0, void 0);
})();
function sse(t) {
  return E7("E", void 0, t);
}
function ase(t) {
  return E7("N", t, void 0);
}
function E7(t, e, n) {
  return { kind: t, value: e, error: n };
}
var Zd = null;
function Yv(t) {
  if (Mh.useDeprecatedSynchronousErrorHandling) {
    var e = !Zd;
    if ((e && (Zd = { errorThrown: !1, error: null }), t(), e)) {
      var n = Zd,
        r = n.errorThrown,
        i = n.error;
      if (((Zd = null), r)) throw i;
    }
  } else t();
}
function ose(t) {
  Mh.useDeprecatedSynchronousErrorHandling &&
    Zd &&
    ((Zd.errorThrown = !0), (Zd.error = t));
}
var x7 = (function (t) {
    Rh(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return (
        (r.isStopped = !1),
        n ? ((r.destination = n), yU(n) && n.add(r)) : (r.destination = fse),
        r
      );
    }
    return (
      (e.create = function (n, r, i) {
        return new N0(n, r, i);
      }),
      (e.prototype.next = function (n) {
        this.isStopped ? T_(ase(n), this) : this._next(n);
      }),
      (e.prototype.error = function (n) {
        this.isStopped
          ? T_(sse(n), this)
          : ((this.isStopped = !0), this._error(n));
      }),
      (e.prototype.complete = function () {
        this.isStopped
          ? T_(ise, this)
          : ((this.isStopped = !0), this._complete());
      }),
      (e.prototype.unsubscribe = function () {
        this.closed ||
          ((this.isStopped = !0),
          t.prototype.unsubscribe.call(this),
          (this.destination = null));
      }),
      (e.prototype._next = function (n) {
        this.destination.next(n);
      }),
      (e.prototype._error = function (n) {
        try {
          this.destination.error(n);
        } finally {
          this.unsubscribe();
        }
      }),
      (e.prototype._complete = function () {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }),
      e
    );
  })(Tw),
  lse = Function.prototype.bind;
function x_(t, e) {
  return lse.call(t, e);
}
var use = (function () {
    function t(e) {
      this.partialObserver = e;
    }
    return (
      (t.prototype.next = function (e) {
        var n = this.partialObserver;
        if (n.next)
          try {
            n.next(e);
          } catch (r) {
            ev(r);
          }
      }),
      (t.prototype.error = function (e) {
        var n = this.partialObserver;
        if (n.error)
          try {
            n.error(e);
          } catch (r) {
            ev(r);
          }
        else ev(e);
      }),
      (t.prototype.complete = function () {
        var e = this.partialObserver;
        if (e.complete)
          try {
            e.complete();
          } catch (n) {
            ev(n);
          }
      }),
      t
    );
  })(),
  N0 = (function (t) {
    Rh(e, t);
    function e(n, r, i) {
      var s = t.call(this) || this,
        a;
      if (_r(n) || !n)
        a = { next: n ?? void 0, error: r ?? void 0, complete: i ?? void 0 };
      else {
        var o;
        s && Mh.useDeprecatedNextContext
          ? ((o = Object.create(n)),
            (o.unsubscribe = function () {
              return s.unsubscribe();
            }),
            (a = {
              next: n.next && x_(n.next, o),
              error: n.error && x_(n.error, o),
              complete: n.complete && x_(n.complete, o),
            }))
          : (a = n);
      }
      return (s.destination = new use(a)), s;
    }
    return e;
  })(x7);
function ev(t) {
  Mh.useDeprecatedSynchronousErrorHandling ? ose(t) : vU(t);
}
function cse(t) {
  throw t;
}
function T_(t, e) {
  var n = Mh.onStoppedNotification;
  n &&
    Qb.setTimeout(function () {
      return n(t, e);
    });
}
var fse = { closed: !0, next: Jb, error: cse, complete: Jb },
  T7 = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })();
function Sw(t) {
  return t;
}
function RNe() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
  return bU(t);
}
function bU(t) {
  return t.length === 0
    ? Sw
    : t.length === 1
    ? t[0]
    : function (n) {
        return t.reduce(function (r, i) {
          return i(r);
        }, n);
      };
}
var aa = (function () {
  function t(e) {
    e && (this._subscribe = e);
  }
  return (
    (t.prototype.lift = function (e) {
      var n = new t();
      return (n.source = this), (n.operator = e), n;
    }),
    (t.prototype.subscribe = function (e, n, r) {
      var i = this,
        s = hse(e) ? e : new N0(e, n, r);
      return (
        Yv(function () {
          var a = i,
            o = a.operator,
            l = a.source;
          s.add(o ? o.call(s, l) : l ? i._subscribe(s) : i._trySubscribe(s));
        }),
        s
      );
    }),
    (t.prototype._trySubscribe = function (e) {
      try {
        return this._subscribe(e);
      } catch (n) {
        e.error(n);
      }
    }),
    (t.prototype.forEach = function (e, n) {
      var r = this;
      return (
        (n = dI(n)),
        new n(function (i, s) {
          var a = new N0({
            next: function (o) {
              try {
                e(o);
              } catch (l) {
                s(l), a.unsubscribe();
              }
            },
            error: s,
            complete: i,
          });
          r.subscribe(a);
        })
      );
    }),
    (t.prototype._subscribe = function (e) {
      var n;
      return (n = this.source) === null || n === void 0
        ? void 0
        : n.subscribe(e);
    }),
    (t.prototype[T7] = function () {
      return this;
    }),
    (t.prototype.pipe = function () {
      for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
      return bU(e)(this);
    }),
    (t.prototype.toPromise = function (e) {
      var n = this;
      return (
        (e = dI(e)),
        new e(function (r, i) {
          var s;
          n.subscribe(
            function (a) {
              return (s = a);
            },
            function (a) {
              return i(a);
            },
            function () {
              return r(s);
            }
          );
        })
      );
    }),
    (t.create = function (e) {
      return new t(e);
    }),
    t
  );
})();
function dI(t) {
  var e;
  return (e = t ?? Mh.Promise) !== null && e !== void 0 ? e : Promise;
}
function dse(t) {
  return t && _r(t.next) && _r(t.error) && _r(t.complete);
}
function hse(t) {
  return (t && t instanceof x7) || (dse(t) && yU(t));
}
function pse(t) {
  return _r(t?.lift);
}
function wl(t) {
  return function (e) {
    if (pse(e))
      return e.lift(function (n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function gl(t, e, n, r, i) {
  return new mse(t, e, n, r, i);
}
var mse = (function (t) {
    Rh(e, t);
    function e(n, r, i, s, a, o) {
      var l = t.call(this, n) || this;
      return (
        (l.onFinalize = a),
        (l.shouldUnsubscribe = o),
        (l._next = r
          ? function (u) {
              try {
                r(u);
              } catch (f) {
                n.error(f);
              }
            }
          : t.prototype._next),
        (l._error = s
          ? function (u) {
              try {
                s(u);
              } catch (f) {
                n.error(f);
              } finally {
                this.unsubscribe();
              }
            }
          : t.prototype._error),
        (l._complete = i
          ? function () {
              try {
                i();
              } catch (u) {
                n.error(u);
              } finally {
                this.unsubscribe();
              }
            }
          : t.prototype._complete),
        l
      );
    }
    return (
      (e.prototype.unsubscribe = function () {
        var n;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var r = this.closed;
          t.prototype.unsubscribe.call(this),
            !r &&
              ((n = this.onFinalize) === null || n === void 0 || n.call(this));
        }
      }),
      e
    );
  })(x7),
  gse = _7(function (t) {
    return function () {
      t(this),
        (this.name = "ObjectUnsubscribedError"),
        (this.message = "object unsubscribed");
    };
  }),
  sf = (function (t) {
    Rh(e, t);
    function e() {
      var n = t.call(this) || this;
      return (
        (n.closed = !1),
        (n.currentObservers = null),
        (n.observers = []),
        (n.isStopped = !1),
        (n.hasError = !1),
        (n.thrownError = null),
        n
      );
    }
    return (
      (e.prototype.lift = function (n) {
        var r = new hI(this, this);
        return (r.operator = n), r;
      }),
      (e.prototype._throwIfClosed = function () {
        if (this.closed) throw new gse();
      }),
      (e.prototype.next = function (n) {
        var r = this;
        Yv(function () {
          var i, s;
          if ((r._throwIfClosed(), !r.isStopped)) {
            r.currentObservers ||
              (r.currentObservers = Array.from(r.observers));
            try {
              for (
                var a = P0(r.currentObservers), o = a.next();
                !o.done;
                o = a.next()
              ) {
                var l = o.value;
                l.next(n);
              }
            } catch (u) {
              i = { error: u };
            } finally {
              try {
                o && !o.done && (s = a.return) && s.call(a);
              } finally {
                if (i) throw i.error;
              }
            }
          }
        });
      }),
      (e.prototype.error = function (n) {
        var r = this;
        Yv(function () {
          if ((r._throwIfClosed(), !r.isStopped)) {
            (r.hasError = r.isStopped = !0), (r.thrownError = n);
            for (var i = r.observers; i.length; ) i.shift().error(n);
          }
        });
      }),
      (e.prototype.complete = function () {
        var n = this;
        Yv(function () {
          if ((n._throwIfClosed(), !n.isStopped)) {
            n.isStopped = !0;
            for (var r = n.observers; r.length; ) r.shift().complete();
          }
        });
      }),
      (e.prototype.unsubscribe = function () {
        (this.isStopped = this.closed = !0),
          (this.observers = this.currentObservers = null);
      }),
      Object.defineProperty(e.prototype, "observed", {
        get: function () {
          var n;
          return (
            ((n = this.observers) === null || n === void 0
              ? void 0
              : n.length) > 0
          );
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._trySubscribe = function (n) {
        return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
      }),
      (e.prototype._subscribe = function (n) {
        return (
          this._throwIfClosed(),
          this._checkFinalizedStatuses(n),
          this._innerSubscribe(n)
        );
      }),
      (e.prototype._innerSubscribe = function (n) {
        var r = this,
          i = this,
          s = i.hasError,
          a = i.isStopped,
          o = i.observers;
        return s || a
          ? gU
          : ((this.currentObservers = null),
            o.push(n),
            new Tw(function () {
              (r.currentObservers = null), lE(o, n);
            }));
      }),
      (e.prototype._checkFinalizedStatuses = function (n) {
        var r = this,
          i = r.hasError,
          s = r.thrownError,
          a = r.isStopped;
        i ? n.error(s) : a && n.complete();
      }),
      (e.prototype.asObservable = function () {
        var n = new aa();
        return (n.source = this), n;
      }),
      (e.create = function (n, r) {
        return new hI(n, r);
      }),
      e
    );
  })(aa),
  hI = (function (t) {
    Rh(e, t);
    function e(n, r) {
      var i = t.call(this) || this;
      return (i.destination = n), (i.source = r), i;
    }
    return (
      (e.prototype.next = function (n) {
        var r, i;
        (i =
          (r = this.destination) === null || r === void 0 ? void 0 : r.next) ===
          null ||
          i === void 0 ||
          i.call(r, n);
      }),
      (e.prototype.error = function (n) {
        var r, i;
        (i =
          (r = this.destination) === null || r === void 0
            ? void 0
            : r.error) === null ||
          i === void 0 ||
          i.call(r, n);
      }),
      (e.prototype.complete = function () {
        var n, r;
        (r =
          (n = this.destination) === null || n === void 0
            ? void 0
            : n.complete) === null ||
          r === void 0 ||
          r.call(n);
      }),
      (e.prototype._subscribe = function (n) {
        var r, i;
        return (i =
          (r = this.source) === null || r === void 0
            ? void 0
            : r.subscribe(n)) !== null && i !== void 0
          ? i
          : gU;
      }),
      e
    );
  })(sf),
  by = (function (t) {
    Rh(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return (r._value = n), r;
    }
    return (
      Object.defineProperty(e.prototype, "value", {
        get: function () {
          return this.getValue();
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._subscribe = function (n) {
        var r = t.prototype._subscribe.call(this, n);
        return !r.closed && n.next(this._value), r;
      }),
      (e.prototype.getValue = function () {
        var n = this,
          r = n.hasError,
          i = n.thrownError,
          s = n._value;
        if (r) throw i;
        return this._throwIfClosed(), s;
      }),
      (e.prototype.next = function (n) {
        t.prototype.next.call(this, (this._value = n));
      }),
      e
    );
  })(sf),
  wU = {
    now: function () {
      return (wU.delegate || Date).now();
    },
    delegate: void 0,
  },
  yse = (function (t) {
    Rh(e, t);
    function e(n, r, i) {
      n === void 0 && (n = 1 / 0),
        r === void 0 && (r = 1 / 0),
        i === void 0 && (i = wU);
      var s = t.call(this) || this;
      return (
        (s._bufferSize = n),
        (s._windowTime = r),
        (s._timestampProvider = i),
        (s._buffer = []),
        (s._infiniteTimeWindow = !0),
        (s._infiniteTimeWindow = r === 1 / 0),
        (s._bufferSize = Math.max(1, n)),
        (s._windowTime = Math.max(1, r)),
        s
      );
    }
    return (
      (e.prototype.next = function (n) {
        var r = this,
          i = r.isStopped,
          s = r._buffer,
          a = r._infiniteTimeWindow,
          o = r._timestampProvider,
          l = r._windowTime;
        i || (s.push(n), !a && s.push(o.now() + l)),
          this._trimBuffer(),
          t.prototype.next.call(this, n);
      }),
      (e.prototype._subscribe = function (n) {
        this._throwIfClosed(), this._trimBuffer();
        for (
          var r = this._innerSubscribe(n),
            i = this,
            s = i._infiniteTimeWindow,
            a = i._buffer,
            o = a.slice(),
            l = 0;
          l < o.length && !n.closed;
          l += s ? 1 : 2
        )
          n.next(o[l]);
        return this._checkFinalizedStatuses(n), r;
      }),
      (e.prototype._trimBuffer = function () {
        var n = this,
          r = n._bufferSize,
          i = n._timestampProvider,
          s = n._buffer,
          a = n._infiniteTimeWindow,
          o = (a ? 1 : 2) * r;
        if ((r < 1 / 0 && o < s.length && s.splice(0, s.length - o), !a)) {
          for (var l = i.now(), u = 0, f = 1; f < s.length && s[f] <= l; f += 2)
            u = f;
          u && s.splice(0, u + 1);
        }
      }),
      e
    );
  })(sf),
  _U = new aa(function (t) {
    return t.complete();
  });
function MNe(t) {
  return t ? vse(t) : _U;
}
function vse(t) {
  return new aa(function (e) {
    return t.schedule(function () {
      return e.complete();
    });
  });
}
function bse(t) {
  return t && _r(t.schedule);
}
function S7(t) {
  return t[t.length - 1];
}
function wse(t) {
  return _r(S7(t)) ? t.pop() : void 0;
}
function EU(t) {
  return bse(S7(t)) ? t.pop() : void 0;
}
function LNe(t, e) {
  return typeof S7(t) == "number" ? t.pop() : e;
}
var A7 = function (t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function xU(t) {
  return _r(t?.then);
}
function TU(t) {
  return _r(t[T7]);
}
function SU(t) {
  return Symbol.asyncIterator && _r(t?.[Symbol.asyncIterator]);
}
function AU(t) {
  return new TypeError(
    "You provided " +
      (t !== null && typeof t == "object"
        ? "an invalid object"
        : "'" + t + "'") +
      " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable."
  );
}
function _se() {
  return typeof Symbol != "function" || !Symbol.iterator
    ? "@@iterator"
    : Symbol.iterator;
}
var CU = _se();
function kU(t) {
  return _r(t?.[CU]);
}
function IU(t) {
  return nse(this, arguments, function () {
    var n, r, i, s;
    return mU(this, function (a) {
      switch (a.label) {
        case 0:
          (n = t.getReader()), (a.label = 1);
        case 1:
          a.trys.push([1, , 9, 10]), (a.label = 2);
        case 2:
          return [4, a0(n.read())];
        case 3:
          return (
            (r = a.sent()),
            (i = r.value),
            (s = r.done),
            s ? [4, a0(void 0)] : [3, 5]
          );
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, a0(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function OU(t) {
  return _r(t?.getReader);
}
function _l(t) {
  if (t instanceof aa) return t;
  if (t != null) {
    if (TU(t)) return Ese(t);
    if (A7(t)) return xse(t);
    if (xU(t)) return Tse(t);
    if (SU(t)) return PU(t);
    if (kU(t)) return Sse(t);
    if (OU(t)) return Ase(t);
  }
  throw AU(t);
}
function Ese(t) {
  return new aa(function (e) {
    var n = t[T7]();
    if (_r(n.subscribe)) return n.subscribe(e);
    throw new TypeError(
      "Provided object does not correctly implement Symbol.observable"
    );
  });
}
function xse(t) {
  return new aa(function (e) {
    for (var n = 0; n < t.length && !e.closed; n++) e.next(t[n]);
    e.complete();
  });
}
function Tse(t) {
  return new aa(function (e) {
    t.then(
      function (n) {
        e.closed || (e.next(n), e.complete());
      },
      function (n) {
        return e.error(n);
      }
    ).then(null, vU);
  });
}
function Sse(t) {
  return new aa(function (e) {
    var n, r;
    try {
      for (var i = P0(t), s = i.next(); !s.done; s = i.next()) {
        var a = s.value;
        if ((e.next(a), e.closed)) return;
      }
    } catch (o) {
      n = { error: o };
    } finally {
      try {
        s && !s.done && (r = i.return) && r.call(i);
      } finally {
        if (n) throw n.error;
      }
    }
    e.complete();
  });
}
function PU(t) {
  return new aa(function (e) {
    Cse(t, e).catch(function (n) {
      return e.error(n);
    });
  });
}
function Ase(t) {
  return PU(IU(t));
}
function Cse(t, e) {
  var n, r, i, s;
  return tse(this, void 0, void 0, function () {
    var a, o;
    return mU(this, function (l) {
      switch (l.label) {
        case 0:
          l.trys.push([0, 5, 6, 11]), (n = rse(t)), (l.label = 1);
        case 1:
          return [4, n.next()];
        case 2:
          if (((r = l.sent()), !!r.done)) return [3, 4];
          if (((a = r.value), e.next(a), e.closed)) return [2];
          l.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return (o = l.sent()), (i = { error: o }), [3, 11];
        case 6:
          return (
            l.trys.push([6, , 9, 10]),
            r && !r.done && (s = n.return) ? [4, s.call(n)] : [3, 8]
          );
        case 7:
          l.sent(), (l.label = 8);
        case 8:
          return [3, 10];
        case 9:
          if (i) throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ed(t, e, n, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var s = e.schedule(function () {
    n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if ((t.add(s), !i)) return s;
}
function NU(t, e) {
  return (
    e === void 0 && (e = 0),
    wl(function (n, r) {
      n.subscribe(
        gl(
          r,
          function (i) {
            return ed(
              r,
              t,
              function () {
                return r.next(i);
              },
              e
            );
          },
          function () {
            return ed(
              r,
              t,
              function () {
                return r.complete();
              },
              e
            );
          },
          function (i) {
            return ed(
              r,
              t,
              function () {
                return r.error(i);
              },
              e
            );
          }
        )
      );
    })
  );
}
function DU(t, e) {
  return (
    e === void 0 && (e = 0),
    wl(function (n, r) {
      r.add(
        t.schedule(function () {
          return n.subscribe(r);
        }, e)
      );
    })
  );
}
function kse(t, e) {
  return _l(t).pipe(DU(e), NU(e));
}
function Ise(t, e) {
  return _l(t).pipe(DU(e), NU(e));
}
function Ose(t, e) {
  return new aa(function (n) {
    var r = 0;
    return e.schedule(function () {
      r === t.length
        ? n.complete()
        : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function Pse(t, e) {
  return new aa(function (n) {
    var r;
    return (
      ed(n, e, function () {
        (r = t[CU]()),
          ed(
            n,
            e,
            function () {
              var i, s, a;
              try {
                (i = r.next()), (s = i.value), (a = i.done);
              } catch (o) {
                n.error(o);
                return;
              }
              a ? n.complete() : n.next(s);
            },
            0,
            !0
          );
      }),
      function () {
        return _r(r?.return) && r.return();
      }
    );
  });
}
function RU(t, e) {
  if (!t) throw new Error("Iterable cannot be null");
  return new aa(function (n) {
    ed(n, e, function () {
      var r = t[Symbol.asyncIterator]();
      ed(
        n,
        e,
        function () {
          r.next().then(function (i) {
            i.done ? n.complete() : n.next(i.value);
          });
        },
        0,
        !0
      );
    });
  });
}
function Nse(t, e) {
  return RU(IU(t), e);
}
function Dse(t, e) {
  if (t != null) {
    if (TU(t)) return kse(t, e);
    if (A7(t)) return Ose(t, e);
    if (xU(t)) return Ise(t, e);
    if (SU(t)) return RU(t, e);
    if (kU(t)) return Pse(t, e);
    if (OU(t)) return Nse(t, e);
  }
  throw AU(t);
}
function Rse(t, e) {
  return e ? Dse(t, e) : _l(t);
}
var Mse = _7(function (t) {
  return function () {
    t(this),
      (this.name = "EmptyError"),
      (this.message = "no elements in sequence");
  };
});
function Aw(t, e) {
  var n = typeof e == "object";
  return new Promise(function (r, i) {
    var s = new N0({
      next: function (a) {
        r(a), s.unsubscribe();
      },
      error: i,
      complete: function () {
        n ? r(e.defaultValue) : i(new Mse());
      },
    });
    t.subscribe(s);
  });
}
function wy(t, e) {
  return wl(function (n, r) {
    var i = 0;
    n.subscribe(
      gl(r, function (s) {
        r.next(t.call(e, s, i++));
      })
    );
  });
}
var Lse = Array.isArray;
function Bse(t, e) {
  return Lse(e) ? t.apply(void 0, od([], Kc(e))) : t(e);
}
function MU(t) {
  return wy(function (e) {
    return Bse(t, e);
  });
}
function Fse(t, e, n, r, i, s, a, o) {
  var l = [],
    u = 0,
    f = 0,
    c = !1,
    d = function () {
      c && !l.length && !u && e.complete();
    },
    p = function (g) {
      return u < r ? m(g) : l.push(g);
    },
    m = function (g) {
      s && e.next(g), u++;
      var w = !1;
      _l(n(g, f++)).subscribe(
        gl(
          e,
          function (y) {
            i?.(y), s ? p(y) : e.next(y);
          },
          function () {
            w = !0;
          },
          void 0,
          function () {
            if (w)
              try {
                u--;
                for (
                  var y = function () {
                    var v = l.shift();
                    a
                      ? ed(e, a, function () {
                          return m(v);
                        })
                      : m(v);
                  };
                  l.length && u < r;

                )
                  y();
                d();
              } catch (v) {
                e.error(v);
              }
          }
        )
      );
    };
  return (
    t.subscribe(
      gl(e, p, function () {
        (c = !0), d();
      })
    ),
    function () {
      o?.();
    }
  );
}
function C7(t, e, n) {
  return (
    n === void 0 && (n = 1 / 0),
    _r(e)
      ? C7(function (r, i) {
          return wy(function (s, a) {
            return e(r, s, i, a);
          })(_l(t(r, i)));
        }, n)
      : (typeof e == "number" && (n = e),
        wl(function (r, i) {
          return Fse(r, i, t, n);
        }))
  );
}
function $se(t) {
  return t === void 0 && (t = 1 / 0), C7(Sw, t);
}
function Use() {
  return $se(1);
}
function pI() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
  return Use()(Rse(t, EU(t)));
}
function jse(t) {
  return new aa(function (e) {
    _l(t()).subscribe(e);
  });
}
var Hse = ["addListener", "removeListener"],
  zse = ["addEventListener", "removeEventListener"],
  Vse = ["on", "off"];
function uE(t, e, n, r) {
  if ((_r(n) && ((r = n), (n = void 0)), r)) return uE(t, e, n).pipe(MU(r));
  var i = Kc(
      qse(t)
        ? zse.map(function (o) {
            return function (l) {
              return t[o](e, l, n);
            };
          })
        : Gse(t)
        ? Hse.map(mI(t, e))
        : Wse(t)
        ? Vse.map(mI(t, e))
        : [],
      2
    ),
    s = i[0],
    a = i[1];
  if (!s && A7(t))
    return C7(function (o) {
      return uE(o, e, n);
    })(_l(t));
  if (!s) throw new TypeError("Invalid event target");
  return new aa(function (o) {
    var l = function () {
      for (var u = [], f = 0; f < arguments.length; f++) u[f] = arguments[f];
      return o.next(1 < u.length ? u : u[0]);
    };
    return (
      s(l),
      function () {
        return a(l);
      }
    );
  });
}
function mI(t, e) {
  return function (n) {
    return function (r) {
      return t[n](e, r);
    };
  };
}
function Gse(t) {
  return _r(t.addListener) && _r(t.removeListener);
}
function Wse(t) {
  return _r(t.on) && _r(t.off);
}
function qse(t) {
  return _r(t.addEventListener) && _r(t.removeEventListener);
}
function k7(t, e, n) {
  return n
    ? k7(t, e).pipe(MU(n))
    : new aa(function (r) {
        var i = function () {
            for (var a = [], o = 0; o < arguments.length; o++)
              a[o] = arguments[o];
            return r.next(a.length === 1 ? a[0] : a);
          },
          s = t(i);
        return _r(e)
          ? function () {
              return e(i, s);
            }
          : void 0;
      });
}
function D0(t, e) {
  return wl(function (n, r) {
    var i = 0;
    n.subscribe(
      gl(r, function (s) {
        return t.call(e, s, i++) && r.next(s);
      })
    );
  });
}
function I7(t) {
  return t <= 0
    ? function () {
        return _U;
      }
    : wl(function (e, n) {
        var r = 0;
        e.subscribe(
          gl(n, function (i) {
            ++r <= t && (n.next(i), t <= r && n.complete());
          })
        );
      });
}
function gI(t) {
  return wy(function () {
    return t;
  });
}
function LU(t, e) {
  return (
    e === void 0 && (e = Sw),
    (t = t ?? Kse),
    wl(function (n, r) {
      var i,
        s = !0;
      n.subscribe(
        gl(r, function (a) {
          var o = e(a);
          (s || !t(i, o)) && ((s = !1), (i = o), r.next(a));
        })
      );
    })
  );
}
function Kse(t, e) {
  return t === e;
}
function Xse(t, e) {
  return LU(function (n, r) {
    return e ? e(n[t], r[t]) : n[t] === r[t];
  });
}
function O7() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
  var n = t.length;
  if (n === 0) throw new Error("list of properties cannot be empty.");
  return wy(function (r) {
    for (var i = r, s = 0; s < n; s++) {
      var a = i?.[t[s]];
      if (typeof a < "u") i = a;
      else return;
    }
    return i;
  });
}
function cE(t) {
  t === void 0 && (t = {});
  var e = t.connector,
    n =
      e === void 0
        ? function () {
            return new sf();
          }
        : e,
    r = t.resetOnError,
    i = r === void 0 ? !0 : r,
    s = t.resetOnComplete,
    a = s === void 0 ? !0 : s,
    o = t.resetOnRefCountZero,
    l = o === void 0 ? !0 : o;
  return function (u) {
    var f,
      c,
      d,
      p = 0,
      m = !1,
      g = !1,
      w = function () {
        c?.unsubscribe(), (c = void 0);
      },
      y = function () {
        w(), (f = d = void 0), (m = g = !1);
      },
      v = function () {
        var E = f;
        y(), E?.unsubscribe();
      };
    return wl(function (E, S) {
      p++, !g && !m && w();
      var D = (d = d ?? n());
      S.add(function () {
        p--, p === 0 && !g && !m && (c = S_(v, l));
      }),
        D.subscribe(S),
        !f &&
          p > 0 &&
          ((f = new N0({
            next: function (P) {
              return D.next(P);
            },
            error: function (P) {
              (g = !0), w(), (c = S_(y, i, P)), D.error(P);
            },
            complete: function () {
              (m = !0), w(), (c = S_(y, a)), D.complete();
            },
          })),
          _l(E).subscribe(f));
    })(u);
  };
}
function S_(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var i = new N0({
      next: function () {
        i.unsubscribe(), t();
      },
    });
    return _l(e.apply(void 0, od([], Kc(n)))).subscribe(i);
  }
}
function Xc(t, e, n) {
  var r,
    i,
    s,
    a,
    o = !1;
  return (
    t && typeof t == "object"
      ? ((r = t.bufferSize),
        (a = r === void 0 ? 1 / 0 : r),
        (i = t.windowTime),
        (e = i === void 0 ? 1 / 0 : i),
        (s = t.refCount),
        (o = s === void 0 ? !1 : s),
        (n = t.scheduler))
      : (a = t ?? 1 / 0),
    cE({
      connector: function () {
        return new yse(a, e, n);
      },
      resetOnError: !0,
      resetOnComplete: !1,
      resetOnRefCountZero: o,
    })
  );
}
function Uc() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
  var n = EU(t);
  return wl(function (r, i) {
    (n ? pI(t, r, n) : pI(t, r)).subscribe(i);
  });
}
function yI(t, e) {
  return wl(function (n, r) {
    var i = null,
      s = 0,
      a = !1,
      o = function () {
        return a && !i && r.complete();
      };
    n.subscribe(
      gl(
        r,
        function (l) {
          i?.unsubscribe();
          var u = 0,
            f = s++;
          _l(t(l, f)).subscribe(
            (i = gl(
              r,
              function (c) {
                return r.next(e ? e(l, c, f, u++) : c);
              },
              function () {
                (i = null), o();
              }
            ))
          );
        },
        function () {
          (a = !0), o();
        }
      )
    );
  });
}
function Lg(t) {
  return wl(function (e, n) {
    _l(t).subscribe(
      gl(
        n,
        function () {
          return n.complete();
        },
        Jb
      )
    ),
      !n.closed && e.subscribe(n);
  });
}
function BU() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
  var n = wse(t);
  return wl(function (r, i) {
    for (
      var s = t.length,
        a = new Array(s),
        o = t.map(function () {
          return !1;
        }),
        l = !1,
        u = function (c) {
          _l(t[c]).subscribe(
            gl(
              i,
              function (d) {
                (a[c] = d),
                  !l && !o[c] && ((o[c] = !0), (l = o.every(Sw)) && (o = null));
              },
              Jb
            )
          );
        },
        f = 0;
      f < s;
      f++
    )
      u(f);
    r.subscribe(
      gl(i, function (c) {
        if (l) {
          var d = od([c], Kc(a));
          i.next(n ? n.apply(void 0, od([], Kc(d))) : d);
        }
      })
    );
  });
}
const Zse = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku",
  },
  FU = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser",
  },
  Ai = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" },
  pa = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku",
  },
  Cf = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit",
  };
class He {
  static getFirstMatch(e, n) {
    const r = n.match(e);
    return (r && r.length > 0 && r[1]) || "";
  }
  static getSecondMatch(e, n) {
    const r = n.match(e);
    return (r && r.length > 1 && r[2]) || "";
  }
  static matchAndReturnConst(e, n, r) {
    if (e.test(n)) return r;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(e) {
    const n = e
      .split(".")
      .splice(0, 2)
      .map((r) => parseInt(r, 10) || 0);
    if ((n.push(0), n[0] === 10))
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  static getAndroidVersionName(e) {
    const n = e
      .split(".")
      .splice(0, 2)
      .map((r) => parseInt(r, 10) || 0);
    if ((n.push(0), !(n[0] === 1 && n[1] < 5))) {
      if (n[0] === 1 && n[1] < 6) return "Cupcake";
      if (n[0] === 1 && n[1] >= 6) return "Donut";
      if (n[0] === 2 && n[1] < 2) return "Eclair";
      if (n[0] === 2 && n[1] === 2) return "Froyo";
      if (n[0] === 2 && n[1] > 2) return "Gingerbread";
      if (n[0] === 3) return "Honeycomb";
      if (n[0] === 4 && n[1] < 1) return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4) return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4) return "KitKat";
      if (n[0] === 5) return "Lollipop";
      if (n[0] === 6) return "Marshmallow";
      if (n[0] === 7) return "Nougat";
      if (n[0] === 8) return "Oreo";
      if (n[0] === 9) return "Pie";
    }
  }
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  static compareVersions(e, n, r = !1) {
    const i = He.getVersionPrecision(e),
      s = He.getVersionPrecision(n);
    let a = Math.max(i, s),
      o = 0;
    const l = He.map([e, n], (u) => {
      const f = a - He.getVersionPrecision(u),
        c = u + new Array(f + 1).join(".0");
      return He.map(
        c.split("."),
        (d) => new Array(20 - d.length).join("0") + d
      ).reverse();
    });
    for (r && (o = a - Math.min(i, s)), a -= 1; a >= o; ) {
      if (l[0][a] > l[1][a]) return 1;
      if (l[0][a] === l[1][a]) {
        if (a === o) return 0;
        a -= 1;
      } else if (l[0][a] < l[1][a]) return -1;
    }
  }
  static map(e, n) {
    const r = [];
    let i;
    if (Array.prototype.map) return Array.prototype.map.call(e, n);
    for (i = 0; i < e.length; i += 1) r.push(n(e[i]));
    return r;
  }
  static find(e, n) {
    let r, i;
    if (Array.prototype.find) return Array.prototype.find.call(e, n);
    for (r = 0, i = e.length; r < i; r += 1) {
      const s = e[r];
      if (n(s, r)) return s;
    }
  }
  static assign(e, ...n) {
    const r = e;
    let i, s;
    if (Object.assign) return Object.assign(e, ...n);
    for (i = 0, s = n.length; i < s; i += 1) {
      const a = n[i];
      typeof a == "object" &&
        a !== null &&
        Object.keys(a).forEach((l) => {
          r[l] = a[l];
        });
    }
    return e;
  }
  static getBrowserAlias(e) {
    return Zse[e];
  }
  static getBrowserTypeByAlias(e) {
    return FU[e] || "";
  }
}
const Cr = /version\/(\d+(\.?_?\d+)+)/i,
  Yse = [
    {
      test: [/googlebot/i],
      describe(t) {
        const e = { name: "Googlebot" },
          n =
            He.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/opera/i],
      describe(t) {
        const e = { name: "Opera" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/opr\/|opios/i],
      describe(t) {
        const e = { name: "Opera" },
          n =
            He.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/SamsungBrowser/i],
      describe(t) {
        const e = { name: "Samsung Internet for Android" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/Whale/i],
      describe(t) {
        const e = { name: "NAVER Whale Browser" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/MZBrowser/i],
      describe(t) {
        const e = { name: "MZ Browser" },
          n =
            He.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/focus/i],
      describe(t) {
        const e = { name: "Focus" },
          n =
            He.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/swing/i],
      describe(t) {
        const e = { name: "Swing" },
          n =
            He.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/coast/i],
      describe(t) {
        const e = { name: "Opera Coast" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(t) {
        const e = { name: "Opera Touch" },
          n =
            He.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/yabrowser/i],
      describe(t) {
        const e = { name: "Yandex Browser" },
          n =
            He.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/ucbrowser/i],
      describe(t) {
        const e = { name: "UC Browser" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/Maxthon|mxios/i],
      describe(t) {
        const e = { name: "Maxthon" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/epiphany/i],
      describe(t) {
        const e = { name: "Epiphany" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/puffin/i],
      describe(t) {
        const e = { name: "Puffin" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/sleipnir/i],
      describe(t) {
        const e = { name: "Sleipnir" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/k-meleon/i],
      describe(t) {
        const e = { name: "K-Meleon" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/micromessenger/i],
      describe(t) {
        const e = { name: "WeChat" },
          n =
            He.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/qqbrowser/i],
      describe(t) {
        const e = {
            name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser",
          },
          n =
            He.getFirstMatch(
              /(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,
              t
            ) || He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/msie|trident/i],
      describe(t) {
        const e = { name: "Internet Explorer" },
          n = He.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/\sedg\//i],
      describe(t) {
        const e = { name: "Microsoft Edge" },
          n = He.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(t) {
        const e = { name: "Microsoft Edge" },
          n = He.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/vivaldi/i],
      describe(t) {
        const e = { name: "Vivaldi" },
          n = He.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/seamonkey/i],
      describe(t) {
        const e = { name: "SeaMonkey" },
          n = He.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/sailfish/i],
      describe(t) {
        const e = { name: "Sailfish" },
          n = He.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/silk/i],
      describe(t) {
        const e = { name: "Amazon Silk" },
          n = He.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/phantom/i],
      describe(t) {
        const e = { name: "PhantomJS" },
          n = He.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/slimerjs/i],
      describe(t) {
        const e = { name: "SlimerJS" },
          n = He.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(t) {
        const e = { name: "BlackBerry" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(t) {
        const e = { name: "WebOS Browser" },
          n =
            He.getFirstMatch(Cr, t) ||
            He.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/bada/i],
      describe(t) {
        const e = { name: "Bada" },
          n = He.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/tizen/i],
      describe(t) {
        const e = { name: "Tizen" },
          n =
            He.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/qupzilla/i],
      describe(t) {
        const e = { name: "QupZilla" },
          n =
            He.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(t) {
        const e = { name: "Firefox" },
          n = He.getFirstMatch(
            /(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,
            t
          );
        return n && (e.version = n), e;
      },
    },
    {
      test: [/electron/i],
      describe(t) {
        const e = { name: "Electron" },
          n = He.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/MiuiBrowser/i],
      describe(t) {
        const e = { name: "Miui" },
          n = He.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/chromium/i],
      describe(t) {
        const e = { name: "Chromium" },
          n =
            He.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) ||
            He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(t) {
        const e = { name: "Chrome" },
          n = He.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/GSA/i],
      describe(t) {
        const e = { name: "Google Search" },
          n = He.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test(t) {
        const e = !t.test(/like android/i),
          n = t.test(/android/i);
        return e && n;
      },
      describe(t) {
        const e = { name: "Android Browser" },
          n = He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/playstation 4/i],
      describe(t) {
        const e = { name: "PlayStation 4" },
          n = He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/safari|applewebkit/i],
      describe(t) {
        const e = { name: "Safari" },
          n = He.getFirstMatch(Cr, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/.*/i],
      describe(t) {
        const e = /^(.*)\/(.*) /,
          n = /^(.*)\/(.*)[ \t]\((.*)/,
          i = t.search("\\(") !== -1 ? n : e;
        return {
          name: He.getFirstMatch(i, t),
          version: He.getSecondMatch(i, t),
        };
      },
    },
  ],
  Qse = [
    {
      test: [/Roku\/DVP/],
      describe(t) {
        const e = He.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
        return { name: pa.Roku, version: e };
      },
    },
    {
      test: [/windows phone/i],
      describe(t) {
        const e = He.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
        return { name: pa.WindowsPhone, version: e };
      },
    },
    {
      test: [/windows /i],
      describe(t) {
        const e = He.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t),
          n = He.getWindowsVersionName(e);
        return { name: pa.Windows, version: e, versionName: n };
      },
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(t) {
        const e = { name: pa.iOS },
          n = He.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/macintosh/i],
      describe(t) {
        const e = He.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(
            /[_\s]/g,
            "."
          ),
          n = He.getMacOSVersionName(e),
          r = { name: pa.MacOS, version: e };
        return n && (r.versionName = n), r;
      },
    },
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(t) {
        const e = He.getFirstMatch(
          /os (\d+([_\s]\d+)*) like mac os x/i,
          t
        ).replace(/[_\s]/g, ".");
        return { name: pa.iOS, version: e };
      },
    },
    {
      test(t) {
        const e = !t.test(/like android/i),
          n = t.test(/android/i);
        return e && n;
      },
      describe(t) {
        const e = He.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t),
          n = He.getAndroidVersionName(e),
          r = { name: pa.Android, version: e };
        return n && (r.versionName = n), r;
      },
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(t) {
        const e = He.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t),
          n = { name: pa.WebOS };
        return e && e.length && (n.version = e), n;
      },
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(t) {
        const e =
          He.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) ||
          He.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) ||
          He.getFirstMatch(/\bbb(\d+)/i, t);
        return { name: pa.BlackBerry, version: e };
      },
    },
    {
      test: [/bada/i],
      describe(t) {
        const e = He.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
        return { name: pa.Bada, version: e };
      },
    },
    {
      test: [/tizen/i],
      describe(t) {
        const e = He.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
        return { name: pa.Tizen, version: e };
      },
    },
    {
      test: [/linux/i],
      describe() {
        return { name: pa.Linux };
      },
    },
    {
      test: [/CrOS/],
      describe() {
        return { name: pa.ChromeOS };
      },
    },
    {
      test: [/PlayStation 4/],
      describe(t) {
        const e = He.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
        return { name: pa.PlayStation4, version: e };
      },
    },
  ],
  Jse = [
    {
      test: [/googlebot/i],
      describe() {
        return { type: "bot", vendor: "Google" };
      },
    },
    {
      test: [/huawei/i],
      describe(t) {
        const e = He.getFirstMatch(/(can-l01)/i, t) && "Nova",
          n = { type: Ai.mobile, vendor: "Huawei" };
        return e && (n.model = e), n;
      },
    },
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return { type: Ai.tablet, vendor: "Nexus" };
      },
    },
    {
      test: [/ipad/i],
      describe() {
        return { type: Ai.tablet, vendor: "Apple", model: "iPad" };
      },
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return { type: Ai.tablet, vendor: "Apple", model: "iPad" };
      },
    },
    {
      test: [/kftt build/i],
      describe() {
        return { type: Ai.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
      },
    },
    {
      test: [/silk/i],
      describe() {
        return { type: Ai.tablet, vendor: "Amazon" };
      },
    },
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return { type: Ai.tablet };
      },
    },
    {
      test(t) {
        const e = t.test(/ipod|iphone/i),
          n = t.test(/like (ipod|iphone)/i);
        return e && !n;
      },
      describe(t) {
        const e = He.getFirstMatch(/(ipod|iphone)/i, t);
        return { type: Ai.mobile, vendor: "Apple", model: e };
      },
    },
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return { type: Ai.mobile, vendor: "Nexus" };
      },
    },
    {
      test: [/[^-]mobi/i],
      describe() {
        return { type: Ai.mobile };
      },
    },
    {
      test(t) {
        return t.getBrowserName(!0) === "blackberry";
      },
      describe() {
        return { type: Ai.mobile, vendor: "BlackBerry" };
      },
    },
    {
      test(t) {
        return t.getBrowserName(!0) === "bada";
      },
      describe() {
        return { type: Ai.mobile };
      },
    },
    {
      test(t) {
        return t.getBrowserName() === "windows phone";
      },
      describe() {
        return { type: Ai.mobile, vendor: "Microsoft" };
      },
    },
    {
      test(t) {
        const e = Number(String(t.getOSVersion()).split(".")[0]);
        return t.getOSName(!0) === "android" && e >= 3;
      },
      describe() {
        return { type: Ai.tablet };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "android";
      },
      describe() {
        return { type: Ai.mobile };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "macos";
      },
      describe() {
        return { type: Ai.desktop, vendor: "Apple" };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "windows";
      },
      describe() {
        return { type: Ai.desktop };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "linux";
      },
      describe() {
        return { type: Ai.desktop };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "playstation 4";
      },
      describe() {
        return { type: Ai.tv };
      },
    },
    {
      test(t) {
        return t.getOSName(!0) === "roku";
      },
      describe() {
        return { type: Ai.tv };
      },
    },
  ],
  eae = [
    {
      test(t) {
        return t.getBrowserName(!0) === "microsoft edge";
      },
      describe(t) {
        if (/\sedg\//i.test(t)) return { name: Cf.Blink };
        const n = He.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
        return { name: Cf.EdgeHTML, version: n };
      },
    },
    {
      test: [/trident/i],
      describe(t) {
        const e = { name: Cf.Trident },
          n = He.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test(t) {
        return t.test(/presto/i);
      },
      describe(t) {
        const e = { name: Cf.Presto },
          n = He.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test(t) {
        const e = t.test(/gecko/i),
          n = t.test(/like gecko/i);
        return e && !n;
      },
      describe(t) {
        const e = { name: Cf.Gecko },
          n = He.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return { name: Cf.Blink };
      },
    },
    {
      test: [/(apple)?webkit/i],
      describe(t) {
        const e = { name: Cf.WebKit },
          n = He.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
        return n && (e.version = n), e;
      },
    },
  ];
let vI = class {
  constructor(e, n = !1) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    (this._ua = e), (this.parsedResult = {}), n !== !0 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(e) {
    return e.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = He.find(Yse, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      e && (this.parsedResult.browser = e.describe(this.getUA())),
      this.parsedResult.browser
    );
  }
  getBrowser() {
    return this.parsedResult.browser
      ? this.parsedResult.browser
      : this.parseBrowser();
  }
  getBrowserName(e) {
    return e
      ? String(this.getBrowser().name).toLowerCase() || ""
      : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const e = He.find(Qse, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      e && (this.parsedResult.os = e.describe(this.getUA())),
      this.parsedResult.os
    );
  }
  getOSName(e) {
    const { name: n } = this.getOS();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform
      ? this.parsedResult.platform
      : this.parsePlatform();
  }
  getPlatformType(e = !1) {
    const { type: n } = this.getPlatform();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = He.find(Jse, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      e && (this.parsedResult.platform = e.describe(this.getUA())),
      this.parsedResult.platform
    );
  }
  getEngine() {
    return this.parsedResult.engine
      ? this.parsedResult.engine
      : this.parseEngine();
  }
  getEngineName(e) {
    return e
      ? String(this.getEngine().name).toLowerCase() || ""
      : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const e = He.find(eae, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      e && (this.parsedResult.engine = e.describe(this.getUA())),
      this.parsedResult.engine
    );
  }
  parse() {
    return (
      this.parseBrowser(),
      this.parseOS(),
      this.parsePlatform(),
      this.parseEngine(),
      this
    );
  }
  getResult() {
    return He.assign({}, this.parsedResult);
  }
  satisfies(e) {
    const n = {};
    let r = 0;
    const i = {};
    let s = 0;
    if (
      (Object.keys(e).forEach((o) => {
        const l = e[o];
        typeof l == "string"
          ? ((i[o] = l), (s += 1))
          : typeof l == "object" && ((n[o] = l), (r += 1));
      }),
      r > 0)
    ) {
      const o = Object.keys(n),
        l = He.find(o, (f) => this.isOS(f));
      if (l) {
        const f = this.satisfies(n[l]);
        if (f !== void 0) return f;
      }
      const u = He.find(o, (f) => this.isPlatform(f));
      if (u) {
        const f = this.satisfies(n[u]);
        if (f !== void 0) return f;
      }
    }
    if (s > 0) {
      const o = Object.keys(i),
        l = He.find(o, (u) => this.isBrowser(u, !0));
      if (l !== void 0) return this.compareVersion(i[l]);
    }
  }
  isBrowser(e, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let i = e.toLowerCase();
    const s = He.getBrowserTypeByAlias(i);
    return n && s && (i = s.toLowerCase()), i === r;
  }
  compareVersion(e) {
    let n = [0],
      r = e,
      i = !1;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return (
        e[0] === ">" || e[0] === "<"
          ? ((r = e.substr(1)),
            e[1] === "=" ? ((i = !0), (r = e.substr(2))) : (n = []),
            e[0] === ">" ? n.push(1) : n.push(-1))
          : e[0] === "="
          ? (r = e.substr(1))
          : e[0] === "~" && ((i = !0), (r = e.substr(1))),
        n.indexOf(He.compareVersions(s, r, i)) > -1
      );
  }
  isOS(e) {
    return this.getOSName(!0) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(!0) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(!0) === String(e).toLowerCase();
  }
  is(e, n = !1) {
    return this.isBrowser(e, n) || this.isOS(e) || this.isPlatform(e);
  }
  some(e = []) {
    return e.some((n) => this.is(n));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */ class tae {
  static getParser(e, n = !1) {
    if (typeof e != "string") throw new Error("UserAgent should be a string");
    return new vI(e, n);
  }
  static parse(e) {
    return new vI(e).getResult();
  }
  static get BROWSER_MAP() {
    return FU;
  }
  static get ENGINE_MAP() {
    return Cf;
  }
  static get OS_MAP() {
    return pa;
  }
  static get PLATFORMS_MAP() {
    return Ai;
  }
}
function o0() {}
function nae(t) {
  return t();
}
function rae(t) {
  t.forEach(nae);
}
function iae(t) {
  return typeof t == "function";
}
function sae(t, e) {
  return t != t
    ? e == e
    : t !== e || (t && typeof t == "object") || typeof t == "function";
}
function $U(t, ...e) {
  if (t == null) return o0;
  const n = t.subscribe(...e);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function aae(t) {
  let e;
  return $U(t, (n) => (e = n))(), e;
}
const lp = [];
function oae(t, e) {
  return { subscribe: Cw(t, e).subscribe };
}
function Cw(t, e = o0) {
  let n;
  const r = new Set();
  function i(o) {
    if (sae(t, o) && ((t = o), n)) {
      const l = !lp.length;
      for (const u of r) u[1](), lp.push(u, t);
      if (l) {
        for (let u = 0; u < lp.length; u += 2) lp[u][0](lp[u + 1]);
        lp.length = 0;
      }
    }
  }
  function s(o) {
    i(o(t));
  }
  function a(o, l = o0) {
    const u = [o, l];
    return (
      r.add(u),
      r.size === 1 && (n = e(i) || o0),
      o(t),
      () => {
        r.delete(u), r.size === 0 && n && (n(), (n = null));
      }
    );
  }
  return { set: i, update: s, subscribe: a };
}
function d1(t, e, n) {
  const r = !Array.isArray(t),
    i = r ? [t] : t,
    s = e.length < 2;
  return oae(n, (a) => {
    let o = !1;
    const l = [];
    let u = 0,
      f = o0;
    const c = () => {
        if (u) return;
        f();
        const p = e(r ? l[0] : l, a);
        s ? a(p) : (f = iae(p) ? p : o0);
      },
      d = i.map((p, m) =>
        $U(
          p,
          (g) => {
            (l[m] = g), (u &= ~(1 << m)), o && c();
          },
          () => {
            u |= 1 << m;
          }
        )
      );
    return (
      (o = !0),
      c(),
      function () {
        rae(d), f(), (o = !1);
      }
    );
  });
}
var lae = function (e) {
  return uae(e) && !cae(e);
};
function uae(t) {
  return !!t && typeof t == "object";
}
function cae(t) {
  var e = Object.prototype.toString.call(t);
  return e === "[object RegExp]" || e === "[object Date]" || hae(t);
}
var fae = typeof Symbol == "function" && Symbol.for,
  dae = fae ? Symbol.for("react.element") : 60103;
function hae(t) {
  return t.$$typeof === dae;
}
function pae(t) {
  return Array.isArray(t) ? [] : {};
}
function Bg(t, e) {
  return e.clone !== !1 && e.isMergeableObject(t) ? R0(pae(t), t, e) : t;
}
function mae(t, e, n) {
  return t.concat(e).map(function (r) {
    return Bg(r, n);
  });
}
function gae(t, e) {
  if (!e.customMerge) return R0;
  var n = e.customMerge(t);
  return typeof n == "function" ? n : R0;
}
function yae(t) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(t).filter(function (e) {
        return Object.propertyIsEnumerable.call(t, e);
      })
    : [];
}
function bI(t) {
  return Object.keys(t).concat(yae(t));
}
function UU(t, e) {
  try {
    return e in t;
  } catch {
    return !1;
  }
}
function vae(t, e) {
  return (
    UU(t, e) &&
    !(
      Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e)
    )
  );
}
function bae(t, e, n) {
  var r = {};
  return (
    n.isMergeableObject(t) &&
      bI(t).forEach(function (i) {
        r[i] = Bg(t[i], n);
      }),
    bI(e).forEach(function (i) {
      vae(t, i) ||
        (UU(t, i) && n.isMergeableObject(e[i])
          ? (r[i] = gae(i, n)(t[i], e[i], n))
          : (r[i] = Bg(e[i], n)));
    }),
    r
  );
}
function R0(t, e, n) {
  (n = n || {}),
    (n.arrayMerge = n.arrayMerge || mae),
    (n.isMergeableObject = n.isMergeableObject || lae),
    (n.cloneUnlessOtherwiseSpecified = Bg);
  var r = Array.isArray(e),
    i = Array.isArray(t),
    s = r === i;
  return s ? (r ? n.arrayMerge(t, e, n) : bae(t, e, n)) : Bg(e, n);
}
R0.all = function (e, n) {
  if (!Array.isArray(e)) throw new Error("first argument should be an array");
  return e.reduce(function (r, i) {
    return R0(r, i, n);
  }, {});
};
var wae = R0,
  _ae = wae;
const Eae = oa(_ae);
var fE = function (t, e) {
  return (
    (fE =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r;
        }) ||
      function (n, r) {
        for (var i in r)
          Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }),
    fE(t, e)
  );
};
function kw(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null"
    );
  fE(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
var Ff = function () {
  return (
    (Ff =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    Ff.apply(this, arguments)
  );
};
function A_(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) &&
        (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
  return t.concat(s || Array.prototype.slice.call(e));
}
var e5 = function () {
  return (
    (e5 =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    e5.apply(this, arguments)
  );
};
var Zn;
(function (t) {
  (t[(t.EXPECT_ARGUMENT_CLOSING_BRACE = 1)] = "EXPECT_ARGUMENT_CLOSING_BRACE"),
    (t[(t.EMPTY_ARGUMENT = 2)] = "EMPTY_ARGUMENT"),
    (t[(t.MALFORMED_ARGUMENT = 3)] = "MALFORMED_ARGUMENT"),
    (t[(t.EXPECT_ARGUMENT_TYPE = 4)] = "EXPECT_ARGUMENT_TYPE"),
    (t[(t.INVALID_ARGUMENT_TYPE = 5)] = "INVALID_ARGUMENT_TYPE"),
    (t[(t.EXPECT_ARGUMENT_STYLE = 6)] = "EXPECT_ARGUMENT_STYLE"),
    (t[(t.INVALID_NUMBER_SKELETON = 7)] = "INVALID_NUMBER_SKELETON"),
    (t[(t.INVALID_DATE_TIME_SKELETON = 8)] = "INVALID_DATE_TIME_SKELETON"),
    (t[(t.EXPECT_NUMBER_SKELETON = 9)] = "EXPECT_NUMBER_SKELETON"),
    (t[(t.EXPECT_DATE_TIME_SKELETON = 10)] = "EXPECT_DATE_TIME_SKELETON"),
    (t[(t.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11)] =
      "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"),
    (t[(t.EXPECT_SELECT_ARGUMENT_OPTIONS = 12)] =
      "EXPECT_SELECT_ARGUMENT_OPTIONS"),
    (t[(t.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13)] =
      "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"),
    (t[(t.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14)] =
      "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"),
    (t[(t.EXPECT_SELECT_ARGUMENT_SELECTOR = 15)] =
      "EXPECT_SELECT_ARGUMENT_SELECTOR"),
    (t[(t.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16)] =
      "EXPECT_PLURAL_ARGUMENT_SELECTOR"),
    (t[(t.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17)] =
      "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"),
    (t[(t.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18)] =
      "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"),
    (t[(t.INVALID_PLURAL_ARGUMENT_SELECTOR = 19)] =
      "INVALID_PLURAL_ARGUMENT_SELECTOR"),
    (t[(t.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20)] =
      "DUPLICATE_PLURAL_ARGUMENT_SELECTOR"),
    (t[(t.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21)] =
      "DUPLICATE_SELECT_ARGUMENT_SELECTOR"),
    (t[(t.MISSING_OTHER_CLAUSE = 22)] = "MISSING_OTHER_CLAUSE"),
    (t[(t.INVALID_TAG = 23)] = "INVALID_TAG"),
    (t[(t.INVALID_TAG_NAME = 25)] = "INVALID_TAG_NAME"),
    (t[(t.UNMATCHED_CLOSING_TAG = 26)] = "UNMATCHED_CLOSING_TAG"),
    (t[(t.UNCLOSED_TAG = 27)] = "UNCLOSED_TAG");
})(Zn || (Zn = {}));
var qr;
(function (t) {
  (t[(t.literal = 0)] = "literal"),
    (t[(t.argument = 1)] = "argument"),
    (t[(t.number = 2)] = "number"),
    (t[(t.date = 3)] = "date"),
    (t[(t.time = 4)] = "time"),
    (t[(t.select = 5)] = "select"),
    (t[(t.plural = 6)] = "plural"),
    (t[(t.pound = 7)] = "pound"),
    (t[(t.tag = 8)] = "tag");
})(qr || (qr = {}));
var M0;
(function (t) {
  (t[(t.number = 0)] = "number"), (t[(t.dateTime = 1)] = "dateTime");
})(M0 || (M0 = {}));
function wI(t) {
  return t.type === qr.literal;
}
function xae(t) {
  return t.type === qr.argument;
}
function jU(t) {
  return t.type === qr.number;
}
function HU(t) {
  return t.type === qr.date;
}
function zU(t) {
  return t.type === qr.time;
}
function VU(t) {
  return t.type === qr.select;
}
function GU(t) {
  return t.type === qr.plural;
}
function Tae(t) {
  return t.type === qr.pound;
}
function WU(t) {
  return t.type === qr.tag;
}
function qU(t) {
  return !!(t && typeof t == "object" && t.type === M0.number);
}
function dE(t) {
  return !!(t && typeof t == "object" && t.type === M0.dateTime);
}
var KU = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  Sae =
    /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function Aae(t) {
  var e = {};
  return (
    t.replace(Sae, function (n) {
      var r = n.length;
      switch (n[0]) {
        case "G":
          e.era = r === 4 ? "long" : r === 5 ? "narrow" : "short";
          break;
        case "y":
          e.year = r === 2 ? "2-digit" : "numeric";
          break;
        case "Y":
        case "u":
        case "U":
        case "r":
          throw new RangeError(
            "`Y/u/U/r` (year) patterns are not supported, use `y` instead"
          );
        case "q":
        case "Q":
          throw new RangeError("`q/Q` (quarter) patterns are not supported");
        case "M":
        case "L":
          e.month = ["numeric", "2-digit", "short", "long", "narrow"][r - 1];
          break;
        case "w":
        case "W":
          throw new RangeError("`w/W` (week) patterns are not supported");
        case "d":
          e.day = ["numeric", "2-digit"][r - 1];
          break;
        case "D":
        case "F":
        case "g":
          throw new RangeError(
            "`D/F/g` (day) patterns are not supported, use `d` instead"
          );
        case "E":
          e.weekday = r === 4 ? "short" : r === 5 ? "narrow" : "short";
          break;
        case "e":
          if (r < 4)
            throw new RangeError(
              "`e..eee` (weekday) patterns are not supported"
            );
          e.weekday = ["short", "long", "narrow", "short"][r - 4];
          break;
        case "c":
          if (r < 4)
            throw new RangeError(
              "`c..ccc` (weekday) patterns are not supported"
            );
          e.weekday = ["short", "long", "narrow", "short"][r - 4];
          break;
        case "a":
          e.hour12 = !0;
          break;
        case "b":
        case "B":
          throw new RangeError(
            "`b/B` (period) patterns are not supported, use `a` instead"
          );
        case "h":
          (e.hourCycle = "h12"), (e.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "H":
          (e.hourCycle = "h23"), (e.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "K":
          (e.hourCycle = "h11"), (e.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "k":
          (e.hourCycle = "h24"), (e.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "j":
        case "J":
        case "C":
          throw new RangeError(
            "`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead"
          );
        case "m":
          e.minute = ["numeric", "2-digit"][r - 1];
          break;
        case "s":
          e.second = ["numeric", "2-digit"][r - 1];
          break;
        case "S":
        case "A":
          throw new RangeError(
            "`S/A` (second) patterns are not supported, use `s` instead"
          );
        case "z":
          e.timeZoneName = r < 4 ? "short" : "long";
          break;
        case "Z":
        case "O":
        case "v":
        case "V":
        case "X":
        case "x":
          throw new RangeError(
            "`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead"
          );
      }
      return "";
    }),
    e
  );
}
var hi = function () {
  return (
    (hi =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    hi.apply(this, arguments)
  );
};
var Cae = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function kae(t) {
  if (t.length === 0) throw new Error("Number skeleton cannot be empty");
  for (
    var e = t.split(Cae).filter(function (d) {
        return d.length > 0;
      }),
      n = [],
      r = 0,
      i = e;
    r < i.length;
    r++
  ) {
    var s = i[r],
      a = s.split("/");
    if (a.length === 0) throw new Error("Invalid number skeleton");
    for (var o = a[0], l = a.slice(1), u = 0, f = l; u < f.length; u++) {
      var c = f[u];
      if (c.length === 0) throw new Error("Invalid number skeleton");
    }
    n.push({ stem: o, options: l });
  }
  return n;
}
function Iae(t) {
  return t.replace(/^(.*?)-/, "");
}
var _I = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g,
  XU = /^(@+)?(\+|#+)?[rs]?$/g,
  Oae = /(\*)(0+)|(#+)(0+)|(0+)/g,
  ZU = /^(0+)$/;
function EI(t) {
  var e = {};
  return (
    t[t.length - 1] === "r"
      ? (e.roundingPriority = "morePrecision")
      : t[t.length - 1] === "s" && (e.roundingPriority = "lessPrecision"),
    t.replace(XU, function (n, r, i) {
      return (
        typeof i != "string"
          ? ((e.minimumSignificantDigits = r.length),
            (e.maximumSignificantDigits = r.length))
          : i === "+"
          ? (e.minimumSignificantDigits = r.length)
          : r[0] === "#"
          ? (e.maximumSignificantDigits = r.length)
          : ((e.minimumSignificantDigits = r.length),
            (e.maximumSignificantDigits =
              r.length + (typeof i == "string" ? i.length : 0))),
        ""
      );
    }),
    e
  );
}
function YU(t) {
  switch (t) {
    case "sign-auto":
      return { signDisplay: "auto" };
    case "sign-accounting":
    case "()":
      return { currencySign: "accounting" };
    case "sign-always":
    case "+!":
      return { signDisplay: "always" };
    case "sign-accounting-always":
    case "()!":
      return { signDisplay: "always", currencySign: "accounting" };
    case "sign-except-zero":
    case "+?":
      return { signDisplay: "exceptZero" };
    case "sign-accounting-except-zero":
    case "()?":
      return { signDisplay: "exceptZero", currencySign: "accounting" };
    case "sign-never":
    case "+_":
      return { signDisplay: "never" };
  }
}
function Pae(t) {
  var e;
  if (
    (t[0] === "E" && t[1] === "E"
      ? ((e = { notation: "engineering" }), (t = t.slice(2)))
      : t[0] === "E" && ((e = { notation: "scientific" }), (t = t.slice(1))),
    e)
  ) {
    var n = t.slice(0, 2);
    if (
      (n === "+!"
        ? ((e.signDisplay = "always"), (t = t.slice(2)))
        : n === "+?" && ((e.signDisplay = "exceptZero"), (t = t.slice(2))),
      !ZU.test(t))
    )
      throw new Error("Malformed concise eng/scientific notation");
    e.minimumIntegerDigits = t.length;
  }
  return e;
}
function xI(t) {
  var e = {},
    n = YU(t);
  return n || e;
}
function Nae(t) {
  for (var e = {}, n = 0, r = t; n < r.length; n++) {
    var i = r[n];
    switch (i.stem) {
      case "percent":
      case "%":
        e.style = "percent";
        continue;
      case "%x100":
        (e.style = "percent"), (e.scale = 100);
        continue;
      case "currency":
        (e.style = "currency"), (e.currency = i.options[0]);
        continue;
      case "group-off":
      case ",_":
        e.useGrouping = !1;
        continue;
      case "precision-integer":
      case ".":
        e.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        (e.style = "unit"), (e.unit = Iae(i.options[0]));
        continue;
      case "compact-short":
      case "K":
        (e.notation = "compact"), (e.compactDisplay = "short");
        continue;
      case "compact-long":
      case "KK":
        (e.notation = "compact"), (e.compactDisplay = "long");
        continue;
      case "scientific":
        e = hi(
          hi(hi({}, e), { notation: "scientific" }),
          i.options.reduce(function (l, u) {
            return hi(hi({}, l), xI(u));
          }, {})
        );
        continue;
      case "engineering":
        e = hi(
          hi(hi({}, e), { notation: "engineering" }),
          i.options.reduce(function (l, u) {
            return hi(hi({}, l), xI(u));
          }, {})
        );
        continue;
      case "notation-simple":
        e.notation = "standard";
        continue;
      case "unit-width-narrow":
        (e.currencyDisplay = "narrowSymbol"), (e.unitDisplay = "narrow");
        continue;
      case "unit-width-short":
        (e.currencyDisplay = "code"), (e.unitDisplay = "short");
        continue;
      case "unit-width-full-name":
        (e.currencyDisplay = "name"), (e.unitDisplay = "long");
        continue;
      case "unit-width-iso-code":
        e.currencyDisplay = "symbol";
        continue;
      case "scale":
        e.scale = parseFloat(i.options[0]);
        continue;
      case "integer-width":
        if (i.options.length > 1)
          throw new RangeError(
            "integer-width stems only accept a single optional option"
          );
        i.options[0].replace(Oae, function (l, u, f, c, d, p) {
          if (u) e.minimumIntegerDigits = f.length;
          else {
            if (c && d)
              throw new Error(
                "We currently do not support maximum integer digits"
              );
            if (p)
              throw new Error(
                "We currently do not support exact integer digits"
              );
          }
          return "";
        });
        continue;
    }
    if (ZU.test(i.stem)) {
      e.minimumIntegerDigits = i.stem.length;
      continue;
    }
    if (_I.test(i.stem)) {
      if (i.options.length > 1)
        throw new RangeError(
          "Fraction-precision stems only accept a single optional option"
        );
      i.stem.replace(_I, function (l, u, f, c, d, p) {
        return (
          f === "*"
            ? (e.minimumFractionDigits = u.length)
            : c && c[0] === "#"
            ? (e.maximumFractionDigits = c.length)
            : d && p
            ? ((e.minimumFractionDigits = d.length),
              (e.maximumFractionDigits = d.length + p.length))
            : ((e.minimumFractionDigits = u.length),
              (e.maximumFractionDigits = u.length)),
          ""
        );
      });
      var s = i.options[0];
      s === "w"
        ? (e = hi(hi({}, e), { trailingZeroDisplay: "stripIfInteger" }))
        : s && (e = hi(hi({}, e), EI(s)));
      continue;
    }
    if (XU.test(i.stem)) {
      e = hi(hi({}, e), EI(i.stem));
      continue;
    }
    var a = YU(i.stem);
    a && (e = hi(hi({}, e), a));
    var o = Pae(i.stem);
    o && (e = hi(hi({}, e), o));
  }
  return e;
}
var tv = {
  AX: ["H"],
  BQ: ["H"],
  CP: ["H"],
  CZ: ["H"],
  DK: ["H"],
  FI: ["H"],
  ID: ["H"],
  IS: ["H"],
  ML: ["H"],
  NE: ["H"],
  RU: ["H"],
  SE: ["H"],
  SJ: ["H"],
  SK: ["H"],
  AS: ["h", "H"],
  BT: ["h", "H"],
  DJ: ["h", "H"],
  ER: ["h", "H"],
  GH: ["h", "H"],
  IN: ["h", "H"],
  LS: ["h", "H"],
  PG: ["h", "H"],
  PW: ["h", "H"],
  SO: ["h", "H"],
  TO: ["h", "H"],
  VU: ["h", "H"],
  WS: ["h", "H"],
  "001": ["H", "h"],
  AL: ["h", "H", "hB"],
  TD: ["h", "H", "hB"],
  "ca-ES": ["H", "h", "hB"],
  CF: ["H", "h", "hB"],
  CM: ["H", "h", "hB"],
  "fr-CA": ["H", "h", "hB"],
  "gl-ES": ["H", "h", "hB"],
  "it-CH": ["H", "h", "hB"],
  "it-IT": ["H", "h", "hB"],
  LU: ["H", "h", "hB"],
  NP: ["H", "h", "hB"],
  PF: ["H", "h", "hB"],
  SC: ["H", "h", "hB"],
  SM: ["H", "h", "hB"],
  SN: ["H", "h", "hB"],
  TF: ["H", "h", "hB"],
  VA: ["H", "h", "hB"],
  CY: ["h", "H", "hb", "hB"],
  GR: ["h", "H", "hb", "hB"],
  CO: ["h", "H", "hB", "hb"],
  DO: ["h", "H", "hB", "hb"],
  KP: ["h", "H", "hB", "hb"],
  KR: ["h", "H", "hB", "hb"],
  NA: ["h", "H", "hB", "hb"],
  PA: ["h", "H", "hB", "hb"],
  PR: ["h", "H", "hB", "hb"],
  VE: ["h", "H", "hB", "hb"],
  AC: ["H", "h", "hb", "hB"],
  AI: ["H", "h", "hb", "hB"],
  BW: ["H", "h", "hb", "hB"],
  BZ: ["H", "h", "hb", "hB"],
  CC: ["H", "h", "hb", "hB"],
  CK: ["H", "h", "hb", "hB"],
  CX: ["H", "h", "hb", "hB"],
  DG: ["H", "h", "hb", "hB"],
  FK: ["H", "h", "hb", "hB"],
  GB: ["H", "h", "hb", "hB"],
  GG: ["H", "h", "hb", "hB"],
  GI: ["H", "h", "hb", "hB"],
  IE: ["H", "h", "hb", "hB"],
  IM: ["H", "h", "hb", "hB"],
  IO: ["H", "h", "hb", "hB"],
  JE: ["H", "h", "hb", "hB"],
  LT: ["H", "h", "hb", "hB"],
  MK: ["H", "h", "hb", "hB"],
  MN: ["H", "h", "hb", "hB"],
  MS: ["H", "h", "hb", "hB"],
  NF: ["H", "h", "hb", "hB"],
  NG: ["H", "h", "hb", "hB"],
  NR: ["H", "h", "hb", "hB"],
  NU: ["H", "h", "hb", "hB"],
  PN: ["H", "h", "hb", "hB"],
  SH: ["H", "h", "hb", "hB"],
  SX: ["H", "h", "hb", "hB"],
  TA: ["H", "h", "hb", "hB"],
  ZA: ["H", "h", "hb", "hB"],
  "af-ZA": ["H", "h", "hB", "hb"],
  AR: ["H", "h", "hB", "hb"],
  CL: ["H", "h", "hB", "hb"],
  CR: ["H", "h", "hB", "hb"],
  CU: ["H", "h", "hB", "hb"],
  EA: ["H", "h", "hB", "hb"],
  "es-BO": ["H", "h", "hB", "hb"],
  "es-BR": ["H", "h", "hB", "hb"],
  "es-EC": ["H", "h", "hB", "hb"],
  "es-ES": ["H", "h", "hB", "hb"],
  "es-GQ": ["H", "h", "hB", "hb"],
  "es-PE": ["H", "h", "hB", "hb"],
  GT: ["H", "h", "hB", "hb"],
  HN: ["H", "h", "hB", "hb"],
  IC: ["H", "h", "hB", "hb"],
  KG: ["H", "h", "hB", "hb"],
  KM: ["H", "h", "hB", "hb"],
  LK: ["H", "h", "hB", "hb"],
  MA: ["H", "h", "hB", "hb"],
  MX: ["H", "h", "hB", "hb"],
  NI: ["H", "h", "hB", "hb"],
  PY: ["H", "h", "hB", "hb"],
  SV: ["H", "h", "hB", "hb"],
  UY: ["H", "h", "hB", "hb"],
  JP: ["H", "h", "K"],
  AD: ["H", "hB"],
  AM: ["H", "hB"],
  AO: ["H", "hB"],
  AT: ["H", "hB"],
  AW: ["H", "hB"],
  BE: ["H", "hB"],
  BF: ["H", "hB"],
  BJ: ["H", "hB"],
  BL: ["H", "hB"],
  BR: ["H", "hB"],
  CG: ["H", "hB"],
  CI: ["H", "hB"],
  CV: ["H", "hB"],
  DE: ["H", "hB"],
  EE: ["H", "hB"],
  FR: ["H", "hB"],
  GA: ["H", "hB"],
  GF: ["H", "hB"],
  GN: ["H", "hB"],
  GP: ["H", "hB"],
  GW: ["H", "hB"],
  HR: ["H", "hB"],
  IL: ["H", "hB"],
  IT: ["H", "hB"],
  KZ: ["H", "hB"],
  MC: ["H", "hB"],
  MD: ["H", "hB"],
  MF: ["H", "hB"],
  MQ: ["H", "hB"],
  MZ: ["H", "hB"],
  NC: ["H", "hB"],
  NL: ["H", "hB"],
  PM: ["H", "hB"],
  PT: ["H", "hB"],
  RE: ["H", "hB"],
  RO: ["H", "hB"],
  SI: ["H", "hB"],
  SR: ["H", "hB"],
  ST: ["H", "hB"],
  TG: ["H", "hB"],
  TR: ["H", "hB"],
  WF: ["H", "hB"],
  YT: ["H", "hB"],
  BD: ["h", "hB", "H"],
  PK: ["h", "hB", "H"],
  AZ: ["H", "hB", "h"],
  BA: ["H", "hB", "h"],
  BG: ["H", "hB", "h"],
  CH: ["H", "hB", "h"],
  GE: ["H", "hB", "h"],
  LI: ["H", "hB", "h"],
  ME: ["H", "hB", "h"],
  RS: ["H", "hB", "h"],
  UA: ["H", "hB", "h"],
  UZ: ["H", "hB", "h"],
  XK: ["H", "hB", "h"],
  AG: ["h", "hb", "H", "hB"],
  AU: ["h", "hb", "H", "hB"],
  BB: ["h", "hb", "H", "hB"],
  BM: ["h", "hb", "H", "hB"],
  BS: ["h", "hb", "H", "hB"],
  CA: ["h", "hb", "H", "hB"],
  DM: ["h", "hb", "H", "hB"],
  "en-001": ["h", "hb", "H", "hB"],
  FJ: ["h", "hb", "H", "hB"],
  FM: ["h", "hb", "H", "hB"],
  GD: ["h", "hb", "H", "hB"],
  GM: ["h", "hb", "H", "hB"],
  GU: ["h", "hb", "H", "hB"],
  GY: ["h", "hb", "H", "hB"],
  JM: ["h", "hb", "H", "hB"],
  KI: ["h", "hb", "H", "hB"],
  KN: ["h", "hb", "H", "hB"],
  KY: ["h", "hb", "H", "hB"],
  LC: ["h", "hb", "H", "hB"],
  LR: ["h", "hb", "H", "hB"],
  MH: ["h", "hb", "H", "hB"],
  MP: ["h", "hb", "H", "hB"],
  MW: ["h", "hb", "H", "hB"],
  NZ: ["h", "hb", "H", "hB"],
  SB: ["h", "hb", "H", "hB"],
  SG: ["h", "hb", "H", "hB"],
  SL: ["h", "hb", "H", "hB"],
  SS: ["h", "hb", "H", "hB"],
  SZ: ["h", "hb", "H", "hB"],
  TC: ["h", "hb", "H", "hB"],
  TT: ["h", "hb", "H", "hB"],
  UM: ["h", "hb", "H", "hB"],
  US: ["h", "hb", "H", "hB"],
  VC: ["h", "hb", "H", "hB"],
  VG: ["h", "hb", "H", "hB"],
  VI: ["h", "hb", "H", "hB"],
  ZM: ["h", "hb", "H", "hB"],
  BO: ["H", "hB", "h", "hb"],
  EC: ["H", "hB", "h", "hb"],
  ES: ["H", "hB", "h", "hb"],
  GQ: ["H", "hB", "h", "hb"],
  PE: ["H", "hB", "h", "hb"],
  AE: ["h", "hB", "hb", "H"],
  "ar-001": ["h", "hB", "hb", "H"],
  BH: ["h", "hB", "hb", "H"],
  DZ: ["h", "hB", "hb", "H"],
  EG: ["h", "hB", "hb", "H"],
  EH: ["h", "hB", "hb", "H"],
  HK: ["h", "hB", "hb", "H"],
  IQ: ["h", "hB", "hb", "H"],
  JO: ["h", "hB", "hb", "H"],
  KW: ["h", "hB", "hb", "H"],
  LB: ["h", "hB", "hb", "H"],
  LY: ["h", "hB", "hb", "H"],
  MO: ["h", "hB", "hb", "H"],
  MR: ["h", "hB", "hb", "H"],
  OM: ["h", "hB", "hb", "H"],
  PH: ["h", "hB", "hb", "H"],
  PS: ["h", "hB", "hb", "H"],
  QA: ["h", "hB", "hb", "H"],
  SA: ["h", "hB", "hb", "H"],
  SD: ["h", "hB", "hb", "H"],
  SY: ["h", "hB", "hb", "H"],
  TN: ["h", "hB", "hb", "H"],
  YE: ["h", "hB", "hb", "H"],
  AF: ["H", "hb", "hB", "h"],
  LA: ["H", "hb", "hB", "h"],
  CN: ["H", "hB", "hb", "h"],
  LV: ["H", "hB", "hb", "h"],
  TL: ["H", "hB", "hb", "h"],
  "zu-ZA": ["H", "hB", "hb", "h"],
  CD: ["hB", "H"],
  IR: ["hB", "H"],
  "hi-IN": ["hB", "h", "H"],
  "kn-IN": ["hB", "h", "H"],
  "ml-IN": ["hB", "h", "H"],
  "te-IN": ["hB", "h", "H"],
  KH: ["hB", "h", "H", "hb"],
  "ta-IN": ["hB", "h", "hb", "H"],
  BN: ["hb", "hB", "h", "H"],
  MY: ["hb", "hB", "h", "H"],
  ET: ["hB", "hb", "h", "H"],
  "gu-IN": ["hB", "hb", "h", "H"],
  "mr-IN": ["hB", "hb", "h", "H"],
  "pa-IN": ["hB", "hb", "h", "H"],
  TW: ["hB", "hb", "h", "H"],
  KE: ["hB", "hb", "H", "h"],
  MM: ["hB", "hb", "H", "h"],
  TZ: ["hB", "hb", "H", "h"],
  UG: ["hB", "hb", "H", "h"],
};
function Dae(t, e) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t.charAt(r);
    if (i === "j") {
      for (var s = 0; r + 1 < t.length && t.charAt(r + 1) === i; ) s++, r++;
      var a = 1 + (s & 1),
        o = s < 2 ? 1 : 3 + (s >> 1),
        l = "a",
        u = Rae(e);
      for ((u == "H" || u == "k") && (o = 0); o-- > 0; ) n += l;
      for (; a-- > 0; ) n = u + n;
    } else i === "J" ? (n += "H") : (n += i);
  }
  return n;
}
function Rae(t) {
  var e = t.hourCycle;
  if (
    (e === void 0 &&
      t.hourCycles &&
      t.hourCycles.length &&
      (e = t.hourCycles[0]),
    e)
  )
    switch (e) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  var n = t.language,
    r;
  n !== "root" && (r = t.maximize().region);
  var i = tv[r || ""] || tv[n || ""] || tv["".concat(n, "-001")] || tv["001"];
  return i[0];
}
var C_,
  Mae = new RegExp("^".concat(KU.source, "*")),
  Lae = new RegExp("".concat(KU.source, "*$"));
function Jn(t, e) {
  return { start: t, end: e };
}
var Bae = !!String.prototype.startsWith,
  Fae = !!String.fromCodePoint,
  $ae = !!Object.fromEntries,
  Uae = !!String.prototype.codePointAt,
  jae = !!String.prototype.trimStart,
  Hae = !!String.prototype.trimEnd,
  zae = !!Number.isSafeInteger,
  Vae = zae
    ? Number.isSafeInteger
    : function (t) {
        return (
          typeof t == "number" &&
          isFinite(t) &&
          Math.floor(t) === t &&
          Math.abs(t) <= 9007199254740991
        );
      },
  hE = !0;
try {
  var Gae = JU("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  hE =
    ((C_ = Gae.exec("a")) === null || C_ === void 0 ? void 0 : C_[0]) === "a";
} catch {
  hE = !1;
}
var TI = Bae
    ? function (e, n, r) {
        return e.startsWith(n, r);
      }
    : function (e, n, r) {
        return e.slice(r, r + n.length) === n;
      },
  pE = Fae
    ? String.fromCodePoint
    : function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
        for (var r = "", i = e.length, s = 0, a; i > s; ) {
          if (((a = e[s++]), a > 1114111))
            throw RangeError(a + " is not a valid code point");
          r +=
            a < 65536
              ? String.fromCharCode(a)
              : String.fromCharCode(
                  ((a -= 65536) >> 10) + 55296,
                  (a % 1024) + 56320
                );
        }
        return r;
      },
  SI = $ae
    ? Object.fromEntries
    : function (e) {
        for (var n = {}, r = 0, i = e; r < i.length; r++) {
          var s = i[r],
            a = s[0],
            o = s[1];
          n[a] = o;
        }
        return n;
      },
  QU = Uae
    ? function (e, n) {
        return e.codePointAt(n);
      }
    : function (e, n) {
        var r = e.length;
        if (!(n < 0 || n >= r)) {
          var i = e.charCodeAt(n),
            s;
          return i < 55296 ||
            i > 56319 ||
            n + 1 === r ||
            (s = e.charCodeAt(n + 1)) < 56320 ||
            s > 57343
            ? i
            : ((i - 55296) << 10) + (s - 56320) + 65536;
        }
      },
  Wae = jae
    ? function (e) {
        return e.trimStart();
      }
    : function (e) {
        return e.replace(Mae, "");
      },
  qae = Hae
    ? function (e) {
        return e.trimEnd();
      }
    : function (e) {
        return e.replace(Lae, "");
      };
function JU(t, e) {
  return new RegExp(t, e);
}
var mE;
if (hE) {
  var AI = JU("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  mE = function (e, n) {
    var r;
    AI.lastIndex = n;
    var i = AI.exec(e);
    return (r = i[1]) !== null && r !== void 0 ? r : "";
  };
} else
  mE = function (e, n) {
    for (var r = []; ; ) {
      var i = QU(e, n);
      if (i === void 0 || ej(i) || Yae(i)) break;
      r.push(i), (n += i >= 65536 ? 2 : 1);
    }
    return pE.apply(void 0, r);
  };
var Kae = (function () {
  function t(e, n) {
    n === void 0 && (n = {}),
      (this.message = e),
      (this.position = { offset: 0, line: 1, column: 1 }),
      (this.ignoreTag = !!n.ignoreTag),
      (this.locale = n.locale),
      (this.requiresOtherClause = !!n.requiresOtherClause),
      (this.shouldParseSkeletons = !!n.shouldParseSkeletons);
  }
  return (
    (t.prototype.parse = function () {
      if (this.offset() !== 0) throw Error("parser can only be used once");
      return this.parseMessage(0, "", !1);
    }),
    (t.prototype.parseMessage = function (e, n, r) {
      for (var i = []; !this.isEOF(); ) {
        var s = this.char();
        if (s === 123) {
          var a = this.parseArgument(e, r);
          if (a.err) return a;
          i.push(a.val);
        } else {
          if (s === 125 && e > 0) break;
          if (s === 35 && (n === "plural" || n === "selectordinal")) {
            var o = this.clonePosition();
            this.bump(),
              i.push({ type: qr.pound, location: Jn(o, this.clonePosition()) });
          } else if (s === 60 && !this.ignoreTag && this.peek() === 47) {
            if (r) break;
            return this.error(
              Zn.UNMATCHED_CLOSING_TAG,
              Jn(this.clonePosition(), this.clonePosition())
            );
          } else if (s === 60 && !this.ignoreTag && gE(this.peek() || 0)) {
            var a = this.parseTag(e, n);
            if (a.err) return a;
            i.push(a.val);
          } else {
            var a = this.parseLiteral(e, n);
            if (a.err) return a;
            i.push(a.val);
          }
        }
      }
      return { val: i, err: null };
    }),
    (t.prototype.parseTag = function (e, n) {
      var r = this.clonePosition();
      this.bump();
      var i = this.parseTagName();
      if ((this.bumpSpace(), this.bumpIf("/>")))
        return {
          val: {
            type: qr.literal,
            value: "<".concat(i, "/>"),
            location: Jn(r, this.clonePosition()),
          },
          err: null,
        };
      if (this.bumpIf(">")) {
        var s = this.parseMessage(e + 1, n, !0);
        if (s.err) return s;
        var a = s.val,
          o = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !gE(this.char()))
            return this.error(Zn.INVALID_TAG, Jn(o, this.clonePosition()));
          var l = this.clonePosition(),
            u = this.parseTagName();
          return i !== u
            ? this.error(Zn.UNMATCHED_CLOSING_TAG, Jn(l, this.clonePosition()))
            : (this.bumpSpace(),
              this.bumpIf(">")
                ? {
                    val: {
                      type: qr.tag,
                      value: i,
                      children: a,
                      location: Jn(r, this.clonePosition()),
                    },
                    err: null,
                  }
                : this.error(Zn.INVALID_TAG, Jn(o, this.clonePosition())));
        } else return this.error(Zn.UNCLOSED_TAG, Jn(r, this.clonePosition()));
      } else return this.error(Zn.INVALID_TAG, Jn(r, this.clonePosition()));
    }),
    (t.prototype.parseTagName = function () {
      var e = this.offset();
      for (this.bump(); !this.isEOF() && Zae(this.char()); ) this.bump();
      return this.message.slice(e, this.offset());
    }),
    (t.prototype.parseLiteral = function (e, n) {
      for (var r = this.clonePosition(), i = ""; ; ) {
        var s = this.tryParseQuote(n);
        if (s) {
          i += s;
          continue;
        }
        var a = this.tryParseUnquoted(e, n);
        if (a) {
          i += a;
          continue;
        }
        var o = this.tryParseLeftAngleBracket();
        if (o) {
          i += o;
          continue;
        }
        break;
      }
      var l = Jn(r, this.clonePosition());
      return { val: { type: qr.literal, value: i, location: l }, err: null };
    }),
    (t.prototype.tryParseLeftAngleBracket = function () {
      return !this.isEOF() &&
        this.char() === 60 &&
        (this.ignoreTag || !Xae(this.peek() || 0))
        ? (this.bump(), "<")
        : null;
    }),
    (t.prototype.tryParseQuote = function (e) {
      if (this.isEOF() || this.char() !== 39) return null;
      switch (this.peek()) {
        case 39:
          return this.bump(), this.bump(), "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (e === "plural" || e === "selectordinal") break;
          return null;
        default:
          return null;
      }
      this.bump();
      var n = [this.char()];
      for (this.bump(); !this.isEOF(); ) {
        var r = this.char();
        if (r === 39)
          if (this.peek() === 39) n.push(39), this.bump();
          else {
            this.bump();
            break;
          }
        else n.push(r);
        this.bump();
      }
      return pE.apply(void 0, n);
    }),
    (t.prototype.tryParseUnquoted = function (e, n) {
      if (this.isEOF()) return null;
      var r = this.char();
      return r === 60 ||
        r === 123 ||
        (r === 35 && (n === "plural" || n === "selectordinal")) ||
        (r === 125 && e > 0)
        ? null
        : (this.bump(), pE(r));
    }),
    (t.prototype.parseArgument = function (e, n) {
      var r = this.clonePosition();
      if ((this.bump(), this.bumpSpace(), this.isEOF()))
        return this.error(
          Zn.EXPECT_ARGUMENT_CLOSING_BRACE,
          Jn(r, this.clonePosition())
        );
      if (this.char() === 125)
        return (
          this.bump(),
          this.error(Zn.EMPTY_ARGUMENT, Jn(r, this.clonePosition()))
        );
      var i = this.parseIdentifierIfPossible().value;
      if (!i)
        return this.error(Zn.MALFORMED_ARGUMENT, Jn(r, this.clonePosition()));
      if ((this.bumpSpace(), this.isEOF()))
        return this.error(
          Zn.EXPECT_ARGUMENT_CLOSING_BRACE,
          Jn(r, this.clonePosition())
        );
      switch (this.char()) {
        case 125:
          return (
            this.bump(),
            {
              val: {
                type: qr.argument,
                value: i,
                location: Jn(r, this.clonePosition()),
              },
              err: null,
            }
          );
        case 44:
          return (
            this.bump(),
            this.bumpSpace(),
            this.isEOF()
              ? this.error(
                  Zn.EXPECT_ARGUMENT_CLOSING_BRACE,
                  Jn(r, this.clonePosition())
                )
              : this.parseArgumentOptions(e, n, i, r)
          );
        default:
          return this.error(Zn.MALFORMED_ARGUMENT, Jn(r, this.clonePosition()));
      }
    }),
    (t.prototype.parseIdentifierIfPossible = function () {
      var e = this.clonePosition(),
        n = this.offset(),
        r = mE(this.message, n),
        i = n + r.length;
      this.bumpTo(i);
      var s = this.clonePosition(),
        a = Jn(e, s);
      return { value: r, location: a };
    }),
    (t.prototype.parseArgumentOptions = function (e, n, r, i) {
      var s,
        a = this.clonePosition(),
        o = this.parseIdentifierIfPossible().value,
        l = this.clonePosition();
      switch (o) {
        case "":
          return this.error(Zn.EXPECT_ARGUMENT_TYPE, Jn(a, l));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var u = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var f = this.clonePosition(),
              c = this.parseSimpleArgStyleIfPossible();
            if (c.err) return c;
            var d = qae(c.val);
            if (d.length === 0)
              return this.error(
                Zn.EXPECT_ARGUMENT_STYLE,
                Jn(this.clonePosition(), this.clonePosition())
              );
            var p = Jn(f, this.clonePosition());
            u = { style: d, styleLocation: p };
          }
          var m = this.tryParseArgumentClose(i);
          if (m.err) return m;
          var g = Jn(i, this.clonePosition());
          if (u && TI(u?.style, "::", 0)) {
            var w = Wae(u.style.slice(2));
            if (o === "number") {
              var c = this.parseNumberSkeletonFromString(w, u.styleLocation);
              return c.err
                ? c
                : {
                    val: {
                      type: qr.number,
                      value: r,
                      location: g,
                      style: c.val,
                    },
                    err: null,
                  };
            } else {
              if (w.length === 0)
                return this.error(Zn.EXPECT_DATE_TIME_SKELETON, g);
              var y = w;
              this.locale && (y = Dae(w, this.locale));
              var d = {
                  type: M0.dateTime,
                  pattern: y,
                  location: u.styleLocation,
                  parsedOptions: this.shouldParseSkeletons ? Aae(y) : {},
                },
                v = o === "date" ? qr.date : qr.time;
              return {
                val: { type: v, value: r, location: g, style: d },
                err: null,
              };
            }
          }
          return {
            val: {
              type:
                o === "number" ? qr.number : o === "date" ? qr.date : qr.time,
              value: r,
              location: g,
              style: (s = u?.style) !== null && s !== void 0 ? s : null,
            },
            err: null,
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var E = this.clonePosition();
          if ((this.bumpSpace(), !this.bumpIf(",")))
            return this.error(
              Zn.EXPECT_SELECT_ARGUMENT_OPTIONS,
              Jn(E, e5({}, E))
            );
          this.bumpSpace();
          var S = this.parseIdentifierIfPossible(),
            D = 0;
          if (o !== "select" && S.value === "offset") {
            if (!this.bumpIf(":"))
              return this.error(
                Zn.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE,
                Jn(this.clonePosition(), this.clonePosition())
              );
            this.bumpSpace();
            var c = this.tryParseDecimalInteger(
              Zn.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE,
              Zn.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE
            );
            if (c.err) return c;
            this.bumpSpace(),
              (S = this.parseIdentifierIfPossible()),
              (D = c.val);
          }
          var P = this.tryParsePluralOrSelectOptions(e, o, n, S);
          if (P.err) return P;
          var m = this.tryParseArgumentClose(i);
          if (m.err) return m;
          var x = Jn(i, this.clonePosition());
          return o === "select"
            ? {
                val: {
                  type: qr.select,
                  value: r,
                  options: SI(P.val),
                  location: x,
                },
                err: null,
              }
            : {
                val: {
                  type: qr.plural,
                  value: r,
                  options: SI(P.val),
                  offset: D,
                  pluralType: o === "plural" ? "cardinal" : "ordinal",
                  location: x,
                },
                err: null,
              };
        }
        default:
          return this.error(Zn.INVALID_ARGUMENT_TYPE, Jn(a, l));
      }
    }),
    (t.prototype.tryParseArgumentClose = function (e) {
      return this.isEOF() || this.char() !== 125
        ? this.error(
            Zn.EXPECT_ARGUMENT_CLOSING_BRACE,
            Jn(e, this.clonePosition())
          )
        : (this.bump(), { val: !0, err: null });
    }),
    (t.prototype.parseSimpleArgStyleIfPossible = function () {
      for (var e = 0, n = this.clonePosition(); !this.isEOF(); ) {
        var r = this.char();
        switch (r) {
          case 39: {
            this.bump();
            var i = this.clonePosition();
            if (!this.bumpUntil("'"))
              return this.error(
                Zn.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE,
                Jn(i, this.clonePosition())
              );
            this.bump();
            break;
          }
          case 123: {
            (e += 1), this.bump();
            break;
          }
          case 125: {
            if (e > 0) e -= 1;
            else
              return {
                val: this.message.slice(n.offset, this.offset()),
                err: null,
              };
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return { val: this.message.slice(n.offset, this.offset()), err: null };
    }),
    (t.prototype.parseNumberSkeletonFromString = function (e, n) {
      var r = [];
      try {
        r = kae(e);
      } catch {
        return this.error(Zn.INVALID_NUMBER_SKELETON, n);
      }
      return {
        val: {
          type: M0.number,
          tokens: r,
          location: n,
          parsedOptions: this.shouldParseSkeletons ? Nae(r) : {},
        },
        err: null,
      };
    }),
    (t.prototype.tryParsePluralOrSelectOptions = function (e, n, r, i) {
      for (
        var s, a = !1, o = [], l = new Set(), u = i.value, f = i.location;
        ;

      ) {
        if (u.length === 0) {
          var c = this.clonePosition();
          if (n !== "select" && this.bumpIf("=")) {
            var d = this.tryParseDecimalInteger(
              Zn.EXPECT_PLURAL_ARGUMENT_SELECTOR,
              Zn.INVALID_PLURAL_ARGUMENT_SELECTOR
            );
            if (d.err) return d;
            (f = Jn(c, this.clonePosition())),
              (u = this.message.slice(c.offset, this.offset()));
          } else break;
        }
        if (l.has(u))
          return this.error(
            n === "select"
              ? Zn.DUPLICATE_SELECT_ARGUMENT_SELECTOR
              : Zn.DUPLICATE_PLURAL_ARGUMENT_SELECTOR,
            f
          );
        u === "other" && (a = !0), this.bumpSpace();
        var p = this.clonePosition();
        if (!this.bumpIf("{"))
          return this.error(
            n === "select"
              ? Zn.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
              : Zn.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT,
            Jn(this.clonePosition(), this.clonePosition())
          );
        var m = this.parseMessage(e + 1, n, r);
        if (m.err) return m;
        var g = this.tryParseArgumentClose(p);
        if (g.err) return g;
        o.push([u, { value: m.val, location: Jn(p, this.clonePosition()) }]),
          l.add(u),
          this.bumpSpace(),
          (s = this.parseIdentifierIfPossible()),
          (u = s.value),
          (f = s.location);
      }
      return o.length === 0
        ? this.error(
            n === "select"
              ? Zn.EXPECT_SELECT_ARGUMENT_SELECTOR
              : Zn.EXPECT_PLURAL_ARGUMENT_SELECTOR,
            Jn(this.clonePosition(), this.clonePosition())
          )
        : this.requiresOtherClause && !a
        ? this.error(
            Zn.MISSING_OTHER_CLAUSE,
            Jn(this.clonePosition(), this.clonePosition())
          )
        : { val: o, err: null };
    }),
    (t.prototype.tryParseDecimalInteger = function (e, n) {
      var r = 1,
        i = this.clonePosition();
      this.bumpIf("+") || (this.bumpIf("-") && (r = -1));
      for (var s = !1, a = 0; !this.isEOF(); ) {
        var o = this.char();
        if (o >= 48 && o <= 57) (s = !0), (a = a * 10 + (o - 48)), this.bump();
        else break;
      }
      var l = Jn(i, this.clonePosition());
      return s
        ? ((a *= r), Vae(a) ? { val: a, err: null } : this.error(n, l))
        : this.error(e, l);
    }),
    (t.prototype.offset = function () {
      return this.position.offset;
    }),
    (t.prototype.isEOF = function () {
      return this.offset() === this.message.length;
    }),
    (t.prototype.clonePosition = function () {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column,
      };
    }),
    (t.prototype.char = function () {
      var e = this.position.offset;
      if (e >= this.message.length) throw Error("out of bound");
      var n = QU(this.message, e);
      if (n === void 0)
        throw Error(
          "Offset ".concat(e, " is at invalid UTF-16 code unit boundary")
        );
      return n;
    }),
    (t.prototype.error = function (e, n) {
      return {
        val: null,
        err: { kind: e, message: this.message, location: n },
      };
    }),
    (t.prototype.bump = function () {
      if (!this.isEOF()) {
        var e = this.char();
        e === 10
          ? ((this.position.line += 1),
            (this.position.column = 1),
            (this.position.offset += 1))
          : ((this.position.column += 1),
            (this.position.offset += e < 65536 ? 1 : 2));
      }
    }),
    (t.prototype.bumpIf = function (e) {
      if (TI(this.message, e, this.offset())) {
        for (var n = 0; n < e.length; n++) this.bump();
        return !0;
      }
      return !1;
    }),
    (t.prototype.bumpUntil = function (e) {
      var n = this.offset(),
        r = this.message.indexOf(e, n);
      return r >= 0
        ? (this.bumpTo(r), !0)
        : (this.bumpTo(this.message.length), !1);
    }),
    (t.prototype.bumpTo = function (e) {
      if (this.offset() > e)
        throw Error(
          "targetOffset "
            .concat(e, " must be greater than or equal to the current offset ")
            .concat(this.offset())
        );
      for (e = Math.min(e, this.message.length); ; ) {
        var n = this.offset();
        if (n === e) break;
        if (n > e)
          throw Error(
            "targetOffset ".concat(
              e,
              " is at invalid UTF-16 code unit boundary"
            )
          );
        if ((this.bump(), this.isEOF())) break;
      }
    }),
    (t.prototype.bumpSpace = function () {
      for (; !this.isEOF() && ej(this.char()); ) this.bump();
    }),
    (t.prototype.peek = function () {
      if (this.isEOF()) return null;
      var e = this.char(),
        n = this.offset(),
        r = this.message.charCodeAt(n + (e >= 65536 ? 2 : 1));
      return r ?? null;
    }),
    t
  );
})();
function gE(t) {
  return (t >= 97 && t <= 122) || (t >= 65 && t <= 90);
}
function Xae(t) {
  return gE(t) || t === 47;
}
function Zae(t) {
  return (
    t === 45 ||
    t === 46 ||
    (t >= 48 && t <= 57) ||
    t === 95 ||
    (t >= 97 && t <= 122) ||
    (t >= 65 && t <= 90) ||
    t == 183 ||
    (t >= 192 && t <= 214) ||
    (t >= 216 && t <= 246) ||
    (t >= 248 && t <= 893) ||
    (t >= 895 && t <= 8191) ||
    (t >= 8204 && t <= 8205) ||
    (t >= 8255 && t <= 8256) ||
    (t >= 8304 && t <= 8591) ||
    (t >= 11264 && t <= 12271) ||
    (t >= 12289 && t <= 55295) ||
    (t >= 63744 && t <= 64975) ||
    (t >= 65008 && t <= 65533) ||
    (t >= 65536 && t <= 983039)
  );
}
function ej(t) {
  return (
    (t >= 9 && t <= 13) ||
    t === 32 ||
    t === 133 ||
    (t >= 8206 && t <= 8207) ||
    t === 8232 ||
    t === 8233
  );
}
function Yae(t) {
  return (
    (t >= 33 && t <= 35) ||
    t === 36 ||
    (t >= 37 && t <= 39) ||
    t === 40 ||
    t === 41 ||
    t === 42 ||
    t === 43 ||
    t === 44 ||
    t === 45 ||
    (t >= 46 && t <= 47) ||
    (t >= 58 && t <= 59) ||
    (t >= 60 && t <= 62) ||
    (t >= 63 && t <= 64) ||
    t === 91 ||
    t === 92 ||
    t === 93 ||
    t === 94 ||
    t === 96 ||
    t === 123 ||
    t === 124 ||
    t === 125 ||
    t === 126 ||
    t === 161 ||
    (t >= 162 && t <= 165) ||
    t === 166 ||
    t === 167 ||
    t === 169 ||
    t === 171 ||
    t === 172 ||
    t === 174 ||
    t === 176 ||
    t === 177 ||
    t === 182 ||
    t === 187 ||
    t === 191 ||
    t === 215 ||
    t === 247 ||
    (t >= 8208 && t <= 8213) ||
    (t >= 8214 && t <= 8215) ||
    t === 8216 ||
    t === 8217 ||
    t === 8218 ||
    (t >= 8219 && t <= 8220) ||
    t === 8221 ||
    t === 8222 ||
    t === 8223 ||
    (t >= 8224 && t <= 8231) ||
    (t >= 8240 && t <= 8248) ||
    t === 8249 ||
    t === 8250 ||
    (t >= 8251 && t <= 8254) ||
    (t >= 8257 && t <= 8259) ||
    t === 8260 ||
    t === 8261 ||
    t === 8262 ||
    (t >= 8263 && t <= 8273) ||
    t === 8274 ||
    t === 8275 ||
    (t >= 8277 && t <= 8286) ||
    (t >= 8592 && t <= 8596) ||
    (t >= 8597 && t <= 8601) ||
    (t >= 8602 && t <= 8603) ||
    (t >= 8604 && t <= 8607) ||
    t === 8608 ||
    (t >= 8609 && t <= 8610) ||
    t === 8611 ||
    (t >= 8612 && t <= 8613) ||
    t === 8614 ||
    (t >= 8615 && t <= 8621) ||
    t === 8622 ||
    (t >= 8623 && t <= 8653) ||
    (t >= 8654 && t <= 8655) ||
    (t >= 8656 && t <= 8657) ||
    t === 8658 ||
    t === 8659 ||
    t === 8660 ||
    (t >= 8661 && t <= 8691) ||
    (t >= 8692 && t <= 8959) ||
    (t >= 8960 && t <= 8967) ||
    t === 8968 ||
    t === 8969 ||
    t === 8970 ||
    t === 8971 ||
    (t >= 8972 && t <= 8991) ||
    (t >= 8992 && t <= 8993) ||
    (t >= 8994 && t <= 9e3) ||
    t === 9001 ||
    t === 9002 ||
    (t >= 9003 && t <= 9083) ||
    t === 9084 ||
    (t >= 9085 && t <= 9114) ||
    (t >= 9115 && t <= 9139) ||
    (t >= 9140 && t <= 9179) ||
    (t >= 9180 && t <= 9185) ||
    (t >= 9186 && t <= 9254) ||
    (t >= 9255 && t <= 9279) ||
    (t >= 9280 && t <= 9290) ||
    (t >= 9291 && t <= 9311) ||
    (t >= 9472 && t <= 9654) ||
    t === 9655 ||
    (t >= 9656 && t <= 9664) ||
    t === 9665 ||
    (t >= 9666 && t <= 9719) ||
    (t >= 9720 && t <= 9727) ||
    (t >= 9728 && t <= 9838) ||
    t === 9839 ||
    (t >= 9840 && t <= 10087) ||
    t === 10088 ||
    t === 10089 ||
    t === 10090 ||
    t === 10091 ||
    t === 10092 ||
    t === 10093 ||
    t === 10094 ||
    t === 10095 ||
    t === 10096 ||
    t === 10097 ||
    t === 10098 ||
    t === 10099 ||
    t === 10100 ||
    t === 10101 ||
    (t >= 10132 && t <= 10175) ||
    (t >= 10176 && t <= 10180) ||
    t === 10181 ||
    t === 10182 ||
    (t >= 10183 && t <= 10213) ||
    t === 10214 ||
    t === 10215 ||
    t === 10216 ||
    t === 10217 ||
    t === 10218 ||
    t === 10219 ||
    t === 10220 ||
    t === 10221 ||
    t === 10222 ||
    t === 10223 ||
    (t >= 10224 && t <= 10239) ||
    (t >= 10240 && t <= 10495) ||
    (t >= 10496 && t <= 10626) ||
    t === 10627 ||
    t === 10628 ||
    t === 10629 ||
    t === 10630 ||
    t === 10631 ||
    t === 10632 ||
    t === 10633 ||
    t === 10634 ||
    t === 10635 ||
    t === 10636 ||
    t === 10637 ||
    t === 10638 ||
    t === 10639 ||
    t === 10640 ||
    t === 10641 ||
    t === 10642 ||
    t === 10643 ||
    t === 10644 ||
    t === 10645 ||
    t === 10646 ||
    t === 10647 ||
    t === 10648 ||
    (t >= 10649 && t <= 10711) ||
    t === 10712 ||
    t === 10713 ||
    t === 10714 ||
    t === 10715 ||
    (t >= 10716 && t <= 10747) ||
    t === 10748 ||
    t === 10749 ||
    (t >= 10750 && t <= 11007) ||
    (t >= 11008 && t <= 11055) ||
    (t >= 11056 && t <= 11076) ||
    (t >= 11077 && t <= 11078) ||
    (t >= 11079 && t <= 11084) ||
    (t >= 11085 && t <= 11123) ||
    (t >= 11124 && t <= 11125) ||
    (t >= 11126 && t <= 11157) ||
    t === 11158 ||
    (t >= 11159 && t <= 11263) ||
    (t >= 11776 && t <= 11777) ||
    t === 11778 ||
    t === 11779 ||
    t === 11780 ||
    t === 11781 ||
    (t >= 11782 && t <= 11784) ||
    t === 11785 ||
    t === 11786 ||
    t === 11787 ||
    t === 11788 ||
    t === 11789 ||
    (t >= 11790 && t <= 11798) ||
    t === 11799 ||
    (t >= 11800 && t <= 11801) ||
    t === 11802 ||
    t === 11803 ||
    t === 11804 ||
    t === 11805 ||
    (t >= 11806 && t <= 11807) ||
    t === 11808 ||
    t === 11809 ||
    t === 11810 ||
    t === 11811 ||
    t === 11812 ||
    t === 11813 ||
    t === 11814 ||
    t === 11815 ||
    t === 11816 ||
    t === 11817 ||
    (t >= 11818 && t <= 11822) ||
    t === 11823 ||
    (t >= 11824 && t <= 11833) ||
    (t >= 11834 && t <= 11835) ||
    (t >= 11836 && t <= 11839) ||
    t === 11840 ||
    t === 11841 ||
    t === 11842 ||
    (t >= 11843 && t <= 11855) ||
    (t >= 11856 && t <= 11857) ||
    t === 11858 ||
    (t >= 11859 && t <= 11903) ||
    (t >= 12289 && t <= 12291) ||
    t === 12296 ||
    t === 12297 ||
    t === 12298 ||
    t === 12299 ||
    t === 12300 ||
    t === 12301 ||
    t === 12302 ||
    t === 12303 ||
    t === 12304 ||
    t === 12305 ||
    (t >= 12306 && t <= 12307) ||
    t === 12308 ||
    t === 12309 ||
    t === 12310 ||
    t === 12311 ||
    t === 12312 ||
    t === 12313 ||
    t === 12314 ||
    t === 12315 ||
    t === 12316 ||
    t === 12317 ||
    (t >= 12318 && t <= 12319) ||
    t === 12320 ||
    t === 12336 ||
    t === 64830 ||
    t === 64831 ||
    (t >= 65093 && t <= 65094)
  );
}
function yE(t) {
  t.forEach(function (e) {
    if ((delete e.location, VU(e) || GU(e)))
      for (var n in e.options)
        delete e.options[n].location, yE(e.options[n].value);
    else
      (jU(e) && qU(e.style)) || ((HU(e) || zU(e)) && dE(e.style))
        ? delete e.style.location
        : WU(e) && yE(e.children);
  });
}
function Qae(t, e) {
  e === void 0 && (e = {}),
    (e = e5({ shouldParseSkeletons: !0, requiresOtherClause: !0 }, e));
  var n = new Kae(t, e).parse();
  if (n.err) {
    var r = SyntaxError(Zn[n.err.kind]);
    throw (
      ((r.location = n.err.location), (r.originalMessage = n.err.message), r)
    );
  }
  return e?.captureLocation || yE(n.val), n.val;
}
function k_(t, e) {
  var n = e && e.cache ? e.cache : ioe,
    r = e && e.serializer ? e.serializer : roe,
    i = e && e.strategy ? e.strategy : eoe;
  return i(t, { cache: n, serializer: r });
}
function Jae(t) {
  return t == null || typeof t == "number" || typeof t == "boolean";
}
function tj(t, e, n, r) {
  var i = Jae(r) ? r : n(r),
    s = e.get(i);
  return typeof s > "u" && ((s = t.call(this, r)), e.set(i, s)), s;
}
function nj(t, e, n) {
  var r = Array.prototype.slice.call(arguments, 3),
    i = n(r),
    s = e.get(i);
  return typeof s > "u" && ((s = t.apply(this, r)), e.set(i, s)), s;
}
function P7(t, e, n, r, i) {
  return n.bind(e, t, r, i);
}
function eoe(t, e) {
  var n = t.length === 1 ? tj : nj;
  return P7(t, this, n, e.cache.create(), e.serializer);
}
function toe(t, e) {
  return P7(t, this, nj, e.cache.create(), e.serializer);
}
function noe(t, e) {
  return P7(t, this, tj, e.cache.create(), e.serializer);
}
var roe = function () {
  return JSON.stringify(arguments);
};
function N7() {
  this.cache = Object.create(null);
}
N7.prototype.get = function (t) {
  return this.cache[t];
};
N7.prototype.set = function (t, e) {
  this.cache[t] = e;
};
var ioe = {
    create: function () {
      return new N7();
    },
  },
  I_ = { variadic: toe, monadic: noe },
  L0;
(function (t) {
  (t.MISSING_VALUE = "MISSING_VALUE"),
    (t.INVALID_VALUE = "INVALID_VALUE"),
    (t.MISSING_INTL_API = "MISSING_INTL_API");
})(L0 || (L0 = {}));
var Iw = (function (t) {
    kw(e, t);
    function e(n, r, i) {
      var s = t.call(this, n) || this;
      return (s.code = r), (s.originalMessage = i), s;
    }
    return (
      (e.prototype.toString = function () {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
      }),
      e
    );
  })(Error),
  CI = (function (t) {
    kw(e, t);
    function e(n, r, i, s) {
      return (
        t.call(
          this,
          'Invalid values for "'
            .concat(n, '": "')
            .concat(r, '". Options are "')
            .concat(Object.keys(i).join('", "'), '"'),
          L0.INVALID_VALUE,
          s
        ) || this
      );
    }
    return e;
  })(Iw),
  soe = (function (t) {
    kw(e, t);
    function e(n, r, i) {
      return (
        t.call(
          this,
          'Value for "'.concat(n, '" must be of type ').concat(r),
          L0.INVALID_VALUE,
          i
        ) || this
      );
    }
    return e;
  })(Iw),
  aoe = (function (t) {
    kw(e, t);
    function e(n, r) {
      return (
        t.call(
          this,
          'The intl string context variable "'
            .concat(n, '" was not provided to the string "')
            .concat(r, '"'),
          L0.MISSING_VALUE,
          r
        ) || this
      );
    }
    return e;
  })(Iw),
  ma;
(function (t) {
  (t[(t.literal = 0)] = "literal"), (t[(t.object = 1)] = "object");
})(ma || (ma = {}));
function ooe(t) {
  return t.length < 2
    ? t
    : t.reduce(function (e, n) {
        var r = e[e.length - 1];
        return (
          !r || r.type !== ma.literal || n.type !== ma.literal
            ? e.push(n)
            : (r.value += n.value),
          e
        );
      }, []);
}
function loe(t) {
  return typeof t == "function";
}
function Qv(t, e, n, r, i, s, a) {
  if (t.length === 1 && wI(t[0]))
    return [{ type: ma.literal, value: t[0].value }];
  for (var o = [], l = 0, u = t; l < u.length; l++) {
    var f = u[l];
    if (wI(f)) {
      o.push({ type: ma.literal, value: f.value });
      continue;
    }
    if (Tae(f)) {
      typeof s == "number" &&
        o.push({ type: ma.literal, value: n.getNumberFormat(e).format(s) });
      continue;
    }
    var c = f.value;
    if (!(i && c in i)) throw new aoe(c, a);
    var d = i[c];
    if (xae(f)) {
      (!d || typeof d == "string" || typeof d == "number") &&
        (d = typeof d == "string" || typeof d == "number" ? String(d) : ""),
        o.push({
          type: typeof d == "string" ? ma.literal : ma.object,
          value: d,
        });
      continue;
    }
    if (HU(f)) {
      var p =
        typeof f.style == "string"
          ? r.date[f.style]
          : dE(f.style)
          ? f.style.parsedOptions
          : void 0;
      o.push({ type: ma.literal, value: n.getDateTimeFormat(e, p).format(d) });
      continue;
    }
    if (zU(f)) {
      var p =
        typeof f.style == "string"
          ? r.time[f.style]
          : dE(f.style)
          ? f.style.parsedOptions
          : r.time.medium;
      o.push({ type: ma.literal, value: n.getDateTimeFormat(e, p).format(d) });
      continue;
    }
    if (jU(f)) {
      var p =
        typeof f.style == "string"
          ? r.number[f.style]
          : qU(f.style)
          ? f.style.parsedOptions
          : void 0;
      p && p.scale && (d = d * (p.scale || 1)),
        o.push({ type: ma.literal, value: n.getNumberFormat(e, p).format(d) });
      continue;
    }
    if (WU(f)) {
      var m = f.children,
        g = f.value,
        w = i[g];
      if (!loe(w)) throw new soe(g, "function", a);
      var y = Qv(m, e, n, r, i, s),
        v = w(
          y.map(function (D) {
            return D.value;
          })
        );
      Array.isArray(v) || (v = [v]),
        o.push.apply(
          o,
          v.map(function (D) {
            return {
              type: typeof D == "string" ? ma.literal : ma.object,
              value: D,
            };
          })
        );
    }
    if (VU(f)) {
      var E = f.options[d] || f.options.other;
      if (!E) throw new CI(f.value, d, Object.keys(f.options), a);
      o.push.apply(o, Qv(E.value, e, n, r, i));
      continue;
    }
    if (GU(f)) {
      var E = f.options["=".concat(d)];
      if (!E) {
        if (!Intl.PluralRules)
          throw new Iw(
            `Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`,
            L0.MISSING_INTL_API,
            a
          );
        var S = n
          .getPluralRules(e, { type: f.pluralType })
          .select(d - (f.offset || 0));
        E = f.options[S] || f.options.other;
      }
      if (!E) throw new CI(f.value, d, Object.keys(f.options), a);
      o.push.apply(o, Qv(E.value, e, n, r, i, d - (f.offset || 0)));
      continue;
    }
  }
  return ooe(o);
}
function uoe(t, e) {
  return e
    ? Ff(
        Ff(Ff({}, t || {}), e || {}),
        Object.keys(t).reduce(function (n, r) {
          return (n[r] = Ff(Ff({}, t[r]), e[r] || {})), n;
        }, {})
      )
    : t;
}
function coe(t, e) {
  return e
    ? Object.keys(t).reduce(function (n, r) {
        return (n[r] = uoe(t[r], e[r])), n;
      }, Ff({}, t))
    : t;
}
function O_(t) {
  return {
    create: function () {
      return {
        get: function (e) {
          return t[e];
        },
        set: function (e, n) {
          t[e] = n;
        },
      };
    },
  };
}
function foe(t) {
  return (
    t === void 0 && (t = { number: {}, dateTime: {}, pluralRules: {} }),
    {
      getNumberFormat: k_(
        function () {
          for (var e, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((e = Intl.NumberFormat).bind.apply(
            e,
            A_([void 0], n, !1)
          ))();
        },
        { cache: O_(t.number), strategy: I_.variadic }
      ),
      getDateTimeFormat: k_(
        function () {
          for (var e, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((e = Intl.DateTimeFormat).bind.apply(
            e,
            A_([void 0], n, !1)
          ))();
        },
        { cache: O_(t.dateTime), strategy: I_.variadic }
      ),
      getPluralRules: k_(
        function () {
          for (var e, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((e = Intl.PluralRules).bind.apply(
            e,
            A_([void 0], n, !1)
          ))();
        },
        { cache: O_(t.pluralRules), strategy: I_.variadic }
      ),
    }
  );
}
var rj = (function () {
  function t(e, n, r, i) {
    var s = this;
    if (
      (n === void 0 && (n = t.defaultLocale),
      (this.formatterCache = { number: {}, dateTime: {}, pluralRules: {} }),
      (this.format = function (a) {
        var o = s.formatToParts(a);
        if (o.length === 1) return o[0].value;
        var l = o.reduce(function (u, f) {
          return (
            !u.length ||
            f.type !== ma.literal ||
            typeof u[u.length - 1] != "string"
              ? u.push(f.value)
              : (u[u.length - 1] += f.value),
            u
          );
        }, []);
        return l.length <= 1 ? l[0] || "" : l;
      }),
      (this.formatToParts = function (a) {
        return Qv(
          s.ast,
          s.locales,
          s.formatters,
          s.formats,
          a,
          void 0,
          s.message
        );
      }),
      (this.resolvedOptions = function () {
        return { locale: s.resolvedLocale.toString() };
      }),
      (this.getAst = function () {
        return s.ast;
      }),
      (this.locales = n),
      (this.resolvedLocale = t.resolveLocale(n)),
      typeof e == "string")
    ) {
      if (((this.message = e), !t.__parse))
        throw new TypeError(
          "IntlMessageFormat.__parse must be set to process `message` of type `string`"
        );
      this.ast = t.__parse(e, {
        ignoreTag: i?.ignoreTag,
        locale: this.resolvedLocale,
      });
    } else this.ast = e;
    if (!Array.isArray(this.ast))
      throw new TypeError("A message must be provided as a String or AST.");
    (this.formats = coe(t.formats, r)),
      (this.formatters = (i && i.formatters) || foe(this.formatterCache));
  }
  return (
    Object.defineProperty(t, "defaultLocale", {
      get: function () {
        return (
          t.memoizedDefaultLocale ||
            (t.memoizedDefaultLocale =
              new Intl.NumberFormat().resolvedOptions().locale),
          t.memoizedDefaultLocale
        );
      },
      enumerable: !1,
      configurable: !0,
    }),
    (t.memoizedDefaultLocale = null),
    (t.resolveLocale = function (e) {
      var n = Intl.NumberFormat.supportedLocalesOf(e);
      return n.length > 0
        ? new Intl.Locale(n[0])
        : new Intl.Locale(typeof e == "string" ? e : e[0]);
    }),
    (t.__parse = Qae),
    (t.formats = {
      number: {
        integer: { maximumFractionDigits: 0 },
        currency: { style: "currency" },
        percent: { style: "percent" },
      },
      date: {
        short: { month: "numeric", day: "numeric", year: "2-digit" },
        medium: { month: "short", day: "numeric", year: "numeric" },
        long: { month: "long", day: "numeric", year: "numeric" },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric",
        },
      },
      time: {
        short: { hour: "numeric", minute: "numeric" },
        medium: { hour: "numeric", minute: "numeric", second: "numeric" },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short",
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short",
        },
      },
    }),
    t
  );
})();
function doe(t, e) {
  if (e == null) return;
  if (e in t) return t[e];
  const n = e.split(".");
  let r = t;
  for (let i = 0; i < n.length; i++)
    if (typeof r == "object") {
      if (i > 0) {
        const s = n.slice(i, n.length).join(".");
        if (s in r) {
          r = r[s];
          break;
        }
      }
      r = r[n[i]];
    } else r = void 0;
  return r;
}
const zf = {},
  hoe = (t, e, n) =>
    n && (e in zf || (zf[e] = {}), t in zf[e] || (zf[e][t] = n), n),
  ij = (t, e) => {
    if (e == null) return;
    if (e in zf && t in zf[e]) return zf[e][t];
    const n = Ey(e);
    for (let r = 0; r < n.length; r++) {
      const i = n[r],
        s = moe(i, t);
      if (s) return hoe(t, e, s);
    }
  };
let D7;
const _y = Cw({});
function poe(t) {
  return D7[t] || null;
}
function sj(t) {
  return t in D7;
}
function moe(t, e) {
  if (!sj(t)) return null;
  const n = poe(t);
  return doe(n, e);
}
function goe(t) {
  if (t == null) return;
  const e = Ey(t);
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (sj(r)) return r;
  }
}
function Jv(t, ...e) {
  delete zf[t], _y.update((n) => ((n[t] = Eae.all([n[t] || {}, ...e])), n));
}
d1([_y], ([t]) => Object.keys(t));
_y.subscribe((t) => (D7 = t));
const eb = {};
function yoe(t, e) {
  eb[t].delete(e), eb[t].size === 0 && delete eb[t];
}
function aj(t) {
  return eb[t];
}
function voe(t) {
  return Ey(t)
    .map((e) => {
      const n = aj(e);
      return [e, n ? [...n] : []];
    })
    .filter(([, e]) => e.length > 0);
}
function t5(t) {
  return t == null
    ? !1
    : Ey(t).some((e) => {
        var n;
        return (n = aj(e)) == null ? void 0 : n.size;
      });
}
function boe(t, e) {
  return Promise.all(
    e.map((r) => (yoe(t, r), r().then((i) => i.default || i)))
  ).then((r) => Jv(t, ...r));
}
const om = {};
function oj(t) {
  if (!t5(t)) return t in om ? om[t] : Promise.resolve();
  const e = voe(t);
  return (
    (om[t] = Promise.all(e.map(([n, r]) => boe(n, r))).then(() => {
      if (t5(t)) return oj(t);
      delete om[t];
    })),
    om[t]
  );
}
var kI = Object.getOwnPropertySymbols,
  woe = Object.prototype.hasOwnProperty,
  _oe = Object.prototype.propertyIsEnumerable,
  Eoe = (t, e) => {
    var n = {};
    for (var r in t) woe.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && kI)
      for (var r of kI(t)) e.indexOf(r) < 0 && _oe.call(t, r) && (n[r] = t[r]);
    return n;
  };
const xoe = {
  number: {
    scientific: { notation: "scientific" },
    engineering: { notation: "engineering" },
    compactLong: { notation: "compact", compactDisplay: "long" },
    compactShort: { notation: "compact", compactDisplay: "short" },
  },
  date: {
    short: { month: "numeric", day: "numeric", year: "2-digit" },
    medium: { month: "short", day: "numeric", year: "numeric" },
    long: { month: "long", day: "numeric", year: "numeric" },
    full: { weekday: "long", month: "long", day: "numeric", year: "numeric" },
  },
  time: {
    short: { hour: "numeric", minute: "numeric" },
    medium: { hour: "numeric", minute: "numeric", second: "numeric" },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short",
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short",
    },
  },
};
function Toe({ locale: t, id: e }) {
  console.warn(
    `[svelte-i18n] The message "${e}" was not found in "${Ey(t).join(
      '", "'
    )}".${
      t5(bd())
        ? `

Note: there are at least one loader still registered to this locale that wasn't executed.`
        : ""
    }`
  );
}
const Soe = {
    fallbackLocale: null,
    loadingDelay: 200,
    formats: xoe,
    warnOnMissingMessages: !0,
    handleMissingMessage: void 0,
    ignoreTag: !0,
  },
  Lm = Soe;
function B0() {
  return Lm;
}
function Aoe(t) {
  const e = t,
    { formats: n } = e,
    r = Eoe(e, ["formats"]);
  let i = t.fallbackLocale;
  if (t.initialLocale)
    try {
      rj.resolveLocale(t.initialLocale) && (i = t.initialLocale);
    } catch {
      console.warn(
        `[svelte-i18n] The initial locale "${t.initialLocale}" is not a valid locale.`
      );
    }
  return (
    r.warnOnMissingMessages &&
      (delete r.warnOnMissingMessages,
      r.handleMissingMessage == null
        ? (r.handleMissingMessage = Toe)
        : console.warn(
            '[svelte-i18n] The "warnOnMissingMessages" option is deprecated. Please use the "handleMissingMessage" option instead.'
          )),
    Object.assign(Lm, r, { initialLocale: i }),
    n &&
      ("number" in n && Object.assign(Lm.formats.number, n.number),
      "date" in n && Object.assign(Lm.formats.date, n.date),
      "time" in n && Object.assign(Lm.formats.time, n.time)),
    Lh.set(i)
  );
}
const P_ = Cw(!1);
var Coe = Object.defineProperty,
  koe = Object.defineProperties,
  Ioe = Object.getOwnPropertyDescriptors,
  II = Object.getOwnPropertySymbols,
  Ooe = Object.prototype.hasOwnProperty,
  Poe = Object.prototype.propertyIsEnumerable,
  OI = (t, e, n) =>
    e in t
      ? Coe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Noe = (t, e) => {
    for (var n in e || (e = {})) Ooe.call(e, n) && OI(t, n, e[n]);
    if (II) for (var n of II(e)) Poe.call(e, n) && OI(t, n, e[n]);
    return t;
  },
  Doe = (t, e) => koe(t, Ioe(e));
let vE;
const n5 = Cw(null);
function PI(t) {
  return t
    .split("-")
    .map((e, n, r) => r.slice(0, n + 1).join("-"))
    .reverse();
}
function Ey(t, e = B0().fallbackLocale) {
  const n = PI(t);
  return e ? [...new Set([...n, ...PI(e)])] : n;
}
function bd() {
  return vE ?? void 0;
}
n5.subscribe((t) => {
  (vE = t ?? void 0),
    typeof window < "u" &&
      t != null &&
      document.documentElement.setAttribute("lang", t);
});
const Roe = (t) => {
    if (t && goe(t) && t5(t)) {
      const { loadingDelay: e } = B0();
      let n;
      return (
        typeof window < "u" && bd() != null && e
          ? (n = window.setTimeout(() => P_.set(!0), e))
          : P_.set(!0),
        oj(t)
          .then(() => {
            n5.set(t);
          })
          .finally(() => {
            clearTimeout(n), P_.set(!1);
          })
      );
    }
    return n5.set(t);
  },
  Lh = Doe(Noe({}, n5), { set: Roe }),
  Moe = () =>
    typeof window > "u"
      ? null
      : window.navigator.language || window.navigator.languages[0],
  Ow = (t) => {
    const e = Object.create(null);
    return (r) => {
      const i = JSON.stringify(r);
      return i in e ? e[i] : (e[i] = t(r));
    };
  };
var Loe = Object.defineProperty,
  r5 = Object.getOwnPropertySymbols,
  lj = Object.prototype.hasOwnProperty,
  uj = Object.prototype.propertyIsEnumerable,
  NI = (t, e, n) =>
    e in t
      ? Loe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  R7 = (t, e) => {
    for (var n in e || (e = {})) lj.call(e, n) && NI(t, n, e[n]);
    if (r5) for (var n of r5(e)) uj.call(e, n) && NI(t, n, e[n]);
    return t;
  },
  h1 = (t, e) => {
    var n = {};
    for (var r in t) lj.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && r5)
      for (var r of r5(t)) e.indexOf(r) < 0 && uj.call(t, r) && (n[r] = t[r]);
    return n;
  };
const Fg = (t, e) => {
    const { formats: n } = B0();
    if (t in n && e in n[t]) return n[t][e];
    throw new Error(`[svelte-i18n] Unknown "${e}" ${t} format.`);
  },
  Boe = Ow((t) => {
    var e = t,
      { locale: n, format: r } = e,
      i = h1(e, ["locale", "format"]);
    if (n == null)
      throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
    return r && (i = Fg("number", r)), new Intl.NumberFormat(n, i);
  }),
  Foe = Ow((t) => {
    var e = t,
      { locale: n, format: r } = e,
      i = h1(e, ["locale", "format"]);
    if (n == null)
      throw new Error('[svelte-i18n] A "locale" must be set to format dates');
    return (
      r
        ? (i = Fg("date", r))
        : Object.keys(i).length === 0 && (i = Fg("date", "short")),
      new Intl.DateTimeFormat(n, i)
    );
  }),
  $oe = Ow((t) => {
    var e = t,
      { locale: n, format: r } = e,
      i = h1(e, ["locale", "format"]);
    if (n == null)
      throw new Error(
        '[svelte-i18n] A "locale" must be set to format time values'
      );
    return (
      r
        ? (i = Fg("time", r))
        : Object.keys(i).length === 0 && (i = Fg("time", "short")),
      new Intl.DateTimeFormat(n, i)
    );
  }),
  Uoe = (t = {}) => {
    var e = t,
      { locale: n = bd() } = e,
      r = h1(e, ["locale"]);
    return Boe(R7({ locale: n }, r));
  },
  joe = (t = {}) => {
    var e = t,
      { locale: n = bd() } = e,
      r = h1(e, ["locale"]);
    return Foe(R7({ locale: n }, r));
  },
  Hoe = (t = {}) => {
    var e = t,
      { locale: n = bd() } = e,
      r = h1(e, ["locale"]);
    return $oe(R7({ locale: n }, r));
  },
  zoe = Ow(
    (t, e = bd()) => new rj(t, e, B0().formats, { ignoreTag: B0().ignoreTag })
  ),
  Voe = (t, e = {}) => {
    var n, r, i, s;
    let a = e;
    typeof t == "object" && ((a = t), (t = a.id));
    const { values: o, locale: l = bd(), default: u } = a;
    if (l == null)
      throw new Error(
        "[svelte-i18n] Cannot format a message without first setting the initial locale."
      );
    let f = ij(t, l);
    if (!f)
      f =
        (s =
          (i =
            (r = (n = B0()).handleMissingMessage) == null
              ? void 0
              : r.call(n, { locale: l, id: t, defaultValue: u })) != null
            ? i
            : u) != null
          ? s
          : t;
    else if (typeof f != "string")
      return (
        console.warn(
          `[svelte-i18n] Message with id "${t}" must be of type "string", found: "${typeof f}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`
        ),
        f
      );
    if (!o) return f;
    let c = f;
    try {
      c = zoe(f, l).format(o);
    } catch (d) {
      d instanceof Error &&
        console.warn(
          `[svelte-i18n] Message "${t}" has syntax error:`,
          d.message
        );
    }
    return c;
  },
  Goe = (t, e) => Hoe(e).format(t),
  Woe = (t, e) => joe(e).format(t),
  qoe = (t, e) => Uoe(e).format(t),
  Koe = (t, e = bd()) => ij(t, e),
  ic = d1([Lh, _y], () => Voe);
d1([Lh], () => Goe);
d1([Lh], () => Woe);
d1([Lh], () => qoe);
d1([Lh, _y], () => Koe);
let cj = (t = 21) =>
  crypto
    .getRandomValues(new Uint8Array(t))
    .reduce(
      (e, n) => (
        (n &= 63),
        n < 36
          ? (e += n.toString(36))
          : n < 62
          ? (e += (n - 26).toString(36).toUpperCase())
          : n > 62
          ? (e += "-")
          : (e += "_"),
        e
      ),
      ""
    );
var fj = { exports: {} };
(function (t, e) {
  (function (n, r) {
    t.exports = r();
  })(self, () => {
    return (
      (n = {
        7629: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(9474),
            f = a(1687),
            c = a(8652),
            d = a(8160),
            p = a(3292),
            m = a(6354),
            g = a(8901),
            w = a(9708),
            y = a(6914),
            v = a(2294),
            E = a(6133),
            S = a(1152),
            D = a(8863),
            P = a(2036),
            x = {
              Base: class {
                constructor(_) {
                  (this.type = _),
                    (this.$_root = null),
                    (this._definition = {}),
                    this._reset();
                }
                _reset() {
                  (this._ids = new v.Ids()),
                    (this._preferences = null),
                    (this._refs = new E.Manager()),
                    (this._cache = null),
                    (this._valids = null),
                    (this._invalids = null),
                    (this._flags = {}),
                    (this._rules = []),
                    (this._singleRules = new Map()),
                    (this.$_terms = {}),
                    (this.$_temp = { ruleset: null, whens: {} });
                }
                describe() {
                  return (
                    o(
                      typeof w.describe == "function",
                      "Manifest functionality disabled"
                    ),
                    w.describe(this)
                  );
                }
                allow() {
                  for (
                    var _ = arguments.length, A = new Array(_), N = 0;
                    N < _;
                    N++
                  )
                    A[N] = arguments[N];
                  return d.verifyFlat(A, "allow"), this._values(A, "_valids");
                }
                alter(_) {
                  o(
                    _ && typeof _ == "object" && !Array.isArray(_),
                    "Invalid targets argument"
                  ),
                    o(
                      !this._inRuleset(),
                      "Cannot set alterations inside a ruleset"
                    );
                  const A = this.clone();
                  A.$_terms.alterations = A.$_terms.alterations || [];
                  for (const N in _) {
                    const M = _[N];
                    o(
                      typeof M == "function",
                      "Alteration adjuster for",
                      N,
                      "must be a function"
                    ),
                      A.$_terms.alterations.push({ target: N, adjuster: M });
                  }
                  return (A.$_temp.ruleset = !1), A;
                }
                artifact(_) {
                  return (
                    o(_ !== void 0, "Artifact cannot be undefined"),
                    o(!this._cache, "Cannot set an artifact with a rule cache"),
                    this.$_setFlag("artifact", _)
                  );
                }
                cast(_) {
                  return (
                    o(_ === !1 || typeof _ == "string", "Invalid to value"),
                    o(
                      _ === !1 || this._definition.cast[_],
                      "Type",
                      this.type,
                      "does not support casting to",
                      _
                    ),
                    this.$_setFlag("cast", _ === !1 ? void 0 : _)
                  );
                }
                default(_, A) {
                  return this._default("default", _, A);
                }
                description(_) {
                  return (
                    o(
                      _ && typeof _ == "string",
                      "Description must be a non-empty string"
                    ),
                    this.$_setFlag("description", _)
                  );
                }
                empty(_) {
                  const A = this.clone();
                  return (
                    _ !== void 0 && (_ = A.$_compile(_, { override: !1 })),
                    A.$_setFlag("empty", _, { clone: !1 })
                  );
                }
                error(_) {
                  return (
                    o(_, "Missing error"),
                    o(
                      _ instanceof Error || typeof _ == "function",
                      "Must provide a valid Error object or a function"
                    ),
                    this.$_setFlag("error", _)
                  );
                }
                example(_) {
                  let A =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  return (
                    o(_ !== void 0, "Missing example"),
                    d.assertOptions(A, ["override"]),
                    this._inner("examples", _, {
                      single: !0,
                      override: A.override,
                    })
                  );
                }
                external(_, A) {
                  return (
                    typeof _ == "object" &&
                      (o(!A, "Cannot combine options with description"),
                      (A = _.description),
                      (_ = _.method)),
                    o(typeof _ == "function", "Method must be a function"),
                    o(
                      A === void 0 || (A && typeof A == "string"),
                      "Description must be a non-empty string"
                    ),
                    this._inner(
                      "externals",
                      { method: _, description: A },
                      { single: !0 }
                    )
                  );
                }
                failover(_, A) {
                  return this._default("failover", _, A);
                }
                forbidden() {
                  return this.presence("forbidden");
                }
                id(_) {
                  return _
                    ? (o(typeof _ == "string", "id must be a non-empty string"),
                      o(
                        /^[^\.]+$/.test(_),
                        "id cannot contain period character"
                      ),
                      this.$_setFlag("id", _))
                    : this.$_setFlag("id", void 0);
                }
                invalid() {
                  for (
                    var _ = arguments.length, A = new Array(_), N = 0;
                    N < _;
                    N++
                  )
                    A[N] = arguments[N];
                  return this._values(A, "_invalids");
                }
                label(_) {
                  return (
                    o(
                      _ && typeof _ == "string",
                      "Label name must be a non-empty string"
                    ),
                    this.$_setFlag("label", _)
                  );
                }
                meta(_) {
                  return (
                    o(_ !== void 0, "Meta cannot be undefined"),
                    this._inner("metas", _, { single: !0 })
                  );
                }
                note() {
                  for (
                    var _ = arguments.length, A = new Array(_), N = 0;
                    N < _;
                    N++
                  )
                    A[N] = arguments[N];
                  o(A.length, "Missing notes");
                  for (const M of A)
                    o(
                      M && typeof M == "string",
                      "Notes must be non-empty strings"
                    );
                  return this._inner("notes", A);
                }
                only() {
                  let _ =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    o(typeof _ == "boolean", "Invalid mode:", _),
                    this.$_setFlag("only", _)
                  );
                }
                optional() {
                  return this.presence("optional");
                }
                prefs(_) {
                  o(_, "Missing preferences"),
                    o(_.context === void 0, "Cannot override context"),
                    o(_.externals === void 0, "Cannot override externals"),
                    o(_.warnings === void 0, "Cannot override warnings"),
                    o(_.debug === void 0, "Cannot override debug"),
                    d.checkPreferences(_);
                  const A = this.clone();
                  return (A._preferences = d.preferences(A._preferences, _)), A;
                }
                presence(_) {
                  return (
                    o(
                      ["optional", "required", "forbidden"].includes(_),
                      "Unknown presence mode",
                      _
                    ),
                    this.$_setFlag("presence", _)
                  );
                }
                raw() {
                  let _ =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("result", _ ? "raw" : void 0);
                }
                result(_) {
                  return (
                    o(["raw", "strip"].includes(_), "Unknown result mode", _),
                    this.$_setFlag("result", _)
                  );
                }
                required() {
                  return this.presence("required");
                }
                strict(_) {
                  const A = this.clone(),
                    N = _ !== void 0 && !_;
                  return (
                    (A._preferences = d.preferences(A._preferences, {
                      convert: N,
                    })),
                    A
                  );
                }
                strip() {
                  let _ =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("result", _ ? "strip" : void 0);
                }
                tag() {
                  for (
                    var _ = arguments.length, A = new Array(_), N = 0;
                    N < _;
                    N++
                  )
                    A[N] = arguments[N];
                  o(A.length, "Missing tags");
                  for (const M of A)
                    o(
                      M && typeof M == "string",
                      "Tags must be non-empty strings"
                    );
                  return this._inner("tags", A);
                }
                unit(_) {
                  return (
                    o(
                      _ && typeof _ == "string",
                      "Unit name must be a non-empty string"
                    ),
                    this.$_setFlag("unit", _)
                  );
                }
                valid() {
                  for (
                    var _ = arguments.length, A = new Array(_), N = 0;
                    N < _;
                    N++
                  )
                    A[N] = arguments[N];
                  d.verifyFlat(A, "valid");
                  const M = this.allow(...A);
                  return M.$_setFlag("only", !!M._valids, { clone: !1 }), M;
                }
                when(_, A) {
                  const N = this.clone();
                  N.$_terms.whens || (N.$_terms.whens = []);
                  const M = p.when(N, _, A);
                  if (!["any", "link"].includes(N.type)) {
                    const T = M.is ? [M] : M.switch;
                    for (const O of T)
                      o(
                        !O.then ||
                          O.then.type === "any" ||
                          O.then.type === N.type,
                        "Cannot combine",
                        N.type,
                        "with",
                        O.then && O.then.type
                      ),
                        o(
                          !O.otherwise ||
                            O.otherwise.type === "any" ||
                            O.otherwise.type === N.type,
                          "Cannot combine",
                          N.type,
                          "with",
                          O.otherwise && O.otherwise.type
                        );
                  }
                  return N.$_terms.whens.push(M), N.$_mutateRebuild();
                }
                cache(_) {
                  o(!this._inRuleset(), "Cannot set caching inside a ruleset"),
                    o(!this._cache, "Cannot override schema cache"),
                    o(
                      this._flags.artifact === void 0,
                      "Cannot cache a rule with an artifact"
                    );
                  const A = this.clone();
                  return (
                    (A._cache = _ || c.provider.provision()),
                    (A.$_temp.ruleset = !1),
                    A
                  );
                }
                clone() {
                  const _ = Object.create(Object.getPrototypeOf(this));
                  return this._assign(_);
                }
                concat(_) {
                  o(d.isSchema(_), "Invalid schema object"),
                    o(
                      this.type === "any" ||
                        _.type === "any" ||
                        _.type === this.type,
                      "Cannot merge type",
                      this.type,
                      "with another type:",
                      _.type
                    ),
                    o(
                      !this._inRuleset(),
                      "Cannot concatenate onto a schema with open ruleset"
                    ),
                    o(
                      !_._inRuleset(),
                      "Cannot concatenate a schema with open ruleset"
                    );
                  let A = this.clone();
                  if (this.type === "any" && _.type !== "any") {
                    const N = _.clone();
                    for (const M of Object.keys(A))
                      M !== "type" && (N[M] = A[M]);
                    A = N;
                  }
                  A._ids.concat(_._ids),
                    A._refs.register(_, E.toSibling),
                    (A._preferences = A._preferences
                      ? d.preferences(A._preferences, _._preferences)
                      : _._preferences),
                    (A._valids = P.merge(A._valids, _._valids, _._invalids)),
                    (A._invalids = P.merge(
                      A._invalids,
                      _._invalids,
                      _._valids
                    ));
                  for (const N of _._singleRules.keys())
                    A._singleRules.has(N) &&
                      ((A._rules = A._rules.filter(
                        (M) => M.keep || M.name !== N
                      )),
                      A._singleRules.delete(N));
                  for (const N of _._rules)
                    _._definition.rules[N.method].multi ||
                      A._singleRules.set(N.name, N),
                      A._rules.push(N);
                  if (A._flags.empty && _._flags.empty) {
                    A._flags.empty = A._flags.empty.concat(_._flags.empty);
                    const N = Object.assign({}, _._flags);
                    delete N.empty, f(A._flags, N);
                  } else if (_._flags.empty) {
                    A._flags.empty = _._flags.empty;
                    const N = Object.assign({}, _._flags);
                    delete N.empty, f(A._flags, N);
                  } else f(A._flags, _._flags);
                  for (const N in _.$_terms) {
                    const M = _.$_terms[N];
                    M
                      ? A.$_terms[N]
                        ? (A.$_terms[N] = A.$_terms[N].concat(M))
                        : (A.$_terms[N] = M.slice())
                      : A.$_terms[N] || (A.$_terms[N] = M);
                  }
                  return (
                    this.$_root._tracer &&
                      this.$_root._tracer._combine(A, [this, _]),
                    A.$_mutateRebuild()
                  );
                }
                extend(_) {
                  return (
                    o(!_.base, "Cannot extend type with another base"),
                    g.type(this, _)
                  );
                }
                extract(_) {
                  return (
                    (_ = Array.isArray(_) ? _ : _.split(".")),
                    this._ids.reach(_)
                  );
                }
                fork(_, A) {
                  o(!this._inRuleset(), "Cannot fork inside a ruleset");
                  let N = this;
                  for (let M of [].concat(_))
                    (M = Array.isArray(M) ? M : M.split(".")),
                      (N = N._ids.fork(M, A, N));
                  return (N.$_temp.ruleset = !1), N;
                }
                rule(_) {
                  const A = this._definition;
                  d.assertOptions(_, Object.keys(A.modifiers)),
                    o(
                      this.$_temp.ruleset !== !1,
                      "Cannot apply rules to empty ruleset or the last rule added does not support rule properties"
                    );
                  const N =
                    this.$_temp.ruleset === null
                      ? this._rules.length - 1
                      : this.$_temp.ruleset;
                  o(
                    N >= 0 && N < this._rules.length,
                    "Cannot apply rules to empty ruleset"
                  );
                  const M = this.clone();
                  for (let T = N; T < M._rules.length; ++T) {
                    const O = M._rules[T],
                      I = l(O);
                    for (const k in _)
                      A.modifiers[k](I, _[k]),
                        o(I.name === O.name, "Cannot change rule name");
                    (M._rules[T] = I),
                      M._singleRules.get(I.name) === O &&
                        M._singleRules.set(I.name, I);
                  }
                  return (M.$_temp.ruleset = !1), M.$_mutateRebuild();
                }
                get ruleset() {
                  o(
                    !this._inRuleset(),
                    "Cannot start a new ruleset without closing the previous one"
                  );
                  const _ = this.clone();
                  return (_.$_temp.ruleset = _._rules.length), _;
                }
                get $() {
                  return this.ruleset;
                }
                tailor(_) {
                  (_ = [].concat(_)),
                    o(!this._inRuleset(), "Cannot tailor inside a ruleset");
                  let A = this;
                  if (this.$_terms.alterations)
                    for (const { target: N, adjuster: M } of this.$_terms
                      .alterations)
                      _.includes(N) &&
                        ((A = M(A)),
                        o(
                          d.isSchema(A),
                          "Alteration adjuster for",
                          N,
                          "failed to return a schema object"
                        ));
                  return (
                    (A = A.$_modify({ each: (N) => N.tailor(_), ref: !1 })),
                    (A.$_temp.ruleset = !1),
                    A.$_mutateRebuild()
                  );
                }
                tracer() {
                  return S.location ? S.location(this) : this;
                }
                validate(_, A) {
                  return D.entry(_, this, A);
                }
                validateAsync(_, A) {
                  return D.entryAsync(_, this, A);
                }
                $_addRule(_) {
                  typeof _ == "string" && (_ = { name: _ }),
                    o(_ && typeof _ == "object", "Invalid options"),
                    o(_.name && typeof _.name == "string", "Invalid rule name");
                  for (const O in _)
                    o(O[0] !== "_", "Cannot set private rule properties");
                  const A = Object.assign({}, _);
                  (A._resolve = []), (A.method = A.method || A.name);
                  const N = this._definition.rules[A.method],
                    M = A.args;
                  o(N, "Unknown rule", A.method);
                  const T = this.clone();
                  if (M) {
                    o(
                      Object.keys(M).length === 1 ||
                        Object.keys(M).length ===
                          this._definition.rules[A.name].args.length,
                      "Invalid rule definition for",
                      this.type,
                      A.name
                    );
                    for (const O in M) {
                      let I = M[O];
                      if (N.argsByName) {
                        const k = N.argsByName.get(O);
                        if (k.ref && d.isResolvable(I))
                          A._resolve.push(O), T.$_mutateRegister(I);
                        else if (
                          (k.normalize && ((I = k.normalize(I)), (M[O] = I)),
                          k.assert)
                        ) {
                          const L = d.validateArg(I, O, k);
                          o(!L, L, "or reference");
                        }
                      }
                      I !== void 0 ? (M[O] = I) : delete M[O];
                    }
                  }
                  return (
                    N.multi ||
                      (T._ruleRemove(A.name, { clone: !1 }),
                      T._singleRules.set(A.name, A)),
                    T.$_temp.ruleset === !1 && (T.$_temp.ruleset = null),
                    N.priority ? T._rules.unshift(A) : T._rules.push(A),
                    T
                  );
                }
                $_compile(_, A) {
                  return p.schema(this.$_root, _, A);
                }
                $_createError(_, A, N, M, T) {
                  let O =
                    arguments.length > 5 && arguments[5] !== void 0
                      ? arguments[5]
                      : {};
                  const I = O.flags !== !1 ? this._flags : {},
                    k = O.messages
                      ? y.merge(this._definition.messages, O.messages)
                      : this._definition.messages;
                  return new m.Report(_, A, N, I, k, M, T);
                }
                $_getFlag(_) {
                  return this._flags[_];
                }
                $_getRule(_) {
                  return this._singleRules.get(_);
                }
                $_mapLabels(_) {
                  return (
                    (_ = Array.isArray(_) ? _ : _.split(".")),
                    this._ids.labels(_)
                  );
                }
                $_match(_, A, N, M) {
                  ((N = Object.assign({}, N)).abortEarly = !0),
                    (N._externals = !1),
                    A.snapshot();
                  const T = !D.validate(_, this, A, N, M).errors;
                  return A.restore(), T;
                }
                $_modify(_) {
                  return (
                    d.assertOptions(_, ["each", "once", "ref", "schema"]),
                    v.schema(this, _) || this
                  );
                }
                $_mutateRebuild() {
                  return (
                    o(
                      !this._inRuleset(),
                      "Cannot add this rule inside a ruleset"
                    ),
                    this._refs.reset(),
                    this._ids.reset(),
                    this.$_modify({
                      each: (_, A) => {
                        let { source: N, name: M, path: T, key: O } = A;
                        const I =
                          this._definition[N][M] &&
                          this._definition[N][M].register;
                        I !== !1 &&
                          this.$_mutateRegister(_, { family: I, key: O });
                      },
                    }),
                    this._definition.rebuild && this._definition.rebuild(this),
                    (this.$_temp.ruleset = !1),
                    this
                  );
                }
                $_mutateRegister(_) {
                  let { family: A, key: N } =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  this._refs.register(_, A), this._ids.register(_, { key: N });
                }
                $_property(_) {
                  return this._definition.properties[_];
                }
                $_reach(_) {
                  return this._ids.reach(_);
                }
                $_rootReferences() {
                  return this._refs.roots();
                }
                $_setFlag(_, A) {
                  let N =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  o(
                    _[0] === "_" || !this._inRuleset(),
                    "Cannot set flag inside a ruleset"
                  );
                  const M = this._definition.flags[_] || {};
                  if ((u(A, M.default) && (A = void 0), u(A, this._flags[_])))
                    return this;
                  const T = N.clone !== !1 ? this.clone() : this;
                  return (
                    A !== void 0
                      ? ((T._flags[_] = A), T.$_mutateRegister(A))
                      : delete T._flags[_],
                    _[0] !== "_" && (T.$_temp.ruleset = !1),
                    T
                  );
                }
                $_parent(_) {
                  for (
                    var A = arguments.length,
                      N = new Array(A > 1 ? A - 1 : 0),
                      M = 1;
                    M < A;
                    M++
                  )
                    N[M - 1] = arguments[M];
                  return this[_][d.symbols.parent].call(this, ...N);
                }
                $_validate(_, A, N) {
                  return D.validate(_, this, A, N);
                }
                _assign(_) {
                  (_.type = this.type),
                    (_.$_root = this.$_root),
                    (_.$_temp = Object.assign({}, this.$_temp)),
                    (_.$_temp.whens = {}),
                    (_._ids = this._ids.clone()),
                    (_._preferences = this._preferences),
                    (_._valids = this._valids && this._valids.clone()),
                    (_._invalids = this._invalids && this._invalids.clone()),
                    (_._rules = this._rules.slice()),
                    (_._singleRules = l(this._singleRules, { shallow: !0 })),
                    (_._refs = this._refs.clone()),
                    (_._flags = Object.assign({}, this._flags)),
                    (_._cache = null),
                    (_.$_terms = {});
                  for (const A in this.$_terms)
                    _.$_terms[A] = this.$_terms[A]
                      ? this.$_terms[A].slice()
                      : null;
                  _.$_super = {};
                  for (const A in this.$_super)
                    _.$_super[A] = this._super[A].bind(_);
                  return _;
                }
                _bare() {
                  const _ = this.clone();
                  _._reset();
                  const A = _._definition.terms;
                  for (const N in A) {
                    const M = A[N];
                    _.$_terms[N] = M.init;
                  }
                  return _.$_mutateRebuild();
                }
                _default(_, A) {
                  let N =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return (
                    d.assertOptions(N, "literal"),
                    o(A !== void 0, "Missing", _, "value"),
                    o(
                      typeof A == "function" || !N.literal,
                      "Only function value supports literal option"
                    ),
                    typeof A == "function" &&
                      N.literal &&
                      (A = { [d.symbols.literal]: !0, literal: A }),
                    this.$_setFlag(_, A)
                  );
                }
                _generate(_, A, N) {
                  if (!this.$_terms.whens) return { schema: this };
                  const M = [],
                    T = [];
                  for (let k = 0; k < this.$_terms.whens.length; ++k) {
                    const L = this.$_terms.whens[k];
                    if (L.concat) {
                      M.push(L.concat), T.push(`${k}.concat`);
                      continue;
                    }
                    const U = L.ref ? L.ref.resolve(_, A, N) : _,
                      $ = L.is ? [L] : L.switch,
                      B = T.length;
                    for (let R = 0; R < $.length; ++R) {
                      const { is: V, then: oe, otherwise: le } = $[R],
                        fe = `${k}${L.switch ? "." + R : ""}`;
                      if (V.$_match(U, A.nest(V, `${fe}.is`), N)) {
                        if (oe) {
                          const z = A.localize(
                              [...A.path, `${fe}.then`],
                              A.ancestors,
                              A.schemas
                            ),
                            { schema: se, id: Y } = oe._generate(_, z, N);
                          M.push(se), T.push(`${fe}.then${Y ? `(${Y})` : ""}`);
                          break;
                        }
                      } else if (le) {
                        const z = A.localize(
                            [...A.path, `${fe}.otherwise`],
                            A.ancestors,
                            A.schemas
                          ),
                          { schema: se, id: Y } = le._generate(_, z, N);
                        M.push(se),
                          T.push(`${fe}.otherwise${Y ? `(${Y})` : ""}`);
                        break;
                      }
                    }
                    if (L.break && T.length > B) break;
                  }
                  const O = T.join(", ");
                  if ((A.mainstay.tracer.debug(A, "rule", "when", O), !O))
                    return { schema: this };
                  if (!A.mainstay.tracer.active && this.$_temp.whens[O])
                    return { schema: this.$_temp.whens[O], id: O };
                  let I = this;
                  this._definition.generate &&
                    (I = this._definition.generate(this, _, A, N));
                  for (const k of M) I = I.concat(k);
                  return (
                    this.$_root._tracer &&
                      this.$_root._tracer._combine(I, [this, ...M]),
                    (this.$_temp.whens[O] = I),
                    { schema: I, id: O }
                  );
                }
                _inner(_, A) {
                  let N =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  o(!this._inRuleset(), `Cannot set ${_} inside a ruleset`);
                  const M = this.clone();
                  return (
                    (M.$_terms[_] && !N.override) || (M.$_terms[_] = []),
                    N.single ? M.$_terms[_].push(A) : M.$_terms[_].push(...A),
                    (M.$_temp.ruleset = !1),
                    M
                  );
                }
                _inRuleset() {
                  return (
                    this.$_temp.ruleset !== null && this.$_temp.ruleset !== !1
                  );
                }
                _ruleRemove(_) {
                  let A =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  if (!this._singleRules.has(_)) return this;
                  const N = A.clone !== !1 ? this.clone() : this;
                  N._singleRules.delete(_);
                  const M = [];
                  for (let T = 0; T < N._rules.length; ++T) {
                    const O = N._rules[T];
                    O.name !== _ || O.keep
                      ? M.push(O)
                      : N._inRuleset() &&
                        T < N.$_temp.ruleset &&
                        --N.$_temp.ruleset;
                  }
                  return (N._rules = M), N;
                }
                _values(_, A) {
                  d.verifyFlat(_, A.slice(1, -1));
                  const N = this.clone(),
                    M = _[0] === d.symbols.override;
                  if (
                    (M && (_ = _.slice(1)),
                    !N[A] && _.length
                      ? (N[A] = new P())
                      : M &&
                        ((N[A] = _.length ? new P() : null),
                        N.$_mutateRebuild()),
                    !N[A])
                  )
                    return N;
                  M && N[A].override();
                  for (const T of _) {
                    o(
                      T !== void 0,
                      "Cannot call allow/valid/invalid with undefined"
                    ),
                      o(
                        T !== d.symbols.override,
                        "Override must be the first value"
                      );
                    const O = A === "_invalids" ? "_valids" : "_invalids";
                    N[O] &&
                      (N[O].remove(T),
                      N[O].length ||
                        (o(
                          A === "_valids" || !N._flags.only,
                          "Setting invalid value",
                          T,
                          "leaves schema rejecting all values due to previous valid rule"
                        ),
                        (N[O] = null))),
                      N[A].add(T, N._refs);
                  }
                  return N;
                }
              },
            };
          (x.Base.prototype[d.symbols.any] = {
            version: d.version,
            compile: p.compile,
            root: "$_root",
          }),
            (x.Base.prototype.isImmutable = !0),
            (x.Base.prototype.deny = x.Base.prototype.invalid),
            (x.Base.prototype.disallow = x.Base.prototype.invalid),
            (x.Base.prototype.equal = x.Base.prototype.valid),
            (x.Base.prototype.exist = x.Base.prototype.required),
            (x.Base.prototype.not = x.Base.prototype.invalid),
            (x.Base.prototype.options = x.Base.prototype.prefs),
            (x.Base.prototype.preferences = x.Base.prototype.prefs),
            (i.exports = new x.Base());
        },
        8652: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(8160),
            f = {
              max: 1e3,
              supported: new Set(["undefined", "boolean", "number", "string"]),
            };
          (s.provider = { provision: (c) => new f.Cache(c) }),
            (f.Cache = class {
              constructor() {
                let c =
                  arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {};
                u.assertOptions(c, ["max"]),
                  o(
                    c.max === void 0 || (c.max && c.max > 0 && isFinite(c.max)),
                    "Invalid max cache size"
                  ),
                  (this._max = c.max || f.max),
                  (this._map = new Map()),
                  (this._list = new f.List());
              }
              get length() {
                return this._map.size;
              }
              set(c, d) {
                if (c !== null && !f.supported.has(typeof c)) return;
                let p = this._map.get(c);
                if (p) return (p.value = d), void this._list.first(p);
                (p = this._list.unshift({ key: c, value: d })),
                  this._map.set(c, p),
                  this._compact();
              }
              get(c) {
                const d = this._map.get(c);
                if (d) return this._list.first(d), l(d.value);
              }
              _compact() {
                if (this._map.size > this._max) {
                  const c = this._list.pop();
                  this._map.delete(c.key);
                }
              }
            }),
            (f.List = class {
              constructor() {
                (this.tail = null), (this.head = null);
              }
              unshift(c) {
                return (
                  (c.next = null),
                  (c.prev = this.head),
                  this.head && (this.head.next = c),
                  (this.head = c),
                  this.tail || (this.tail = c),
                  c
                );
              }
              first(c) {
                c !== this.head && (this._remove(c), this.unshift(c));
              }
              pop() {
                return this._remove(this.tail);
              }
              _remove(c) {
                const { next: d, prev: p } = c;
                return (
                  (d.prev = p),
                  p && (p.next = d),
                  c === this.tail && (this.tail = d),
                  (c.prev = null),
                  (c.next = null),
                  c
                );
              }
            });
        },
        8160: (i, s, a) => {
          const o = a(375),
            l = a(7916),
            u = a(5934);
          let f, c;
          const d = {
            isoDate:
              /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/,
          };
          (s.version = u.version),
            (s.defaults = {
              abortEarly: !0,
              allowUnknown: !1,
              artifacts: !1,
              cache: !0,
              context: null,
              convert: !0,
              dateFormat: "iso",
              errors: {
                escapeHtml: !1,
                label: "path",
                language: null,
                render: !0,
                stack: !1,
                wrap: { label: '"', array: "[]" },
              },
              externals: !0,
              messages: {},
              nonEnumerables: !1,
              noDefaults: !1,
              presence: "optional",
              skipFunctions: !1,
              stripUnknown: !1,
              warnings: !1,
            }),
            (s.symbols = {
              any: Symbol.for("@hapi/joi/schema"),
              arraySingle: Symbol("arraySingle"),
              deepDefault: Symbol("deepDefault"),
              errors: Symbol("errors"),
              literal: Symbol("literal"),
              override: Symbol("override"),
              parent: Symbol("parent"),
              prefs: Symbol("prefs"),
              ref: Symbol("ref"),
              template: Symbol("template"),
              values: Symbol("values"),
            }),
            (s.assertOptions = function (p, m) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : "Options";
              o(
                p && typeof p == "object" && !Array.isArray(p),
                "Options must be of type object"
              );
              const w = Object.keys(p).filter((y) => !m.includes(y));
              o(w.length === 0, `${g} contain unknown keys: ${w}`);
            }),
            (s.checkPreferences = function (p) {
              c = c || a(3378);
              const m = c.preferences.validate(p);
              if (m.error) throw new l([m.error.details[0].message]);
            }),
            (s.compare = function (p, m, g) {
              switch (g) {
                case "=":
                  return p === m;
                case ">":
                  return p > m;
                case "<":
                  return p < m;
                case ">=":
                  return p >= m;
                case "<=":
                  return p <= m;
              }
            }),
            (s.default = function (p, m) {
              return p === void 0 ? m : p;
            }),
            (s.isIsoDate = function (p) {
              return d.isoDate.test(p);
            }),
            (s.isNumber = function (p) {
              return typeof p == "number" && !isNaN(p);
            }),
            (s.isResolvable = function (p) {
              return !!p && (p[s.symbols.ref] || p[s.symbols.template]);
            }),
            (s.isSchema = function (p) {
              let m =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              const g = p && p[s.symbols.any];
              return (
                !!g &&
                (o(
                  m.legacy || g.version === s.version,
                  "Cannot mix different versions of joi schemas"
                ),
                !0)
              );
            }),
            (s.isValues = function (p) {
              return p[s.symbols.values];
            }),
            (s.limit = function (p) {
              return Number.isSafeInteger(p) && p >= 0;
            }),
            (s.preferences = function (p, m) {
              (f = f || a(6914)), (p = p || {}), (m = m || {});
              const g = Object.assign({}, p, m);
              return (
                m.errors &&
                  p.errors &&
                  ((g.errors = Object.assign({}, p.errors, m.errors)),
                  (g.errors.wrap = Object.assign(
                    {},
                    p.errors.wrap,
                    m.errors.wrap
                  ))),
                m.messages && (g.messages = f.compile(m.messages, p.messages)),
                delete g[s.symbols.prefs],
                g
              );
            }),
            (s.tryWithPath = function (p, m) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              try {
                return p();
              } catch (w) {
                throw (
                  (w.path !== void 0
                    ? (w.path = m + "." + w.path)
                    : (w.path = m),
                  g.append && (w.message = `${w.message} (${w.path})`),
                  w)
                );
              }
            }),
            (s.validateArg = function (p, m, g) {
              let { assert: w, message: y } = g;
              if (s.isSchema(w)) {
                const v = w.validate(p);
                return v.error ? v.error.message : void 0;
              }
              if (!w(p)) return m ? `${m} ${y}` : y;
            }),
            (s.verifyFlat = function (p, m) {
              for (const g of p)
                o(
                  !Array.isArray(g),
                  "Method no longer accepts array arguments:",
                  m
                );
            });
        },
        3292: (i, s, a) => {
          const o = a(375),
            l = a(8160),
            u = a(6133),
            f = {};
          (s.schema = function (c, d) {
            let p =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {};
            l.assertOptions(p, ["appendPath", "override"]);
            try {
              return f.schema(c, d, p);
            } catch (m) {
              throw (
                (p.appendPath &&
                  m.path !== void 0 &&
                  (m.message = `${m.message} (${m.path})`),
                m)
              );
            }
          }),
            (f.schema = function (c, d, p) {
              o(d !== void 0, "Invalid undefined schema"),
                Array.isArray(d) &&
                  (o(d.length, "Invalid empty array schema"),
                  d.length === 1 && (d = d[0]));
              const m = function (g) {
                for (
                  var w = arguments.length,
                    y = new Array(w > 1 ? w - 1 : 0),
                    v = 1;
                  v < w;
                  v++
                )
                  y[v - 1] = arguments[v];
                return p.override !== !1
                  ? g.valid(c.override, ...y)
                  : g.valid(...y);
              };
              if (f.simple(d)) return m(c, d);
              if (typeof d == "function") return c.custom(d);
              if (
                (o(typeof d == "object", "Invalid schema content:", typeof d),
                l.isResolvable(d))
              )
                return m(c, d);
              if (l.isSchema(d)) return d;
              if (Array.isArray(d)) {
                for (const g of d)
                  if (!f.simple(g)) return c.alternatives().try(...d);
                return m(c, ...d);
              }
              return d instanceof RegExp
                ? c.string().regex(d)
                : d instanceof Date
                ? m(c.date(), d)
                : (o(
                    Object.getPrototypeOf(d) === Object.getPrototypeOf({}),
                    "Schema can only contain plain objects"
                  ),
                  c.object().keys(d));
            }),
            (s.ref = function (c, d) {
              return u.isRef(c) ? c : u.create(c, d);
            }),
            (s.compile = function (c, d) {
              let p =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              l.assertOptions(p, ["legacy"]);
              const m = d && d[l.symbols.any];
              if (m)
                return (
                  o(
                    p.legacy || m.version === l.version,
                    "Cannot mix different versions of joi schemas:",
                    m.version,
                    l.version
                  ),
                  d
                );
              if (typeof d != "object" || !p.legacy)
                return s.schema(c, d, { appendPath: !0 });
              const g = f.walk(d);
              return g
                ? g.compile(g.root, d)
                : s.schema(c, d, { appendPath: !0 });
            }),
            (f.walk = function (c) {
              if (typeof c != "object") return null;
              if (Array.isArray(c)) {
                for (const p of c) {
                  const m = f.walk(p);
                  if (m) return m;
                }
                return null;
              }
              const d = c[l.symbols.any];
              if (d) return { root: c[d.root], compile: d.compile };
              o(
                Object.getPrototypeOf(c) === Object.getPrototypeOf({}),
                "Schema can only contain plain objects"
              );
              for (const p in c) {
                const m = f.walk(c[p]);
                if (m) return m;
              }
              return null;
            }),
            (f.simple = function (c) {
              return (
                c === null || ["boolean", "string", "number"].includes(typeof c)
              );
            }),
            (s.when = function (c, d, p) {
              if (
                (p === void 0 &&
                  (o(d && typeof d == "object", "Missing options"),
                  (p = d),
                  (d = u.create("."))),
                Array.isArray(p) && (p = { switch: p }),
                l.assertOptions(p, [
                  "is",
                  "not",
                  "then",
                  "otherwise",
                  "switch",
                  "break",
                ]),
                l.isSchema(d))
              )
                return (
                  o(
                    p.is === void 0,
                    '"is" can not be used with a schema condition'
                  ),
                  o(
                    p.not === void 0,
                    '"not" can not be used with a schema condition'
                  ),
                  o(
                    p.switch === void 0,
                    '"switch" can not be used with a schema condition'
                  ),
                  f.condition(c, {
                    is: d,
                    then: p.then,
                    otherwise: p.otherwise,
                    break: p.break,
                  })
                );
              if (
                (o(u.isRef(d) || typeof d == "string", "Invalid condition:", d),
                o(
                  p.not === void 0 || p.is === void 0,
                  'Cannot combine "is" with "not"'
                ),
                p.switch === void 0)
              ) {
                let g = p;
                p.not !== void 0 &&
                  (g = {
                    is: p.not,
                    then: p.otherwise,
                    otherwise: p.then,
                    break: p.break,
                  });
                let w =
                  g.is !== void 0
                    ? c.$_compile(g.is)
                    : c.$_root.invalid(null, !1, 0, "").required();
                return (
                  o(
                    g.then !== void 0 || g.otherwise !== void 0,
                    'options must have at least one of "then", "otherwise", or "switch"'
                  ),
                  o(
                    g.break === void 0 ||
                      g.then === void 0 ||
                      g.otherwise === void 0,
                    "Cannot specify then, otherwise, and break all together"
                  ),
                  p.is === void 0 ||
                    u.isRef(p.is) ||
                    l.isSchema(p.is) ||
                    (w = w.required()),
                  f.condition(c, {
                    ref: s.ref(d),
                    is: w,
                    then: g.then,
                    otherwise: g.otherwise,
                    break: g.break,
                  })
                );
              }
              o(Array.isArray(p.switch), '"switch" must be an array'),
                o(p.is === void 0, 'Cannot combine "switch" with "is"'),
                o(p.not === void 0, 'Cannot combine "switch" with "not"'),
                o(p.then === void 0, 'Cannot combine "switch" with "then"');
              const m = { ref: s.ref(d), switch: [], break: p.break };
              for (let g = 0; g < p.switch.length; ++g) {
                const w = p.switch[g],
                  y = g === p.switch.length - 1;
                l.assertOptions(
                  w,
                  y ? ["is", "then", "otherwise"] : ["is", "then"]
                ),
                  o(w.is !== void 0, 'Switch statement missing "is"'),
                  o(w.then !== void 0, 'Switch statement missing "then"');
                const v = { is: c.$_compile(w.is), then: c.$_compile(w.then) };
                if (
                  (u.isRef(w.is) ||
                    l.isSchema(w.is) ||
                    (v.is = v.is.required()),
                  y)
                ) {
                  o(
                    p.otherwise === void 0 || w.otherwise === void 0,
                    'Cannot specify "otherwise" inside and outside a "switch"'
                  );
                  const E = p.otherwise !== void 0 ? p.otherwise : w.otherwise;
                  E !== void 0 &&
                    (o(
                      m.break === void 0,
                      "Cannot specify both otherwise and break"
                    ),
                    (v.otherwise = c.$_compile(E)));
                }
                m.switch.push(v);
              }
              return m;
            }),
            (f.condition = function (c, d) {
              for (const p of ["then", "otherwise"])
                d[p] === void 0 ? delete d[p] : (d[p] = c.$_compile(d[p]));
              return d;
            });
        },
        6354: (i, s, a) => {
          const o = a(5688),
            l = a(8160),
            u = a(3328);
          (s.Report = class {
            constructor(f, c, d, p, m, g, w) {
              if (
                ((this.code = f),
                (this.flags = p),
                (this.messages = m),
                (this.path = g.path),
                (this.prefs = w),
                (this.state = g),
                (this.value = c),
                (this.message = null),
                (this.template = null),
                (this.local = d || {}),
                (this.local.label = s.label(
                  this.flags,
                  this.state,
                  this.prefs,
                  this.messages
                )),
                this.value === void 0 ||
                  this.local.hasOwnProperty("value") ||
                  (this.local.value = this.value),
                this.path.length)
              ) {
                const y = this.path[this.path.length - 1];
                typeof y != "object" && (this.local.key = y);
              }
            }
            _setTemplate(f) {
              if (
                ((this.template = f),
                !this.flags.label && this.path.length === 0)
              ) {
                const c = this._template(this.template, "root");
                c && (this.local.label = c);
              }
            }
            toString() {
              if (this.message) return this.message;
              const f = this.code;
              if (!this.prefs.errors.render) return this.code;
              const c =
                this._template(this.template) ||
                this._template(this.prefs.messages) ||
                this._template(this.messages);
              return c === void 0
                ? `Error code "${f}" is not defined, your custom type is missing the correct messages definition`
                : ((this.message = c.render(
                    this.value,
                    this.state,
                    this.prefs,
                    this.local,
                    {
                      errors: this.prefs.errors,
                      messages: [this.prefs.messages, this.messages],
                    }
                  )),
                  this.prefs.errors.label ||
                    (this.message = this.message.replace(/^"" /, "").trim()),
                  this.message);
            }
            _template(f, c) {
              return s.template(
                this.value,
                f,
                c || this.code,
                this.state,
                this.prefs
              );
            }
          }),
            (s.path = function (f) {
              let c = "";
              for (const d of f)
                typeof d != "object" &&
                  (typeof d == "string"
                    ? (c && (c += "."), (c += d))
                    : (c += `[${d}]`));
              return c;
            }),
            (s.template = function (f, c, d, p, m) {
              if (!c) return;
              if (u.isTemplate(c)) return d !== "root" ? c : null;
              let g = m.errors.language;
              if ((l.isResolvable(g) && (g = g.resolve(f, p, m)), g && c[g])) {
                if (c[g][d] !== void 0) return c[g][d];
                if (c[g]["*"] !== void 0) return c[g]["*"];
              }
              return c[d] ? c[d] : c["*"];
            }),
            (s.label = function (f, c, d, p) {
              if (f.label) return f.label;
              if (!d.errors.label) return "";
              let m = c.path;
              return (
                d.errors.label === "key" &&
                  c.path.length > 1 &&
                  (m = c.path.slice(-1)),
                s.path(m) ||
                  s.template(null, d.messages, "root", c, d) ||
                  (p && s.template(null, p, "root", c, d)) ||
                  "value"
              );
            }),
            (s.process = function (f, c, d) {
              if (!f) return null;
              const { override: p, message: m, details: g } = s.details(f);
              if (p) return p;
              if (d.errors.stack) return new s.ValidationError(m, g, c);
              const w = Error.stackTraceLimit;
              Error.stackTraceLimit = 0;
              const y = new s.ValidationError(m, g, c);
              return (Error.stackTraceLimit = w), y;
            }),
            (s.details = function (f) {
              let c =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
                d = [];
              const p = [];
              for (const m of f) {
                if (m instanceof Error) {
                  if (c.override !== !1) return { override: m };
                  const w = m.toString();
                  d.push(w),
                    p.push({
                      message: w,
                      type: "override",
                      context: { error: m },
                    });
                  continue;
                }
                const g = m.toString();
                d.push(g),
                  p.push({
                    message: g,
                    path: m.path.filter((w) => typeof w != "object"),
                    type: m.code,
                    context: m.local,
                  });
              }
              return (
                d.length > 1 && (d = [...new Set(d)]),
                { message: d.join(". "), details: p }
              );
            }),
            (s.ValidationError = class extends Error {
              constructor(f, c, d) {
                super(f), (this._original = d), (this.details = c);
              }
              static isError(f) {
                return f instanceof s.ValidationError;
              }
            }),
            (s.ValidationError.prototype.isJoi = !0),
            (s.ValidationError.prototype.name = "ValidationError"),
            (s.ValidationError.prototype.annotate = o.error);
        },
        8901: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(8160),
            f = a(6914),
            c = {};
          (s.type = function (d, p) {
            const m = Object.getPrototypeOf(d),
              g = l(m),
              w = d._assign(Object.create(g)),
              y = Object.assign({}, p);
            delete y.base, (g._definition = y);
            const v = m._definition || {};
            (y.messages = f.merge(v.messages, y.messages)),
              (y.properties = Object.assign({}, v.properties, y.properties)),
              (w.type = y.type),
              (y.flags = Object.assign({}, v.flags, y.flags));
            const E = Object.assign({}, v.terms);
            if (y.terms)
              for (const x in y.terms) {
                const _ = y.terms[x];
                o(
                  w.$_terms[x] === void 0,
                  "Invalid term override for",
                  y.type,
                  x
                ),
                  (w.$_terms[x] = _.init),
                  (E[x] = _);
              }
            (y.terms = E),
              y.args || (y.args = v.args),
              (y.prepare = c.prepare(y.prepare, v.prepare)),
              y.coerce &&
                (typeof y.coerce == "function" &&
                  (y.coerce = { method: y.coerce }),
                y.coerce.from &&
                  !Array.isArray(y.coerce.from) &&
                  (y.coerce = {
                    method: y.coerce.method,
                    from: [].concat(y.coerce.from),
                  })),
              (y.coerce = c.coerce(y.coerce, v.coerce)),
              (y.validate = c.validate(y.validate, v.validate));
            const S = Object.assign({}, v.rules);
            if (y.rules)
              for (const x in y.rules) {
                const _ = y.rules[x];
                o(
                  typeof _ == "object",
                  "Invalid rule definition for",
                  y.type,
                  x
                );
                let A = _.method;
                if (
                  (A === void 0 &&
                    (A = function () {
                      return this.$_addRule(x);
                    }),
                  A && (o(!g[x], "Rule conflict in", y.type, x), (g[x] = A)),
                  o(!S[x], "Rule conflict in", y.type, x),
                  (S[x] = _),
                  _.alias)
                ) {
                  const N = [].concat(_.alias);
                  for (const M of N) g[M] = _.method;
                }
                _.args &&
                  ((_.argsByName = new Map()),
                  (_.args = _.args.map(
                    (N) => (
                      typeof N == "string" && (N = { name: N }),
                      o(
                        !_.argsByName.has(N.name),
                        "Duplicated argument name",
                        N.name
                      ),
                      u.isSchema(N.assert) &&
                        (N.assert = N.assert.strict().label(N.name)),
                      _.argsByName.set(N.name, N),
                      N
                    )
                  )));
              }
            y.rules = S;
            const D = Object.assign({}, v.modifiers);
            if (y.modifiers)
              for (const x in y.modifiers) {
                o(!g[x], "Rule conflict in", y.type, x);
                const _ = y.modifiers[x];
                o(
                  typeof _ == "function",
                  "Invalid modifier definition for",
                  y.type,
                  x
                );
                const A = function (N) {
                  return this.rule({ [x]: N });
                };
                (g[x] = A), (D[x] = _);
              }
            if (((y.modifiers = D), y.overrides)) {
              (g._super = m), (w.$_super = {});
              for (const x in y.overrides)
                o(m[x], "Cannot override missing", x),
                  (y.overrides[x][u.symbols.parent] = m[x]),
                  (w.$_super[x] = m[x].bind(w));
              Object.assign(g, y.overrides);
            }
            y.cast = Object.assign({}, v.cast, y.cast);
            const P = Object.assign({}, v.manifest, y.manifest);
            return (
              (P.build = c.build(
                y.manifest && y.manifest.build,
                v.manifest && v.manifest.build
              )),
              (y.manifest = P),
              (y.rebuild = c.rebuild(y.rebuild, v.rebuild)),
              w
            );
          }),
            (c.build = function (d, p) {
              return d && p
                ? function (m, g) {
                    return p(d(m, g), g);
                  }
                : d || p;
            }),
            (c.coerce = function (d, p) {
              return d && p
                ? {
                    from:
                      d.from && p.from
                        ? [...new Set([...d.from, ...p.from])]
                        : null,
                    method(m, g) {
                      let w;
                      if (
                        (!p.from || p.from.includes(typeof m)) &&
                        ((w = p.method(m, g)), w)
                      ) {
                        if (w.errors || w.value === void 0) return w;
                        m = w.value;
                      }
                      if (!d.from || d.from.includes(typeof m)) {
                        const y = d.method(m, g);
                        if (y) return y;
                      }
                      return w;
                    },
                  }
                : d || p;
            }),
            (c.prepare = function (d, p) {
              return d && p
                ? function (m, g) {
                    const w = d(m, g);
                    if (w) {
                      if (w.errors || w.value === void 0) return w;
                      m = w.value;
                    }
                    return p(m, g) || w;
                  }
                : d || p;
            }),
            (c.rebuild = function (d, p) {
              return d && p
                ? function (m) {
                    p(m), d(m);
                  }
                : d || p;
            }),
            (c.validate = function (d, p) {
              return d && p
                ? function (m, g) {
                    const w = p(m, g);
                    if (w) {
                      if (
                        w.errors &&
                        (!Array.isArray(w.errors) || w.errors.length)
                      )
                        return w;
                      m = w.value;
                    }
                    return d(m, g) || w;
                  }
                : d || p;
            });
        },
        5107: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(8652),
            f = a(8160),
            c = a(3292),
            d = a(6354),
            p = a(8901),
            m = a(9708),
            g = a(6133),
            w = a(3328),
            y = a(1152);
          let v;
          const E = {
            types: {
              alternatives: a(4946),
              any: a(8068),
              array: a(546),
              boolean: a(4937),
              date: a(7500),
              function: a(390),
              link: a(8785),
              number: a(3832),
              object: a(8966),
              string: a(7417),
              symbol: a(8826),
            },
            aliases: { alt: "alternatives", bool: "boolean", func: "function" },
            root: function () {
              const S = { _types: new Set(Object.keys(E.types)) };
              for (const D of S._types)
                S[D] = function () {
                  for (
                    var P = arguments.length, x = new Array(P), _ = 0;
                    _ < P;
                    _++
                  )
                    x[_] = arguments[_];
                  return (
                    o(
                      !x.length ||
                        ["alternatives", "link", "object"].includes(D),
                      "The",
                      D,
                      "type does not allow arguments"
                    ),
                    E.generate(this, E.types[D], x)
                  );
                };
              for (const D of [
                "allow",
                "custom",
                "disallow",
                "equal",
                "exist",
                "forbidden",
                "invalid",
                "not",
                "only",
                "optional",
                "options",
                "prefs",
                "preferences",
                "required",
                "strip",
                "valid",
                "when",
              ])
                S[D] = function () {
                  return this.any()[D](...arguments);
                };
              Object.assign(S, E.methods);
              for (const D in E.aliases) {
                const P = E.aliases[D];
                S[D] = S[P];
              }
              return (S.x = S.expression), y.setup && y.setup(S), S;
            },
          };
          (E.methods = {
            ValidationError: d.ValidationError,
            version: f.version,
            cache: u.provider,
            assert(S, D) {
              for (
                var P = arguments.length,
                  x = new Array(P > 2 ? P - 2 : 0),
                  _ = 2;
                _ < P;
                _++
              )
                x[_ - 2] = arguments[_];
              E.assert(S, D, !0, x);
            },
            attempt(S, D) {
              for (
                var P = arguments.length,
                  x = new Array(P > 2 ? P - 2 : 0),
                  _ = 2;
                _ < P;
                _++
              )
                x[_ - 2] = arguments[_];
              return E.assert(S, D, !1, x);
            },
            build(S) {
              return (
                o(
                  typeof m.build == "function",
                  "Manifest functionality disabled"
                ),
                m.build(this, S)
              );
            },
            checkPreferences(S) {
              f.checkPreferences(S);
            },
            compile(S, D) {
              return c.compile(this, S, D);
            },
            defaults(S) {
              o(typeof S == "function", "modifier must be a function");
              const D = Object.assign({}, this);
              for (const P of D._types) {
                const x = S(D[P]());
                o(f.isSchema(x), "modifier must return a valid schema object"),
                  (D[P] = function () {
                    for (
                      var _ = arguments.length, A = new Array(_), N = 0;
                      N < _;
                      N++
                    )
                      A[N] = arguments[N];
                    return E.generate(this, x, A);
                  });
              }
              return D;
            },
            expression() {
              for (
                var S = arguments.length, D = new Array(S), P = 0;
                P < S;
                P++
              )
                D[P] = arguments[P];
              return new w(...D);
            },
            extend() {
              for (
                var S = arguments.length, D = new Array(S), P = 0;
                P < S;
                P++
              )
                D[P] = arguments[P];
              f.verifyFlat(D, "extend"),
                (v = v || a(3378)),
                o(D.length, "You need to provide at least one extension"),
                this.assert(D, v.extensions);
              const x = Object.assign({}, this);
              x._types = new Set(x._types);
              for (let _ of D) {
                typeof _ == "function" && (_ = _(x)),
                  this.assert(_, v.extension);
                const A = E.expandExtension(_, x);
                for (const N of A) {
                  o(
                    x[N.type] === void 0 || x._types.has(N.type),
                    "Cannot override name",
                    N.type
                  );
                  const M = N.base || this.any(),
                    T = p.type(M, N);
                  x._types.add(N.type),
                    (x[N.type] = function () {
                      for (
                        var O = arguments.length, I = new Array(O), k = 0;
                        k < O;
                        k++
                      )
                        I[k] = arguments[k];
                      return E.generate(this, T, I);
                    });
                }
              }
              return x;
            },
            isError: d.ValidationError.isError,
            isExpression: w.isTemplate,
            isRef: g.isRef,
            isSchema: f.isSchema,
            in() {
              return g.in(...arguments);
            },
            override: f.symbols.override,
            ref() {
              return g.create(...arguments);
            },
            types() {
              const S = {};
              for (const D of this._types) S[D] = this[D]();
              for (const D in E.aliases) S[D] = this[D]();
              return S;
            },
          }),
            (E.assert = function (S, D, P, x) {
              const _ =
                  x[0] instanceof Error || typeof x[0] == "string"
                    ? x[0]
                    : null,
                A = _ !== null ? x[1] : x[0],
                N = D.validate(
                  S,
                  f.preferences({ errors: { stack: !0 } }, A || {})
                );
              let M = N.error;
              if (!M) return N.value;
              if (_ instanceof Error) throw _;
              const T =
                P && typeof M.annotate == "function" ? M.annotate() : M.message;
              throw (
                (M instanceof d.ValidationError == 0 && (M = l(M)),
                (M.message = _ ? `${_} ${T}` : T),
                M)
              );
            }),
            (E.generate = function (S, D, P) {
              return (
                o(S, "Must be invoked on a Joi instance."),
                (D.$_root = S),
                D._definition.args && P.length ? D._definition.args(D, ...P) : D
              );
            }),
            (E.expandExtension = function (S, D) {
              if (typeof S.type == "string") return [S];
              const P = [];
              for (const x of D._types)
                if (S.type.test(x)) {
                  const _ = Object.assign({}, S);
                  (_.type = x), (_.base = D[x]()), P.push(_);
                }
              return P;
            }),
            (i.exports = E.root());
        },
        6914: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(3328);
          (s.compile = function (f, c) {
            if (typeof f == "string")
              return o(!c, "Cannot set single message string"), new u(f);
            if (u.isTemplate(f))
              return o(!c, "Cannot set single message template"), f;
            o(
              typeof f == "object" && !Array.isArray(f),
              "Invalid message options"
            ),
              (c = c ? l(c) : {});
            for (let d in f) {
              const p = f[d];
              if (d === "root" || u.isTemplate(p)) {
                c[d] = p;
                continue;
              }
              if (typeof p == "string") {
                c[d] = new u(p);
                continue;
              }
              o(
                typeof p == "object" && !Array.isArray(p),
                "Invalid message for",
                d
              );
              const m = d;
              for (d in ((c[m] = c[m] || {}), p)) {
                const g = p[d];
                d === "root" || u.isTemplate(g)
                  ? (c[m][d] = g)
                  : (o(typeof g == "string", "Invalid message for", d, "in", m),
                    (c[m][d] = new u(g)));
              }
            }
            return c;
          }),
            (s.decompile = function (f) {
              const c = {};
              for (let d in f) {
                const p = f[d];
                if (d === "root") {
                  c.root = p;
                  continue;
                }
                if (u.isTemplate(p)) {
                  c[d] = p.describe({ compact: !0 });
                  continue;
                }
                const m = d;
                for (d in ((c[m] = {}), p)) {
                  const g = p[d];
                  d !== "root"
                    ? (c[m][d] = g.describe({ compact: !0 }))
                    : (c[m].root = g);
                }
              }
              return c;
            }),
            (s.merge = function (f, c) {
              if (!f) return s.compile(c);
              if (!c) return f;
              if (typeof c == "string") return new u(c);
              if (u.isTemplate(c)) return c;
              const d = l(f);
              for (let p in c) {
                const m = c[p];
                if (p === "root" || u.isTemplate(m)) {
                  d[p] = m;
                  continue;
                }
                if (typeof m == "string") {
                  d[p] = new u(m);
                  continue;
                }
                o(
                  typeof m == "object" && !Array.isArray(m),
                  "Invalid message for",
                  p
                );
                const g = p;
                for (p in ((d[g] = d[g] || {}), m)) {
                  const w = m[p];
                  p === "root" || u.isTemplate(w)
                    ? (d[g][p] = w)
                    : (o(
                        typeof w == "string",
                        "Invalid message for",
                        p,
                        "in",
                        g
                      ),
                      (d[g][p] = new u(w)));
                }
              }
              return d;
            });
        },
        2294: (i, s, a) => {
          const o = a(375),
            l = a(8160),
            u = a(6133),
            f = {};
          (s.Ids = f.Ids =
            class {
              constructor() {
                (this._byId = new Map()),
                  (this._byKey = new Map()),
                  (this._schemaChain = !1);
              }
              clone() {
                const c = new f.Ids();
                return (
                  (c._byId = new Map(this._byId)),
                  (c._byKey = new Map(this._byKey)),
                  (c._schemaChain = this._schemaChain),
                  c
                );
              }
              concat(c) {
                c._schemaChain && (this._schemaChain = !0);
                for (const [d, p] of c._byId.entries())
                  o(
                    !this._byKey.has(d),
                    "Schema id conflicts with existing key:",
                    d
                  ),
                    this._byId.set(d, p);
                for (const [d, p] of c._byKey.entries())
                  o(
                    !this._byId.has(d),
                    "Schema key conflicts with existing id:",
                    d
                  ),
                    this._byKey.set(d, p);
              }
              fork(c, d, p) {
                const m = this._collect(c);
                m.push({ schema: p });
                const g = m.shift();
                let w = { id: g.id, schema: d(g.schema) };
                o(
                  l.isSchema(w.schema),
                  "adjuster function failed to return a joi schema type"
                );
                for (const y of m)
                  w = { id: y.id, schema: f.fork(y.schema, w.id, w.schema) };
                return w.schema;
              }
              labels(c) {
                let d =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : [];
                const p = c[0],
                  m = this._get(p);
                if (!m) return [...d, ...c].join(".");
                const g = c.slice(1);
                return (
                  (d = [...d, m.schema._flags.label || p]),
                  g.length ? m.schema._ids.labels(g, d) : d.join(".")
                );
              }
              reach(c) {
                let d =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : [];
                const p = c[0],
                  m = this._get(p);
                o(m, "Schema does not contain path", [...d, ...c].join("."));
                const g = c.slice(1);
                return g.length ? m.schema._ids.reach(g, [...d, p]) : m.schema;
              }
              register(c) {
                let { key: d } =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {};
                if (!c || !l.isSchema(c)) return;
                (c.$_property("schemaChain") || c._ids._schemaChain) &&
                  (this._schemaChain = !0);
                const p = c._flags.id;
                if (p) {
                  const m = this._byId.get(p);
                  o(
                    !m || m.schema === c,
                    "Cannot add different schemas with the same id:",
                    p
                  ),
                    o(
                      !this._byKey.has(p),
                      "Schema id conflicts with existing key:",
                      p
                    ),
                    this._byId.set(p, { schema: c, id: p });
                }
                d &&
                  (o(!this._byKey.has(d), "Schema already contains key:", d),
                  o(
                    !this._byId.has(d),
                    "Schema key conflicts with existing id:",
                    d
                  ),
                  this._byKey.set(d, { schema: c, id: d }));
              }
              reset() {
                (this._byId = new Map()),
                  (this._byKey = new Map()),
                  (this._schemaChain = !1);
              }
              _collect(c) {
                let d =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : [],
                  p =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : [];
                const m = c[0],
                  g = this._get(m);
                o(g, "Schema does not contain path", [...d, ...c].join(".")),
                  (p = [g, ...p]);
                const w = c.slice(1);
                return w.length ? g.schema._ids._collect(w, [...d, m], p) : p;
              }
              _get(c) {
                return this._byId.get(c) || this._byKey.get(c);
              }
            }),
            (f.fork = function (c, d, p) {
              const m = s.schema(c, {
                each: (g, w) => {
                  let { key: y } = w;
                  if (d === (g._flags.id || y)) return p;
                },
                ref: !1,
              });
              return m ? m.$_mutateRebuild() : c;
            }),
            (s.schema = function (c, d) {
              let p;
              for (const m in c._flags) {
                if (m[0] === "_") continue;
                const g = f.scan(c._flags[m], { source: "flags", name: m }, d);
                g !== void 0 && ((p = p || c.clone()), (p._flags[m] = g));
              }
              for (let m = 0; m < c._rules.length; ++m) {
                const g = c._rules[m],
                  w = f.scan(g.args, { source: "rules", name: g.name }, d);
                if (w !== void 0) {
                  p = p || c.clone();
                  const y = Object.assign({}, g);
                  (y.args = w),
                    (p._rules[m] = y),
                    p._singleRules.get(g.name) === g &&
                      p._singleRules.set(g.name, y);
                }
              }
              for (const m in c.$_terms) {
                if (m[0] === "_") continue;
                const g = f.scan(c.$_terms[m], { source: "terms", name: m }, d);
                g !== void 0 && ((p = p || c.clone()), (p.$_terms[m] = g));
              }
              return p;
            }),
            (f.scan = function (c, d, p, m, g) {
              const w = m || [];
              if (c === null || typeof c != "object") return;
              let y;
              if (Array.isArray(c)) {
                for (let v = 0; v < c.length; ++v) {
                  const E =
                      d.source === "terms" && d.name === "keys" && c[v].key,
                    S = f.scan(c[v], d, p, [v, ...w], E);
                  S !== void 0 && ((y = y || c.slice()), (y[v] = S));
                }
                return y;
              }
              if (
                (p.schema !== !1 && l.isSchema(c)) ||
                (p.ref !== !1 && u.isRef(c))
              ) {
                const v = p.each(c, { ...d, path: w, key: g });
                return v === c ? void 0 : v;
              }
              for (const v in c) {
                if (v[0] === "_") continue;
                const E = f.scan(c[v], d, p, [v, ...w], g);
                E !== void 0 && ((y = y || Object.assign({}, c)), (y[v] = E));
              }
              return y;
            });
        },
        6133: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(9621),
            f = a(8160);
          let c;
          const d = {
            symbol: Symbol("ref"),
            defaults: {
              adjust: null,
              in: !1,
              iterables: null,
              map: null,
              separator: ".",
              type: "value",
            },
          };
          (s.create = function (p) {
            let m =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {};
            o(typeof p == "string", "Invalid reference key:", p),
              f.assertOptions(m, [
                "adjust",
                "ancestor",
                "in",
                "iterables",
                "map",
                "prefix",
                "render",
                "separator",
              ]),
              o(
                !m.prefix || typeof m.prefix == "object",
                "options.prefix must be of type object"
              );
            const g = Object.assign({}, d.defaults, m);
            delete g.prefix;
            const w = g.separator,
              y = d.context(p, w, m.prefix);
            if (((g.type = y.type), (p = y.key), g.type === "value"))
              if (
                (y.root &&
                  (o(
                    !w || p[0] !== w,
                    "Cannot specify relative path with root prefix"
                  ),
                  (g.ancestor = "root"),
                  p || (p = null)),
                w && w === p)
              )
                (p = null), (g.ancestor = 0);
              else if (g.ancestor !== void 0)
                o(
                  !w || !p || p[0] !== w,
                  "Cannot combine prefix with ancestor option"
                );
              else {
                const [v, E] = d.ancestor(p, w);
                E && (p = p.slice(E)) === "" && (p = null), (g.ancestor = v);
              }
            return (
              (g.path = w ? (p === null ? [] : p.split(w)) : [p]), new d.Ref(g)
            );
          }),
            (s.in = function (p) {
              let m =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              return s.create(p, { ...m, in: !0 });
            }),
            (s.isRef = function (p) {
              return !!p && !!p[f.symbols.ref];
            }),
            (d.Ref = class {
              constructor(p) {
                o(typeof p == "object", "Invalid reference construction"),
                  f.assertOptions(p, [
                    "adjust",
                    "ancestor",
                    "in",
                    "iterables",
                    "map",
                    "path",
                    "render",
                    "separator",
                    "type",
                    "depth",
                    "key",
                    "root",
                    "display",
                  ]),
                  o(
                    [!1, void 0].includes(p.separator) ||
                      (typeof p.separator == "string" &&
                        p.separator.length === 1),
                    "Invalid separator"
                  ),
                  o(
                    !p.adjust || typeof p.adjust == "function",
                    "options.adjust must be a function"
                  ),
                  o(
                    !p.map || Array.isArray(p.map),
                    "options.map must be an array"
                  ),
                  o(
                    !p.map || !p.adjust,
                    "Cannot set both map and adjust options"
                  ),
                  Object.assign(this, d.defaults, p),
                  o(
                    this.type === "value" || this.ancestor === void 0,
                    "Non-value references cannot reference ancestors"
                  ),
                  Array.isArray(this.map) && (this.map = new Map(this.map)),
                  (this.depth = this.path.length),
                  (this.key = this.path.length
                    ? this.path.join(this.separator)
                    : null),
                  (this.root = this.path[0]),
                  this.updateDisplay();
              }
              resolve(p, m, g, w) {
                let y =
                  arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : {};
                return (
                  o(!this.in || y.in, "Invalid in() reference usage"),
                  this.type === "global"
                    ? this._resolve(g.context, m, y)
                    : this.type === "local"
                    ? this._resolve(w, m, y)
                    : this.ancestor
                    ? this.ancestor === "root"
                      ? this._resolve(m.ancestors[m.ancestors.length - 1], m, y)
                      : (o(
                          this.ancestor <= m.ancestors.length,
                          "Invalid reference exceeds the schema root:",
                          this.display
                        ),
                        this._resolve(m.ancestors[this.ancestor - 1], m, y))
                    : this._resolve(p, m, y)
                );
              }
              _resolve(p, m, g) {
                let w;
                if (
                  (this.type === "value" &&
                    m.mainstay.shadow &&
                    g.shadow !== !1 &&
                    (w = m.mainstay.shadow.get(this.absolute(m))),
                  w === void 0 &&
                    (w = u(p, this.path, {
                      iterables: this.iterables,
                      functions: !0,
                    })),
                  this.adjust && (w = this.adjust(w)),
                  this.map)
                ) {
                  const y = this.map.get(w);
                  y !== void 0 && (w = y);
                }
                return m.mainstay && m.mainstay.tracer.resolve(m, this, w), w;
              }
              toString() {
                return this.display;
              }
              absolute(p) {
                return [...p.path.slice(0, -this.ancestor), ...this.path];
              }
              clone() {
                return new d.Ref(this);
              }
              describe() {
                const p = { path: this.path };
                this.type !== "value" && (p.type = this.type),
                  this.separator !== "." && (p.separator = this.separator),
                  this.type === "value" &&
                    this.ancestor !== 1 &&
                    (p.ancestor = this.ancestor),
                  this.map && (p.map = [...this.map]);
                for (const m of ["adjust", "iterables", "render"])
                  this[m] !== null && this[m] !== void 0 && (p[m] = this[m]);
                return this.in !== !1 && (p.in = !0), { ref: p };
              }
              updateDisplay() {
                const p = this.key !== null ? this.key : "";
                if (this.type !== "value")
                  return void (this.display = `ref:${this.type}:${p}`);
                if (!this.separator) return void (this.display = `ref:${p}`);
                if (!this.ancestor)
                  return void (this.display = `ref:${this.separator}${p}`);
                if (this.ancestor === "root")
                  return void (this.display = `ref:root:${p}`);
                if (this.ancestor === 1)
                  return void (this.display = `ref:${p || ".."}`);
                const m = new Array(this.ancestor + 1)
                  .fill(this.separator)
                  .join("");
                this.display = `ref:${m}${p || ""}`;
              }
            }),
            (d.Ref.prototype[f.symbols.ref] = !0),
            (s.build = function (p) {
              return (
                (p = Object.assign({}, d.defaults, p)).type === "value" &&
                  p.ancestor === void 0 &&
                  (p.ancestor = 1),
                new d.Ref(p)
              );
            }),
            (d.context = function (p, m) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              if (((p = p.trim()), g)) {
                const w = g.global === void 0 ? "$" : g.global;
                if (w !== m && p.startsWith(w))
                  return { key: p.slice(w.length), type: "global" };
                const y = g.local === void 0 ? "#" : g.local;
                if (y !== m && p.startsWith(y))
                  return { key: p.slice(y.length), type: "local" };
                const v = g.root === void 0 ? "/" : g.root;
                if (v !== m && p.startsWith(v))
                  return { key: p.slice(v.length), type: "value", root: !0 };
              }
              return { key: p, type: "value" };
            }),
            (d.ancestor = function (p, m) {
              if (!m) return [1, 0];
              if (p[0] !== m) return [1, 0];
              if (p[1] !== m) return [0, 1];
              let g = 2;
              for (; p[g] === m; ) ++g;
              return [g - 1, g];
            }),
            (s.toSibling = 0),
            (s.toParent = 1),
            (s.Manager = class {
              constructor() {
                this.refs = [];
              }
              register(p, m) {
                if (p)
                  if (((m = m === void 0 ? s.toParent : m), Array.isArray(p)))
                    for (const g of p) this.register(g, m);
                  else if (f.isSchema(p))
                    for (const g of p._refs.refs)
                      g.ancestor - m >= 0 &&
                        this.refs.push({
                          ancestor: g.ancestor - m,
                          root: g.root,
                        });
                  else
                    s.isRef(p) &&
                      p.type === "value" &&
                      p.ancestor - m >= 0 &&
                      this.refs.push({
                        ancestor: p.ancestor - m,
                        root: p.root,
                      }),
                      (c = c || a(3328)),
                      c.isTemplate(p) && this.register(p.refs(), m);
              }
              get length() {
                return this.refs.length;
              }
              clone() {
                const p = new s.Manager();
                return (p.refs = l(this.refs)), p;
              }
              reset() {
                this.refs = [];
              }
              roots() {
                return this.refs.filter((p) => !p.ancestor).map((p) => p.root);
              }
            });
        },
        3378: (i, s, a) => {
          const o = a(5107),
            l = {};
          (l.wrap = o.string().min(1).max(2).allow(!1)),
            (s.preferences = o
              .object({
                allowUnknown: o.boolean(),
                abortEarly: o.boolean(),
                artifacts: o.boolean(),
                cache: o.boolean(),
                context: o.object(),
                convert: o.boolean(),
                dateFormat: o.valid("date", "iso", "string", "time", "utc"),
                debug: o.boolean(),
                errors: {
                  escapeHtml: o.boolean(),
                  label: o.valid("path", "key", !1),
                  language: [o.string(), o.object().ref()],
                  render: o.boolean(),
                  stack: o.boolean(),
                  wrap: { label: l.wrap, array: l.wrap, string: l.wrap },
                },
                externals: o.boolean(),
                messages: o.object(),
                noDefaults: o.boolean(),
                nonEnumerables: o.boolean(),
                presence: o.valid("required", "optional", "forbidden"),
                skipFunctions: o.boolean(),
                stripUnknown: o
                  .object({ arrays: o.boolean(), objects: o.boolean() })
                  .or("arrays", "objects")
                  .allow(!0, !1),
                warnings: o.boolean(),
              })
              .strict()),
            (l.nameRx = /^[a-zA-Z0-9]\w*$/),
            (l.rule = o.object({
              alias: o.array().items(o.string().pattern(l.nameRx)).single(),
              args: o.array().items(
                o.string(),
                o.object({
                  name: o.string().pattern(l.nameRx).required(),
                  ref: o.boolean(),
                  assert: o
                    .alternatives([o.function(), o.object().schema()])
                    .conditional("ref", { is: !0, then: o.required() }),
                  normalize: o.function(),
                  message: o
                    .string()
                    .when("assert", { is: o.function(), then: o.required() }),
                })
              ),
              convert: o.boolean(),
              manifest: o.boolean(),
              method: o.function().allow(!1),
              multi: o.boolean(),
              validate: o.function(),
            })),
            (s.extension = o
              .object({
                type: o
                  .alternatives([o.string(), o.object().regex()])
                  .required(),
                args: o.function(),
                cast: o.object().pattern(
                  l.nameRx,
                  o.object({
                    from: o.function().maxArity(1).required(),
                    to: o.function().minArity(1).maxArity(2).required(),
                  })
                ),
                base: o.object().schema().when("type", {
                  is: o.object().regex(),
                  then: o.forbidden(),
                }),
                coerce: [
                  o.function().maxArity(3),
                  o.object({
                    method: o.function().maxArity(3).required(),
                    from: o.array().items(o.string()).single(),
                  }),
                ],
                flags: o
                  .object()
                  .pattern(
                    l.nameRx,
                    o.object({ setter: o.string(), default: o.any() })
                  ),
                manifest: { build: o.function().arity(2) },
                messages: [o.object(), o.string()],
                modifiers: o
                  .object()
                  .pattern(l.nameRx, o.function().minArity(1).maxArity(2)),
                overrides: o.object().pattern(l.nameRx, o.function()),
                prepare: o.function().maxArity(3),
                rebuild: o.function().arity(1),
                rules: o.object().pattern(l.nameRx, l.rule),
                terms: o.object().pattern(
                  l.nameRx,
                  o.object({
                    init: o.array().allow(null).required(),
                    manifest: o.object().pattern(/.+/, [
                      o.valid("schema", "single"),
                      o.object({
                        mapped: o
                          .object({
                            from: o.string().required(),
                            to: o.string().required(),
                          })
                          .required(),
                      }),
                    ]),
                  })
                ),
                validate: o.function().maxArity(3),
              })
              .strict()),
            (s.extensions = o
              .array()
              .items(o.object(), o.function().arity(1))
              .strict()),
            (l.desc = {
              buffer: o.object({ buffer: o.string() }),
              func: o.object({
                function: o.function().required(),
                options: { literal: !0 },
              }),
              override: o.object({ override: !0 }),
              ref: o.object({
                ref: o
                  .object({
                    type: o.valid("value", "global", "local"),
                    path: o.array().required(),
                    separator: o.string().length(1).allow(!1),
                    ancestor: o.number().min(0).integer().allow("root"),
                    map: o.array().items(o.array().length(2)).min(1),
                    adjust: o.function(),
                    iterables: o.boolean(),
                    in: o.boolean(),
                    render: o.boolean(),
                  })
                  .required(),
              }),
              regex: o.object({ regex: o.string().min(3) }),
              special: o.object({ special: o.valid("deep").required() }),
              template: o.object({
                template: o.string().required(),
                options: o.object(),
              }),
              value: o.object({
                value: o.alternatives([o.object(), o.array()]).required(),
              }),
            }),
            (l.desc.entity = o.alternatives([
              o.array().items(o.link("...")),
              o.boolean(),
              o.function(),
              o.number(),
              o.string(),
              l.desc.buffer,
              l.desc.func,
              l.desc.ref,
              l.desc.regex,
              l.desc.special,
              l.desc.template,
              l.desc.value,
              o.link("/"),
            ])),
            (l.desc.values = o
              .array()
              .items(
                null,
                o.boolean(),
                o.function(),
                o.number().allow(1 / 0, -1 / 0),
                o.string().allow(""),
                o.symbol(),
                l.desc.buffer,
                l.desc.func,
                l.desc.override,
                l.desc.ref,
                l.desc.regex,
                l.desc.template,
                l.desc.value
              )),
            (l.desc.messages = o
              .object()
              .pattern(/.+/, [
                o.string(),
                l.desc.template,
                o.object().pattern(/.+/, [o.string(), l.desc.template]),
              ])),
            (s.description = o
              .object({
                type: o.string().required(),
                flags: o
                  .object({
                    cast: o.string(),
                    default: o.any(),
                    description: o.string(),
                    empty: o.link("/"),
                    failover: l.desc.entity,
                    id: o.string(),
                    label: o.string(),
                    only: !0,
                    presence: ["optional", "required", "forbidden"],
                    result: ["raw", "strip"],
                    strip: o.boolean(),
                    unit: o.string(),
                  })
                  .unknown(),
                preferences: {
                  allowUnknown: o.boolean(),
                  abortEarly: o.boolean(),
                  artifacts: o.boolean(),
                  cache: o.boolean(),
                  convert: o.boolean(),
                  dateFormat: ["date", "iso", "string", "time", "utc"],
                  errors: {
                    escapeHtml: o.boolean(),
                    label: ["path", "key"],
                    language: [o.string(), l.desc.ref],
                    wrap: { label: l.wrap, array: l.wrap },
                  },
                  externals: o.boolean(),
                  messages: l.desc.messages,
                  noDefaults: o.boolean(),
                  nonEnumerables: o.boolean(),
                  presence: ["required", "optional", "forbidden"],
                  skipFunctions: o.boolean(),
                  stripUnknown: o
                    .object({ arrays: o.boolean(), objects: o.boolean() })
                    .or("arrays", "objects")
                    .allow(!0, !1),
                  warnings: o.boolean(),
                },
                allow: l.desc.values,
                invalid: l.desc.values,
                rules: o
                  .array()
                  .min(1)
                  .items({
                    name: o.string().required(),
                    args: o.object().min(1),
                    keep: o.boolean(),
                    message: [o.string(), l.desc.messages],
                    warn: o.boolean(),
                  }),
                keys: o.object().pattern(/.*/, o.link("/")),
                link: l.desc.ref,
              })
              .pattern(/^[a-z]\w*$/, o.any()));
        },
        493: (i, s, a) => {
          const o = a(8571),
            l = a(9621),
            u = a(8160),
            f = { value: Symbol("value") };
          (i.exports = f.State =
            class {
              constructor(c, d, p) {
                (this.path = c),
                  (this.ancestors = d),
                  (this.mainstay = p.mainstay),
                  (this.schemas = p.schemas),
                  (this.debug = null);
              }
              localize(c) {
                let d =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : null,
                  p =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : null;
                const m = new f.State(c, d, this);
                return (
                  p && m.schemas && (m.schemas = [f.schemas(p), ...m.schemas]),
                  m
                );
              }
              nest(c, d) {
                const p = new f.State(this.path, this.ancestors, this);
                return (
                  (p.schemas = p.schemas && [f.schemas(c), ...p.schemas]),
                  (p.debug = d),
                  p
                );
              }
              shadow(c, d) {
                (this.mainstay.shadow = this.mainstay.shadow || new f.Shadow()),
                  this.mainstay.shadow.set(this.path, c, d);
              }
              snapshot() {
                this.mainstay.shadow &&
                  (this._snapshot = o(this.mainstay.shadow.node(this.path))),
                  this.mainstay.snapshot();
              }
              restore() {
                this.mainstay.shadow &&
                  (this.mainstay.shadow.override(this.path, this._snapshot),
                  (this._snapshot = void 0)),
                  this.mainstay.restore();
              }
            }),
            (f.schemas = function (c) {
              return u.isSchema(c) ? { schema: c } : c;
            }),
            (f.Shadow = class {
              constructor() {
                this._values = null;
              }
              set(c, d, p) {
                if (
                  !c.length ||
                  (p === "strip" && typeof c[c.length - 1] == "number")
                )
                  return;
                this._values = this._values || new Map();
                let m = this._values;
                for (let g = 0; g < c.length; ++g) {
                  const w = c[g];
                  let y = m.get(w);
                  y || ((y = new Map()), m.set(w, y)), (m = y);
                }
                m[f.value] = d;
              }
              get(c) {
                const d = this.node(c);
                if (d) return d[f.value];
              }
              node(c) {
                if (this._values) return l(this._values, c, { iterables: !0 });
              }
              override(c, d) {
                if (!this._values) return;
                const p = c.slice(0, -1),
                  m = c[c.length - 1],
                  g = l(this._values, p, { iterables: !0 });
                d ? g.set(m, d) : g && g.delete(m);
              }
            });
        },
        3328: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(5277),
            f = a(1447),
            c = a(8160),
            d = a(6354),
            p = a(6133),
            m = {
              symbol: Symbol("template"),
              opens: new Array(1e3).join("\0"),
              closes: new Array(1e3).join(""),
              dateFormat: {
                date: Date.prototype.toDateString,
                iso: Date.prototype.toISOString,
                string: Date.prototype.toString,
                time: Date.prototype.toTimeString,
                utc: Date.prototype.toUTCString,
              },
            };
          (i.exports = m.Template =
            class {
              constructor(g, w) {
                o(typeof g == "string", "Template source must be a string"),
                  o(
                    !g.includes("\0") && !g.includes(""),
                    "Template source cannot contain reserved control characters"
                  ),
                  (this.source = g),
                  (this.rendered = g),
                  (this._template = null),
                  (this._settings = l(w)),
                  this._parse();
              }
              _parse() {
                if (!this.source.includes("{")) return;
                const g = m.encode(this.source),
                  w = m.split(g);
                let y = !1;
                const v = [],
                  E = w.shift();
                E && v.push(E);
                for (const S of w) {
                  const D = S[0] !== "{",
                    P = D ? "}" : "}}",
                    x = S.indexOf(P);
                  if (x === -1 || S[1] === "{") {
                    v.push(`{${m.decode(S)}`);
                    continue;
                  }
                  let _ = S.slice(D ? 0 : 1, x);
                  const A = _[0] === ":";
                  A && (_ = _.slice(1));
                  const N = this._ref(m.decode(_), { raw: D, wrapped: A });
                  v.push(N), typeof N != "string" && (y = !0);
                  const M = S.slice(x + P.length);
                  M && v.push(m.decode(M));
                }
                y ? (this._template = v) : (this.rendered = v.join(""));
              }
              static date(g, w) {
                return m.dateFormat[w.dateFormat].call(g);
              }
              describe() {
                let g =
                  arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {};
                if (!this._settings && g.compact) return this.source;
                const w = { template: this.source };
                return this._settings && (w.options = this._settings), w;
              }
              static build(g) {
                return new m.Template(g.template, g.options);
              }
              isDynamic() {
                return !!this._template;
              }
              static isTemplate(g) {
                return !!g && !!g[c.symbols.template];
              }
              refs() {
                if (!this._template) return;
                const g = [];
                for (const w of this._template)
                  typeof w != "string" && g.push(...w.refs);
                return g;
              }
              resolve(g, w, y, v) {
                return this._template && this._template.length === 1
                  ? this._part(this._template[0], g, w, y, v, {})
                  : this.render(g, w, y, v);
              }
              _part(g) {
                for (
                  var w = arguments.length,
                    y = new Array(w > 1 ? w - 1 : 0),
                    v = 1;
                  v < w;
                  v++
                )
                  y[v - 1] = arguments[v];
                return g.ref ? g.ref.resolve(...y) : g.formula.evaluate(y);
              }
              render(g, w, y, v) {
                let E =
                  arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : {};
                if (!this.isDynamic()) return this.rendered;
                const S = [];
                for (const D of this._template)
                  if (typeof D == "string") S.push(D);
                  else {
                    const P = this._part(D, g, w, y, v, E),
                      x = m.stringify(P, g, w, y, v, E);
                    if (x !== void 0) {
                      const _ =
                        D.raw || (E.errors && E.errors.escapeHtml) === !1
                          ? x
                          : u(x);
                      S.push(m.wrap(_, D.wrapped && y.errors.wrap.label));
                    }
                  }
                return S.join("");
              }
              _ref(g, w) {
                let { raw: y, wrapped: v } = w;
                const E = [],
                  S = (P) => {
                    const x = p.create(P, this._settings);
                    return E.push(x), (_) => x.resolve(..._);
                  };
                try {
                  var D = new f.Parser(g, {
                    reference: S,
                    functions: m.functions,
                    constants: m.constants,
                  });
                } catch (P) {
                  throw (
                    ((P.message = `Invalid template variable "${g}" fails due to: ${P.message}`),
                    P)
                  );
                }
                if (D.single) {
                  if (D.single.type === "reference") {
                    const P = E[0];
                    return {
                      ref: P,
                      raw: y,
                      refs: E,
                      wrapped: v || (P.type === "local" && P.key === "label"),
                    };
                  }
                  return m.stringify(D.single.value);
                }
                return { formula: D, raw: y, refs: E };
              }
              toString() {
                return this.source;
              }
            }),
            (m.Template.prototype[c.symbols.template] = !0),
            (m.Template.prototype.isImmutable = !0),
            (m.encode = function (g) {
              return g
                .replace(/\\(\{+)/g, (w, y) => m.opens.slice(0, y.length))
                .replace(/\\(\}+)/g, (w, y) => m.closes.slice(0, y.length));
            }),
            (m.decode = function (g) {
              return g.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
            }),
            (m.split = function (g) {
              const w = [];
              let y = "";
              for (let v = 0; v < g.length; ++v) {
                const E = g[v];
                if (E === "{") {
                  let S = "";
                  for (; v + 1 < g.length && g[v + 1] === "{"; )
                    (S += "{"), ++v;
                  w.push(y), (y = S);
                } else y += E;
              }
              return w.push(y), w;
            }),
            (m.wrap = function (g, w) {
              return w
                ? w.length === 1
                  ? `${w}${g}${w}`
                  : `${w[0]}${g}${w[1]}`
                : g;
            }),
            (m.stringify = function (g, w, y, v, E) {
              let S =
                arguments.length > 5 && arguments[5] !== void 0
                  ? arguments[5]
                  : {};
              const D = typeof g,
                P = (v && v.errors && v.errors.wrap) || {};
              let x = !1;
              if (
                (p.isRef(g) &&
                  g.render &&
                  ((x = g.in), (g = g.resolve(w, y, v, E, { in: g.in, ...S }))),
                g === null)
              )
                return "null";
              if (D === "string") return m.wrap(g, S.arrayItems && P.string);
              if (D === "number" || D === "function" || D === "symbol")
                return g.toString();
              if (D !== "object") return JSON.stringify(g);
              if (g instanceof Date) return m.Template.date(g, v);
              if (g instanceof Map) {
                const A = [];
                for (const [N, M] of g.entries())
                  A.push(`${N.toString()} -> ${M.toString()}`);
                g = A;
              }
              if (!Array.isArray(g)) return g.toString();
              const _ = [];
              for (const A of g)
                _.push(m.stringify(A, w, y, v, E, { arrayItems: !0, ...S }));
              return m.wrap(_.join(", "), !x && P.array);
            }),
            (m.constants = {
              true: !0,
              false: !1,
              null: null,
              second: 1e3,
              minute: 6e4,
              hour: 36e5,
              day: 864e5,
            }),
            (m.functions = {
              if: (g, w, y) => (g ? w : y),
              length: (g) =>
                typeof g == "string"
                  ? g.length
                  : g && typeof g == "object"
                  ? Array.isArray(g)
                    ? g.length
                    : Object.keys(g).length
                  : null,
              msg(g) {
                const [w, y, v, E, S] = this,
                  D = S.messages;
                if (!D) return "";
                const P =
                  d.template(w, D[0], g, y, v) || d.template(w, D[1], g, y, v);
                return P ? P.render(w, y, v, E, S) : "";
              },
              number: (g) =>
                typeof g == "number"
                  ? g
                  : typeof g == "string"
                  ? parseFloat(g)
                  : typeof g == "boolean"
                  ? g
                    ? 1
                    : 0
                  : g instanceof Date
                  ? g.getTime()
                  : null,
            });
        },
        4946: (i, s, a) => {
          const o = a(375),
            l = a(1687),
            u = a(8068),
            f = a(8160),
            c = a(3292),
            d = a(6354),
            p = a(6133),
            m = {};
          (i.exports = u.extend({
            type: "alternatives",
            flags: { match: { default: "any" } },
            terms: { matches: { init: [], register: p.toSibling } },
            args(g) {
              for (
                var w = arguments.length,
                  y = new Array(w > 1 ? w - 1 : 0),
                  v = 1;
                v < w;
                v++
              )
                y[v - 1] = arguments[v];
              return y.length === 1 && Array.isArray(y[0])
                ? g.try(...y[0])
                : g.try(...y);
            },
            validate(g, w) {
              const { schema: y, error: v, state: E, prefs: S } = w;
              if (y._flags.match) {
                const P = [],
                  x = [];
                for (let A = 0; A < y.$_terms.matches.length; ++A) {
                  const N = y.$_terms.matches[A],
                    M = E.nest(N.schema, `match.${A}`);
                  M.snapshot();
                  const T = N.schema.$_validate(g, M, S);
                  T.errors ? (x.push(T.errors), M.restore()) : P.push(T.value);
                }
                if (P.length === 0)
                  return {
                    errors: v("alternatives.any", {
                      details: x.map((A) => d.details(A, { override: !1 })),
                    }),
                  };
                if (y._flags.match === "one")
                  return P.length === 1
                    ? { value: P[0] }
                    : { errors: v("alternatives.one") };
                if (P.length !== y.$_terms.matches.length)
                  return {
                    errors: v("alternatives.all", {
                      details: x.map((A) => d.details(A, { override: !1 })),
                    }),
                  };
                const _ = (A) =>
                  A.$_terms.matches.some(
                    (N) =>
                      N.schema.type === "object" ||
                      (N.schema.type === "alternatives" && _(N.schema))
                  );
                return _(y)
                  ? { value: P.reduce((A, N) => l(A, N, { mergeArrays: !1 })) }
                  : { value: P[P.length - 1] };
              }
              const D = [];
              for (let P = 0; P < y.$_terms.matches.length; ++P) {
                const x = y.$_terms.matches[P];
                if (x.schema) {
                  const N = E.nest(x.schema, `match.${P}`);
                  N.snapshot();
                  const M = x.schema.$_validate(g, N, S);
                  if (!M.errors) return M;
                  N.restore(), D.push({ schema: x.schema, reports: M.errors });
                  continue;
                }
                const _ = x.ref ? x.ref.resolve(g, E, S) : g,
                  A = x.is ? [x] : x.switch;
                for (let N = 0; N < A.length; ++N) {
                  const M = A[N],
                    { is: T, then: O, otherwise: I } = M,
                    k = `match.${P}${x.switch ? "." + N : ""}`;
                  if (T.$_match(_, E.nest(T, `${k}.is`), S)) {
                    if (O) return O.$_validate(g, E.nest(O, `${k}.then`), S);
                  } else if (I)
                    return I.$_validate(g, E.nest(I, `${k}.otherwise`), S);
                }
              }
              return m.errors(D, w);
            },
            rules: {
              conditional: {
                method(g, w) {
                  o(!this._flags._endedSwitch, "Unreachable condition"),
                    o(
                      !this._flags.match,
                      "Cannot combine match mode",
                      this._flags.match,
                      "with conditional rule"
                    ),
                    o(
                      w.break === void 0,
                      "Cannot use break option with alternatives conditional"
                    );
                  const y = this.clone(),
                    v = c.when(y, g, w),
                    E = v.is ? [v] : v.switch;
                  for (const S of E)
                    if (S.then && S.otherwise) {
                      y.$_setFlag("_endedSwitch", !0, { clone: !1 });
                      break;
                    }
                  return y.$_terms.matches.push(v), y.$_mutateRebuild();
                },
              },
              match: {
                method(g) {
                  if (
                    (o(
                      ["any", "one", "all"].includes(g),
                      "Invalid alternatives match mode",
                      g
                    ),
                    g !== "any")
                  )
                    for (const w of this.$_terms.matches)
                      o(
                        w.schema,
                        "Cannot combine match mode",
                        g,
                        "with conditional rules"
                      );
                  return this.$_setFlag("match", g);
                },
              },
              try: {
                method() {
                  for (
                    var g = arguments.length, w = new Array(g), y = 0;
                    y < g;
                    y++
                  )
                    w[y] = arguments[y];
                  o(w.length, "Missing alternative schemas"),
                    f.verifyFlat(w, "try"),
                    o(!this._flags._endedSwitch, "Unreachable condition");
                  const v = this.clone();
                  for (const E of w)
                    v.$_terms.matches.push({ schema: v.$_compile(E) });
                  return v.$_mutateRebuild();
                },
              },
            },
            overrides: {
              label(g) {
                return this.$_parent("label", g).$_modify({
                  each: (w, y) => (y.path[0] !== "is" ? w.label(g) : void 0),
                  ref: !1,
                });
              },
            },
            rebuild(g) {
              g.$_modify({
                each: (w) => {
                  f.isSchema(w) &&
                    w.type === "array" &&
                    g.$_setFlag("_arrayItems", !0, { clone: !1 });
                },
              });
            },
            manifest: {
              build(g, w) {
                if (w.matches)
                  for (const y of w.matches) {
                    const {
                      schema: v,
                      ref: E,
                      is: S,
                      not: D,
                      then: P,
                      otherwise: x,
                    } = y;
                    g = v
                      ? g.try(v)
                      : E
                      ? g.conditional(E, {
                          is: S,
                          then: P,
                          not: D,
                          otherwise: x,
                          switch: y.switch,
                        })
                      : g.conditional(S, { then: P, otherwise: x });
                  }
                return g;
              },
            },
            messages: {
              "alternatives.all":
                "{{#label}} does not match all of the required types",
              "alternatives.any":
                "{{#label}} does not match any of the allowed types",
              "alternatives.match":
                "{{#label}} does not match any of the allowed types",
              "alternatives.one":
                "{{#label}} matches more than one allowed type",
              "alternatives.types": "{{#label}} must be one of {{#types}}",
            },
          })),
            (m.errors = function (g, w) {
              let { error: y, state: v } = w;
              if (!g.length) return { errors: y("alternatives.any") };
              if (g.length === 1) return { errors: g[0].reports };
              const E = new Set(),
                S = [];
              for (const { reports: D, schema: P } of g) {
                if (D.length > 1) return m.unmatched(g, y);
                const x = D[0];
                if (x instanceof d.Report == 0) return m.unmatched(g, y);
                if (x.state.path.length !== v.path.length) {
                  S.push({ type: P.type, report: x });
                  continue;
                }
                if (x.code === "any.only") {
                  for (const N of x.local.valids) E.add(N);
                  continue;
                }
                const [_, A] = x.code.split(".");
                A === "base" ? E.add(_) : S.push({ type: P.type, report: x });
              }
              return S.length
                ? S.length === 1
                  ? { errors: S[0].report }
                  : m.unmatched(g, y)
                : { errors: y("alternatives.types", { types: [...E] }) };
            }),
            (m.unmatched = function (g, w) {
              const y = [];
              for (const v of g) y.push(...v.reports);
              return {
                errors: w("alternatives.match", d.details(y, { override: !1 })),
              };
            });
        },
        8068: (i, s, a) => {
          const o = a(375),
            l = a(7629),
            u = a(8160),
            f = a(6914);
          i.exports = l.extend({
            type: "any",
            flags: { only: { default: !1 } },
            terms: {
              alterations: { init: null },
              examples: { init: null },
              externals: { init: null },
              metas: { init: [] },
              notes: { init: [] },
              shared: { init: null },
              tags: { init: [] },
              whens: { init: null },
            },
            rules: {
              custom: {
                method(c, d) {
                  return (
                    o(typeof c == "function", "Method must be a function"),
                    o(
                      d === void 0 || (d && typeof d == "string"),
                      "Description must be a non-empty string"
                    ),
                    this.$_addRule({
                      name: "custom",
                      args: { method: c, description: d },
                    })
                  );
                },
                validate(c, d, p) {
                  let { method: m } = p;
                  try {
                    return m(c, d);
                  } catch (g) {
                    return d.error("any.custom", { error: g });
                  }
                },
                args: ["method", "description"],
                multi: !0,
              },
              messages: {
                method(c) {
                  return this.prefs({ messages: c });
                },
              },
              shared: {
                method(c) {
                  o(
                    u.isSchema(c) && c._flags.id,
                    "Schema must be a schema with an id"
                  );
                  const d = this.clone();
                  return (
                    (d.$_terms.shared = d.$_terms.shared || []),
                    d.$_terms.shared.push(c),
                    d.$_mutateRegister(c),
                    d
                  );
                },
              },
              warning: {
                method(c, d) {
                  return (
                    o(c && typeof c == "string", "Invalid warning code"),
                    this.$_addRule({
                      name: "warning",
                      args: { code: c, local: d },
                      warn: !0,
                    })
                  );
                },
                validate(c, d, p) {
                  let { code: m, local: g } = p;
                  return d.error(m, g);
                },
                args: ["code", "local"],
                multi: !0,
              },
            },
            modifiers: {
              keep(c) {
                let d =
                  !(arguments.length > 1 && arguments[1] !== void 0) ||
                  arguments[1];
                c.keep = d;
              },
              message(c, d) {
                c.message = f.compile(d);
              },
              warn(c) {
                let d =
                  !(arguments.length > 1 && arguments[1] !== void 0) ||
                  arguments[1];
                c.warn = d;
              },
            },
            manifest: {
              build(c, d) {
                for (const p in d) {
                  const m = d[p];
                  if (
                    [
                      "examples",
                      "externals",
                      "metas",
                      "notes",
                      "tags",
                    ].includes(p)
                  )
                    for (const g of m) c = c[p.slice(0, -1)](g);
                  else if (p !== "alterations")
                    if (p !== "whens") {
                      if (p === "shared") for (const g of m) c = c.shared(g);
                    } else
                      for (const g of m) {
                        const {
                          ref: w,
                          is: y,
                          not: v,
                          then: E,
                          otherwise: S,
                          concat: D,
                        } = g;
                        c = D
                          ? c.concat(D)
                          : w
                          ? c.when(w, {
                              is: y,
                              not: v,
                              then: E,
                              otherwise: S,
                              switch: g.switch,
                              break: g.break,
                            })
                          : c.when(y, {
                              then: E,
                              otherwise: S,
                              break: g.break,
                            });
                      }
                  else {
                    const g = {};
                    for (const { target: w, adjuster: y } of m) g[w] = y;
                    c = c.alter(g);
                  }
                }
                return c;
              },
            },
            messages: {
              "any.custom":
                "{{#label}} failed custom validation because {{#error.message}}",
              "any.default":
                "{{#label}} threw an error when running default method",
              "any.failover":
                "{{#label}} threw an error when running failover method",
              "any.invalid": "{{#label}} contains an invalid value",
              "any.only":
                '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
              "any.ref":
                "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
              "any.required": "{{#label}} is required",
              "any.unknown": "{{#label}} is not allowed",
            },
          });
        },
        546: (i, s, a) => {
          const o = a(375),
            l = a(9474),
            u = a(9621),
            f = a(8068),
            c = a(8160),
            d = a(3292),
            p = {};
          (i.exports = f.extend({
            type: "array",
            flags: { single: { default: !1 }, sparse: { default: !1 } },
            terms: {
              items: { init: [], manifest: "schema" },
              ordered: { init: [], manifest: "schema" },
              _exclusions: { init: [] },
              _inclusions: { init: [] },
              _requireds: { init: [] },
            },
            coerce: {
              from: "object",
              method(m, g) {
                let { schema: w, state: y, prefs: v } = g;
                if (!Array.isArray(m)) return;
                const E = w.$_getRule("sort");
                return E ? p.sort(w, m, E.args.options, y, v) : void 0;
              },
            },
            validate(m, g) {
              let { schema: w, error: y } = g;
              if (!Array.isArray(m)) {
                if (w._flags.single) {
                  const v = [m];
                  return (v[c.symbols.arraySingle] = !0), { value: v };
                }
                return { errors: y("array.base") };
              }
              if (w.$_getRule("items") || w.$_terms.externals)
                return { value: m.slice() };
            },
            rules: {
              has: {
                method(m) {
                  m = this.$_compile(m, { appendPath: !0 });
                  const g = this.$_addRule({
                    name: "has",
                    args: { schema: m },
                  });
                  return g.$_mutateRegister(m), g;
                },
                validate(m, g, w) {
                  let { state: y, prefs: v, error: E } = g,
                    { schema: S } = w;
                  const D = [m, ...y.ancestors];
                  for (let x = 0; x < m.length; ++x) {
                    const _ = y.localize([...y.path, x], D, S);
                    if (S.$_match(m[x], _, v)) return m;
                  }
                  const P = S._flags.label;
                  return P
                    ? E("array.hasKnown", { patternLabel: P })
                    : E("array.hasUnknown", null);
                },
                multi: !0,
              },
              items: {
                method() {
                  for (
                    var m = arguments.length, g = new Array(m), w = 0;
                    w < m;
                    w++
                  )
                    g[w] = arguments[w];
                  c.verifyFlat(g, "items");
                  const y = this.$_addRule("items");
                  for (let v = 0; v < g.length; ++v) {
                    const E = c.tryWithPath(() => this.$_compile(g[v]), v, {
                      append: !0,
                    });
                    y.$_terms.items.push(E);
                  }
                  return y.$_mutateRebuild();
                },
                validate(m, g) {
                  let {
                    schema: w,
                    error: y,
                    state: v,
                    prefs: E,
                    errorsArray: S,
                  } = g;
                  const D = w.$_terms._requireds.slice(),
                    P = w.$_terms.ordered.slice(),
                    x = [...w.$_terms._inclusions, ...D],
                    _ = !m[c.symbols.arraySingle];
                  delete m[c.symbols.arraySingle];
                  const A = S();
                  let N = m.length;
                  for (let M = 0; M < N; ++M) {
                    const T = m[M];
                    let O = !1,
                      I = !1;
                    const k = _ ? M : new Number(M),
                      L = [...v.path, k];
                    if (!w._flags.sparse && T === void 0) {
                      if (
                        (A.push(
                          y(
                            "array.sparse",
                            { key: k, path: L, pos: M, value: void 0 },
                            v.localize(L)
                          )
                        ),
                        E.abortEarly)
                      )
                        return A;
                      P.shift();
                      continue;
                    }
                    const U = [m, ...v.ancestors];
                    for (const V of w.$_terms._exclusions)
                      if (
                        V.$_match(T, v.localize(L, U, V), E, {
                          presence: "ignore",
                        })
                      ) {
                        if (
                          (A.push(
                            y(
                              "array.excludes",
                              { pos: M, value: T },
                              v.localize(L)
                            )
                          ),
                          E.abortEarly)
                        )
                          return A;
                        (O = !0), P.shift();
                        break;
                      }
                    if (O) continue;
                    if (w.$_terms.ordered.length) {
                      if (P.length) {
                        const V = P.shift(),
                          oe = V.$_validate(T, v.localize(L, U, V), E);
                        if (oe.errors) {
                          if ((A.push(...oe.errors), E.abortEarly)) return A;
                        } else if (V._flags.result === "strip")
                          p.fastSplice(m, M), --M, --N;
                        else {
                          if (!w._flags.sparse && oe.value === void 0) {
                            if (
                              (A.push(
                                y(
                                  "array.sparse",
                                  { key: k, path: L, pos: M, value: void 0 },
                                  v.localize(L)
                                )
                              ),
                              E.abortEarly)
                            )
                              return A;
                            continue;
                          }
                          m[M] = oe.value;
                        }
                        continue;
                      }
                      if (!w.$_terms.items.length) {
                        if (
                          (A.push(
                            y("array.orderedLength", {
                              pos: M,
                              limit: w.$_terms.ordered.length,
                            })
                          ),
                          E.abortEarly)
                        )
                          return A;
                        break;
                      }
                    }
                    const $ = [];
                    let B = D.length;
                    for (let V = 0; V < B; ++V) {
                      const oe = v.localize(L, U, D[V]);
                      oe.snapshot();
                      const le = D[V].$_validate(T, oe, E);
                      if ((($[V] = le), !le.errors)) {
                        if (
                          ((m[M] = le.value),
                          (I = !0),
                          p.fastSplice(D, V),
                          --V,
                          --B,
                          !w._flags.sparse &&
                            le.value === void 0 &&
                            (A.push(
                              y(
                                "array.sparse",
                                { key: k, path: L, pos: M, value: void 0 },
                                v.localize(L)
                              )
                            ),
                            E.abortEarly))
                        )
                          return A;
                        break;
                      }
                      oe.restore();
                    }
                    if (I) continue;
                    const R = (E.stripUnknown && !!E.stripUnknown.arrays) || !1;
                    B = x.length;
                    for (const V of x) {
                      let oe;
                      const le = D.indexOf(V);
                      if (le !== -1) oe = $[le];
                      else {
                        const fe = v.localize(L, U, V);
                        if (
                          (fe.snapshot(),
                          (oe = V.$_validate(T, fe, E)),
                          !oe.errors)
                        ) {
                          V._flags.result === "strip"
                            ? (p.fastSplice(m, M), --M, --N)
                            : w._flags.sparse || oe.value !== void 0
                            ? (m[M] = oe.value)
                            : (A.push(
                                y(
                                  "array.sparse",
                                  { key: k, path: L, pos: M, value: void 0 },
                                  v.localize(L)
                                )
                              ),
                              (O = !0)),
                            (I = !0);
                          break;
                        }
                        fe.restore();
                      }
                      if (B === 1) {
                        if (R) {
                          p.fastSplice(m, M), --M, --N, (I = !0);
                          break;
                        }
                        if ((A.push(...oe.errors), E.abortEarly)) return A;
                        O = !0;
                        break;
                      }
                    }
                    if (
                      !O &&
                      (w.$_terms._inclusions.length ||
                        w.$_terms._requireds.length) &&
                      !I
                    ) {
                      if (R) {
                        p.fastSplice(m, M), --M, --N;
                        continue;
                      }
                      if (
                        (A.push(
                          y(
                            "array.includes",
                            { pos: M, value: T },
                            v.localize(L)
                          )
                        ),
                        E.abortEarly)
                      )
                        return A;
                    }
                  }
                  return (
                    D.length && p.fillMissedErrors(w, A, D, m, v, E),
                    P.length &&
                      (p.fillOrderedErrors(w, A, P, m, v, E),
                      A.length || p.fillDefault(P, m, v, E)),
                    A.length ? A : m
                  );
                },
                priority: !0,
                manifest: !1,
              },
              length: {
                method(m) {
                  return this.$_addRule({
                    name: "length",
                    args: { limit: m },
                    operator: "=",
                  });
                },
                validate(m, g, w, y) {
                  let { limit: v } = w,
                    { name: E, operator: S, args: D } = y;
                  return c.compare(m.length, v, S)
                    ? m
                    : g.error("array." + E, { limit: D.limit, value: m });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: c.limit,
                    message: "must be a positive integer",
                  },
                ],
              },
              max: {
                method(m) {
                  return this.$_addRule({
                    name: "max",
                    method: "length",
                    args: { limit: m },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(m) {
                  return this.$_addRule({
                    name: "min",
                    method: "length",
                    args: { limit: m },
                    operator: ">=",
                  });
                },
              },
              ordered: {
                method() {
                  for (
                    var m = arguments.length, g = new Array(m), w = 0;
                    w < m;
                    w++
                  )
                    g[w] = arguments[w];
                  c.verifyFlat(g, "ordered");
                  const y = this.$_addRule("items");
                  for (let v = 0; v < g.length; ++v) {
                    const E = c.tryWithPath(() => this.$_compile(g[v]), v, {
                      append: !0,
                    });
                    p.validateSingle(E, y),
                      y.$_mutateRegister(E),
                      y.$_terms.ordered.push(E);
                  }
                  return y.$_mutateRebuild();
                },
              },
              single: {
                method(m) {
                  const g = m === void 0 || !!m;
                  return (
                    o(
                      !g || !this._flags._arrayItems,
                      "Cannot specify single rule when array has array items"
                    ),
                    this.$_setFlag("single", g)
                  );
                },
              },
              sort: {
                method() {
                  let m =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  c.assertOptions(m, ["by", "order"]);
                  const g = { order: m.order || "ascending" };
                  return (
                    m.by &&
                      ((g.by = d.ref(m.by, { ancestor: 0 })),
                      o(!g.by.ancestor, "Cannot sort by ancestor")),
                    this.$_addRule({ name: "sort", args: { options: g } })
                  );
                },
                validate(m, g, w) {
                  let { error: y, state: v, prefs: E, schema: S } = g,
                    { options: D } = w;
                  const { value: P, errors: x } = p.sort(S, m, D, v, E);
                  if (x) return x;
                  for (let _ = 0; _ < m.length; ++_)
                    if (m[_] !== P[_])
                      return y("array.sort", {
                        order: D.order,
                        by: D.by ? D.by.key : "value",
                      });
                  return m;
                },
                convert: !0,
              },
              sparse: {
                method(m) {
                  const g = m === void 0 || !!m;
                  return this._flags.sparse === g
                    ? this
                    : (g ? this.clone() : this.$_addRule("items")).$_setFlag(
                        "sparse",
                        g,
                        { clone: !1 }
                      );
                },
              },
              unique: {
                method(m) {
                  let g =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  o(
                    !m || typeof m == "function" || typeof m == "string",
                    "comparator must be a function or a string"
                  ),
                    c.assertOptions(g, ["ignoreUndefined", "separator"]);
                  const w = {
                    name: "unique",
                    args: { options: g, comparator: m },
                  };
                  if (m)
                    if (typeof m == "string") {
                      const y = c.default(g.separator, ".");
                      w.path = y ? m.split(y) : [m];
                    } else w.comparator = m;
                  return this.$_addRule(w);
                },
                validate(m, g, w, y) {
                  let { state: v, error: E, schema: S } = g,
                    { comparator: D, options: P } = w,
                    { comparator: x, path: _ } = y;
                  const A = {
                      string: Object.create(null),
                      number: Object.create(null),
                      undefined: Object.create(null),
                      boolean: Object.create(null),
                      object: new Map(),
                      function: new Map(),
                      custom: new Map(),
                    },
                    N = x || l,
                    M = P.ignoreUndefined;
                  for (let T = 0; T < m.length; ++T) {
                    const O = _ ? u(m[T], _) : m[T],
                      I = x ? A.custom : A[typeof O];
                    if (
                      (o(
                        I,
                        "Failed to find unique map container for type",
                        typeof O
                      ),
                      I instanceof Map)
                    ) {
                      const k = I.entries();
                      let L;
                      for (; !(L = k.next()).done; )
                        if (N(L.value[0], O)) {
                          const U = v.localize(
                              [...v.path, T],
                              [m, ...v.ancestors]
                            ),
                            $ = {
                              pos: T,
                              value: m[T],
                              dupePos: L.value[1],
                              dupeValue: m[L.value[1]],
                            };
                          return _ && ($.path = D), E("array.unique", $, U);
                        }
                      I.set(O, T);
                    } else {
                      if ((!M || O !== void 0) && I[O] !== void 0) {
                        const k = {
                          pos: T,
                          value: m[T],
                          dupePos: I[O],
                          dupeValue: m[I[O]],
                        };
                        return (
                          _ && (k.path = D),
                          E(
                            "array.unique",
                            k,
                            v.localize([...v.path, T], [m, ...v.ancestors])
                          )
                        );
                      }
                      I[O] = T;
                    }
                  }
                  return m;
                },
                args: ["comparator", "options"],
                multi: !0,
              },
            },
            cast: { set: { from: Array.isArray, to: (m, g) => new Set(m) } },
            rebuild(m) {
              (m.$_terms._inclusions = []),
                (m.$_terms._exclusions = []),
                (m.$_terms._requireds = []);
              for (const g of m.$_terms.items)
                p.validateSingle(g, m),
                  g._flags.presence === "required"
                    ? m.$_terms._requireds.push(g)
                    : g._flags.presence === "forbidden"
                    ? m.$_terms._exclusions.push(g)
                    : m.$_terms._inclusions.push(g);
              for (const g of m.$_terms.ordered) p.validateSingle(g, m);
            },
            manifest: {
              build: (m, g) => (
                g.items && (m = m.items(...g.items)),
                g.ordered && (m = m.ordered(...g.ordered)),
                m
              ),
            },
            messages: {
              "array.base": "{{#label}} must be an array",
              "array.excludes": "{{#label}} contains an excluded value",
              "array.hasKnown":
                "{{#label}} does not contain at least one required match for type {:#patternLabel}",
              "array.hasUnknown":
                "{{#label}} does not contain at least one required match",
              "array.includes":
                "{{#label}} does not match any of the allowed types",
              "array.includesRequiredBoth":
                "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
              "array.includesRequiredKnowns":
                "{{#label}} does not contain {{#knownMisses}}",
              "array.includesRequiredUnknowns":
                "{{#label}} does not contain {{#unknownMisses}} required value(s)",
              "array.length": "{{#label}} must contain {{#limit}} items",
              "array.max":
                "{{#label}} must contain less than or equal to {{#limit}} items",
              "array.min": "{{#label}} must contain at least {{#limit}} items",
              "array.orderedLength":
                "{{#label}} must contain at most {{#limit}} items",
              "array.sort":
                "{{#label}} must be sorted in {#order} order by {{#by}}",
              "array.sort.mismatching":
                "{{#label}} cannot be sorted due to mismatching types",
              "array.sort.unsupported":
                "{{#label}} cannot be sorted due to unsupported type {#type}",
              "array.sparse": "{{#label}} must not be a sparse array item",
              "array.unique": "{{#label}} contains a duplicate value",
            },
          })),
            (p.fillMissedErrors = function (m, g, w, y, v, E) {
              const S = [];
              let D = 0;
              for (const P of w) {
                const x = P._flags.label;
                x ? S.push(x) : ++D;
              }
              S.length
                ? D
                  ? g.push(
                      m.$_createError(
                        "array.includesRequiredBoth",
                        y,
                        { knownMisses: S, unknownMisses: D },
                        v,
                        E
                      )
                    )
                  : g.push(
                      m.$_createError(
                        "array.includesRequiredKnowns",
                        y,
                        { knownMisses: S },
                        v,
                        E
                      )
                    )
                : g.push(
                    m.$_createError(
                      "array.includesRequiredUnknowns",
                      y,
                      { unknownMisses: D },
                      v,
                      E
                    )
                  );
            }),
            (p.fillOrderedErrors = function (m, g, w, y, v, E) {
              const S = [];
              for (const D of w) D._flags.presence === "required" && S.push(D);
              S.length && p.fillMissedErrors(m, g, S, y, v, E);
            }),
            (p.fillDefault = function (m, g, w, y) {
              const v = [];
              let E = !0;
              for (let S = m.length - 1; S >= 0; --S) {
                const D = m[S],
                  P = [g, ...w.ancestors],
                  x = D.$_validate(void 0, w.localize(w.path, P, D), y).value;
                if (E) {
                  if (x === void 0) continue;
                  E = !1;
                }
                v.unshift(x);
              }
              v.length && g.push(...v);
            }),
            (p.fastSplice = function (m, g) {
              let w = g;
              for (; w < m.length; ) m[w++] = m[w];
              --m.length;
            }),
            (p.validateSingle = function (m, g) {
              (m.type === "array" || m._flags._arrayItems) &&
                (o(
                  !g._flags.single,
                  "Cannot specify array item with single rule enabled"
                ),
                g.$_setFlag("_arrayItems", !0, { clone: !1 }));
            }),
            (p.sort = function (m, g, w, y, v) {
              const E = w.order === "ascending" ? 1 : -1,
                S = -1 * E,
                D = E,
                P = (x, _) => {
                  let A = p.compare(x, _, S, D);
                  if (
                    A !== null ||
                    (w.by &&
                      ((x = w.by.resolve(x, y, v)),
                      (_ = w.by.resolve(_, y, v))),
                    (A = p.compare(x, _, S, D)),
                    A !== null)
                  )
                    return A;
                  const N = typeof x;
                  if (N !== typeof _)
                    throw m.$_createError(
                      "array.sort.mismatching",
                      g,
                      null,
                      y,
                      v
                    );
                  if (N !== "number" && N !== "string")
                    throw m.$_createError(
                      "array.sort.unsupported",
                      g,
                      { type: N },
                      y,
                      v
                    );
                  return N === "number" ? (x - _) * E : x < _ ? S : D;
                };
              try {
                return { value: g.slice().sort(P) };
              } catch (x) {
                return { errors: x };
              }
            }),
            (p.compare = function (m, g, w, y) {
              return m === g
                ? 0
                : m === void 0
                ? 1
                : g === void 0
                ? -1
                : m === null
                ? y
                : g === null
                ? w
                : null;
            });
        },
        4937: (i, s, a) => {
          const o = a(375),
            l = a(8068),
            u = a(8160),
            f = a(2036),
            c = {
              isBool: function (d) {
                return typeof d == "boolean";
              },
            };
          i.exports = l.extend({
            type: "boolean",
            flags: { sensitive: { default: !1 } },
            terms: {
              falsy: { init: null, manifest: "values" },
              truthy: { init: null, manifest: "values" },
            },
            coerce(d, p) {
              let { schema: m } = p;
              if (typeof d != "boolean") {
                if (typeof d == "string") {
                  const g = m._flags.sensitive ? d : d.toLowerCase();
                  d = g === "true" || (g !== "false" && d);
                }
                return (
                  typeof d != "boolean" &&
                    (d =
                      (m.$_terms.truthy &&
                        m.$_terms.truthy.has(
                          d,
                          null,
                          null,
                          !m._flags.sensitive
                        )) ||
                      ((!m.$_terms.falsy ||
                        !m.$_terms.falsy.has(
                          d,
                          null,
                          null,
                          !m._flags.sensitive
                        )) &&
                        d)),
                  { value: d }
                );
              }
            },
            validate(d, p) {
              let { error: m } = p;
              if (typeof d != "boolean")
                return { value: d, errors: m("boolean.base") };
            },
            rules: {
              truthy: {
                method() {
                  for (
                    var d = arguments.length, p = new Array(d), m = 0;
                    m < d;
                    m++
                  )
                    p[m] = arguments[m];
                  u.verifyFlat(p, "truthy");
                  const g = this.clone();
                  g.$_terms.truthy = g.$_terms.truthy || new f();
                  for (let w = 0; w < p.length; ++w) {
                    const y = p[w];
                    o(y !== void 0, "Cannot call truthy with undefined"),
                      g.$_terms.truthy.add(y);
                  }
                  return g;
                },
              },
              falsy: {
                method() {
                  for (
                    var d = arguments.length, p = new Array(d), m = 0;
                    m < d;
                    m++
                  )
                    p[m] = arguments[m];
                  u.verifyFlat(p, "falsy");
                  const g = this.clone();
                  g.$_terms.falsy = g.$_terms.falsy || new f();
                  for (let w = 0; w < p.length; ++w) {
                    const y = p[w];
                    o(y !== void 0, "Cannot call falsy with undefined"),
                      g.$_terms.falsy.add(y);
                  }
                  return g;
                },
              },
              sensitive: {
                method() {
                  let d =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("sensitive", d);
                },
              },
            },
            cast: {
              number: { from: c.isBool, to: (d, p) => (d ? 1 : 0) },
              string: { from: c.isBool, to: (d, p) => (d ? "true" : "false") },
            },
            manifest: {
              build: (d, p) => (
                p.truthy && (d = d.truthy(...p.truthy)),
                p.falsy && (d = d.falsy(...p.falsy)),
                d
              ),
            },
            messages: { "boolean.base": "{{#label}} must be a boolean" },
          });
        },
        7500: (i, s, a) => {
          const o = a(375),
            l = a(8068),
            u = a(8160),
            f = a(3328),
            c = {
              isDate: function (d) {
                return d instanceof Date;
              },
            };
          (i.exports = l.extend({
            type: "date",
            coerce: {
              from: ["number", "string"],
              method(d, p) {
                let { schema: m } = p;
                return { value: c.parse(d, m._flags.format) || d };
              },
            },
            validate(d, p) {
              let { schema: m, error: g, prefs: w } = p;
              if (d instanceof Date && !isNaN(d.getTime())) return;
              const y = m._flags.format;
              return w.convert && y && typeof d == "string"
                ? { value: d, errors: g("date.format", { format: y }) }
                : { value: d, errors: g("date.base") };
            },
            rules: {
              compare: {
                method: !1,
                validate(d, p, m, g) {
                  let { date: w } = m,
                    { name: y, operator: v, args: E } = g;
                  const S = w === "now" ? Date.now() : w.getTime();
                  return u.compare(d.getTime(), S, v)
                    ? d
                    : p.error("date." + y, { limit: E.date, value: d });
                },
                args: [
                  {
                    name: "date",
                    ref: !0,
                    normalize: (d) => (d === "now" ? d : c.parse(d)),
                    assert: (d) => d !== null,
                    message: "must have a valid date format",
                  },
                ],
              },
              format: {
                method(d) {
                  return (
                    o(
                      ["iso", "javascript", "unix"].includes(d),
                      "Unknown date format",
                      d
                    ),
                    this.$_setFlag("format", d)
                  );
                },
              },
              greater: {
                method(d) {
                  return this.$_addRule({
                    name: "greater",
                    method: "compare",
                    args: { date: d },
                    operator: ">",
                  });
                },
              },
              iso: {
                method() {
                  return this.format("iso");
                },
              },
              less: {
                method(d) {
                  return this.$_addRule({
                    name: "less",
                    method: "compare",
                    args: { date: d },
                    operator: "<",
                  });
                },
              },
              max: {
                method(d) {
                  return this.$_addRule({
                    name: "max",
                    method: "compare",
                    args: { date: d },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(d) {
                  return this.$_addRule({
                    name: "min",
                    method: "compare",
                    args: { date: d },
                    operator: ">=",
                  });
                },
              },
              timestamp: {
                method() {
                  let d =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "javascript";
                  return (
                    o(
                      ["javascript", "unix"].includes(d),
                      '"type" must be one of "javascript, unix"'
                    ),
                    this.format(d)
                  );
                },
              },
            },
            cast: {
              number: { from: c.isDate, to: (d, p) => d.getTime() },
              string: {
                from: c.isDate,
                to(d, p) {
                  let { prefs: m } = p;
                  return f.date(d, m);
                },
              },
            },
            messages: {
              "date.base": "{{#label}} must be a valid date",
              "date.format":
                '{{#label}} must be in {msg("date.format." + #format) || #format} format',
              "date.greater": "{{#label}} must be greater than {{:#limit}}",
              "date.less": "{{#label}} must be less than {{:#limit}}",
              "date.max":
                "{{#label}} must be less than or equal to {{:#limit}}",
              "date.min":
                "{{#label}} must be greater than or equal to {{:#limit}}",
              "date.format.iso": "ISO 8601 date",
              "date.format.javascript": "timestamp or number of milliseconds",
              "date.format.unix": "timestamp or number of seconds",
            },
          })),
            (c.parse = function (d, p) {
              if (d instanceof Date) return d;
              if (
                (typeof d != "string" && (isNaN(d) || !isFinite(d))) ||
                /^\s*$/.test(d)
              )
                return null;
              if (p === "iso")
                return u.isIsoDate(d) ? c.date(d.toString()) : null;
              const m = d;
              if (
                (typeof d == "string" &&
                  /^[+-]?\d+(\.\d+)?$/.test(d) &&
                  (d = parseFloat(d)),
                p)
              ) {
                if (p === "javascript") return c.date(1 * d);
                if (p === "unix") return c.date(1e3 * d);
                if (typeof m == "string") return null;
              }
              return c.date(d);
            }),
            (c.date = function (d) {
              const p = new Date(d);
              return isNaN(p.getTime()) ? null : p;
            });
        },
        390: (i, s, a) => {
          const o = a(375),
            l = a(7824);
          i.exports = l.extend({
            type: "function",
            properties: { typeof: "function" },
            rules: {
              arity: {
                method(u) {
                  return (
                    o(
                      Number.isSafeInteger(u) && u >= 0,
                      "n must be a positive integer"
                    ),
                    this.$_addRule({ name: "arity", args: { n: u } })
                  );
                },
                validate(u, f, c) {
                  let { n: d } = c;
                  return u.length === d
                    ? u
                    : f.error("function.arity", { n: d });
                },
              },
              class: {
                method() {
                  return this.$_addRule("class");
                },
                validate: (u, f) =>
                  /^\s*class\s/.test(u.toString())
                    ? u
                    : f.error("function.class", { value: u }),
              },
              minArity: {
                method(u) {
                  return (
                    o(
                      Number.isSafeInteger(u) && u > 0,
                      "n must be a strict positive integer"
                    ),
                    this.$_addRule({ name: "minArity", args: { n: u } })
                  );
                },
                validate(u, f, c) {
                  let { n: d } = c;
                  return u.length >= d
                    ? u
                    : f.error("function.minArity", { n: d });
                },
              },
              maxArity: {
                method(u) {
                  return (
                    o(
                      Number.isSafeInteger(u) && u >= 0,
                      "n must be a positive integer"
                    ),
                    this.$_addRule({ name: "maxArity", args: { n: u } })
                  );
                },
                validate(u, f, c) {
                  let { n: d } = c;
                  return u.length <= d
                    ? u
                    : f.error("function.maxArity", { n: d });
                },
              },
            },
            messages: {
              "function.arity": "{{#label}} must have an arity of {{#n}}",
              "function.class": "{{#label}} must be a class",
              "function.maxArity":
                "{{#label}} must have an arity lesser or equal to {{#n}}",
              "function.minArity":
                "{{#label}} must have an arity greater or equal to {{#n}}",
            },
          });
        },
        7824: (i, s, a) => {
          const o = a(978),
            l = a(375),
            u = a(8571),
            f = a(3652),
            c = a(8068),
            d = a(8160),
            p = a(3292),
            m = a(6354),
            g = a(6133),
            w = a(3328),
            y = { renameDefaults: { alias: !1, multiple: !1, override: !1 } };
          (i.exports = c.extend({
            type: "_keys",
            properties: { typeof: "object" },
            flags: { unknown: { default: !1 } },
            terms: {
              dependencies: { init: null },
              keys: {
                init: null,
                manifest: { mapped: { from: "schema", to: "key" } },
              },
              patterns: { init: null },
              renames: { init: null },
            },
            args: (v, E) => v.keys(E),
            validate(v, E) {
              let { schema: S, error: D, state: P, prefs: x } = E;
              if (!v || typeof v !== S.$_property("typeof") || Array.isArray(v))
                return {
                  value: v,
                  errors: D("object.base", { type: S.$_property("typeof") }),
                };
              if (
                !(
                  S.$_terms.renames ||
                  S.$_terms.dependencies ||
                  S.$_terms.keys ||
                  S.$_terms.patterns ||
                  S.$_terms.externals
                )
              )
                return;
              v = y.clone(v, x);
              const _ = [];
              if (S.$_terms.renames && !y.rename(S, v, P, x, _))
                return { value: v, errors: _ };
              if (
                !S.$_terms.keys &&
                !S.$_terms.patterns &&
                !S.$_terms.dependencies
              )
                return { value: v, errors: _ };
              const A = new Set(Object.keys(v));
              if (S.$_terms.keys) {
                const N = [v, ...P.ancestors];
                for (const M of S.$_terms.keys) {
                  const T = M.key,
                    O = v[T];
                  A.delete(T);
                  const I = P.localize([...P.path, T], N, M),
                    k = M.schema.$_validate(O, I, x);
                  if (k.errors) {
                    if (x.abortEarly) return { value: v, errors: k.errors };
                    k.value !== void 0 && (v[T] = k.value), _.push(...k.errors);
                  } else
                    M.schema._flags.result === "strip" ||
                    (k.value === void 0 && O !== void 0)
                      ? delete v[T]
                      : k.value !== void 0 && (v[T] = k.value);
                }
              }
              if (A.size || S._flags._hasPatternMatch) {
                const N = y.unknown(S, v, A, _, P, x);
                if (N) return N;
              }
              if (S.$_terms.dependencies)
                for (const N of S.$_terms.dependencies) {
                  if (
                    N.key !== null &&
                    y.isPresent(N.options)(
                      N.key.resolve(v, P, x, null, { shadow: !1 })
                    ) === !1
                  )
                    continue;
                  const M = y.dependencies[N.rel](S, N, v, P, x);
                  if (M) {
                    const T = S.$_createError(M.code, v, M.context, P, x);
                    if (x.abortEarly) return { value: v, errors: T };
                    _.push(T);
                  }
                }
              return { value: v, errors: _ };
            },
            rules: {
              and: {
                method() {
                  for (
                    var v = arguments.length, E = new Array(v), S = 0;
                    S < v;
                    S++
                  )
                    E[S] = arguments[S];
                  return (
                    d.verifyFlat(E, "and"), y.dependency(this, "and", null, E)
                  );
                },
              },
              append: {
                method(v) {
                  return v == null || Object.keys(v).length === 0
                    ? this
                    : this.keys(v);
                },
              },
              assert: {
                method(v, E, S) {
                  w.isTemplate(v) || (v = p.ref(v)),
                    l(
                      S === void 0 || typeof S == "string",
                      "Message must be a string"
                    ),
                    (E = this.$_compile(E, { appendPath: !0 }));
                  const D = this.$_addRule({
                    name: "assert",
                    args: { subject: v, schema: E, message: S },
                  });
                  return D.$_mutateRegister(v), D.$_mutateRegister(E), D;
                },
                validate(v, E, S) {
                  let { error: D, prefs: P, state: x } = E,
                    { subject: _, schema: A, message: N } = S;
                  const M = _.resolve(v, x, P),
                    T = g.isRef(_) ? _.absolute(x) : [];
                  return A.$_match(M, x.localize(T, [v, ...x.ancestors], A), P)
                    ? v
                    : D("object.assert", { subject: _, message: N });
                },
                args: ["subject", "schema", "message"],
                multi: !0,
              },
              instance: {
                method(v, E) {
                  return (
                    l(typeof v == "function", "constructor must be a function"),
                    (E = E || v.name),
                    this.$_addRule({
                      name: "instance",
                      args: { constructor: v, name: E },
                    })
                  );
                },
                validate(v, E, S) {
                  let { constructor: D, name: P } = S;
                  return v instanceof D
                    ? v
                    : E.error("object.instance", { type: P, value: v });
                },
                args: ["constructor", "name"],
              },
              keys: {
                method(v) {
                  l(
                    v === void 0 || typeof v == "object",
                    "Object schema must be a valid object"
                  ),
                    l(!d.isSchema(v), "Object schema cannot be a joi schema");
                  const E = this.clone();
                  if (v)
                    if (Object.keys(v).length) {
                      E.$_terms.keys = E.$_terms.keys
                        ? E.$_terms.keys.filter((S) => !v.hasOwnProperty(S.key))
                        : new y.Keys();
                      for (const S in v)
                        d.tryWithPath(
                          () =>
                            E.$_terms.keys.push({
                              key: S,
                              schema: this.$_compile(v[S]),
                            }),
                          S
                        );
                    } else E.$_terms.keys = new y.Keys();
                  else E.$_terms.keys = null;
                  return E.$_mutateRebuild();
                },
              },
              length: {
                method(v) {
                  return this.$_addRule({
                    name: "length",
                    args: { limit: v },
                    operator: "=",
                  });
                },
                validate(v, E, S, D) {
                  let { limit: P } = S,
                    { name: x, operator: _, args: A } = D;
                  return d.compare(Object.keys(v).length, P, _)
                    ? v
                    : E.error("object." + x, { limit: A.limit, value: v });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: d.limit,
                    message: "must be a positive integer",
                  },
                ],
              },
              max: {
                method(v) {
                  return this.$_addRule({
                    name: "max",
                    method: "length",
                    args: { limit: v },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(v) {
                  return this.$_addRule({
                    name: "min",
                    method: "length",
                    args: { limit: v },
                    operator: ">=",
                  });
                },
              },
              nand: {
                method() {
                  for (
                    var v = arguments.length, E = new Array(v), S = 0;
                    S < v;
                    S++
                  )
                    E[S] = arguments[S];
                  return (
                    d.verifyFlat(E, "nand"), y.dependency(this, "nand", null, E)
                  );
                },
              },
              or: {
                method() {
                  for (
                    var v = arguments.length, E = new Array(v), S = 0;
                    S < v;
                    S++
                  )
                    E[S] = arguments[S];
                  return (
                    d.verifyFlat(E, "or"), y.dependency(this, "or", null, E)
                  );
                },
              },
              oxor: {
                method() {
                  for (
                    var v = arguments.length, E = new Array(v), S = 0;
                    S < v;
                    S++
                  )
                    E[S] = arguments[S];
                  return y.dependency(this, "oxor", null, E);
                },
              },
              pattern: {
                method(v, E) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  const D = v instanceof RegExp;
                  D || (v = this.$_compile(v, { appendPath: !0 })),
                    l(E !== void 0, "Invalid rule"),
                    d.assertOptions(S, ["fallthrough", "matches"]),
                    D &&
                      l(
                        !v.flags.includes("g") && !v.flags.includes("y"),
                        "pattern should not use global or sticky mode"
                      ),
                    (E = this.$_compile(E, { appendPath: !0 }));
                  const P = this.clone();
                  P.$_terms.patterns = P.$_terms.patterns || [];
                  const x = { [D ? "regex" : "schema"]: v, rule: E };
                  return (
                    S.matches &&
                      ((x.matches = this.$_compile(S.matches)),
                      x.matches.type !== "array" &&
                        (x.matches = x.matches.$_root.array().items(x.matches)),
                      P.$_mutateRegister(x.matches),
                      P.$_setFlag("_hasPatternMatch", !0, { clone: !1 })),
                    S.fallthrough && (x.fallthrough = !0),
                    P.$_terms.patterns.push(x),
                    P.$_mutateRegister(E),
                    P
                  );
                },
              },
              ref: {
                method() {
                  return this.$_addRule("ref");
                },
                validate: (v, E) =>
                  g.isRef(v) ? v : E.error("object.refType", { value: v }),
              },
              regex: {
                method() {
                  return this.$_addRule("regex");
                },
                validate: (v, E) =>
                  v instanceof RegExp
                    ? v
                    : E.error("object.regex", { value: v }),
              },
              rename: {
                method(v, E) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  l(
                    typeof v == "string" || v instanceof RegExp,
                    "Rename missing the from argument"
                  ),
                    l(
                      typeof E == "string" || E instanceof w,
                      "Invalid rename to argument"
                    ),
                    l(E !== v, "Cannot rename key to same name:", v),
                    d.assertOptions(S, [
                      "alias",
                      "ignoreUndefined",
                      "override",
                      "multiple",
                    ]);
                  const D = this.clone();
                  D.$_terms.renames = D.$_terms.renames || [];
                  for (const P of D.$_terms.renames)
                    l(
                      P.from !== v,
                      "Cannot rename the same key multiple times"
                    );
                  return (
                    E instanceof w && D.$_mutateRegister(E),
                    D.$_terms.renames.push({
                      from: v,
                      to: E,
                      options: o(y.renameDefaults, S),
                    }),
                    D
                  );
                },
              },
              schema: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "any";
                  return this.$_addRule({ name: "schema", args: { type: v } });
                },
                validate(v, E, S) {
                  let { type: D } = S;
                  return !d.isSchema(v) || (D !== "any" && v.type !== D)
                    ? E.error("object.schema", { type: D })
                    : v;
                },
              },
              unknown: {
                method(v) {
                  return this.$_setFlag("unknown", v !== !1);
                },
              },
              with: {
                method(v, E) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return y.dependency(this, "with", v, E, S);
                },
              },
              without: {
                method(v, E) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return y.dependency(this, "without", v, E, S);
                },
              },
              xor: {
                method() {
                  for (
                    var v = arguments.length, E = new Array(v), S = 0;
                    S < v;
                    S++
                  )
                    E[S] = arguments[S];
                  return (
                    d.verifyFlat(E, "xor"), y.dependency(this, "xor", null, E)
                  );
                },
              },
            },
            overrides: {
              default(v, E) {
                return (
                  v === void 0 && (v = d.symbols.deepDefault),
                  this.$_parent("default", v, E)
                );
              },
            },
            rebuild(v) {
              if (v.$_terms.keys) {
                const E = new f.Sorter();
                for (const S of v.$_terms.keys)
                  d.tryWithPath(
                    () =>
                      E.add(S, {
                        after: S.schema.$_rootReferences(),
                        group: S.key,
                      }),
                    S.key
                  );
                v.$_terms.keys = new y.Keys(...E.nodes);
              }
            },
            manifest: {
              build(v, E) {
                if ((E.keys && (v = v.keys(E.keys)), E.dependencies))
                  for (const {
                    rel: S,
                    key: D = null,
                    peers: P,
                    options: x,
                  } of E.dependencies)
                    v = y.dependency(v, S, D, P, x);
                if (E.patterns)
                  for (const {
                    regex: S,
                    schema: D,
                    rule: P,
                    fallthrough: x,
                    matches: _,
                  } of E.patterns)
                    v = v.pattern(S || D, P, { fallthrough: x, matches: _ });
                if (E.renames)
                  for (const { from: S, to: D, options: P } of E.renames)
                    v = v.rename(S, D, P);
                return v;
              },
            },
            messages: {
              "object.and":
                "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
              "object.assert":
                '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
              "object.base": "{{#label}} must be of type {{#type}}",
              "object.instance": "{{#label}} must be an instance of {{:#type}}",
              "object.length":
                '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.max":
                '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.min":
                '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.missing":
                "{{#label}} must contain at least one of {{#peersWithLabels}}",
              "object.nand":
                "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
              "object.oxor":
                "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
              "object.pattern.match":
                "{{#label}} keys failed to match pattern requirements",
              "object.refType": "{{#label}} must be a Joi reference",
              "object.regex": "{{#label}} must be a RegExp object",
              "object.rename.multiple":
                "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
              "object.rename.override":
                "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
              "object.schema":
                "{{#label}} must be a Joi schema of {{#type}} type",
              "object.unknown": "{{#label}} is not allowed",
              "object.with":
                "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
              "object.without":
                "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
              "object.xor":
                "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}",
            },
          })),
            (y.clone = function (v, E) {
              if (typeof v == "object") {
                if (E.nonEnumerables) return u(v, { shallow: !0 });
                const D = Object.create(Object.getPrototypeOf(v));
                return Object.assign(D, v), D;
              }
              const S = function () {
                for (
                  var D = arguments.length, P = new Array(D), x = 0;
                  x < D;
                  x++
                )
                  P[x] = arguments[x];
                return v.apply(this, P);
              };
              return (
                (S.prototype = u(v.prototype)),
                Object.defineProperty(S, "name", {
                  value: v.name,
                  writable: !1,
                }),
                Object.defineProperty(S, "length", {
                  value: v.length,
                  writable: !1,
                }),
                Object.assign(S, v),
                S
              );
            }),
            (y.dependency = function (v, E, S, D, P) {
              l(S === null || typeof S == "string", E, "key must be a strings"),
                P ||
                  (P =
                    D.length > 1 && typeof D[D.length - 1] == "object"
                      ? D.pop()
                      : {}),
                d.assertOptions(P, ["separator", "isPresent"]),
                (D = [].concat(D));
              const x = d.default(P.separator, "."),
                _ = [];
              for (const N of D)
                l(typeof N == "string", E, "peers must be strings"),
                  _.push(p.ref(N, { separator: x, ancestor: 0, prefix: !1 }));
              S !== null &&
                (S = p.ref(S, { separator: x, ancestor: 0, prefix: !1 }));
              const A = v.clone();
              return (
                (A.$_terms.dependencies = A.$_terms.dependencies || []),
                A.$_terms.dependencies.push(new y.Dependency(E, S, _, D, P)),
                A
              );
            }),
            (y.dependencies = {
              and(v, E, S, D, P) {
                const x = [],
                  _ = [],
                  A = E.peers.length,
                  N = y.isPresent(E.options);
                for (const M of E.peers)
                  N(M.resolve(S, D, P, null, { shadow: !1 })) === !1
                    ? x.push(M.key)
                    : _.push(M.key);
                if (x.length !== A && _.length !== A)
                  return {
                    code: "object.and",
                    context: {
                      present: _,
                      presentWithLabels: y.keysToLabels(v, _),
                      missing: x,
                      missingWithLabels: y.keysToLabels(v, x),
                    },
                  };
              },
              nand(v, E, S, D, P) {
                const x = [],
                  _ = y.isPresent(E.options);
                for (const M of E.peers)
                  _(M.resolve(S, D, P, null, { shadow: !1 })) && x.push(M.key);
                if (x.length !== E.peers.length) return;
                const A = E.paths[0],
                  N = E.paths.slice(1);
                return {
                  code: "object.nand",
                  context: {
                    main: A,
                    mainWithLabel: y.keysToLabels(v, A),
                    peers: N,
                    peersWithLabels: y.keysToLabels(v, N),
                  },
                };
              },
              or(v, E, S, D, P) {
                const x = y.isPresent(E.options);
                for (const _ of E.peers)
                  if (x(_.resolve(S, D, P, null, { shadow: !1 }))) return;
                return {
                  code: "object.missing",
                  context: {
                    peers: E.paths,
                    peersWithLabels: y.keysToLabels(v, E.paths),
                  },
                };
              },
              oxor(v, E, S, D, P) {
                const x = [],
                  _ = y.isPresent(E.options);
                for (const N of E.peers)
                  _(N.resolve(S, D, P, null, { shadow: !1 })) && x.push(N.key);
                if (!x.length || x.length === 1) return;
                const A = {
                  peers: E.paths,
                  peersWithLabels: y.keysToLabels(v, E.paths),
                };
                return (
                  (A.present = x),
                  (A.presentWithLabels = y.keysToLabels(v, x)),
                  { code: "object.oxor", context: A }
                );
              },
              with(v, E, S, D, P) {
                const x = y.isPresent(E.options);
                for (const _ of E.peers)
                  if (x(_.resolve(S, D, P, null, { shadow: !1 })) === !1)
                    return {
                      code: "object.with",
                      context: {
                        main: E.key.key,
                        mainWithLabel: y.keysToLabels(v, E.key.key),
                        peer: _.key,
                        peerWithLabel: y.keysToLabels(v, _.key),
                      },
                    };
              },
              without(v, E, S, D, P) {
                const x = y.isPresent(E.options);
                for (const _ of E.peers)
                  if (x(_.resolve(S, D, P, null, { shadow: !1 })))
                    return {
                      code: "object.without",
                      context: {
                        main: E.key.key,
                        mainWithLabel: y.keysToLabels(v, E.key.key),
                        peer: _.key,
                        peerWithLabel: y.keysToLabels(v, _.key),
                      },
                    };
              },
              xor(v, E, S, D, P) {
                const x = [],
                  _ = y.isPresent(E.options);
                for (const N of E.peers)
                  _(N.resolve(S, D, P, null, { shadow: !1 })) && x.push(N.key);
                if (x.length === 1) return;
                const A = {
                  peers: E.paths,
                  peersWithLabels: y.keysToLabels(v, E.paths),
                };
                return x.length === 0
                  ? { code: "object.missing", context: A }
                  : ((A.present = x),
                    (A.presentWithLabels = y.keysToLabels(v, x)),
                    { code: "object.xor", context: A });
              },
            }),
            (y.keysToLabels = function (v, E) {
              return Array.isArray(E)
                ? E.map((S) => v.$_mapLabels(S))
                : v.$_mapLabels(E);
            }),
            (y.isPresent = function (v) {
              return typeof v.isPresent == "function"
                ? v.isPresent
                : (E) => E !== void 0;
            }),
            (y.rename = function (v, E, S, D, P) {
              const x = {};
              for (const _ of v.$_terms.renames) {
                const A = [],
                  N = typeof _.from != "string";
                if (N)
                  for (const M in E) {
                    if (
                      (E[M] === void 0 && _.options.ignoreUndefined) ||
                      M === _.to
                    )
                      continue;
                    const T = _.from.exec(M);
                    T && A.push({ from: M, to: _.to, match: T });
                  }
                else
                  !Object.prototype.hasOwnProperty.call(E, _.from) ||
                    (E[_.from] === void 0 && _.options.ignoreUndefined) ||
                    A.push(_);
                for (const M of A) {
                  const T = M.from;
                  let O = M.to;
                  if (
                    (O instanceof w && (O = O.render(E, S, D, M.match)),
                    T !== O)
                  ) {
                    if (
                      (!_.options.multiple &&
                        x[O] &&
                        (P.push(
                          v.$_createError(
                            "object.rename.multiple",
                            E,
                            { from: T, to: O, pattern: N },
                            S,
                            D
                          )
                        ),
                        D.abortEarly)) ||
                      (Object.prototype.hasOwnProperty.call(E, O) &&
                        !_.options.override &&
                        !x[O] &&
                        (P.push(
                          v.$_createError(
                            "object.rename.override",
                            E,
                            { from: T, to: O, pattern: N },
                            S,
                            D
                          )
                        ),
                        D.abortEarly))
                    )
                      return !1;
                    E[T] === void 0 ? delete E[O] : (E[O] = E[T]),
                      (x[O] = !0),
                      _.options.alias || delete E[T];
                  }
                }
              }
              return !0;
            }),
            (y.unknown = function (v, E, S, D, P, x) {
              if (v.$_terms.patterns) {
                let _ = !1;
                const A = v.$_terms.patterns.map((M) => {
                    if (M.matches) return (_ = !0), [];
                  }),
                  N = [E, ...P.ancestors];
                for (const M of S) {
                  const T = E[M],
                    O = [...P.path, M];
                  for (let I = 0; I < v.$_terms.patterns.length; ++I) {
                    const k = v.$_terms.patterns[I];
                    if (k.regex) {
                      const $ = k.regex.test(M);
                      if (
                        (P.mainstay.tracer.debug(
                          P,
                          "rule",
                          `pattern.${I}`,
                          $ ? "pass" : "error"
                        ),
                        !$)
                      )
                        continue;
                    } else if (
                      !k.schema.$_match(M, P.nest(k.schema, `pattern.${I}`), x)
                    )
                      continue;
                    S.delete(M);
                    const L = P.localize(O, N, { schema: k.rule, key: M }),
                      U = k.rule.$_validate(T, L, x);
                    if (U.errors) {
                      if (x.abortEarly) return { value: E, errors: U.errors };
                      D.push(...U.errors);
                    }
                    if (
                      (k.matches && A[I].push(M),
                      (E[M] = U.value),
                      !k.fallthrough)
                    )
                      break;
                  }
                }
                if (_)
                  for (let M = 0; M < A.length; ++M) {
                    const T = A[M];
                    if (!T) continue;
                    const O = v.$_terms.patterns[M].matches,
                      I = P.localize(P.path, N, O),
                      k = O.$_validate(T, I, x);
                    if (k.errors) {
                      const L = m.details(k.errors, { override: !1 });
                      L.matches = T;
                      const U = v.$_createError(
                        "object.pattern.match",
                        E,
                        L,
                        P,
                        x
                      );
                      if (x.abortEarly) return { value: E, errors: U };
                      D.push(U);
                    }
                  }
              }
              if (S.size && (v.$_terms.keys || v.$_terms.patterns)) {
                if ((x.stripUnknown && !v._flags.unknown) || x.skipFunctions) {
                  const _ = !(
                    !x.stripUnknown ||
                    (x.stripUnknown !== !0 && !x.stripUnknown.objects)
                  );
                  for (const A of S)
                    _
                      ? (delete E[A], S.delete(A))
                      : typeof E[A] == "function" && S.delete(A);
                }
                if (!d.default(v._flags.unknown, x.allowUnknown))
                  for (const _ of S) {
                    const A = P.localize([...P.path, _], []),
                      N = v.$_createError(
                        "object.unknown",
                        E[_],
                        { child: _ },
                        A,
                        x,
                        { flags: !1 }
                      );
                    if (x.abortEarly) return { value: E, errors: N };
                    D.push(N);
                  }
              }
            }),
            (y.Dependency = class {
              constructor(v, E, S, D, P) {
                (this.rel = v),
                  (this.key = E),
                  (this.peers = S),
                  (this.paths = D),
                  (this.options = P);
              }
              describe() {
                const v = { rel: this.rel, peers: this.paths };
                return (
                  this.key !== null && (v.key = this.key.key),
                  this.peers[0].separator !== "." &&
                    (v.options = {
                      ...v.options,
                      separator: this.peers[0].separator,
                    }),
                  this.options.isPresent &&
                    (v.options = {
                      ...v.options,
                      isPresent: this.options.isPresent,
                    }),
                  v
                );
              }
            }),
            (y.Keys = class extends Array {
              concat(v) {
                const E = this.slice(),
                  S = new Map();
                for (let D = 0; D < E.length; ++D) S.set(E[D].key, D);
                for (const D of v) {
                  const P = D.key,
                    x = S.get(P);
                  x !== void 0
                    ? (E[x] = { key: P, schema: E[x].schema.concat(D.schema) })
                    : E.push(D);
                }
                return E;
              }
            });
        },
        8785: (i, s, a) => {
          const o = a(375),
            l = a(8068),
            u = a(8160),
            f = a(3292),
            c = a(6354),
            d = {};
          (i.exports = l.extend({
            type: "link",
            properties: { schemaChain: !0 },
            terms: { link: { init: null, manifest: "single", register: !1 } },
            args: (p, m) => p.ref(m),
            validate(p, m) {
              let { schema: g, state: w, prefs: y } = m;
              o(g.$_terms.link, "Uninitialized link schema");
              const v = d.generate(g, p, w, y),
                E = g.$_terms.link[0].ref;
              return v.$_validate(
                p,
                w.nest(v, `link:${E.display}:${v.type}`),
                y
              );
            },
            generate: (p, m, g, w) => d.generate(p, m, g, w),
            rules: {
              ref: {
                method(p) {
                  o(!this.$_terms.link, "Cannot reinitialize schema"),
                    (p = f.ref(p)),
                    o(
                      p.type === "value" || p.type === "local",
                      "Invalid reference type:",
                      p.type
                    ),
                    o(
                      p.type === "local" ||
                        p.ancestor === "root" ||
                        p.ancestor > 0,
                      "Link cannot reference itself"
                    );
                  const m = this.clone();
                  return (m.$_terms.link = [{ ref: p }]), m;
                },
              },
              relative: {
                method() {
                  let p =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("relative", p);
                },
              },
            },
            overrides: {
              concat(p) {
                o(this.$_terms.link, "Uninitialized link schema"),
                  o(u.isSchema(p), "Invalid schema object"),
                  o(
                    p.type !== "link",
                    "Cannot merge type link with another link"
                  );
                const m = this.clone();
                return (
                  m.$_terms.whens || (m.$_terms.whens = []),
                  m.$_terms.whens.push({ concat: p }),
                  m.$_mutateRebuild()
                );
              },
            },
            manifest: {
              build: (p, m) => (
                o(m.link, "Invalid link description missing link"),
                p.ref(m.link)
              ),
            },
          })),
            (d.generate = function (p, m, g, w) {
              let y = g.mainstay.links.get(p);
              if (y) return y._generate(m, g, w).schema;
              const v = p.$_terms.link[0].ref,
                { perspective: E, path: S } = d.perspective(v, g);
              d.assert(E, "which is outside of schema boundaries", v, p, g, w);
              try {
                y = S.length ? E.$_reach(S) : E;
              } catch {
                d.assert(!1, "to non-existing schema", v, p, g, w);
              }
              return (
                d.assert(
                  y.type !== "link",
                  "which is another link",
                  v,
                  p,
                  g,
                  w
                ),
                p._flags.relative || g.mainstay.links.set(p, y),
                y._generate(m, g, w).schema
              );
            }),
            (d.perspective = function (p, m) {
              if (p.type === "local") {
                for (const { schema: g, key: w } of m.schemas) {
                  if ((g._flags.id || w) === p.path[0])
                    return { perspective: g, path: p.path.slice(1) };
                  if (g.$_terms.shared) {
                    for (const y of g.$_terms.shared)
                      if (y._flags.id === p.path[0])
                        return { perspective: y, path: p.path.slice(1) };
                  }
                }
                return { perspective: null, path: null };
              }
              return p.ancestor === "root"
                ? {
                    perspective: m.schemas[m.schemas.length - 1].schema,
                    path: p.path,
                  }
                : {
                    perspective:
                      m.schemas[p.ancestor] && m.schemas[p.ancestor].schema,
                    path: p.path,
                  };
            }),
            (d.assert = function (p, m, g, w, y, v) {
              p ||
                o(
                  !1,
                  `"${c.label(w._flags, y, v)}" contains link reference "${
                    g.display
                  }" ${m}`
                );
            });
        },
        3832: (i, s, a) => {
          const o = a(375),
            l = a(8068),
            u = a(8160),
            f = {
              numberRx:
                /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
              precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
              exponentialPartRegex: /[eE][+-]?\d+$/,
              leadingSignAndZerosRegex: /^[+-]?(0*)?/,
              dotRegex: /\./,
              trailingZerosRegex: /0+$/,
            };
          (i.exports = l.extend({
            type: "number",
            flags: { unsafe: { default: !1 } },
            coerce: {
              from: "string",
              method(c, d) {
                let { schema: p, error: m } = d;
                if (!c.match(f.numberRx)) return;
                c = c.trim();
                const g = { value: parseFloat(c) };
                if ((g.value === 0 && (g.value = 0), !p._flags.unsafe))
                  if (c.match(/e/i)) {
                    if (
                      f.extractSignificantDigits(c) !==
                      f.extractSignificantDigits(String(g.value))
                    )
                      return (g.errors = m("number.unsafe")), g;
                  } else {
                    const w = g.value.toString();
                    if (w.match(/e/i)) return g;
                    if (w !== f.normalizeDecimal(c))
                      return (g.errors = m("number.unsafe")), g;
                  }
                return g;
              },
            },
            validate(c, d) {
              let { schema: p, error: m, prefs: g } = d;
              if (c === 1 / 0 || c === -1 / 0)
                return { value: c, errors: m("number.infinity") };
              if (!u.isNumber(c)) return { value: c, errors: m("number.base") };
              const w = { value: c };
              if (g.convert) {
                const y = p.$_getRule("precision");
                if (y) {
                  const v = Math.pow(10, y.args.limit);
                  w.value = Math.round(w.value * v) / v;
                }
              }
              return (
                w.value === 0 && (w.value = 0),
                !p._flags.unsafe &&
                  (c > Number.MAX_SAFE_INTEGER ||
                    c < Number.MIN_SAFE_INTEGER) &&
                  (w.errors = m("number.unsafe")),
                w
              );
            },
            rules: {
              compare: {
                method: !1,
                validate(c, d, p, m) {
                  let { limit: g } = p,
                    { name: w, operator: y, args: v } = m;
                  return u.compare(c, g, y)
                    ? c
                    : d.error("number." + w, { limit: v.limit, value: c });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: u.isNumber,
                    message: "must be a number",
                  },
                ],
              },
              greater: {
                method(c) {
                  return this.$_addRule({
                    name: "greater",
                    method: "compare",
                    args: { limit: c },
                    operator: ">",
                  });
                },
              },
              integer: {
                method() {
                  return this.$_addRule("integer");
                },
                validate: (c, d) =>
                  Math.trunc(c) - c == 0 ? c : d.error("number.integer"),
              },
              less: {
                method(c) {
                  return this.$_addRule({
                    name: "less",
                    method: "compare",
                    args: { limit: c },
                    operator: "<",
                  });
                },
              },
              max: {
                method(c) {
                  return this.$_addRule({
                    name: "max",
                    method: "compare",
                    args: { limit: c },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(c) {
                  return this.$_addRule({
                    name: "min",
                    method: "compare",
                    args: { limit: c },
                    operator: ">=",
                  });
                },
              },
              multiple: {
                method(c) {
                  return this.$_addRule({
                    name: "multiple",
                    args: { base: c },
                  });
                },
                validate(c, d, p, m) {
                  let { base: g } = p;
                  return (c * (1 / g)) % 1 == 0
                    ? c
                    : d.error("number.multiple", {
                        multiple: m.args.base,
                        value: c,
                      });
                },
                args: [
                  {
                    name: "base",
                    ref: !0,
                    assert: (c) => typeof c == "number" && isFinite(c) && c > 0,
                    message: "must be a positive number",
                  },
                ],
                multi: !0,
              },
              negative: {
                method() {
                  return this.sign("negative");
                },
              },
              port: {
                method() {
                  return this.$_addRule("port");
                },
                validate: (c, d) =>
                  Number.isSafeInteger(c) && c >= 0 && c <= 65535
                    ? c
                    : d.error("number.port"),
              },
              positive: {
                method() {
                  return this.sign("positive");
                },
              },
              precision: {
                method(c) {
                  return (
                    o(Number.isSafeInteger(c), "limit must be an integer"),
                    this.$_addRule({ name: "precision", args: { limit: c } })
                  );
                },
                validate(c, d, p) {
                  let { limit: m } = p;
                  const g = c.toString().match(f.precisionRx);
                  return Math.max(
                    (g[1] ? g[1].length : 0) - (g[2] ? parseInt(g[2], 10) : 0),
                    0
                  ) <= m
                    ? c
                    : d.error("number.precision", { limit: m, value: c });
                },
                convert: !0,
              },
              sign: {
                method(c) {
                  return (
                    o(["negative", "positive"].includes(c), "Invalid sign", c),
                    this.$_addRule({ name: "sign", args: { sign: c } })
                  );
                },
                validate(c, d, p) {
                  let { sign: m } = p;
                  return (m === "negative" && c < 0) ||
                    (m === "positive" && c > 0)
                    ? c
                    : d.error(`number.${m}`);
                },
              },
              unsafe: {
                method() {
                  let c =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    o(typeof c == "boolean", "enabled must be a boolean"),
                    this.$_setFlag("unsafe", c)
                  );
                },
              },
            },
            cast: {
              string: {
                from: (c) => typeof c == "number",
                to: (c, d) => c.toString(),
              },
            },
            messages: {
              "number.base": "{{#label}} must be a number",
              "number.greater": "{{#label}} must be greater than {{#limit}}",
              "number.infinity": "{{#label}} cannot be infinity",
              "number.integer": "{{#label}} must be an integer",
              "number.less": "{{#label}} must be less than {{#limit}}",
              "number.max":
                "{{#label}} must be less than or equal to {{#limit}}",
              "number.min":
                "{{#label}} must be greater than or equal to {{#limit}}",
              "number.multiple":
                "{{#label}} must be a multiple of {{#multiple}}",
              "number.negative": "{{#label}} must be a negative number",
              "number.port": "{{#label}} must be a valid port",
              "number.positive": "{{#label}} must be a positive number",
              "number.precision":
                "{{#label}} must have no more than {{#limit}} decimal places",
              "number.unsafe": "{{#label}} must be a safe number",
            },
          })),
            (f.extractSignificantDigits = function (c) {
              return c
                .replace(f.exponentialPartRegex, "")
                .replace(f.dotRegex, "")
                .replace(f.trailingZerosRegex, "")
                .replace(f.leadingSignAndZerosRegex, "");
            }),
            (f.normalizeDecimal = function (c) {
              return (
                (c = c
                  .replace(/^\+/, "")
                  .replace(/\.0*$/, "")
                  .replace(/^(-?)\.([^\.]*)$/, "$10.$2")
                  .replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") &&
                  c.endsWith("0") &&
                  (c = c.replace(/0+$/, "")),
                c === "-0" ? "0" : c
              );
            });
        },
        8966: (i, s, a) => {
          const o = a(7824);
          i.exports = o.extend({
            type: "object",
            cast: {
              map: {
                from: (l) => l && typeof l == "object",
                to: (l, u) => new Map(Object.entries(l)),
              },
            },
          });
        },
        7417: (i, s, a) => {
          const o = a(375),
            l = a(5380),
            u = a(1745),
            f = a(9959),
            c = a(6064),
            d = a(9926),
            p = a(5752),
            m = a(8068),
            g = a(8160),
            w = {
              tlds: d instanceof Set && { tlds: { allow: d, deny: null } },
              base64Regex: {
                true: {
                  true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
                  false:
                    /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
                },
                false: {
                  true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
                  false:
                    /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/,
                },
              },
              dataUriRegex:
                /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
              hexRegex: /^[a-f0-9]+$/i,
              ipRegex: f.regex({ cidr: "forbidden" }).regex,
              isoDurationRegex:
                /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
              guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" },
              guidVersions: {
                uuidv1: "1",
                uuidv2: "2",
                uuidv3: "3",
                uuidv4: "4",
                uuidv5: "5",
              },
              guidSeparators: new Set([void 0, !0, !1, "-", ":"]),
              normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
            };
          (i.exports = m.extend({
            type: "string",
            flags: { insensitive: { default: !1 }, truncate: { default: !1 } },
            terms: { replacements: { init: null } },
            coerce: {
              from: "string",
              method(y, v) {
                let { schema: E, state: S, prefs: D } = v;
                const P = E.$_getRule("normalize");
                P && (y = y.normalize(P.args.form));
                const x = E.$_getRule("case");
                x &&
                  (y =
                    x.args.direction === "upper"
                      ? y.toLocaleUpperCase()
                      : y.toLocaleLowerCase());
                const _ = E.$_getRule("trim");
                if (
                  (_ && _.args.enabled && (y = y.trim()),
                  E.$_terms.replacements)
                )
                  for (const N of E.$_terms.replacements)
                    y = y.replace(N.pattern, N.replacement);
                const A = E.$_getRule("hex");
                if (
                  (A &&
                    A.args.options.byteAligned &&
                    y.length % 2 != 0 &&
                    (y = `0${y}`),
                  E.$_getRule("isoDate"))
                ) {
                  const N = w.isoDate(y);
                  N && (y = N);
                }
                if (E._flags.truncate) {
                  const N = E.$_getRule("max");
                  if (N) {
                    let M = N.args.limit;
                    if (
                      g.isResolvable(M) &&
                      ((M = M.resolve(y, S, D)), !g.limit(M))
                    )
                      return {
                        value: y,
                        errors: E.$_createError(
                          "any.ref",
                          M,
                          {
                            ref: N.args.limit,
                            arg: "limit",
                            reason: "must be a positive integer",
                          },
                          S,
                          D
                        ),
                      };
                    y = y.slice(0, M);
                  }
                }
                return { value: y };
              },
            },
            validate(y, v) {
              let { schema: E, error: S } = v;
              if (typeof y != "string")
                return { value: y, errors: S("string.base") };
              if (y === "") {
                const D = E.$_getRule("min");
                return D && D.args.limit === 0
                  ? void 0
                  : { value: y, errors: S("string.empty") };
              }
            },
            rules: {
              alphanum: {
                method() {
                  return this.$_addRule("alphanum");
                },
                validate: (y, v) =>
                  /^[a-zA-Z0-9]+$/.test(y) ? y : v.error("string.alphanum"),
              },
              base64: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(y, ["paddingRequired", "urlSafe"]),
                    (y = { urlSafe: !1, paddingRequired: !0, ...y }),
                    o(
                      typeof y.paddingRequired == "boolean",
                      "paddingRequired must be boolean"
                    ),
                    o(typeof y.urlSafe == "boolean", "urlSafe must be boolean"),
                    this.$_addRule({ name: "base64", args: { options: y } })
                  );
                },
                validate(y, v, E) {
                  let { options: S } = E;
                  return w.base64Regex[S.paddingRequired][S.urlSafe].test(y)
                    ? y
                    : v.error("string.base64");
                },
              },
              case: {
                method(y) {
                  return (
                    o(["lower", "upper"].includes(y), "Invalid case:", y),
                    this.$_addRule({ name: "case", args: { direction: y } })
                  );
                },
                validate(y, v, E) {
                  let { direction: S } = E;
                  return (S === "lower" && y === y.toLocaleLowerCase()) ||
                    (S === "upper" && y === y.toLocaleUpperCase())
                    ? y
                    : v.error(`string.${S}case`);
                },
                convert: !0,
              },
              creditCard: {
                method() {
                  return this.$_addRule("creditCard");
                },
                validate(y, v) {
                  let E = y.length,
                    S = 0,
                    D = 1;
                  for (; E--; ) {
                    const P = y.charAt(E) * D;
                    (S += P - 9 * (P > 9)), (D ^= 3);
                  }
                  return S > 0 && S % 10 == 0
                    ? y
                    : v.error("string.creditCard");
                },
              },
              dataUri: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(y, ["paddingRequired"]),
                    (y = { paddingRequired: !0, ...y }),
                    o(
                      typeof y.paddingRequired == "boolean",
                      "paddingRequired must be boolean"
                    ),
                    this.$_addRule({ name: "dataUri", args: { options: y } })
                  );
                },
                validate(y, v, E) {
                  let { options: S } = E;
                  const D = y.match(w.dataUriRegex);
                  return D &&
                    (!D[2] ||
                      D[2] !== "base64" ||
                      w.base64Regex[S.paddingRequired].false.test(D[3]))
                    ? y
                    : v.error("string.dataUri");
                },
              },
              domain: {
                method(y) {
                  y &&
                    g.assertOptions(y, [
                      "allowFullyQualified",
                      "allowUnicode",
                      "maxDomainSegments",
                      "minDomainSegments",
                      "tlds",
                    ]);
                  const v = w.addressOptions(y);
                  return this.$_addRule({
                    name: "domain",
                    args: { options: y },
                    address: v,
                  });
                },
                validate(y, v, E, S) {
                  let { address: D } = S;
                  return l.isValid(y, D) ? y : v.error("string.domain");
                },
              },
              email: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(y, [
                    "allowFullyQualified",
                    "allowUnicode",
                    "ignoreLength",
                    "maxDomainSegments",
                    "minDomainSegments",
                    "multiple",
                    "separator",
                    "tlds",
                  ]),
                    o(
                      y.multiple === void 0 || typeof y.multiple == "boolean",
                      "multiple option must be an boolean"
                    );
                  const v = w.addressOptions(y),
                    E = new RegExp(
                      `\\s*[${y.separator ? c(y.separator) : ","}]\\s*`
                    );
                  return this.$_addRule({
                    name: "email",
                    args: { options: y },
                    regex: E,
                    address: v,
                  });
                },
                validate(y, v, E, S) {
                  let { options: D } = E,
                    { regex: P, address: x } = S;
                  const _ = D.multiple ? y.split(P) : [y],
                    A = [];
                  for (const N of _) u.isValid(N, x) || A.push(N);
                  return A.length
                    ? v.error("string.email", { value: y, invalids: A })
                    : y;
                },
              },
              guid: {
                alias: "uuid",
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(y, ["version", "separator"]);
                  let v = "";
                  if (y.version) {
                    const D = [].concat(y.version);
                    o(
                      D.length >= 1,
                      "version must have at least 1 valid version specified"
                    );
                    const P = new Set();
                    for (let x = 0; x < D.length; ++x) {
                      const _ = D[x];
                      o(
                        typeof _ == "string",
                        "version at position " + x + " must be a string"
                      );
                      const A = w.guidVersions[_.toLowerCase()];
                      o(
                        A,
                        "version at position " +
                          x +
                          " must be one of " +
                          Object.keys(w.guidVersions).join(", ")
                      ),
                        o(
                          !P.has(A),
                          "version at position " +
                            x +
                            " must not be a duplicate"
                        ),
                        (v += A),
                        P.add(A);
                    }
                  }
                  o(
                    w.guidSeparators.has(y.separator),
                    'separator must be one of true, false, "-", or ":"'
                  );
                  const E =
                      y.separator === void 0
                        ? "[:-]?"
                        : y.separator === !0
                        ? "[:-]"
                        : y.separator === !1
                        ? "[]?"
                        : `\\${y.separator}`,
                    S = new RegExp(
                      `^([\\[{\\(]?)[0-9A-F]{8}(${E})[0-9A-F]{4}\\2?[${
                        v || "0-9A-F"
                      }][0-9A-F]{3}\\2?[${
                        v ? "89AB" : "0-9A-F"
                      }][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,
                      "i"
                    );
                  return this.$_addRule({
                    name: "guid",
                    args: { options: y },
                    regex: S,
                  });
                },
                validate(y, v, E, S) {
                  let { regex: D } = S;
                  const P = D.exec(y);
                  return P
                    ? w.guidBrackets[P[1]] !== P[P.length - 1]
                      ? v.error("string.guid")
                      : y
                    : v.error("string.guid");
                },
              },
              hex: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(y, ["byteAligned"]),
                    (y = { byteAligned: !1, ...y }),
                    o(
                      typeof y.byteAligned == "boolean",
                      "byteAligned must be boolean"
                    ),
                    this.$_addRule({ name: "hex", args: { options: y } })
                  );
                },
                validate(y, v, E) {
                  let { options: S } = E;
                  return w.hexRegex.test(y)
                    ? S.byteAligned && y.length % 2 != 0
                      ? v.error("string.hexAlign")
                      : y
                    : v.error("string.hex");
                },
              },
              hostname: {
                method() {
                  return this.$_addRule("hostname");
                },
                validate: (y, v) =>
                  l.isValid(y, { minDomainSegments: 1 }) || w.ipRegex.test(y)
                    ? y
                    : v.error("string.hostname"),
              },
              insensitive: {
                method() {
                  return this.$_setFlag("insensitive", !0);
                },
              },
              ip: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(y, ["cidr", "version"]);
                  const { cidr: v, versions: E, regex: S } = f.regex(y),
                    D = y.version ? E : void 0;
                  return this.$_addRule({
                    name: "ip",
                    args: { options: { cidr: v, version: D } },
                    regex: S,
                  });
                },
                validate(y, v, E, S) {
                  let { options: D } = E,
                    { regex: P } = S;
                  return P.test(y)
                    ? y
                    : D.version
                    ? v.error("string.ipVersion", {
                        value: y,
                        cidr: D.cidr,
                        version: D.version,
                      })
                    : v.error("string.ip", { value: y, cidr: D.cidr });
                },
              },
              isoDate: {
                method() {
                  return this.$_addRule("isoDate");
                },
                validate(y, v) {
                  let { error: E } = v;
                  return w.isoDate(y) ? y : E("string.isoDate");
                },
              },
              isoDuration: {
                method() {
                  return this.$_addRule("isoDuration");
                },
                validate: (y, v) =>
                  w.isoDurationRegex.test(y)
                    ? y
                    : v.error("string.isoDuration"),
              },
              length: {
                method(y, v) {
                  return w.length(this, "length", y, "=", v);
                },
                validate(y, v, E, S) {
                  let { limit: D, encoding: P } = E,
                    { name: x, operator: _, args: A } = S;
                  const N = !P && y.length;
                  return g.compare(N, D, _)
                    ? y
                    : v.error("string." + x, {
                        limit: A.limit,
                        value: y,
                        encoding: P,
                      });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: g.limit,
                    message: "must be a positive integer",
                  },
                  "encoding",
                ],
              },
              lowercase: {
                method() {
                  return this.case("lower");
                },
              },
              max: {
                method(y, v) {
                  return w.length(this, "max", y, "<=", v);
                },
                args: ["limit", "encoding"],
              },
              min: {
                method(y, v) {
                  return w.length(this, "min", y, ">=", v);
                },
                args: ["limit", "encoding"],
              },
              normalize: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "NFC";
                  return (
                    o(
                      w.normalizationForms.includes(y),
                      "normalization form must be one of " +
                        w.normalizationForms.join(", ")
                    ),
                    this.$_addRule({ name: "normalize", args: { form: y } })
                  );
                },
                validate(y, v, E) {
                  let { error: S } = v,
                    { form: D } = E;
                  return y === y.normalize(D)
                    ? y
                    : S("string.normalize", { value: y, form: D });
                },
                convert: !0,
              },
              pattern: {
                alias: "regex",
                method(y) {
                  let v =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  o(y instanceof RegExp, "regex must be a RegExp"),
                    o(
                      !y.flags.includes("g") && !y.flags.includes("y"),
                      "regex should not use global or sticky mode"
                    ),
                    typeof v == "string" && (v = { name: v }),
                    g.assertOptions(v, ["invert", "name"]);
                  const E = [
                    "string.pattern",
                    v.invert ? ".invert" : "",
                    v.name ? ".name" : ".base",
                  ].join("");
                  return this.$_addRule({
                    name: "pattern",
                    args: { regex: y, options: v },
                    errorCode: E,
                  });
                },
                validate(y, v, E, S) {
                  let { regex: D, options: P } = E,
                    { errorCode: x } = S;
                  return D.test(y) ^ P.invert
                    ? y
                    : v.error(x, { name: P.name, regex: D, value: y });
                },
                args: ["regex", "options"],
                multi: !0,
              },
              replace: {
                method(y, v) {
                  typeof y == "string" && (y = new RegExp(c(y), "g")),
                    o(y instanceof RegExp, "pattern must be a RegExp"),
                    o(typeof v == "string", "replacement must be a String");
                  const E = this.clone();
                  return (
                    E.$_terms.replacements || (E.$_terms.replacements = []),
                    E.$_terms.replacements.push({ pattern: y, replacement: v }),
                    E
                  );
                },
              },
              token: {
                method() {
                  return this.$_addRule("token");
                },
                validate: (y, v) =>
                  /^\w+$/.test(y) ? y : v.error("string.token"),
              },
              trim: {
                method() {
                  let y =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    o(typeof y == "boolean", "enabled must be a boolean"),
                    this.$_addRule({ name: "trim", args: { enabled: y } })
                  );
                },
                validate(y, v, E) {
                  let { enabled: S } = E;
                  return S && y !== y.trim() ? v.error("string.trim") : y;
                },
                convert: !0,
              },
              truncate: {
                method() {
                  let y =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    o(typeof y == "boolean", "enabled must be a boolean"),
                    this.$_setFlag("truncate", y)
                  );
                },
              },
              uppercase: {
                method() {
                  return this.case("upper");
                },
              },
              uri: {
                method() {
                  let y =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(y, [
                    "allowRelative",
                    "allowQuerySquareBrackets",
                    "domain",
                    "relativeOnly",
                    "scheme",
                  ]),
                    y.domain &&
                      g.assertOptions(y.domain, [
                        "allowFullyQualified",
                        "allowUnicode",
                        "maxDomainSegments",
                        "minDomainSegments",
                        "tlds",
                      ]);
                  const { regex: v, scheme: E } = p.regex(y),
                    S = y.domain ? w.addressOptions(y.domain) : null;
                  return this.$_addRule({
                    name: "uri",
                    args: { options: y },
                    regex: v,
                    domain: S,
                    scheme: E,
                  });
                },
                validate(y, v, E, S) {
                  let { options: D } = E,
                    { regex: P, domain: x, scheme: _ } = S;
                  if (["http:/", "https:/"].includes(y))
                    return v.error("string.uri");
                  const A = P.exec(y);
                  if (A) {
                    const N = A[1] || A[2];
                    return !x || (D.allowRelative && !N) || l.isValid(N, x)
                      ? y
                      : v.error("string.domain", { value: N });
                  }
                  return D.relativeOnly
                    ? v.error("string.uriRelativeOnly")
                    : D.scheme
                    ? v.error("string.uriCustomScheme", { scheme: _, value: y })
                    : v.error("string.uri");
                },
              },
            },
            manifest: {
              build(y, v) {
                if (v.replacements)
                  for (const { pattern: E, replacement: S } of v.replacements)
                    y = y.replace(E, S);
                return y;
              },
            },
            messages: {
              "string.alphanum":
                "{{#label}} must only contain alpha-numeric characters",
              "string.base": "{{#label}} must be a string",
              "string.base64": "{{#label}} must be a valid base64 string",
              "string.creditCard": "{{#label}} must be a credit card",
              "string.dataUri": "{{#label}} must be a valid dataUri string",
              "string.domain": "{{#label}} must contain a valid domain name",
              "string.email": "{{#label}} must be a valid email",
              "string.empty": "{{#label}} is not allowed to be empty",
              "string.guid": "{{#label}} must be a valid GUID",
              "string.hex":
                "{{#label}} must only contain hexadecimal characters",
              "string.hexAlign":
                "{{#label}} hex decoded representation must be byte aligned",
              "string.hostname": "{{#label}} must be a valid hostname",
              "string.ip":
                "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
              "string.ipVersion":
                "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
              "string.isoDate": "{{#label}} must be in iso format",
              "string.isoDuration":
                "{{#label}} must be a valid ISO 8601 duration",
              "string.length":
                "{{#label}} length must be {{#limit}} characters long",
              "string.lowercase":
                "{{#label}} must only contain lowercase characters",
              "string.max":
                "{{#label}} length must be less than or equal to {{#limit}} characters long",
              "string.min":
                "{{#label}} length must be at least {{#limit}} characters long",
              "string.normalize":
                "{{#label}} must be unicode normalized in the {{#form}} form",
              "string.token":
                "{{#label}} must only contain alpha-numeric and underscore characters",
              "string.pattern.base":
                "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
              "string.pattern.name":
                "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
              "string.pattern.invert.base":
                "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
              "string.pattern.invert.name":
                "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
              "string.trim":
                "{{#label}} must not have leading or trailing whitespace",
              "string.uri": "{{#label}} must be a valid uri",
              "string.uriCustomScheme":
                "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
              "string.uriRelativeOnly":
                "{{#label}} must be a valid relative uri",
              "string.uppercase":
                "{{#label}} must only contain uppercase characters",
            },
          })),
            (w.addressOptions = function (y) {
              if (
                !y ||
                (o(
                  y.minDomainSegments === void 0 ||
                    (Number.isSafeInteger(y.minDomainSegments) &&
                      y.minDomainSegments > 0),
                  "minDomainSegments must be a positive integer"
                ),
                o(
                  y.maxDomainSegments === void 0 ||
                    (Number.isSafeInteger(y.maxDomainSegments) &&
                      y.maxDomainSegments > 0),
                  "maxDomainSegments must be a positive integer"
                ),
                y.tlds === !1)
              )
                return y;
              if (y.tlds === !0 || y.tlds === void 0)
                return (
                  o(w.tlds, "Built-in TLD list disabled"),
                  Object.assign({}, y, w.tlds)
                );
              o(
                typeof y.tlds == "object",
                "tlds must be true, false, or an object"
              );
              const v = y.tlds.deny;
              if (v)
                return (
                  Array.isArray(v) &&
                    (y = Object.assign({}, y, { tlds: { deny: new Set(v) } })),
                  o(
                    y.tlds.deny instanceof Set,
                    "tlds.deny must be an array, Set, or boolean"
                  ),
                  o(
                    !y.tlds.allow,
                    "Cannot specify both tlds.allow and tlds.deny lists"
                  ),
                  w.validateTlds(y.tlds.deny, "tlds.deny"),
                  y
                );
              const E = y.tlds.allow;
              return E
                ? E === !0
                  ? (o(w.tlds, "Built-in TLD list disabled"),
                    Object.assign({}, y, w.tlds))
                  : (Array.isArray(E) &&
                      (y = Object.assign({}, y, {
                        tlds: { allow: new Set(E) },
                      })),
                    o(
                      y.tlds.allow instanceof Set,
                      "tlds.allow must be an array, Set, or boolean"
                    ),
                    w.validateTlds(y.tlds.allow, "tlds.allow"),
                    y)
                : y;
            }),
            (w.validateTlds = function (y, v) {
              for (const E of y)
                o(
                  l.isValid(E, { minDomainSegments: 1, maxDomainSegments: 1 }),
                  `${v} must contain valid top level domain names`
                );
            }),
            (w.isoDate = function (y) {
              if (!g.isIsoDate(y)) return null;
              /.*T.*[+-]\d\d$/.test(y) && (y += "00");
              const v = new Date(y);
              return isNaN(v.getTime()) ? null : v.toISOString();
            }),
            (w.length = function (y, v, E, S, D) {
              return (
                o(!D || !1, "Invalid encoding:", D),
                y.$_addRule({
                  name: v,
                  method: "length",
                  args: { limit: E, encoding: D },
                  operator: S,
                })
              );
            });
        },
        8826: (i, s, a) => {
          const o = a(375),
            l = a(8068),
            u = {};
          (u.Map = class extends Map {
            slice() {
              return new u.Map(this);
            }
          }),
            (i.exports = l.extend({
              type: "symbol",
              terms: { map: { init: new u.Map() } },
              coerce: {
                method(f, c) {
                  let { schema: d, error: p } = c;
                  const m = d.$_terms.map.get(f);
                  return (
                    m && (f = m),
                    d._flags.only && typeof f != "symbol"
                      ? {
                          value: f,
                          errors: p("symbol.map", { map: d.$_terms.map }),
                        }
                      : { value: f }
                  );
                },
              },
              validate(f, c) {
                let { error: d } = c;
                if (typeof f != "symbol")
                  return { value: f, errors: d("symbol.base") };
              },
              rules: {
                map: {
                  method(f) {
                    f &&
                      !f[Symbol.iterator] &&
                      typeof f == "object" &&
                      (f = Object.entries(f)),
                      o(
                        f && f[Symbol.iterator],
                        "Iterable must be an iterable or object"
                      );
                    const c = this.clone(),
                      d = [];
                    for (const p of f) {
                      o(p && p[Symbol.iterator], "Entry must be an iterable");
                      const [m, g] = p;
                      o(
                        typeof m != "object" &&
                          typeof m != "function" &&
                          typeof m != "symbol",
                        "Key must not be of type object, function, or Symbol"
                      ),
                        o(typeof g == "symbol", "Value must be a Symbol"),
                        c.$_terms.map.set(m, g),
                        d.push(g);
                    }
                    return c.valid(...d);
                  },
                },
              },
              manifest: { build: (f, c) => (c.map && (f = f.map(c.map)), f) },
              messages: {
                "symbol.base": "{{#label}} must be a symbol",
                "symbol.map": "{{#label}} must be one of {{#map}}",
              },
            }));
        },
        8863: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(738),
            f = a(9621),
            c = a(8160),
            d = a(6354),
            p = a(493),
            m = { result: Symbol("result") };
          (s.entry = function (g, w, y) {
            let v = c.defaults;
            y &&
              (o(
                y.warnings === void 0,
                "Cannot override warnings preference in synchronous validation"
              ),
              o(
                y.artifacts === void 0,
                "Cannot override artifacts preference in synchronous validation"
              ),
              (v = c.preferences(c.defaults, y)));
            const E = m.entry(g, w, v);
            o(
              !E.mainstay.externals.length,
              "Schema with external rules must use validateAsync()"
            );
            const S = { value: E.value };
            return (
              E.error && (S.error = E.error),
              E.mainstay.warnings.length &&
                (S.warning = d.details(E.mainstay.warnings)),
              E.mainstay.debug && (S.debug = E.mainstay.debug),
              E.mainstay.artifacts && (S.artifacts = E.mainstay.artifacts),
              S
            );
          }),
            (s.entryAsync = async function (g, w, y) {
              let v = c.defaults;
              y && (v = c.preferences(c.defaults, y));
              const E = m.entry(g, w, v),
                S = E.mainstay;
              if (E.error)
                throw (S.debug && (E.error.debug = S.debug), E.error);
              if (S.externals.length) {
                let P = E.value;
                const x = [];
                for (const _ of S.externals) {
                  const A = _.state.path,
                    N = _.schema.type === "link" ? S.links.get(_.schema) : null;
                  let M,
                    T,
                    O = P;
                  const I = A.length ? [P] : [],
                    k = A.length ? f(g, A) : g;
                  if (A.length) {
                    M = A[A.length - 1];
                    let L = P;
                    for (const U of A.slice(0, -1)) (L = L[U]), I.unshift(L);
                    (T = I[0]), (O = T[M]);
                  }
                  try {
                    const L = ($, B) =>
                        (N || _.schema).$_createError($, O, B, _.state, v),
                      U = await _.method(O, {
                        schema: _.schema,
                        linked: N,
                        state: _.state,
                        prefs: y,
                        original: k,
                        error: L,
                        errorsArray: m.errorsArray,
                        warn: ($, B) =>
                          S.warnings.push(
                            (N || _.schema).$_createError($, O, B, _.state, v)
                          ),
                        message: ($, B) =>
                          (N || _.schema).$_createError(
                            "external",
                            O,
                            B,
                            _.state,
                            v,
                            { messages: $ }
                          ),
                      });
                    if (U === void 0 || U === O) continue;
                    if (U instanceof d.Report) {
                      if (
                        (S.tracer.log(
                          _.schema,
                          _.state,
                          "rule",
                          "external",
                          "error"
                        ),
                        x.push(U),
                        v.abortEarly)
                      )
                        break;
                      continue;
                    }
                    if (Array.isArray(U) && U[c.symbols.errors]) {
                      if (
                        (S.tracer.log(
                          _.schema,
                          _.state,
                          "rule",
                          "external",
                          "error"
                        ),
                        x.push(...U),
                        v.abortEarly)
                      )
                        break;
                      continue;
                    }
                    T
                      ? (S.tracer.value(_.state, "rule", O, U, "external"),
                        (T[M] = U))
                      : (S.tracer.value(_.state, "rule", P, U, "external"),
                        (P = U));
                  } catch (L) {
                    throw (v.errors.label && (L.message += ` (${_.label})`), L);
                  }
                }
                if (((E.value = P), x.length))
                  throw (
                    ((E.error = d.process(x, g, v)),
                    S.debug && (E.error.debug = S.debug),
                    E.error)
                  );
              }
              if (!v.warnings && !v.debug && !v.artifacts) return E.value;
              const D = { value: E.value };
              return (
                S.warnings.length && (D.warning = d.details(S.warnings)),
                S.debug && (D.debug = S.debug),
                S.artifacts && (D.artifacts = S.artifacts),
                D
              );
            }),
            (m.Mainstay = class {
              constructor(g, w, y) {
                (this.externals = []),
                  (this.warnings = []),
                  (this.tracer = g),
                  (this.debug = w),
                  (this.links = y),
                  (this.shadow = null),
                  (this.artifacts = null),
                  (this._snapshots = []);
              }
              snapshot() {
                this._snapshots.push({
                  externals: this.externals.slice(),
                  warnings: this.warnings.slice(),
                });
              }
              restore() {
                const g = this._snapshots.pop();
                (this.externals = g.externals), (this.warnings = g.warnings);
              }
            }),
            (m.entry = function (g, w, y) {
              const { tracer: v, cleanup: E } = m.tracer(w, y),
                S = y.debug ? [] : null,
                D = w._ids._schemaChain ? new Map() : null,
                P = new m.Mainstay(v, S, D),
                x = w._ids._schemaChain ? [{ schema: w }] : null,
                _ = new p([], [], { mainstay: P, schemas: x }),
                A = s.validate(g, w, _, y);
              E && w.$_root.untrace();
              const N = d.process(A.errors, g, y);
              return { value: A.value, error: N, mainstay: P };
            }),
            (m.tracer = function (g, w) {
              return g.$_root._tracer
                ? { tracer: g.$_root._tracer._register(g) }
                : w.debug
                ? (o(g.$_root.trace, "Debug mode not supported"),
                  { tracer: g.$_root.trace()._register(g), cleanup: !0 })
                : { tracer: m.ignore };
            }),
            (s.validate = function (g, w, y, v) {
              let E =
                arguments.length > 4 && arguments[4] !== void 0
                  ? arguments[4]
                  : {};
              if (
                (w.$_terms.whens && (w = w._generate(g, y, v).schema),
                w._preferences && (v = m.prefs(w, v)),
                w._cache && v.cache)
              ) {
                const N = w._cache.get(g);
                if ((y.mainstay.tracer.debug(y, "validate", "cached", !!N), N))
                  return N;
              }
              const S = (N, M, T) => w.$_createError(N, g, M, T || y, v),
                D = {
                  original: g,
                  prefs: v,
                  schema: w,
                  state: y,
                  error: S,
                  errorsArray: m.errorsArray,
                  warn: (N, M, T) => y.mainstay.warnings.push(S(N, M, T)),
                  message: (N, M) =>
                    w.$_createError("custom", g, M, y, v, { messages: N }),
                };
              y.mainstay.tracer.entry(w, y);
              const P = w._definition;
              if (P.prepare && g !== void 0 && v.convert) {
                const N = P.prepare(g, D);
                if (N) {
                  if (
                    (y.mainstay.tracer.value(y, "prepare", g, N.value),
                    N.errors)
                  )
                    return m.finalize(N.value, [].concat(N.errors), D);
                  g = N.value;
                }
              }
              if (
                P.coerce &&
                g !== void 0 &&
                v.convert &&
                (!P.coerce.from || P.coerce.from.includes(typeof g))
              ) {
                const N = P.coerce.method(g, D);
                if (N) {
                  if (
                    (y.mainstay.tracer.value(y, "coerced", g, N.value),
                    N.errors)
                  )
                    return m.finalize(N.value, [].concat(N.errors), D);
                  g = N.value;
                }
              }
              const x = w._flags.empty;
              x &&
                x.$_match(m.trim(g, w), y.nest(x), c.defaults) &&
                (y.mainstay.tracer.value(y, "empty", g, void 0), (g = void 0));
              const _ =
                E.presence ||
                w._flags.presence ||
                (w._flags._endedSwitch ? null : v.presence);
              if (g === void 0) {
                if (_ === "forbidden") return m.finalize(g, null, D);
                if (_ === "required")
                  return m.finalize(
                    g,
                    [w.$_createError("any.required", g, null, y, v)],
                    D
                  );
                if (_ === "optional") {
                  if (w._flags.default !== c.symbols.deepDefault)
                    return m.finalize(g, null, D);
                  y.mainstay.tracer.value(y, "default", g, {}), (g = {});
                }
              } else if (_ === "forbidden")
                return m.finalize(
                  g,
                  [w.$_createError("any.unknown", g, null, y, v)],
                  D
                );
              const A = [];
              if (w._valids) {
                const N = w._valids.get(g, y, v, w._flags.insensitive);
                if (N)
                  return (
                    v.convert &&
                      (y.mainstay.tracer.value(y, "valids", g, N.value),
                      (g = N.value)),
                    y.mainstay.tracer.filter(w, y, "valid", N),
                    m.finalize(g, null, D)
                  );
                if (w._flags.only) {
                  const M = w.$_createError(
                    "any.only",
                    g,
                    { valids: w._valids.values({ display: !0 }) },
                    y,
                    v
                  );
                  if (v.abortEarly) return m.finalize(g, [M], D);
                  A.push(M);
                }
              }
              if (w._invalids) {
                const N = w._invalids.get(g, y, v, w._flags.insensitive);
                if (N) {
                  y.mainstay.tracer.filter(w, y, "invalid", N);
                  const M = w.$_createError(
                    "any.invalid",
                    g,
                    { invalids: w._invalids.values({ display: !0 }) },
                    y,
                    v
                  );
                  if (v.abortEarly) return m.finalize(g, [M], D);
                  A.push(M);
                }
              }
              if (P.validate) {
                const N = P.validate(g, D);
                if (
                  N &&
                  (y.mainstay.tracer.value(y, "base", g, N.value),
                  (g = N.value),
                  N.errors)
                ) {
                  if (!Array.isArray(N.errors))
                    return A.push(N.errors), m.finalize(g, A, D);
                  if (N.errors.length)
                    return A.push(...N.errors), m.finalize(g, A, D);
                }
              }
              return w._rules.length ? m.rules(g, A, D) : m.finalize(g, A, D);
            }),
            (m.rules = function (g, w, y) {
              const { schema: v, state: E, prefs: S } = y;
              for (const D of v._rules) {
                const P = v._definition.rules[D.method];
                if (P.convert && S.convert) {
                  E.mainstay.tracer.log(v, E, "rule", D.name, "full");
                  continue;
                }
                let x,
                  _ = D.args;
                if (D._resolve.length) {
                  _ = Object.assign({}, _);
                  for (const N of D._resolve) {
                    const M = P.argsByName.get(N),
                      T = _[N].resolve(g, E, S),
                      O = M.normalize ? M.normalize(T) : T,
                      I = c.validateArg(O, null, M);
                    if (I) {
                      x = v.$_createError(
                        "any.ref",
                        T,
                        { arg: N, ref: _[N], reason: I },
                        E,
                        S
                      );
                      break;
                    }
                    _[N] = O;
                  }
                }
                x = x || P.validate(g, y, _, D);
                const A = m.rule(x, D);
                if (A.errors) {
                  if (
                    (E.mainstay.tracer.log(v, E, "rule", D.name, "error"),
                    D.warn)
                  ) {
                    E.mainstay.warnings.push(...A.errors);
                    continue;
                  }
                  if (S.abortEarly) return m.finalize(g, A.errors, y);
                  w.push(...A.errors);
                } else
                  E.mainstay.tracer.log(v, E, "rule", D.name, "pass"),
                    E.mainstay.tracer.value(E, "rule", g, A.value, D.name),
                    (g = A.value);
              }
              return m.finalize(g, w, y);
            }),
            (m.rule = function (g, w) {
              return g instanceof d.Report
                ? (m.error(g, w), { errors: [g], value: null })
                : Array.isArray(g) && g[c.symbols.errors]
                ? (g.forEach((y) => m.error(y, w)), { errors: g, value: null })
                : { errors: null, value: g };
            }),
            (m.error = function (g, w) {
              return w.message && g._setTemplate(w.message), g;
            }),
            (m.finalize = function (g, w, y) {
              w = w || [];
              const { schema: v, state: E, prefs: S } = y;
              if (w.length) {
                const P = m.default("failover", void 0, w, y);
                P !== void 0 &&
                  (E.mainstay.tracer.value(E, "failover", g, P),
                  (g = P),
                  (w = []));
              }
              if (w.length && v._flags.error)
                if (typeof v._flags.error == "function") {
                  (w = v._flags.error(w)), Array.isArray(w) || (w = [w]);
                  for (const P of w)
                    o(
                      P instanceof Error || P instanceof d.Report,
                      "error() must return an Error object"
                    );
                } else w = [v._flags.error];
              if (g === void 0) {
                const P = m.default("default", g, w, y);
                E.mainstay.tracer.value(E, "default", g, P), (g = P);
              }
              if (v._flags.cast && g !== void 0) {
                const P = v._definition.cast[v._flags.cast];
                if (P.from(g)) {
                  const x = P.to(g, y);
                  E.mainstay.tracer.value(E, "cast", g, x, v._flags.cast),
                    (g = x);
                }
              }
              if (v.$_terms.externals && S.externals && S._externals !== !1)
                for (const { method: P } of v.$_terms.externals)
                  E.mainstay.externals.push({
                    method: P,
                    schema: v,
                    state: E,
                    label: d.label(v._flags, E, S),
                  });
              const D = { value: g, errors: w.length ? w : null };
              return (
                v._flags.result &&
                  ((D.value =
                    v._flags.result === "strip" ? void 0 : y.original),
                  E.mainstay.tracer.value(E, v._flags.result, g, D.value),
                  E.shadow(g, v._flags.result)),
                v._cache &&
                  S.cache !== !1 &&
                  !v._refs.length &&
                  v._cache.set(y.original, D),
                g === void 0 ||
                  D.errors ||
                  v._flags.artifact === void 0 ||
                  ((E.mainstay.artifacts = E.mainstay.artifacts || new Map()),
                  E.mainstay.artifacts.has(v._flags.artifact) ||
                    E.mainstay.artifacts.set(v._flags.artifact, []),
                  E.mainstay.artifacts.get(v._flags.artifact).push(E.path)),
                D
              );
            }),
            (m.prefs = function (g, w) {
              const y = w === c.defaults;
              return y && g._preferences[c.symbols.prefs]
                ? g._preferences[c.symbols.prefs]
                : ((w = c.preferences(w, g._preferences)),
                  y && (g._preferences[c.symbols.prefs] = w),
                  w);
            }),
            (m.default = function (g, w, y, v) {
              const { schema: E, state: S, prefs: D } = v,
                P = E._flags[g];
              if (D.noDefaults || P === void 0) return w;
              if ((S.mainstay.tracer.log(E, S, "rule", g, "full"), !P))
                return P;
              if (typeof P == "function") {
                const x = P.length ? [l(S.ancestors[0]), v] : [];
                try {
                  return P(...x);
                } catch (_) {
                  return void y.push(
                    E.$_createError(`any.${g}`, null, { error: _ }, S, D)
                  );
                }
              }
              return typeof P != "object"
                ? P
                : P[c.symbols.literal]
                ? P.literal
                : c.isResolvable(P)
                ? P.resolve(w, S, D)
                : l(P);
            }),
            (m.trim = function (g, w) {
              if (typeof g != "string") return g;
              const y = w.$_getRule("trim");
              return y && y.args.enabled ? g.trim() : g;
            }),
            (m.ignore = {
              active: !1,
              debug: u,
              entry: u,
              filter: u,
              log: u,
              resolve: u,
              value: u,
            }),
            (m.errorsArray = function () {
              const g = [];
              return (g[c.symbols.errors] = !0), g;
            });
        },
        2036: (i, s, a) => {
          const o = a(375),
            l = a(9474),
            u = a(8160),
            f = {};
          (i.exports = f.Values =
            class {
              constructor(c, d) {
                (this._values = new Set(c)),
                  (this._refs = new Set(d)),
                  (this._lowercase = f.lowercases(c)),
                  (this._override = !1);
              }
              get length() {
                return this._values.size + this._refs.size;
              }
              add(c, d) {
                u.isResolvable(c)
                  ? this._refs.has(c) || (this._refs.add(c), d && d.register(c))
                  : this.has(c, null, null, !1) ||
                    (this._values.add(c),
                    typeof c == "string" &&
                      this._lowercase.set(c.toLowerCase(), c));
              }
              static merge(c, d, p) {
                if (((c = c || new f.Values()), d)) {
                  if (d._override) return d.clone();
                  for (const m of [...d._values, ...d._refs]) c.add(m);
                }
                if (p) for (const m of [...p._values, ...p._refs]) c.remove(m);
                return c.length ? c : null;
              }
              remove(c) {
                u.isResolvable(c)
                  ? this._refs.delete(c)
                  : (this._values.delete(c),
                    typeof c == "string" &&
                      this._lowercase.delete(c.toLowerCase()));
              }
              has(c, d, p, m) {
                return !!this.get(c, d, p, m);
              }
              get(c, d, p, m) {
                if (!this.length) return !1;
                if (this._values.has(c)) return { value: c };
                if (typeof c == "string" && c && m) {
                  const g = this._lowercase.get(c.toLowerCase());
                  if (g) return { value: g };
                }
                if (!this._refs.size && typeof c != "object") return !1;
                if (typeof c == "object") {
                  for (const g of this._values)
                    if (l(g, c)) return { value: g };
                }
                if (d)
                  for (const g of this._refs) {
                    const w = g.resolve(c, d, p, null, { in: !0 });
                    if (w === void 0) continue;
                    const y =
                      g.in && typeof w == "object"
                        ? Array.isArray(w)
                          ? w
                          : Object.keys(w)
                        : [w];
                    for (const v of y)
                      if (typeof v == typeof c) {
                        if (m && c && typeof c == "string") {
                          if (v.toLowerCase() === c.toLowerCase())
                            return { value: v, ref: g };
                        } else if (l(v, c)) return { value: v, ref: g };
                      }
                  }
                return !1;
              }
              override() {
                this._override = !0;
              }
              values(c) {
                if (c && c.display) {
                  const d = [];
                  for (const p of [...this._values, ...this._refs])
                    p !== void 0 && d.push(p);
                  return d;
                }
                return Array.from([...this._values, ...this._refs]);
              }
              clone() {
                const c = new f.Values(this._values, this._refs);
                return (c._override = this._override), c;
              }
              concat(c) {
                o(!c._override, "Cannot concat override set of values");
                const d = new f.Values(
                  [...this._values, ...c._values],
                  [...this._refs, ...c._refs]
                );
                return (d._override = this._override), d;
              }
              describe() {
                const c = [];
                this._override && c.push({ override: !0 });
                for (const d of this._values.values())
                  c.push(d && typeof d == "object" ? { value: d } : d);
                for (const d of this._refs.values()) c.push(d.describe());
                return c;
              }
            }),
            (f.Values.prototype[u.symbols.values] = !0),
            (f.Values.prototype.slice = f.Values.prototype.clone),
            (f.lowercases = function (c) {
              const d = new Map();
              if (c)
                for (const p of c)
                  typeof p == "string" && d.set(p.toLowerCase(), p);
              return d;
            });
        },
        978: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(1687),
            f = a(9621),
            c = {};
          (i.exports = function (d, p) {
            let m =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {};
            if (
              (o(
                d && typeof d == "object",
                "Invalid defaults value: must be an object"
              ),
              o(
                !p || p === !0 || typeof p == "object",
                "Invalid source value: must be true, falsy or an object"
              ),
              o(typeof m == "object", "Invalid options: must be an object"),
              !p)
            )
              return null;
            if (m.shallow) return c.applyToDefaultsWithShallow(d, p, m);
            const g = l(d);
            if (p === !0) return g;
            const w = m.nullOverride !== void 0 && m.nullOverride;
            return u(g, p, { nullOverride: w, mergeArrays: !1 });
          }),
            (c.applyToDefaultsWithShallow = function (d, p, m) {
              const g = m.shallow;
              o(Array.isArray(g), "Invalid keys");
              const w = new Map(),
                y = p === !0 ? null : new Set();
              for (let S of g) {
                S = Array.isArray(S) ? S : S.split(".");
                const D = f(d, S);
                D && typeof D == "object"
                  ? w.set(D, (y && f(p, S)) || D)
                  : y && y.add(S);
              }
              const v = l(d, {}, w);
              if (!y) return v;
              for (const S of y) c.reachCopy(v, p, S);
              const E = m.nullOverride !== void 0 && m.nullOverride;
              return u(v, p, { nullOverride: E, mergeArrays: !1 });
            }),
            (c.reachCopy = function (d, p, m) {
              for (const y of m) {
                if (!(y in p)) return;
                const v = p[y];
                if (typeof v != "object" || v === null) return;
                p = v;
              }
              const g = p;
              let w = d;
              for (let y = 0; y < m.length - 1; ++y) {
                const v = m[y];
                typeof w[v] != "object" && (w[v] = {}), (w = w[v]);
              }
              w[m[m.length - 1]] = g;
            });
        },
        375: (i, s, a) => {
          const o = a(7916);
          i.exports = function (l) {
            if (!l) {
              for (
                var u = arguments.length,
                  f = new Array(u > 1 ? u - 1 : 0),
                  c = 1;
                c < u;
                c++
              )
                f[c - 1] = arguments[c];
              throw f.length === 1 && f[0] instanceof Error ? f[0] : new o(f);
            }
          };
        },
        8571: (i, s, a) => {
          const o = a(9621),
            l = a(4277),
            u = a(7043),
            f = {
              needsProtoHack: new Set([l.set, l.map, l.weakSet, l.weakMap]),
            };
          (i.exports = f.clone =
            function (c) {
              let d =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
                p =
                  arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : null;
              if (typeof c != "object" || c === null) return c;
              let m = f.clone,
                g = p;
              if (d.shallow) {
                if (d.shallow !== !0) return f.cloneWithShallow(c, d);
                m = (E) => E;
              } else if (g) {
                const E = g.get(c);
                if (E) return E;
              } else g = new Map();
              const w = l.getInternalProto(c);
              if (w === l.buffer) return !1;
              if (w === l.date) return new Date(c.getTime());
              if (w === l.regex) return new RegExp(c);
              const y = f.base(c, w, d);
              if (y === c) return c;
              if ((g && g.set(c, y), w === l.set))
                for (const E of c) y.add(m(E, d, g));
              else if (w === l.map)
                for (const [E, S] of c) y.set(E, m(S, d, g));
              const v = u.keys(c, d);
              for (const E of v) {
                if (E === "__proto__") continue;
                if (w === l.array && E === "length") {
                  y.length = c.length;
                  continue;
                }
                const S = Object.getOwnPropertyDescriptor(c, E);
                S
                  ? S.get || S.set
                    ? Object.defineProperty(y, E, S)
                    : S.enumerable
                    ? (y[E] = m(c[E], d, g))
                    : Object.defineProperty(y, E, {
                        enumerable: !1,
                        writable: !0,
                        configurable: !0,
                        value: m(c[E], d, g),
                      })
                  : Object.defineProperty(y, E, {
                      enumerable: !0,
                      writable: !0,
                      configurable: !0,
                      value: m(c[E], d, g),
                    });
              }
              return y;
            }),
            (f.cloneWithShallow = function (c, d) {
              const p = d.shallow;
              (d = Object.assign({}, d)).shallow = !1;
              const m = new Map();
              for (const g of p) {
                const w = o(c, g);
                (typeof w != "object" && typeof w != "function") || m.set(w, w);
              }
              return f.clone(c, d, m);
            }),
            (f.base = function (c, d, p) {
              if (p.prototype === !1)
                return f.needsProtoHack.has(d)
                  ? new d.constructor()
                  : d === l.array
                  ? []
                  : {};
              const m = Object.getPrototypeOf(c);
              if (m && m.isImmutable) return c;
              if (d === l.array) {
                const g = [];
                return m !== d && Object.setPrototypeOf(g, m), g;
              }
              if (f.needsProtoHack.has(d)) {
                const g = new m.constructor();
                return m !== d && Object.setPrototypeOf(g, m), g;
              }
              return Object.create(m);
            });
        },
        9474: (i, s, a) => {
          const o = a(4277),
            l = { mismatched: null };
          (i.exports = function (u, f, c) {
            return (
              (c = Object.assign({ prototype: !0 }, c)),
              !!l.isDeepEqual(u, f, c, [])
            );
          }),
            (l.isDeepEqual = function (u, f, c, d) {
              if (u === f) return u !== 0 || 1 / u == 1 / f;
              const p = typeof u;
              if (p !== typeof f || u === null || f === null) return !1;
              if (p === "function") {
                if (!c.deepFunction || u.toString() !== f.toString()) return !1;
              } else if (p !== "object") return u != u && f != f;
              const m = l.getSharedType(u, f, !!c.prototype);
              switch (m) {
                case o.buffer:
                  return !1;
                case o.promise:
                  return u === f;
                case o.regex:
                  return u.toString() === f.toString();
                case l.mismatched:
                  return !1;
              }
              for (let g = d.length - 1; g >= 0; --g)
                if (d[g].isSame(u, f)) return !0;
              d.push(new l.SeenEntry(u, f));
              try {
                return !!l.isDeepEqualObj(m, u, f, c, d);
              } finally {
                d.pop();
              }
            }),
            (l.getSharedType = function (u, f, c) {
              if (c)
                return Object.getPrototypeOf(u) !== Object.getPrototypeOf(f)
                  ? l.mismatched
                  : o.getInternalProto(u);
              const d = o.getInternalProto(u);
              return d !== o.getInternalProto(f) ? l.mismatched : d;
            }),
            (l.valueOf = function (u) {
              const f = u.valueOf;
              if (f === void 0) return u;
              try {
                return f.call(u);
              } catch (c) {
                return c;
              }
            }),
            (l.hasOwnEnumerableProperty = function (u, f) {
              return Object.prototype.propertyIsEnumerable.call(u, f);
            }),
            (l.isSetSimpleEqual = function (u, f) {
              for (const c of Set.prototype.values.call(u))
                if (!Set.prototype.has.call(f, c)) return !1;
              return !0;
            }),
            (l.isDeepEqualObj = function (u, f, c, d, p) {
              const {
                  isDeepEqual: m,
                  valueOf: g,
                  hasOwnEnumerableProperty: w,
                } = l,
                { keys: y, getOwnPropertySymbols: v } = Object;
              if (u === o.array) {
                if (!d.part) {
                  if (f.length !== c.length) return !1;
                  for (let x = 0; x < f.length; ++x)
                    if (!m(f[x], c[x], d, p)) return !1;
                  return !0;
                }
                for (const x of f)
                  for (const _ of c) if (m(x, _, d, p)) return !0;
              } else if (u === o.set) {
                if (f.size !== c.size) return !1;
                if (!l.isSetSimpleEqual(f, c)) {
                  const x = new Set(Set.prototype.values.call(c));
                  for (const _ of Set.prototype.values.call(f)) {
                    if (x.delete(_)) continue;
                    let A = !1;
                    for (const N of x)
                      if (m(_, N, d, p)) {
                        x.delete(N), (A = !0);
                        break;
                      }
                    if (!A) return !1;
                  }
                }
              } else if (u === o.map) {
                if (f.size !== c.size) return !1;
                for (const [x, _] of Map.prototype.entries.call(f))
                  if (
                    (_ === void 0 && !Map.prototype.has.call(c, x)) ||
                    !m(_, Map.prototype.get.call(c, x), d, p)
                  )
                    return !1;
              } else if (
                u === o.error &&
                (f.name !== c.name || f.message !== c.message)
              )
                return !1;
              const E = g(f),
                S = g(c);
              if ((f !== E || c !== S) && !m(E, S, d, p)) return !1;
              const D = y(f);
              if (!d.part && D.length !== y(c).length && !d.skip) return !1;
              let P = 0;
              for (const x of D)
                if (d.skip && d.skip.includes(x)) c[x] === void 0 && ++P;
                else if (!w(c, x) || !m(f[x], c[x], d, p)) return !1;
              if (!d.part && D.length - P !== y(c).length) return !1;
              if (d.symbols !== !1) {
                const x = v(f),
                  _ = new Set(v(c));
                for (const A of x) {
                  if (!d.skip || !d.skip.includes(A)) {
                    if (w(f, A)) {
                      if (!w(c, A) || !m(f[A], c[A], d, p)) return !1;
                    } else if (w(c, A)) return !1;
                  }
                  _.delete(A);
                }
                for (const A of _) if (w(c, A)) return !1;
              }
              return !0;
            }),
            (l.SeenEntry = class {
              constructor(u, f) {
                (this.obj = u), (this.ref = f);
              }
              isSame(u, f) {
                return this.obj === u && this.ref === f;
              }
            });
        },
        7916: (i, s, a) => {
          const o = a(8761);
          i.exports = class extends Error {
            constructor(l) {
              super(
                l
                  .filter((u) => u !== "")
                  .map((u) =>
                    typeof u == "string"
                      ? u
                      : u instanceof Error
                      ? u.message
                      : o(u)
                  )
                  .join(" ") || "Unknown error"
              ),
                typeof Error.captureStackTrace == "function" &&
                  Error.captureStackTrace(this, s.assert);
            }
          };
        },
        5277: (i) => {
          const s = {};
          (i.exports = function (a) {
            if (!a) return "";
            let o = "";
            for (let l = 0; l < a.length; ++l) {
              const u = a.charCodeAt(l);
              s.isSafe(u) ? (o += a[l]) : (o += s.escapeHtmlChar(u));
            }
            return o;
          }),
            (s.escapeHtmlChar = function (a) {
              return (
                s.namedHtml.get(a) ||
                (a >= 256
                  ? "&#" + a + ";"
                  : `&#x${a.toString(16).padStart(2, "0")};`)
              );
            }),
            (s.isSafe = function (a) {
              return s.safeCharCodes.has(a);
            }),
            (s.namedHtml = new Map([
              [38, "&amp;"],
              [60, "&lt;"],
              [62, "&gt;"],
              [34, "&quot;"],
              [160, "&nbsp;"],
              [162, "&cent;"],
              [163, "&pound;"],
              [164, "&curren;"],
              [169, "&copy;"],
              [174, "&reg;"],
            ])),
            (s.safeCharCodes = (function () {
              const a = new Set();
              for (let o = 32; o < 123; ++o)
                (o >= 97 ||
                  (o >= 65 && o <= 90) ||
                  (o >= 48 && o <= 57) ||
                  o === 32 ||
                  o === 46 ||
                  o === 44 ||
                  o === 45 ||
                  o === 58 ||
                  o === 95) &&
                  a.add(o);
              return a;
            })());
        },
        6064: (i) => {
          i.exports = function (s) {
            return s.replace(
              /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,
              "\\$&"
            );
          };
        },
        738: (i) => {
          i.exports = function () {};
        },
        1687: (i, s, a) => {
          const o = a(375),
            l = a(8571),
            u = a(7043),
            f = {};
          i.exports = f.merge = function (c, d, p) {
            if (
              (o(
                c && typeof c == "object",
                "Invalid target value: must be an object"
              ),
              o(
                d == null || typeof d == "object",
                "Invalid source value: must be null, undefined, or an object"
              ),
              !d)
            )
              return c;
            if (
              ((p = Object.assign({ nullOverride: !0, mergeArrays: !0 }, p)),
              Array.isArray(d))
            ) {
              o(Array.isArray(c), "Cannot merge array onto an object"),
                p.mergeArrays || (c.length = 0);
              for (let g = 0; g < d.length; ++g)
                c.push(l(d[g], { symbols: p.symbols }));
              return c;
            }
            const m = u.keys(d, p);
            for (let g = 0; g < m.length; ++g) {
              const w = m[g];
              if (
                w === "__proto__" ||
                !Object.prototype.propertyIsEnumerable.call(d, w)
              )
                continue;
              const y = d[w];
              if (y && typeof y == "object") {
                if (c[w] === y) continue;
                !c[w] ||
                typeof c[w] != "object" ||
                Array.isArray(c[w]) !== Array.isArray(y) ||
                y instanceof Date ||
                y instanceof RegExp
                  ? (c[w] = l(y, { symbols: p.symbols }))
                  : f.merge(c[w], y, p);
              } else (y != null || p.nullOverride) && (c[w] = y);
            }
            return c;
          };
        },
        9621: (i, s, a) => {
          const o = a(375),
            l = {};
          (i.exports = function (u, f, c) {
            if (f === !1 || f == null) return u;
            typeof (c = c || {}) == "string" && (c = { separator: c });
            const d = Array.isArray(f);
            o(
              !d || !c.separator,
              "Separator option is not valid for array-based chain"
            );
            const p = d ? f : f.split(c.separator || ".");
            let m = u;
            for (let g = 0; g < p.length; ++g) {
              let w = p[g];
              const y = c.iterables && l.iterables(m);
              if (Array.isArray(m) || y === "set") {
                const v = Number(w);
                Number.isInteger(v) && (w = v < 0 ? m.length + v : v);
              }
              if (
                !m ||
                (typeof m == "function" && c.functions === !1) ||
                (!y && m[w] === void 0)
              ) {
                o(
                  !c.strict || g + 1 === p.length,
                  "Missing segment",
                  w,
                  "in reach path ",
                  f
                ),
                  o(
                    typeof m == "object" ||
                      c.functions === !0 ||
                      typeof m != "function",
                    "Invalid segment",
                    w,
                    "in reach path ",
                    f
                  ),
                  (m = c.default);
                break;
              }
              m = y ? (y === "set" ? [...m][w] : m.get(w)) : m[w];
            }
            return m;
          }),
            (l.iterables = function (u) {
              return u instanceof Set
                ? "set"
                : u instanceof Map
                ? "map"
                : void 0;
            });
        },
        8761: (i) => {
          i.exports = function () {
            try {
              return JSON.stringify(...arguments);
            } catch (s) {
              return "[Cannot display object: " + s.message + "]";
            }
          };
        },
        4277: (i, s) => {
          const a = {};
          (s = i.exports =
            {
              array: Array.prototype,
              buffer: !1,
              date: Date.prototype,
              error: Error.prototype,
              generic: Object.prototype,
              map: Map.prototype,
              promise: Promise.prototype,
              regex: RegExp.prototype,
              set: Set.prototype,
              weakMap: WeakMap.prototype,
              weakSet: WeakSet.prototype,
            }),
            (a.typeMap = new Map([
              ["[object Error]", s.error],
              ["[object Map]", s.map],
              ["[object Promise]", s.promise],
              ["[object Set]", s.set],
              ["[object WeakMap]", s.weakMap],
              ["[object WeakSet]", s.weakSet],
            ])),
            (s.getInternalProto = function (o) {
              if (Array.isArray(o)) return s.array;
              if (o instanceof Date) return s.date;
              if (o instanceof RegExp) return s.regex;
              if (o instanceof Error) return s.error;
              const l = Object.prototype.toString.call(o);
              return a.typeMap.get(l) || s.generic;
            });
        },
        7043: (i, s) => {
          s.keys = function (a) {
            return (arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : {}
            ).symbols !== !1
              ? Reflect.ownKeys(a)
              : Object.getOwnPropertyNames(a);
          };
        },
        3652: (i, s, a) => {
          const o = a(375),
            l = {};
          (s.Sorter = class {
            constructor() {
              (this._items = []), (this.nodes = []);
            }
            add(u, f) {
              const c = [].concat((f = f || {}).before || []),
                d = [].concat(f.after || []),
                p = f.group || "?",
                m = f.sort || 0;
              o(!c.includes(p), `Item cannot come before itself: ${p}`),
                o(
                  !c.includes("?"),
                  "Item cannot come before unassociated items"
                ),
                o(!d.includes(p), `Item cannot come after itself: ${p}`),
                o(
                  !d.includes("?"),
                  "Item cannot come after unassociated items"
                ),
                Array.isArray(u) || (u = [u]);
              for (const g of u) {
                const w = {
                  seq: this._items.length,
                  sort: m,
                  before: c,
                  after: d,
                  group: p,
                  node: g,
                };
                this._items.push(w);
              }
              if (!f.manual) {
                const g = this._sort();
                o(
                  g,
                  "item",
                  p !== "?" ? `added into group ${p}` : "",
                  "created a dependencies error"
                );
              }
              return this.nodes;
            }
            merge(u) {
              Array.isArray(u) || (u = [u]);
              for (const c of u)
                if (c)
                  for (const d of c._items)
                    this._items.push(Object.assign({}, d));
              this._items.sort(l.mergeSort);
              for (let c = 0; c < this._items.length; ++c)
                this._items[c].seq = c;
              const f = this._sort();
              return o(f, "merge created a dependencies error"), this.nodes;
            }
            sort() {
              const u = this._sort();
              return o(u, "sort created a dependencies error"), this.nodes;
            }
            _sort() {
              const u = {},
                f = Object.create(null),
                c = Object.create(null);
              for (const w of this._items) {
                const y = w.seq,
                  v = w.group;
                (c[v] = c[v] || []), c[v].push(y), (u[y] = w.before);
                for (const E of w.after) (f[E] = f[E] || []), f[E].push(y);
              }
              for (const w in u) {
                const y = [];
                for (const v in u[w]) {
                  const E = u[w][v];
                  (c[E] = c[E] || []), y.push(...c[E]);
                }
                u[w] = y;
              }
              for (const w in f)
                if (c[w]) for (const y of c[w]) u[y].push(...f[w]);
              const d = {};
              for (const w in u) {
                const y = u[w];
                for (const v of y) (d[v] = d[v] || []), d[v].push(w);
              }
              const p = {},
                m = [];
              for (let w = 0; w < this._items.length; ++w) {
                let y = w;
                if (d[w]) {
                  y = null;
                  for (let v = 0; v < this._items.length; ++v) {
                    if (p[v] === !0) continue;
                    d[v] || (d[v] = []);
                    const E = d[v].length;
                    let S = 0;
                    for (let D = 0; D < E; ++D) p[d[v][D]] && ++S;
                    if (S === E) {
                      y = v;
                      break;
                    }
                  }
                }
                y !== null && ((p[y] = !0), m.push(y));
              }
              if (m.length !== this._items.length) return !1;
              const g = {};
              for (const w of this._items) g[w.seq] = w;
              (this._items = []), (this.nodes = []);
              for (const w of m) {
                const y = g[w];
                this.nodes.push(y.node), this._items.push(y);
              }
              return !0;
            }
          }),
            (l.mergeSort = (u, f) =>
              u.sort === f.sort ? 0 : u.sort < f.sort ? -1 : 1);
        },
        5380: (i, s, a) => {
          const o = a(443),
            l = a(2178),
            u = {
              minDomainSegments: 2,
              nonAsciiRx: /[^\x00-\x7f]/,
              domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
              tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
              domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
              URL: o.URL || URL,
            };
          (s.analyze = function (f) {
            let c =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {};
            if (!f) return l.code("DOMAIN_NON_EMPTY_STRING");
            if (typeof f != "string")
              throw new Error("Invalid input: domain must be a string");
            if (f.length > 256) return l.code("DOMAIN_TOO_LONG");
            if (u.nonAsciiRx.test(f)) {
              if (c.allowUnicode === !1)
                return l.code("DOMAIN_INVALID_UNICODE_CHARS");
              f = f.normalize("NFC");
            }
            if (u.domainControlRx.test(f))
              return l.code("DOMAIN_INVALID_CHARS");
            (f = u.punycode(f)),
              c.allowFullyQualified &&
                f[f.length - 1] === "." &&
                (f = f.slice(0, -1));
            const d = c.minDomainSegments || u.minDomainSegments,
              p = f.split(".");
            if (p.length < d) return l.code("DOMAIN_SEGMENTS_COUNT");
            if (c.maxDomainSegments && p.length > c.maxDomainSegments)
              return l.code("DOMAIN_SEGMENTS_COUNT_MAX");
            const m = c.tlds;
            if (m) {
              const g = p[p.length - 1].toLowerCase();
              if ((m.deny && m.deny.has(g)) || (m.allow && !m.allow.has(g)))
                return l.code("DOMAIN_FORBIDDEN_TLDS");
            }
            for (let g = 0; g < p.length; ++g) {
              const w = p[g];
              if (!w.length) return l.code("DOMAIN_EMPTY_SEGMENT");
              if (w.length > 63) return l.code("DOMAIN_LONG_SEGMENT");
              if (g < p.length - 1) {
                if (!u.domainSegmentRx.test(w))
                  return l.code("DOMAIN_INVALID_CHARS");
              } else if (!u.tldSegmentRx.test(w))
                return l.code("DOMAIN_INVALID_TLDS_CHARS");
            }
            return null;
          }),
            (s.isValid = function (f, c) {
              return !s.analyze(f, c);
            }),
            (u.punycode = function (f) {
              f.includes("%") && (f = f.replace(/%/g, "%25"));
              try {
                return new u.URL(`http://${f}`).host;
              } catch {
                return f;
              }
            });
        },
        1745: (i, s, a) => {
          const o = a(9848),
            l = a(5380),
            u = a(2178),
            f = {
              nonAsciiRx: /[^\x00-\x7f]/,
              encoder: new (o.TextEncoder || TextEncoder)(),
            };
          (s.analyze = function (c, d) {
            return f.email(c, d);
          }),
            (s.isValid = function (c, d) {
              return !f.email(c, d);
            }),
            (f.email = function (c) {
              let d =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              if (typeof c != "string")
                throw new Error("Invalid input: email must be a string");
              if (!c) return u.code("EMPTY_STRING");
              const p = !f.nonAsciiRx.test(c);
              if (!p) {
                if (d.allowUnicode === !1) return u.code("FORBIDDEN_UNICODE");
                c = c.normalize("NFC");
              }
              const m = c.split("@");
              if (m.length !== 2)
                return m.length > 2
                  ? u.code("MULTIPLE_AT_CHAR")
                  : u.code("MISSING_AT_CHAR");
              const [g, w] = m;
              if (!g) return u.code("EMPTY_LOCAL");
              if (!d.ignoreLength) {
                if (c.length > 254) return u.code("ADDRESS_TOO_LONG");
                if (f.encoder.encode(g).length > 64)
                  return u.code("LOCAL_TOO_LONG");
              }
              return f.local(g, p) || l.analyze(w, d);
            }),
            (f.local = function (c, d) {
              const p = c.split(".");
              for (const m of p) {
                if (!m.length) return u.code("EMPTY_LOCAL_SEGMENT");
                if (d) {
                  if (!f.atextRx.test(m)) return u.code("INVALID_LOCAL_CHARS");
                } else
                  for (const g of m) {
                    if (f.atextRx.test(g)) continue;
                    const w = f.binary(g);
                    if (!f.atomRx.test(w)) return u.code("INVALID_LOCAL_CHARS");
                  }
              }
            }),
            (f.binary = function (c) {
              return Array.from(f.encoder.encode(c))
                .map((d) => String.fromCharCode(d))
                .join("");
            }),
            (f.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/),
            (f.atomRx = new RegExp(
              [
                "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
                "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
                "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})",
              ].join("|")
            ));
        },
        2178: (i, s) => {
          (s.codes = {
            EMPTY_STRING: "Address must be a non-empty string",
            FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
            MULTIPLE_AT_CHAR:
              "Address cannot contain more than one @ character",
            MISSING_AT_CHAR: "Address must contain one @ character",
            EMPTY_LOCAL: "Address local part cannot be empty",
            ADDRESS_TOO_LONG: "Address too long",
            LOCAL_TOO_LONG: "Address local part too long",
            EMPTY_LOCAL_SEGMENT:
              "Address local part contains empty dot-separated segment",
            INVALID_LOCAL_CHARS:
              "Address local part contains invalid character",
            DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
            DOMAIN_TOO_LONG: "Domain too long",
            DOMAIN_INVALID_UNICODE_CHARS:
              "Domain contains forbidden Unicode characters",
            DOMAIN_INVALID_CHARS: "Domain contains invalid character",
            DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
            DOMAIN_SEGMENTS_COUNT:
              "Domain lacks the minimum required number of segments",
            DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
            DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
            DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
            DOMAIN_LONG_SEGMENT:
              "Domain contains dot-separated segment that is too long",
          }),
            (s.code = function (a) {
              return { code: a, error: s.codes[a] };
            });
        },
        9959: (i, s, a) => {
          const o = a(375),
            l = a(5752);
          s.regex = function () {
            let u =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {};
            o(
              u.cidr === void 0 || typeof u.cidr == "string",
              "options.cidr must be a string"
            );
            const f = u.cidr ? u.cidr.toLowerCase() : "optional";
            o(
              ["required", "optional", "forbidden"].includes(f),
              "options.cidr must be one of required, optional, forbidden"
            ),
              o(
                u.version === void 0 ||
                  typeof u.version == "string" ||
                  Array.isArray(u.version),
                "options.version must be a string or an array of string"
              );
            let c = u.version || ["ipv4", "ipv6", "ipvfuture"];
            Array.isArray(c) || (c = [c]),
              o(
                c.length >= 1,
                "options.version must have at least 1 version specified"
              );
            for (let m = 0; m < c.length; ++m)
              o(
                typeof c[m] == "string",
                "options.version must only contain strings"
              ),
                (c[m] = c[m].toLowerCase()),
                o(
                  ["ipv4", "ipv6", "ipvfuture"].includes(c[m]),
                  "options.version contains unknown version " +
                    c[m] +
                    " - must be one of ipv4, ipv6, ipvfuture"
                );
            c = Array.from(new Set(c));
            const d = `(?:${c
                .map((m) => {
                  if (f === "forbidden") return l.ip[m];
                  const g = `\\/${m === "ipv4" ? l.ip.v4Cidr : l.ip.v6Cidr}`;
                  return f === "required"
                    ? `${l.ip[m]}${g}`
                    : `${l.ip[m]}(?:${g})?`;
                })
                .join("|")})`,
              p = new RegExp(`^${d}$`);
            return { cidr: f, versions: c, regex: p, raw: d };
          };
        },
        5752: (i, s, a) => {
          const o = a(375),
            l = a(6064),
            u = {
              generate: function () {
                const f = {},
                  c = "\\dA-Fa-f",
                  d = "[" + c + "]",
                  p = "\\w-\\.~",
                  m = "!\\$&'\\(\\)\\*\\+,;=",
                  g = "%" + c,
                  w = p + g + m + ":@",
                  y = "[" + w + "]",
                  v = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
                f.ipv4address = "(?:" + v + "\\.){3}" + v;
                const E = d + "{1,4}",
                  S = "(?:" + E + ":" + E + "|" + f.ipv4address + ")",
                  D = "(?:" + E + ":){6}" + S,
                  P = "::(?:" + E + ":){5}" + S,
                  x = "(?:" + E + ")?::(?:" + E + ":){4}" + S,
                  _ =
                    "(?:(?:" + E + ":){0,1}" + E + ")?::(?:" + E + ":){3}" + S,
                  A =
                    "(?:(?:" + E + ":){0,2}" + E + ")?::(?:" + E + ":){2}" + S,
                  N = "(?:(?:" + E + ":){0,3}" + E + ")?::" + E + ":" + S,
                  M = "(?:(?:" + E + ":){0,4}" + E + ")?::" + S,
                  T = "(?:(?:" + E + ":){0,5}" + E + ")?::" + E,
                  O = "(?:(?:" + E + ":){0,6}" + E + ")?::";
                (f.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])"),
                  (f.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])"),
                  (f.ipv6address =
                    "(?:" +
                    D +
                    "|" +
                    P +
                    "|" +
                    x +
                    "|" +
                    _ +
                    "|" +
                    A +
                    "|" +
                    N +
                    "|" +
                    M +
                    "|" +
                    T +
                    "|" +
                    O +
                    ")"),
                  (f.ipvFuture = "v" + d + "+\\.[" + p + m + ":]+"),
                  (f.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*"),
                  (f.schemeRegex = new RegExp(f.scheme));
                const I = "[" + p + g + m + ":]*",
                  k = "[" + p + g + m + "]{1,255}",
                  L =
                    "(?:\\[(?:" +
                    f.ipv6address +
                    "|" +
                    f.ipvFuture +
                    ")\\]|" +
                    f.ipv4address +
                    "|" +
                    k +
                    ")",
                  U = "(?:" + I + "@)?" + L + "(?::\\d*)?",
                  $ = "(?:" + I + "@)?(" + L + ")(?::\\d*)?",
                  B = y + "*",
                  R = y + "+",
                  V = "(?:\\/" + B + ")*",
                  oe = "\\/(?:" + R + V + ")?",
                  le = R + V,
                  fe = "[" + p + g + m + "@]+" + V,
                  z = "(?:\\/\\/\\/" + B + V + ")";
                return (
                  (f.hierPart =
                    "(?:(?:\\/\\/" +
                    U +
                    V +
                    ")|" +
                    oe +
                    "|" +
                    le +
                    "|" +
                    z +
                    ")"),
                  (f.hierPartCapture =
                    "(?:(?:\\/\\/" + $ + V + ")|" + oe + "|" + le + ")"),
                  (f.relativeRef =
                    "(?:(?:\\/\\/" + U + V + ")|" + oe + "|" + fe + "|)"),
                  (f.relativeRefCapture =
                    "(?:(?:\\/\\/" + $ + V + ")|" + oe + "|" + fe + "|)"),
                  (f.query = "[" + w + "\\/\\?]*(?=#|$)"),
                  (f.queryWithSquareBrackets =
                    "[" + w + "\\[\\]\\/\\?]*(?=#|$)"),
                  (f.fragment = "[" + w + "\\/\\?]*"),
                  f
                );
              },
            };
          (u.rfc3986 = u.generate()),
            (s.ip = {
              v4Cidr: u.rfc3986.ipv4Cidr,
              v6Cidr: u.rfc3986.ipv6Cidr,
              ipv4: u.rfc3986.ipv4address,
              ipv6: u.rfc3986.ipv6address,
              ipvfuture: u.rfc3986.ipvFuture,
            }),
            (u.createRegex = function (f) {
              const c = u.rfc3986,
                d =
                  "(?:\\?" +
                  (f.allowQuerySquareBrackets
                    ? c.queryWithSquareBrackets
                    : c.query) +
                  ")?(?:#" +
                  c.fragment +
                  ")?",
                p = f.domain ? c.relativeRefCapture : c.relativeRef;
              if (f.relativeOnly) return u.wrap(p + d);
              let m = "";
              if (f.scheme) {
                o(
                  f.scheme instanceof RegExp ||
                    typeof f.scheme == "string" ||
                    Array.isArray(f.scheme),
                  "scheme must be a RegExp, String, or Array"
                );
                const y = [].concat(f.scheme);
                o(
                  y.length >= 1,
                  "scheme must have at least 1 scheme specified"
                );
                const v = [];
                for (let E = 0; E < y.length; ++E) {
                  const S = y[E];
                  o(
                    S instanceof RegExp || typeof S == "string",
                    "scheme at position " + E + " must be a RegExp or String"
                  ),
                    S instanceof RegExp
                      ? v.push(S.source.toString())
                      : (o(
                          c.schemeRegex.test(S),
                          "scheme at position " + E + " must be a valid scheme"
                        ),
                        v.push(l(S)));
                }
                m = v.join("|");
              }
              const g =
                  "(?:" +
                  (m ? "(?:" + m + ")" : c.scheme) +
                  ":" +
                  (f.domain ? c.hierPartCapture : c.hierPart) +
                  ")",
                w = f.allowRelative ? "(?:" + g + "|" + p + ")" : g;
              return u.wrap(w + d, m);
            }),
            (u.wrap = function (f, c) {
              return {
                raw: (f = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${f}`),
                regex: new RegExp(`^${f}$`),
                scheme: c,
              };
            }),
            (u.uriRegex = u.createRegex({})),
            (s.regex = function () {
              let f =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : {};
              return f.scheme ||
                f.allowRelative ||
                f.relativeOnly ||
                f.allowQuerySquareBrackets ||
                f.domain
                ? u.createRegex(f)
                : u.uriRegex;
            });
        },
        1447: (i, s) => {
          const a = {
            operators: [
              "!",
              "^",
              "*",
              "/",
              "%",
              "+",
              "-",
              "<",
              "<=",
              ">",
              ">=",
              "==",
              "!=",
              "&&",
              "||",
              "??",
            ],
            operatorCharacters: [
              "!",
              "^",
              "*",
              "/",
              "%",
              "+",
              "-",
              "<",
              "=",
              ">",
              "&",
              "|",
              "?",
            ],
            operatorsOrder: [
              ["^"],
              ["*", "/", "%"],
              ["+", "-"],
              ["<", "<=", ">", ">="],
              ["==", "!="],
              ["&&"],
              ["||", "??"],
            ],
            operatorsPrefix: ["!", "n"],
            literals: { '"': '"', "`": "`", "'": "'", "[": "]" },
            numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
            tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
            symbol: Symbol("formula"),
            settings: Symbol("settings"),
          };
          (s.Parser = class {
            constructor(o) {
              let l =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              if (!l[a.settings] && l.constants)
                for (const u in l.constants) {
                  const f = l.constants[u];
                  if (
                    f !== null &&
                    !["boolean", "number", "string"].includes(typeof f)
                  )
                    throw new Error(
                      `Formula constant ${u} contains invalid ${typeof f} value type`
                    );
                }
              (this.settings = l[a.settings]
                ? l
                : Object.assign(
                    { [a.settings]: !0, constants: {}, functions: {} },
                    l
                  )),
                (this.single = null),
                (this._parts = null),
                this._parse(o);
            }
            _parse(o) {
              let l = [],
                u = "",
                f = 0,
                c = !1;
              const d = (m) => {
                if (f) throw new Error("Formula missing closing parenthesis");
                const g = l.length ? l[l.length - 1] : null;
                if (c || u || m) {
                  if (g && g.type === "reference" && m === ")")
                    return (
                      (g.type = "function"),
                      (g.value = this._subFormula(u, g.value)),
                      void (u = "")
                    );
                  if (m === ")") {
                    const w = new s.Parser(u, this.settings);
                    l.push({ type: "segment", value: w });
                  } else if (c) {
                    if (c === "]")
                      return (
                        l.push({ type: "reference", value: u }), void (u = "")
                      );
                    l.push({ type: "literal", value: u });
                  } else if (a.operatorCharacters.includes(u))
                    g &&
                    g.type === "operator" &&
                    a.operators.includes(g.value + u)
                      ? (g.value += u)
                      : l.push({ type: "operator", value: u });
                  else if (u.match(a.numberRx))
                    l.push({ type: "constant", value: parseFloat(u) });
                  else if (this.settings.constants[u] !== void 0)
                    l.push({
                      type: "constant",
                      value: this.settings.constants[u],
                    });
                  else {
                    if (!u.match(a.tokenRx))
                      throw new Error(`Formula contains invalid token: ${u}`);
                    l.push({ type: "reference", value: u });
                  }
                  u = "";
                }
              };
              for (const m of o)
                c
                  ? m === c
                    ? (d(), (c = !1))
                    : (u += m)
                  : f
                  ? m === "("
                    ? ((u += m), ++f)
                    : m === ")"
                    ? (--f, f ? (u += m) : d(m))
                    : (u += m)
                  : m in a.literals
                  ? (c = a.literals[m])
                  : m === "("
                  ? (d(), ++f)
                  : a.operatorCharacters.includes(m)
                  ? (d(), (u = m), d())
                  : m !== " "
                  ? (u += m)
                  : d();
              d(),
                (l = l.map((m, g) =>
                  m.type !== "operator" ||
                  m.value !== "-" ||
                  (g && l[g - 1].type !== "operator")
                    ? m
                    : { type: "operator", value: "n" }
                ));
              let p = !1;
              for (const m of l) {
                if (m.type === "operator") {
                  if (a.operatorsPrefix.includes(m.value)) continue;
                  if (!p)
                    throw new Error(
                      "Formula contains an operator in invalid position"
                    );
                  if (!a.operators.includes(m.value))
                    throw new Error(
                      `Formula contains an unknown operator ${m.value}`
                    );
                } else if (p)
                  throw new Error("Formula missing expected operator");
                p = !p;
              }
              if (!p)
                throw new Error("Formula contains invalid trailing operator");
              l.length === 1 &&
                ["reference", "literal", "constant"].includes(l[0].type) &&
                (this.single = {
                  type: l[0].type === "reference" ? "reference" : "value",
                  value: l[0].value,
                }),
                (this._parts = l.map((m) => {
                  if (m.type === "operator")
                    return a.operatorsPrefix.includes(m.value) ? m : m.value;
                  if (m.type !== "reference") return m.value;
                  if (
                    this.settings.tokenRx &&
                    !this.settings.tokenRx.test(m.value)
                  )
                    throw new Error(
                      `Formula contains invalid reference ${m.value}`
                    );
                  return this.settings.reference
                    ? this.settings.reference(m.value)
                    : a.reference(m.value);
                }));
            }
            _subFormula(o, l) {
              const u = this.settings.functions[l];
              if (typeof u != "function")
                throw new Error(`Formula contains unknown function ${l}`);
              let f = [];
              if (o) {
                let c = "",
                  d = 0,
                  p = !1;
                const m = () => {
                  if (!c)
                    throw new Error(
                      `Formula contains function ${l} with invalid arguments ${o}`
                    );
                  f.push(c), (c = "");
                };
                for (let g = 0; g < o.length; ++g) {
                  const w = o[g];
                  p
                    ? ((c += w), w === p && (p = !1))
                    : w in a.literals && !d
                    ? ((c += w), (p = a.literals[w]))
                    : w !== "," || d
                    ? ((c += w), w === "(" ? ++d : w === ")" && --d)
                    : m();
                }
                m();
              }
              return (
                (f = f.map((c) => new s.Parser(c, this.settings))),
                function (c) {
                  const d = [];
                  for (const p of f) d.push(p.evaluate(c));
                  return u.call(c, ...d);
                }
              );
            }
            evaluate(o) {
              const l = this._parts.slice();
              for (let u = l.length - 2; u >= 0; --u) {
                const f = l[u];
                if (f && f.type === "operator") {
                  const c = l[u + 1];
                  l.splice(u + 1, 1);
                  const d = a.evaluate(c, o);
                  l[u] = a.single(f.value, d);
                }
              }
              return (
                a.operatorsOrder.forEach((u) => {
                  for (let f = 1; f < l.length - 1; )
                    if (u.includes(l[f])) {
                      const c = l[f],
                        d = a.evaluate(l[f - 1], o),
                        p = a.evaluate(l[f + 1], o);
                      l.splice(f, 2);
                      const m = a.calculate(c, d, p);
                      l[f - 1] = m === 0 ? 0 : m;
                    } else f += 2;
                }),
                a.evaluate(l[0], o)
              );
            }
          }),
            (s.Parser.prototype[a.symbol] = !0),
            (a.reference = function (o) {
              return function (l) {
                return l && l[o] !== void 0 ? l[o] : null;
              };
            }),
            (a.evaluate = function (o, l) {
              return o === null
                ? null
                : typeof o == "function"
                ? o(l)
                : o[a.symbol]
                ? o.evaluate(l)
                : o;
            }),
            (a.single = function (o, l) {
              if (o === "!") return !l;
              const u = -l;
              return u === 0 ? 0 : u;
            }),
            (a.calculate = function (o, l, u) {
              if (o === "??") return a.exists(l) ? l : u;
              if (typeof l == "string" || typeof u == "string") {
                if (o === "+")
                  return (l = a.exists(l) ? l : "") + (a.exists(u) ? u : "");
              } else
                switch (o) {
                  case "^":
                    return Math.pow(l, u);
                  case "*":
                    return l * u;
                  case "/":
                    return l / u;
                  case "%":
                    return l % u;
                  case "+":
                    return l + u;
                  case "-":
                    return l - u;
                }
              switch (o) {
                case "<":
                  return l < u;
                case "<=":
                  return l <= u;
                case ">":
                  return l > u;
                case ">=":
                  return l >= u;
                case "==":
                  return l === u;
                case "!=":
                  return l !== u;
                case "&&":
                  return l && u;
                case "||":
                  return l || u;
              }
              return null;
            }),
            (a.exists = function (o) {
              return o != null;
            });
        },
        9926: () => {},
        5688: () => {},
        9708: () => {},
        1152: () => {},
        443: () => {},
        9848: () => {},
        5934: (i) => {
          i.exports = { version: "17.9.1" };
        },
      }),
      (r = {}),
      (function i(s) {
        var a = r[s];
        if (a !== void 0) return a.exports;
        var o = (r[s] = { exports: {} });
        return n[s](o, o.exports, i), o.exports;
      })(5107)
    );
    var n, r;
  });
})(fj);
var Xoe = fj.exports;
const ae = oa(Xoe);
class DI extends Error {
  constructor(e) {
    super(e.message),
      (this.message = e.message),
      (this.code = e.code),
      (this.data = e.data);
  }
}
const hr = (t, e) => {
    let n;
    t.request ? (n = t.request.bind(t)) : t.sendAsync && (n = Zoe(t));
    const r = async ({ method: i, params: s }) => {
      const a = i;
      if (e && e[a] === null)
        throw new DI({
          code: 4200,
          message: `The Provider does not support the requested method: ${i}`,
        });
      if (e && e[a]) return e[a]({ baseRequest: n, params: s });
      if (n) return n({ method: i, params: s });
      throw new DI({
        code: 4200,
        message: `The Provider does not support the requested method: ${i}`,
      });
    };
    return (t.request = r), t;
  },
  Zoe =
    (t) =>
    ({ method: e, params: n }) =>
      new Promise((r, i) => {
        t.sendAsync(
          { id: 0, jsonrpc: "2.0", method: e, params: n },
          (s, { result: a }) => {
            s ? i(JSON.parse(s)) : r(a ?? null);
          }
        );
      });
var Yoe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  N_ = Math.ceil,
  rl = Math.floor,
  Wa = "[BigNumber Error] ",
  RI = Wa + "Number primitive has more than 15 significant digits: ",
  Ml = 1e14,
  vn = 14,
  D_ = 9007199254740991,
  R_ = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  _f = 1e7,
  ys = 1e9;
function dj(t) {
  var e,
    n,
    r,
    i = (v.prototype = { constructor: v, toString: null, valueOf: null }),
    s = new v(1),
    a = 20,
    o = 4,
    l = -7,
    u = 21,
    f = -1e7,
    c = 1e7,
    d = !1,
    p = 1,
    m = 0,
    g = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: " ",
      suffix: "",
    },
    w = "0123456789abcdefghijklmnopqrstuvwxyz",
    y = !0;
  function v(_, A) {
    var N,
      M,
      T,
      O,
      I,
      k,
      L,
      U,
      $ = this;
    if (!($ instanceof v)) return new v(_, A);
    if (A == null) {
      if (_ && _._isBigNumber === !0) {
        ($.s = _.s),
          !_.c || _.e > c
            ? ($.c = $.e = null)
            : _.e < f
            ? ($.c = [($.e = 0)])
            : (($.e = _.e), ($.c = _.c.slice()));
        return;
      }
      if ((k = typeof _ == "number") && _ * 0 == 0) {
        if ((($.s = 1 / _ < 0 ? ((_ = -_), -1) : 1), _ === ~~_)) {
          for (O = 0, I = _; I >= 10; I /= 10, O++);
          O > c ? ($.c = $.e = null) : (($.e = O), ($.c = [_]));
          return;
        }
        U = String(_);
      } else {
        if (!Yoe.test((U = String(_)))) return r($, U, k);
        $.s = U.charCodeAt(0) == 45 ? ((U = U.slice(1)), -1) : 1;
      }
      (O = U.indexOf(".")) > -1 && (U = U.replace(".", "")),
        (I = U.search(/e/i)) > 0
          ? (O < 0 && (O = I), (O += +U.slice(I + 1)), (U = U.substring(0, I)))
          : O < 0 && (O = U.length);
    } else {
      if ((ei(A, 2, w.length, "Base"), A == 10 && y))
        return ($ = new v(_)), P($, a + $.e + 1, o);
      if (((U = String(_)), (k = typeof _ == "number"))) {
        if (_ * 0 != 0) return r($, U, k, A);
        if (
          (($.s = 1 / _ < 0 ? ((U = U.slice(1)), -1) : 1),
          v.DEBUG && U.replace(/^0\.0*|\./, "").length > 15)
        )
          throw Error(RI + _);
      } else $.s = U.charCodeAt(0) === 45 ? ((U = U.slice(1)), -1) : 1;
      for (N = w.slice(0, A), O = I = 0, L = U.length; I < L; I++)
        if (N.indexOf((M = U.charAt(I))) < 0) {
          if (M == ".") {
            if (I > O) {
              O = L;
              continue;
            }
          } else if (
            !T &&
            ((U == U.toUpperCase() && (U = U.toLowerCase())) ||
              (U == U.toLowerCase() && (U = U.toUpperCase())))
          ) {
            (T = !0), (I = -1), (O = 0);
            continue;
          }
          return r($, String(_), k, A);
        }
      (k = !1),
        (U = n(U, A, 10, $.s)),
        (O = U.indexOf(".")) > -1 ? (U = U.replace(".", "")) : (O = U.length);
    }
    for (I = 0; U.charCodeAt(I) === 48; I++);
    for (L = U.length; U.charCodeAt(--L) === 48; );
    if ((U = U.slice(I, ++L))) {
      if (((L -= I), k && v.DEBUG && L > 15 && (_ > D_ || _ !== rl(_))))
        throw Error(RI + $.s * _);
      if ((O = O - I - 1) > c) $.c = $.e = null;
      else if (O < f) $.c = [($.e = 0)];
      else {
        if (
          (($.e = O), ($.c = []), (I = (O + 1) % vn), O < 0 && (I += vn), I < L)
        ) {
          for (I && $.c.push(+U.slice(0, I)), L -= vn; I < L; )
            $.c.push(+U.slice(I, (I += vn)));
          I = vn - (U = U.slice(I)).length;
        } else I -= L;
        for (; I--; U += "0");
        $.c.push(+U);
      }
    } else $.c = [($.e = 0)];
  }
  (v.clone = dj),
    (v.ROUND_UP = 0),
    (v.ROUND_DOWN = 1),
    (v.ROUND_CEIL = 2),
    (v.ROUND_FLOOR = 3),
    (v.ROUND_HALF_UP = 4),
    (v.ROUND_HALF_DOWN = 5),
    (v.ROUND_HALF_EVEN = 6),
    (v.ROUND_HALF_CEIL = 7),
    (v.ROUND_HALF_FLOOR = 8),
    (v.EUCLID = 9),
    (v.config = v.set =
      function (_) {
        var A, N;
        if (_ != null)
          if (typeof _ == "object") {
            if (
              (_.hasOwnProperty((A = "DECIMAL_PLACES")) &&
                ((N = _[A]), ei(N, 0, ys, A), (a = N)),
              _.hasOwnProperty((A = "ROUNDING_MODE")) &&
                ((N = _[A]), ei(N, 0, 8, A), (o = N)),
              _.hasOwnProperty((A = "EXPONENTIAL_AT")) &&
                ((N = _[A]),
                N && N.pop
                  ? (ei(N[0], -ys, 0, A),
                    ei(N[1], 0, ys, A),
                    (l = N[0]),
                    (u = N[1]))
                  : (ei(N, -ys, ys, A), (l = -(u = N < 0 ? -N : N)))),
              _.hasOwnProperty((A = "RANGE")))
            )
              if (((N = _[A]), N && N.pop))
                ei(N[0], -ys, -1, A),
                  ei(N[1], 1, ys, A),
                  (f = N[0]),
                  (c = N[1]);
              else if ((ei(N, -ys, ys, A), N)) f = -(c = N < 0 ? -N : N);
              else throw Error(Wa + A + " cannot be zero: " + N);
            if (_.hasOwnProperty((A = "CRYPTO")))
              if (((N = _[A]), N === !!N))
                if (N)
                  if (
                    typeof crypto < "u" &&
                    crypto &&
                    (crypto.getRandomValues || crypto.randomBytes)
                  )
                    d = N;
                  else throw ((d = !N), Error(Wa + "crypto unavailable"));
                else d = N;
              else throw Error(Wa + A + " not true or false: " + N);
            if (
              (_.hasOwnProperty((A = "MODULO_MODE")) &&
                ((N = _[A]), ei(N, 0, 9, A), (p = N)),
              _.hasOwnProperty((A = "POW_PRECISION")) &&
                ((N = _[A]), ei(N, 0, ys, A), (m = N)),
              _.hasOwnProperty((A = "FORMAT")))
            )
              if (((N = _[A]), typeof N == "object")) g = N;
              else throw Error(Wa + A + " not an object: " + N);
            if (_.hasOwnProperty((A = "ALPHABET")))
              if (
                ((N = _[A]),
                typeof N == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(N))
              )
                (y = N.slice(0, 10) == "0123456789"), (w = N);
              else throw Error(Wa + A + " invalid: " + N);
          } else throw Error(Wa + "Object expected: " + _);
        return {
          DECIMAL_PLACES: a,
          ROUNDING_MODE: o,
          EXPONENTIAL_AT: [l, u],
          RANGE: [f, c],
          CRYPTO: d,
          MODULO_MODE: p,
          POW_PRECISION: m,
          FORMAT: g,
          ALPHABET: w,
        };
      }),
    (v.isBigNumber = function (_) {
      if (!_ || _._isBigNumber !== !0) return !1;
      if (!v.DEBUG) return !0;
      var A,
        N,
        M = _.c,
        T = _.e,
        O = _.s;
      e: if ({}.toString.call(M) == "[object Array]") {
        if ((O === 1 || O === -1) && T >= -ys && T <= ys && T === rl(T)) {
          if (M[0] === 0) {
            if (T === 0 && M.length === 1) return !0;
            break e;
          }
          if (
            ((A = (T + 1) % vn), A < 1 && (A += vn), String(M[0]).length == A)
          ) {
            for (A = 0; A < M.length; A++)
              if (((N = M[A]), N < 0 || N >= Ml || N !== rl(N))) break e;
            if (N !== 0) return !0;
          }
        }
      } else if (
        M === null &&
        T === null &&
        (O === null || O === 1 || O === -1)
      )
        return !0;
      throw Error(Wa + "Invalid BigNumber: " + _);
    }),
    (v.maximum = v.max =
      function () {
        return S(arguments, -1);
      }),
    (v.minimum = v.min =
      function () {
        return S(arguments, 1);
      }),
    (v.random = (function () {
      var _ = 9007199254740992,
        A =
          (Math.random() * _) & 2097151
            ? function () {
                return rl(Math.random() * _);
              }
            : function () {
                return (
                  ((Math.random() * 1073741824) | 0) * 8388608 +
                  ((Math.random() * 8388608) | 0)
                );
              };
      return function (N) {
        var M,
          T,
          O,
          I,
          k,
          L = 0,
          U = [],
          $ = new v(s);
        if ((N == null ? (N = a) : ei(N, 0, ys), (I = N_(N / vn)), d))
          if (crypto.getRandomValues) {
            for (M = crypto.getRandomValues(new Uint32Array((I *= 2))); L < I; )
              (k = M[L] * 131072 + (M[L + 1] >>> 11)),
                k >= 9e15
                  ? ((T = crypto.getRandomValues(new Uint32Array(2))),
                    (M[L] = T[0]),
                    (M[L + 1] = T[1]))
                  : (U.push(k % 1e14), (L += 2));
            L = I / 2;
          } else if (crypto.randomBytes) {
            for (M = crypto.randomBytes((I *= 7)); L < I; )
              (k =
                (M[L] & 31) * 281474976710656 +
                M[L + 1] * 1099511627776 +
                M[L + 2] * 4294967296 +
                M[L + 3] * 16777216 +
                (M[L + 4] << 16) +
                (M[L + 5] << 8) +
                M[L + 6]),
                k >= 9e15
                  ? crypto.randomBytes(7).copy(M, L)
                  : (U.push(k % 1e14), (L += 7));
            L = I / 7;
          } else throw ((d = !1), Error(Wa + "crypto unavailable"));
        if (!d) for (; L < I; ) (k = A()), k < 9e15 && (U[L++] = k % 1e14);
        for (
          I = U[--L],
            N %= vn,
            I && N && ((k = R_[vn - N]), (U[L] = rl(I / k) * k));
          U[L] === 0;
          U.pop(), L--
        );
        if (L < 0) U = [(O = 0)];
        else {
          for (O = -1; U[0] === 0; U.splice(0, 1), O -= vn);
          for (L = 1, k = U[0]; k >= 10; k /= 10, L++);
          L < vn && (O -= vn - L);
        }
        return ($.e = O), ($.c = U), $;
      };
    })()),
    (v.sum = function () {
      for (var _ = 1, A = arguments, N = new v(A[0]); _ < A.length; )
        N = N.plus(A[_++]);
      return N;
    }),
    (n = (function () {
      var _ = "0123456789";
      function A(N, M, T, O) {
        for (var I, k = [0], L, U = 0, $ = N.length; U < $; ) {
          for (L = k.length; L--; k[L] *= M);
          for (k[0] += O.indexOf(N.charAt(U++)), I = 0; I < k.length; I++)
            k[I] > T - 1 &&
              (k[I + 1] == null && (k[I + 1] = 0),
              (k[I + 1] += (k[I] / T) | 0),
              (k[I] %= T));
        }
        return k.reverse();
      }
      return function (N, M, T, O, I) {
        var k,
          L,
          U,
          $,
          B,
          R,
          V,
          oe,
          le = N.indexOf("."),
          fe = a,
          z = o;
        for (
          le >= 0 &&
            (($ = m),
            (m = 0),
            (N = N.replace(".", "")),
            (oe = new v(M)),
            (R = oe.pow(N.length - le)),
            (m = $),
            (oe.c = A(bc(el(R.c), R.e, "0"), 10, T, _)),
            (oe.e = oe.c.length)),
            V = A(N, M, T, I ? ((k = w), _) : ((k = _), w)),
            U = $ = V.length;
          V[--$] == 0;
          V.pop()
        );
        if (!V[0]) return k.charAt(0);
        if (
          (le < 0
            ? --U
            : ((R.c = V),
              (R.e = U),
              (R.s = O),
              (R = e(R, oe, fe, z, T)),
              (V = R.c),
              (B = R.r),
              (U = R.e)),
          (L = U + fe + 1),
          (le = V[L]),
          ($ = T / 2),
          (B = B || L < 0 || V[L + 1] != null),
          (B =
            z < 4
              ? (le != null || B) && (z == 0 || z == (R.s < 0 ? 3 : 2))
              : le > $ ||
                (le == $ &&
                  (z == 4 ||
                    B ||
                    (z == 6 && V[L - 1] & 1) ||
                    z == (R.s < 0 ? 8 : 7)))),
          L < 1 || !V[0])
        )
          N = B ? bc(k.charAt(1), -fe, k.charAt(0)) : k.charAt(0);
        else {
          if (((V.length = L), B))
            for (--T; ++V[--L] > T; )
              (V[L] = 0), L || (++U, (V = [1].concat(V)));
          for ($ = V.length; !V[--$]; );
          for (le = 0, N = ""; le <= $; N += k.charAt(V[le++]));
          N = bc(N, U, k.charAt(0));
        }
        return N;
      };
    })()),
    (e = (function () {
      function _(M, T, O) {
        var I,
          k,
          L,
          U,
          $ = 0,
          B = M.length,
          R = T % _f,
          V = (T / _f) | 0;
        for (M = M.slice(); B--; )
          (L = M[B] % _f),
            (U = (M[B] / _f) | 0),
            (I = V * L + U * R),
            (k = R * L + (I % _f) * _f + $),
            ($ = ((k / O) | 0) + ((I / _f) | 0) + V * U),
            (M[B] = k % O);
        return $ && (M = [$].concat(M)), M;
      }
      function A(M, T, O, I) {
        var k, L;
        if (O != I) L = O > I ? 1 : -1;
        else
          for (k = L = 0; k < O; k++)
            if (M[k] != T[k]) {
              L = M[k] > T[k] ? 1 : -1;
              break;
            }
        return L;
      }
      function N(M, T, O, I) {
        for (var k = 0; O--; )
          (M[O] -= k), (k = M[O] < T[O] ? 1 : 0), (M[O] = k * I + M[O] - T[O]);
        for (; !M[0] && M.length > 1; M.splice(0, 1));
      }
      return function (M, T, O, I, k) {
        var L,
          U,
          $,
          B,
          R,
          V,
          oe,
          le,
          fe,
          z,
          se,
          Y,
          Q,
          ee,
          F,
          te,
          he,
          Te = M.s == T.s ? 1 : -1,
          Ce = M.c,
          ke = T.c;
        if (!Ce || !Ce[0] || !ke || !ke[0])
          return new v(
            !M.s || !T.s || (Ce ? ke && Ce[0] == ke[0] : !ke)
              ? NaN
              : (Ce && Ce[0] == 0) || !ke
              ? Te * 0
              : Te / 0
          );
        for (
          le = new v(Te),
            fe = le.c = [],
            U = M.e - T.e,
            Te = O + U + 1,
            k ||
              ((k = Ml),
              (U = il(M.e / vn) - il(T.e / vn)),
              (Te = (Te / vn) | 0)),
            $ = 0;
          ke[$] == (Ce[$] || 0);
          $++
        );
        if ((ke[$] > (Ce[$] || 0) && U--, Te < 0)) fe.push(1), (B = !0);
        else {
          for (
            ee = Ce.length,
              te = ke.length,
              $ = 0,
              Te += 2,
              R = rl(k / (ke[0] + 1)),
              R > 1 &&
                ((ke = _(ke, R, k)),
                (Ce = _(Ce, R, k)),
                (te = ke.length),
                (ee = Ce.length)),
              Q = te,
              z = Ce.slice(0, te),
              se = z.length;
            se < te;
            z[se++] = 0
          );
          (he = ke.slice()),
            (he = [0].concat(he)),
            (F = ke[0]),
            ke[1] >= k / 2 && F++;
          do {
            if (((R = 0), (L = A(ke, z, te, se)), L < 0)) {
              if (
                ((Y = z[0]),
                te != se && (Y = Y * k + (z[1] || 0)),
                (R = rl(Y / F)),
                R > 1)
              )
                for (
                  R >= k && (R = k - 1),
                    V = _(ke, R, k),
                    oe = V.length,
                    se = z.length;
                  A(V, z, oe, se) == 1;

                )
                  R--, N(V, te < oe ? he : ke, oe, k), (oe = V.length), (L = 1);
              else R == 0 && (L = R = 1), (V = ke.slice()), (oe = V.length);
              if (
                (oe < se && (V = [0].concat(V)),
                N(z, V, se, k),
                (se = z.length),
                L == -1)
              )
                for (; A(ke, z, te, se) < 1; )
                  R++, N(z, te < se ? he : ke, se, k), (se = z.length);
            } else L === 0 && (R++, (z = [0]));
            (fe[$++] = R),
              z[0] ? (z[se++] = Ce[Q] || 0) : ((z = [Ce[Q]]), (se = 1));
          } while ((Q++ < ee || z[0] != null) && Te--);
          (B = z[0] != null), fe[0] || fe.splice(0, 1);
        }
        if (k == Ml) {
          for ($ = 1, Te = fe[0]; Te >= 10; Te /= 10, $++);
          P(le, O + (le.e = $ + U * vn - 1) + 1, I, B);
        } else (le.e = U), (le.r = +B);
        return le;
      };
    })());
  function E(_, A, N, M) {
    var T, O, I, k, L;
    if ((N == null ? (N = o) : ei(N, 0, 8), !_.c)) return _.toString();
    if (((T = _.c[0]), (I = _.e), A == null))
      (L = el(_.c)),
        (L =
          M == 1 || (M == 2 && (I <= l || I >= u)) ? rv(L, I) : bc(L, I, "0"));
    else if (
      ((_ = P(new v(_), A, N)),
      (O = _.e),
      (L = el(_.c)),
      (k = L.length),
      M == 1 || (M == 2 && (A <= O || O <= l)))
    ) {
      for (; k < A; L += "0", k++);
      L = rv(L, O);
    } else if (((A -= I), (L = bc(L, O, "0")), O + 1 > k)) {
      if (--A > 0) for (L += "."; A--; L += "0");
    } else if (((A += O - k), A > 0))
      for (O + 1 == k && (L += "."); A--; L += "0");
    return _.s < 0 && T ? "-" + L : L;
  }
  function S(_, A) {
    for (var N, M, T = 1, O = new v(_[0]); T < _.length; T++)
      (M = new v(_[T])),
        (!M.s || (N = Rd(O, M)) === A || (N === 0 && O.s === A)) && (O = M);
    return O;
  }
  function D(_, A, N) {
    for (var M = 1, T = A.length; !A[--T]; A.pop());
    for (T = A[0]; T >= 10; T /= 10, M++);
    return (
      (N = M + N * vn - 1) > c
        ? (_.c = _.e = null)
        : N < f
        ? (_.c = [(_.e = 0)])
        : ((_.e = N), (_.c = A)),
      _
    );
  }
  r = (function () {
    var _ = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      A = /^([^.]+)\.$/,
      N = /^\.([^.]+)$/,
      M = /^-?(Infinity|NaN)$/,
      T = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (O, I, k, L) {
      var U,
        $ = k ? I : I.replace(T, "");
      if (M.test($)) O.s = isNaN($) ? null : $ < 0 ? -1 : 1;
      else {
        if (
          !k &&
          (($ = $.replace(_, function (B, R, V) {
            return (
              (U = (V = V.toLowerCase()) == "x" ? 16 : V == "b" ? 2 : 8),
              !L || L == U ? R : B
            );
          })),
          L && ((U = L), ($ = $.replace(A, "$1").replace(N, "0.$1"))),
          I != $)
        )
          return new v($, U);
        if (v.DEBUG)
          throw Error(Wa + "Not a" + (L ? " base " + L : "") + " number: " + I);
        O.s = null;
      }
      O.c = O.e = null;
    };
  })();
  function P(_, A, N, M) {
    var T,
      O,
      I,
      k,
      L,
      U,
      $,
      B = _.c,
      R = R_;
    if (B) {
      e: {
        for (T = 1, k = B[0]; k >= 10; k /= 10, T++);
        if (((O = A - T), O < 0))
          (O += vn),
            (I = A),
            (L = B[(U = 0)]),
            ($ = rl((L / R[T - I - 1]) % 10));
        else if (((U = N_((O + 1) / vn)), U >= B.length))
          if (M) {
            for (; B.length <= U; B.push(0));
            (L = $ = 0), (T = 1), (O %= vn), (I = O - vn + 1);
          } else break e;
        else {
          for (L = k = B[U], T = 1; k >= 10; k /= 10, T++);
          (O %= vn),
            (I = O - vn + T),
            ($ = I < 0 ? 0 : rl((L / R[T - I - 1]) % 10));
        }
        if (
          ((M =
            M || A < 0 || B[U + 1] != null || (I < 0 ? L : L % R[T - I - 1])),
          (M =
            N < 4
              ? ($ || M) && (N == 0 || N == (_.s < 0 ? 3 : 2))
              : $ > 5 ||
                ($ == 5 &&
                  (N == 4 ||
                    M ||
                    (N == 6 &&
                      (O > 0 ? (I > 0 ? L / R[T - I] : 0) : B[U - 1]) % 10 &
                        1) ||
                    N == (_.s < 0 ? 8 : 7)))),
          A < 1 || !B[0])
        )
          return (
            (B.length = 0),
            M
              ? ((A -= _.e + 1),
                (B[0] = R[(vn - (A % vn)) % vn]),
                (_.e = -A || 0))
              : (B[0] = _.e = 0),
            _
          );
        if (
          (O == 0
            ? ((B.length = U), (k = 1), U--)
            : ((B.length = U + 1),
              (k = R[vn - O]),
              (B[U] = I > 0 ? rl((L / R[T - I]) % R[I]) * k : 0)),
          M)
        )
          for (;;)
            if (U == 0) {
              for (O = 1, I = B[0]; I >= 10; I /= 10, O++);
              for (I = B[0] += k, k = 1; I >= 10; I /= 10, k++);
              O != k && (_.e++, B[0] == Ml && (B[0] = 1));
              break;
            } else {
              if (((B[U] += k), B[U] != Ml)) break;
              (B[U--] = 0), (k = 1);
            }
        for (O = B.length; B[--O] === 0; B.pop());
      }
      _.e > c ? (_.c = _.e = null) : _.e < f && (_.c = [(_.e = 0)]);
    }
    return _;
  }
  function x(_) {
    var A,
      N = _.e;
    return N === null
      ? _.toString()
      : ((A = el(_.c)),
        (A = N <= l || N >= u ? rv(A, N) : bc(A, N, "0")),
        _.s < 0 ? "-" + A : A);
  }
  return (
    (i.absoluteValue = i.abs =
      function () {
        var _ = new v(this);
        return _.s < 0 && (_.s = 1), _;
      }),
    (i.comparedTo = function (_, A) {
      return Rd(this, new v(_, A));
    }),
    (i.decimalPlaces = i.dp =
      function (_, A) {
        var N,
          M,
          T,
          O = this;
        if (_ != null)
          return (
            ei(_, 0, ys),
            A == null ? (A = o) : ei(A, 0, 8),
            P(new v(O), _ + O.e + 1, A)
          );
        if (!(N = O.c)) return null;
        if (((M = ((T = N.length - 1) - il(this.e / vn)) * vn), (T = N[T])))
          for (; T % 10 == 0; T /= 10, M--);
        return M < 0 && (M = 0), M;
      }),
    (i.dividedBy = i.div =
      function (_, A) {
        return e(this, new v(_, A), a, o);
      }),
    (i.dividedToIntegerBy = i.idiv =
      function (_, A) {
        return e(this, new v(_, A), 0, 1);
      }),
    (i.exponentiatedBy = i.pow =
      function (_, A) {
        var N,
          M,
          T,
          O,
          I,
          k,
          L,
          U,
          $,
          B = this;
        if (((_ = new v(_)), _.c && !_.isInteger()))
          throw Error(Wa + "Exponent not an integer: " + x(_));
        if (
          (A != null && (A = new v(A)),
          (k = _.e > 14),
          !B.c ||
            !B.c[0] ||
            (B.c[0] == 1 && !B.e && B.c.length == 1) ||
            !_.c ||
            !_.c[0])
        )
          return (
            ($ = new v(Math.pow(+x(B), k ? _.s * (2 - nv(_)) : +x(_)))),
            A ? $.mod(A) : $
          );
        if (((L = _.s < 0), A)) {
          if (A.c ? !A.c[0] : !A.s) return new v(NaN);
          (M = !L && B.isInteger() && A.isInteger()), M && (B = B.mod(A));
        } else {
          if (
            _.e > 9 &&
            (B.e > 0 ||
              B.e < -1 ||
              (B.e == 0
                ? B.c[0] > 1 || (k && B.c[1] >= 24e7)
                : B.c[0] < 8e13 || (k && B.c[0] <= 9999975e7)))
          )
            return (
              (O = B.s < 0 && nv(_) ? -0 : 0),
              B.e > -1 && (O = 1 / O),
              new v(L ? 1 / O : O)
            );
          m && (O = N_(m / vn + 2));
        }
        for (
          k
            ? ((N = new v(0.5)), L && (_.s = 1), (U = nv(_)))
            : ((T = Math.abs(+x(_))), (U = T % 2)),
            $ = new v(s);
          ;

        ) {
          if (U) {
            if ((($ = $.times(B)), !$.c)) break;
            O ? $.c.length > O && ($.c.length = O) : M && ($ = $.mod(A));
          }
          if (T) {
            if (((T = rl(T / 2)), T === 0)) break;
            U = T % 2;
          } else if (((_ = _.times(N)), P(_, _.e + 1, 1), _.e > 14)) U = nv(_);
          else {
            if (((T = +x(_)), T === 0)) break;
            U = T % 2;
          }
          (B = B.times(B)),
            O ? B.c && B.c.length > O && (B.c.length = O) : M && (B = B.mod(A));
        }
        return M
          ? $
          : (L && ($ = s.div($)), A ? $.mod(A) : O ? P($, m, o, I) : $);
      }),
    (i.integerValue = function (_) {
      var A = new v(this);
      return _ == null ? (_ = o) : ei(_, 0, 8), P(A, A.e + 1, _);
    }),
    (i.isEqualTo = i.eq =
      function (_, A) {
        return Rd(this, new v(_, A)) === 0;
      }),
    (i.isFinite = function () {
      return !!this.c;
    }),
    (i.isGreaterThan = i.gt =
      function (_, A) {
        return Rd(this, new v(_, A)) > 0;
      }),
    (i.isGreaterThanOrEqualTo = i.gte =
      function (_, A) {
        return (A = Rd(this, new v(_, A))) === 1 || A === 0;
      }),
    (i.isInteger = function () {
      return !!this.c && il(this.e / vn) > this.c.length - 2;
    }),
    (i.isLessThan = i.lt =
      function (_, A) {
        return Rd(this, new v(_, A)) < 0;
      }),
    (i.isLessThanOrEqualTo = i.lte =
      function (_, A) {
        return (A = Rd(this, new v(_, A))) === -1 || A === 0;
      }),
    (i.isNaN = function () {
      return !this.s;
    }),
    (i.isNegative = function () {
      return this.s < 0;
    }),
    (i.isPositive = function () {
      return this.s > 0;
    }),
    (i.isZero = function () {
      return !!this.c && this.c[0] == 0;
    }),
    (i.minus = function (_, A) {
      var N,
        M,
        T,
        O,
        I = this,
        k = I.s;
      if (((_ = new v(_, A)), (A = _.s), !k || !A)) return new v(NaN);
      if (k != A) return (_.s = -A), I.plus(_);
      var L = I.e / vn,
        U = _.e / vn,
        $ = I.c,
        B = _.c;
      if (!L || !U) {
        if (!$ || !B) return $ ? ((_.s = -A), _) : new v(B ? I : NaN);
        if (!$[0] || !B[0])
          return B[0] ? ((_.s = -A), _) : new v($[0] ? I : o == 3 ? -0 : 0);
      }
      if (((L = il(L)), (U = il(U)), ($ = $.slice()), (k = L - U))) {
        for (
          (O = k < 0) ? ((k = -k), (T = $)) : ((U = L), (T = B)),
            T.reverse(),
            A = k;
          A--;
          T.push(0)
        );
        T.reverse();
      } else
        for (
          M = (O = (k = $.length) < (A = B.length)) ? k : A, k = A = 0;
          A < M;
          A++
        )
          if ($[A] != B[A]) {
            O = $[A] < B[A];
            break;
          }
      if (
        (O && ((T = $), ($ = B), (B = T), (_.s = -_.s)),
        (A = (M = B.length) - (N = $.length)),
        A > 0)
      )
        for (; A--; $[N++] = 0);
      for (A = Ml - 1; M > k; ) {
        if ($[--M] < B[M]) {
          for (N = M; N && !$[--N]; $[N] = A);
          --$[N], ($[M] += Ml);
        }
        $[M] -= B[M];
      }
      for (; $[0] == 0; $.splice(0, 1), --U);
      return $[0]
        ? D(_, $, U)
        : ((_.s = o == 3 ? -1 : 1), (_.c = [(_.e = 0)]), _);
    }),
    (i.modulo = i.mod =
      function (_, A) {
        var N,
          M,
          T = this;
        return (
          (_ = new v(_, A)),
          !T.c || !_.s || (_.c && !_.c[0])
            ? new v(NaN)
            : !_.c || (T.c && !T.c[0])
            ? new v(T)
            : (p == 9
                ? ((M = _.s),
                  (_.s = 1),
                  (N = e(T, _, 0, 3)),
                  (_.s = M),
                  (N.s *= M))
                : (N = e(T, _, 0, p)),
              (_ = T.minus(N.times(_))),
              !_.c[0] && p == 1 && (_.s = T.s),
              _)
        );
      }),
    (i.multipliedBy = i.times =
      function (_, A) {
        var N,
          M,
          T,
          O,
          I,
          k,
          L,
          U,
          $,
          B,
          R,
          V,
          oe,
          le,
          fe,
          z = this,
          se = z.c,
          Y = (_ = new v(_, A)).c;
        if (!se || !Y || !se[0] || !Y[0])
          return (
            !z.s || !_.s || (se && !se[0] && !Y) || (Y && !Y[0] && !se)
              ? (_.c = _.e = _.s = null)
              : ((_.s *= z.s),
                !se || !Y ? (_.c = _.e = null) : ((_.c = [0]), (_.e = 0))),
            _
          );
        for (
          M = il(z.e / vn) + il(_.e / vn),
            _.s *= z.s,
            L = se.length,
            B = Y.length,
            L < B && ((oe = se), (se = Y), (Y = oe), (T = L), (L = B), (B = T)),
            T = L + B,
            oe = [];
          T--;
          oe.push(0)
        );
        for (le = Ml, fe = _f, T = B; --T >= 0; ) {
          for (
            N = 0, R = Y[T] % fe, V = (Y[T] / fe) | 0, I = L, O = T + I;
            O > T;

          )
            (U = se[--I] % fe),
              ($ = (se[I] / fe) | 0),
              (k = V * U + $ * R),
              (U = R * U + (k % fe) * fe + oe[O] + N),
              (N = ((U / le) | 0) + ((k / fe) | 0) + V * $),
              (oe[O--] = U % le);
          oe[O] = N;
        }
        return N ? ++M : oe.splice(0, 1), D(_, oe, M);
      }),
    (i.negated = function () {
      var _ = new v(this);
      return (_.s = -_.s || null), _;
    }),
    (i.plus = function (_, A) {
      var N,
        M = this,
        T = M.s;
      if (((_ = new v(_, A)), (A = _.s), !T || !A)) return new v(NaN);
      if (T != A) return (_.s = -A), M.minus(_);
      var O = M.e / vn,
        I = _.e / vn,
        k = M.c,
        L = _.c;
      if (!O || !I) {
        if (!k || !L) return new v(T / 0);
        if (!k[0] || !L[0]) return L[0] ? _ : new v(k[0] ? M : T * 0);
      }
      if (((O = il(O)), (I = il(I)), (k = k.slice()), (T = O - I))) {
        for (
          T > 0 ? ((I = O), (N = L)) : ((T = -T), (N = k)), N.reverse();
          T--;
          N.push(0)
        );
        N.reverse();
      }
      for (
        T = k.length,
          A = L.length,
          T - A < 0 && ((N = L), (L = k), (k = N), (A = T)),
          T = 0;
        A;

      )
        (T = ((k[--A] = k[A] + L[A] + T) / Ml) | 0),
          (k[A] = Ml === k[A] ? 0 : k[A] % Ml);
      return T && ((k = [T].concat(k)), ++I), D(_, k, I);
    }),
    (i.precision = i.sd =
      function (_, A) {
        var N,
          M,
          T,
          O = this;
        if (_ != null && _ !== !!_)
          return (
            ei(_, 1, ys), A == null ? (A = o) : ei(A, 0, 8), P(new v(O), _, A)
          );
        if (!(N = O.c)) return null;
        if (((T = N.length - 1), (M = T * vn + 1), (T = N[T]))) {
          for (; T % 10 == 0; T /= 10, M--);
          for (T = N[0]; T >= 10; T /= 10, M++);
        }
        return _ && O.e + 1 > M && (M = O.e + 1), M;
      }),
    (i.shiftedBy = function (_) {
      return ei(_, -D_, D_), this.times("1e" + _);
    }),
    (i.squareRoot = i.sqrt =
      function () {
        var _,
          A,
          N,
          M,
          T,
          O = this,
          I = O.c,
          k = O.s,
          L = O.e,
          U = a + 4,
          $ = new v("0.5");
        if (k !== 1 || !I || !I[0])
          return new v(!k || (k < 0 && (!I || I[0])) ? NaN : I ? O : 1 / 0);
        if (
          ((k = Math.sqrt(+x(O))),
          k == 0 || k == 1 / 0
            ? ((A = el(I)),
              (A.length + L) % 2 == 0 && (A += "0"),
              (k = Math.sqrt(+A)),
              (L = il((L + 1) / 2) - (L < 0 || L % 2)),
              k == 1 / 0
                ? (A = "5e" + L)
                : ((A = k.toExponential()),
                  (A = A.slice(0, A.indexOf("e") + 1) + L)),
              (N = new v(A)))
            : (N = new v(k + "")),
          N.c[0])
        ) {
          for (L = N.e, k = L + U, k < 3 && (k = 0); ; )
            if (
              ((T = N),
              (N = $.times(T.plus(e(O, T, U, 1)))),
              el(T.c).slice(0, k) === (A = el(N.c)).slice(0, k))
            )
              if (
                (N.e < L && --k,
                (A = A.slice(k - 3, k + 1)),
                A == "9999" || (!M && A == "4999"))
              ) {
                if (!M && (P(T, T.e + a + 2, 0), T.times(T).eq(O))) {
                  N = T;
                  break;
                }
                (U += 4), (k += 4), (M = 1);
              } else {
                (!+A || (!+A.slice(1) && A.charAt(0) == "5")) &&
                  (P(N, N.e + a + 2, 1), (_ = !N.times(N).eq(O)));
                break;
              }
        }
        return P(N, N.e + a + 1, o, _);
      }),
    (i.toExponential = function (_, A) {
      return _ != null && (ei(_, 0, ys), _++), E(this, _, A, 1);
    }),
    (i.toFixed = function (_, A) {
      return _ != null && (ei(_, 0, ys), (_ = _ + this.e + 1)), E(this, _, A);
    }),
    (i.toFormat = function (_, A, N) {
      var M,
        T = this;
      if (N == null)
        _ != null && A && typeof A == "object"
          ? ((N = A), (A = null))
          : _ && typeof _ == "object"
          ? ((N = _), (_ = A = null))
          : (N = g);
      else if (typeof N != "object")
        throw Error(Wa + "Argument not an object: " + N);
      if (((M = T.toFixed(_, A)), T.c)) {
        var O,
          I = M.split("."),
          k = +N.groupSize,
          L = +N.secondaryGroupSize,
          U = N.groupSeparator || "",
          $ = I[0],
          B = I[1],
          R = T.s < 0,
          V = R ? $.slice(1) : $,
          oe = V.length;
        if ((L && ((O = k), (k = L), (L = O), (oe -= O)), k > 0 && oe > 0)) {
          for (O = oe % k || k, $ = V.substr(0, O); O < oe; O += k)
            $ += U + V.substr(O, k);
          L > 0 && ($ += U + V.slice(O)), R && ($ = "-" + $);
        }
        M = B
          ? $ +
            (N.decimalSeparator || "") +
            ((L = +N.fractionGroupSize)
              ? B.replace(
                  new RegExp("\\d{" + L + "}\\B", "g"),
                  "$&" + (N.fractionGroupSeparator || "")
                )
              : B)
          : $;
      }
      return (N.prefix || "") + M + (N.suffix || "");
    }),
    (i.toFraction = function (_) {
      var A,
        N,
        M,
        T,
        O,
        I,
        k,
        L,
        U,
        $,
        B,
        R,
        V = this,
        oe = V.c;
      if (
        _ != null &&
        ((k = new v(_)), (!k.isInteger() && (k.c || k.s !== 1)) || k.lt(s))
      )
        throw Error(
          Wa +
            "Argument " +
            (k.isInteger() ? "out of range: " : "not an integer: ") +
            x(k)
        );
      if (!oe) return new v(V);
      for (
        A = new v(s),
          U = N = new v(s),
          M = L = new v(s),
          R = el(oe),
          O = A.e = R.length - V.e - 1,
          A.c[0] = R_[(I = O % vn) < 0 ? vn + I : I],
          _ = !_ || k.comparedTo(A) > 0 ? (O > 0 ? A : U) : k,
          I = c,
          c = 1 / 0,
          k = new v(R),
          L.c[0] = 0;
        ($ = e(k, A, 0, 1)), (T = N.plus($.times(M))), T.comparedTo(_) != 1;

      )
        (N = M),
          (M = T),
          (U = L.plus($.times((T = U)))),
          (L = T),
          (A = k.minus($.times((T = A)))),
          (k = T);
      return (
        (T = e(_.minus(N), M, 0, 1)),
        (L = L.plus(T.times(U))),
        (N = N.plus(T.times(M))),
        (L.s = U.s = V.s),
        (O = O * 2),
        (B =
          e(U, M, O, o)
            .minus(V)
            .abs()
            .comparedTo(e(L, N, O, o).minus(V).abs()) < 1
            ? [U, M]
            : [L, N]),
        (c = I),
        B
      );
    }),
    (i.toNumber = function () {
      return +x(this);
    }),
    (i.toPrecision = function (_, A) {
      return _ != null && ei(_, 1, ys), E(this, _, A, 2);
    }),
    (i.toString = function (_) {
      var A,
        N = this,
        M = N.s,
        T = N.e;
      return (
        T === null
          ? M
            ? ((A = "Infinity"), M < 0 && (A = "-" + A))
            : (A = "NaN")
          : (_ == null
              ? (A = T <= l || T >= u ? rv(el(N.c), T) : bc(el(N.c), T, "0"))
              : _ === 10 && y
              ? ((N = P(new v(N), a + T + 1, o)), (A = bc(el(N.c), N.e, "0")))
              : (ei(_, 2, w.length, "Base"),
                (A = n(bc(el(N.c), T, "0"), 10, _, M, !0))),
            M < 0 && N.c[0] && (A = "-" + A)),
        A
      );
    }),
    (i.valueOf = i.toJSON =
      function () {
        return x(this);
      }),
    (i._isBigNumber = !0),
    (i[Symbol.toStringTag] = "BigNumber"),
    (i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf),
    t != null && v.set(t),
    v
  );
}
function il(t) {
  var e = t | 0;
  return t > 0 || t === e ? e : e - 1;
}
function el(t) {
  for (var e, n, r = 1, i = t.length, s = t[0] + ""; r < i; ) {
    for (e = t[r++] + "", n = vn - e.length; n--; e = "0" + e);
    s += e;
  }
  for (i = s.length; s.charCodeAt(--i) === 48; );
  return s.slice(0, i + 1 || 1);
}
function Rd(t, e) {
  var n,
    r,
    i = t.c,
    s = e.c,
    a = t.s,
    o = e.s,
    l = t.e,
    u = e.e;
  if (!a || !o) return null;
  if (((n = i && !i[0]), (r = s && !s[0]), n || r)) return n ? (r ? 0 : -o) : a;
  if (a != o) return a;
  if (((n = a < 0), (r = l == u), !i || !s)) return r ? 0 : !i ^ n ? 1 : -1;
  if (!r) return (l > u) ^ n ? 1 : -1;
  for (o = (l = i.length) < (u = s.length) ? l : u, a = 0; a < o; a++)
    if (i[a] != s[a]) return (i[a] > s[a]) ^ n ? 1 : -1;
  return l == u ? 0 : (l > u) ^ n ? 1 : -1;
}
function ei(t, e, n, r) {
  if (t < e || t > n || t !== rl(t))
    throw Error(
      Wa +
        (r || "Argument") +
        (typeof t == "number"
          ? t < e || t > n
            ? " out of range: "
            : " not an integer: "
          : " not a primitive number: ") +
        String(t)
    );
}
function nv(t) {
  var e = t.c.length - 1;
  return il(t.e / vn) == e && t.c[e] % 2 != 0;
}
function rv(t, e) {
  return (
    (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) +
    (e < 0 ? "e" : "e+") +
    e
  );
}
function bc(t, e, n) {
  var r, i;
  if (e < 0) {
    for (i = n + "."; ++e; i += n);
    t = i + t;
  } else if (((r = t.length), ++e > r)) {
    for (i = n, e -= r; --e; i += n);
    t += i;
  } else e < r && (t = t.slice(0, e) + "." + t.slice(e));
  return t;
}
var gh = dj();
function hj(t) {
  return new gh(t).div(1e18).toString(10);
}
var td;
(function (t) {
  (t[(t.ACCOUNT_ACCESS_REJECTED = 4001)] = "ACCOUNT_ACCESS_REJECTED"),
    (t[(t.ACCOUNT_ACCESS_ALREADY_REQUESTED = -32002)] =
      "ACCOUNT_ACCESS_ALREADY_REQUESTED"),
    (t[(t.UNAUTHORIZED = 4100)] = "UNAUTHORIZED"),
    (t[(t.INVALID_PARAMS = -32602)] = "INVALID_PARAMS"),
    (t[(t.UNSUPPORTED_METHOD = 4200)] = "UNSUPPORTED_METHOD"),
    (t[(t.DISCONNECTED = 4900)] = "DISCONNECTED"),
    (t[(t.CHAIN_DISCONNECTED = 4901)] = "CHAIN_DISCONNECTED"),
    (t[(t.CHAIN_NOT_ADDED = 4902)] = "CHAIN_NOT_ADDED"),
    (t[(t.DOES_NOT_EXIST = -32601)] = "DOES_NOT_EXIST"),
    (t[(t.UNRECOGNIZED_CHAIN_ID = -32603)] = "UNRECOGNIZED_CHAIN_ID");
})(td || (td = {}));
function Ri(t, e) {
  const n = t.validate(e);
  return n.error ? n : null;
}
const M7 = ae
    .alternatives()
    .try(ae.string().pattern(/^0x[0-9a-fA-F]+$/), ae.number().positive()),
  L7 = ae.string().valid("evm"),
  Qoe = ae.object({
    url: ae.string().required(),
    headers: ae.object(),
    user: ae.string(),
    password: ae.string(),
    allowInsecureAuthentication: ae.boolean(),
    allowGzip: ae.boolean(),
    throttleLimit: ae.number(),
    throttleSlotInterval: ae.number(),
    throttleCallback: ae.function(),
    timeout: ae.number(),
  }),
  Joe = ae.object({
    address: ae.string().required(),
    icon: ae.string().optional(),
  }),
  ele = ae.object({
    namespace: L7,
    id: M7.required(),
    rpcUrl: ae.string(),
    label: ae.string(),
    token: ae.string(),
    secondaryTokens: ae.array().max(5).items(Joe).optional(),
    icon: ae.string(),
    color: ae.string(),
    publicRpcUrl: ae.string(),
    protectedRpcUrl: ae.string(),
    blockExplorerUrl: ae.string(),
    providerConnectionInfoValidation: Qoe,
  });
var i5 = { exports: {} };
i5.exports;
(function (t, e) {
  var n = 200,
    r = "Expected a function",
    i = "__lodash_hash_undefined__",
    s = 1,
    a = 2,
    o = 1 / 0,
    l = 9007199254740991,
    u = "[object Arguments]",
    f = "[object Array]",
    c = "[object Boolean]",
    d = "[object Date]",
    p = "[object Error]",
    m = "[object Function]",
    g = "[object GeneratorFunction]",
    w = "[object Map]",
    y = "[object Number]",
    v = "[object Object]",
    E = "[object Promise]",
    S = "[object RegExp]",
    D = "[object Set]",
    P = "[object String]",
    x = "[object Symbol]",
    _ = "[object WeakMap]",
    A = "[object ArrayBuffer]",
    N = "[object DataView]",
    M = "[object Float32Array]",
    T = "[object Float64Array]",
    O = "[object Int8Array]",
    I = "[object Int16Array]",
    k = "[object Int32Array]",
    L = "[object Uint8Array]",
    U = "[object Uint8ClampedArray]",
    $ = "[object Uint16Array]",
    B = "[object Uint32Array]",
    R = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    V = /^\w*$/,
    oe = /^\./,
    le =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    fe = /[\\^$.*+?()[\]{}|]/g,
    z = /\\(\\)?/g,
    se = /^\[object .+?Constructor\]$/,
    Y = /^(?:0|[1-9]\d*)$/,
    Q = {};
  (Q[M] = Q[T] = Q[O] = Q[I] = Q[k] = Q[L] = Q[U] = Q[$] = Q[B] = !0),
    (Q[u] =
      Q[f] =
      Q[A] =
      Q[c] =
      Q[N] =
      Q[d] =
      Q[p] =
      Q[m] =
      Q[w] =
      Q[y] =
      Q[v] =
      Q[S] =
      Q[D] =
      Q[P] =
      Q[_] =
        !1);
  var ee = typeof Ur == "object" && Ur && Ur.Object === Object && Ur,
    F = typeof self == "object" && self && self.Object === Object && self,
    te = ee || F || Function("return this")(),
    he = e && !e.nodeType && e,
    Te = he && !0 && t && !t.nodeType && t,
    Ce = Te && Te.exports === he,
    ke = Ce && ee.process,
    at = (function () {
      try {
        return ke && ke.binding("util");
      } catch {}
    })(),
    Rt = at && at.isTypedArray;
  function Ft(X, j, K, ce) {
    for (var Ee = -1, Ne = X ? X.length : 0; ++Ee < Ne; ) {
      var Ie = X[Ee];
      j(ce, Ie, K(Ie), X);
    }
    return ce;
  }
  function Nt(X, j) {
    for (var K = -1, ce = X ? X.length : 0; ++K < ce; )
      if (j(X[K], K, X)) return !0;
    return !1;
  }
  function Ot(X) {
    return function (j) {
      return j?.[X];
    };
  }
  function et(X, j) {
    for (var K = -1, ce = Array(X); ++K < X; ) ce[K] = j(K);
    return ce;
  }
  function st(X) {
    return function (j) {
      return X(j);
    };
  }
  function vt(X, j) {
    return X?.[j];
  }
  function Re(X) {
    var j = !1;
    if (X != null && typeof X.toString != "function")
      try {
        j = !!(X + "");
      } catch {}
    return j;
  }
  function me(X) {
    var j = -1,
      K = Array(X.size);
    return (
      X.forEach(function (ce, Ee) {
        K[++j] = [Ee, ce];
      }),
      K
    );
  }
  function $e(X, j) {
    return function (K) {
      return X(j(K));
    };
  }
  function De(X) {
    var j = -1,
      K = Array(X.size);
    return (
      X.forEach(function (ce) {
        K[++j] = ce;
      }),
      K
    );
  }
  var je = Array.prototype,
    lt = Function.prototype,
    Ke = Object.prototype,
    tt = te["__core-js_shared__"],
    jt = (function () {
      var X = /[^.]+$/.exec((tt && tt.keys && tt.keys.IE_PROTO) || "");
      return X ? "Symbol(src)_1." + X : "";
    })(),
    ct = lt.toString,
    rt = Ke.hasOwnProperty,
    Dt = Ke.toString,
    Ht = RegExp(
      "^" +
        ct
          .call(rt)
          .replace(fe, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    Yt = te.Symbol,
    sr = te.Uint8Array,
    Bt = Ke.propertyIsEnumerable,
    en = je.splice,
    Tr = $e(Object.keys, Object),
    on = Qr(te, "DataView"),
    Pt = Qr(te, "Map"),
    fn = Qr(te, "Promise"),
    Wt = Qr(te, "Set"),
    qt = Qr(te, "WeakMap"),
    Ye = Qr(Object, "create"),
    xe = q(on),
    nt = q(Pt),
    gt = q(fn),
    ht = q(Wt),
    wt = q(qt),
    rn = Yt ? Yt.prototype : void 0,
    ot = rn ? rn.valueOf : void 0,
    pt = rn ? rn.toString : void 0;
  function zt(X) {
    var j = -1,
      K = X ? X.length : 0;
    for (this.clear(); ++j < K; ) {
      var ce = X[j];
      this.set(ce[0], ce[1]);
    }
  }
  function Zt() {
    this.__data__ = Ye ? Ye(null) : {};
  }
  function $t(X) {
    return this.has(X) && delete this.__data__[X];
  }
  function Vr(X) {
    var j = this.__data__;
    if (Ye) {
      var K = j[X];
      return K === i ? void 0 : K;
    }
    return rt.call(j, X) ? j[X] : void 0;
  }
  function $n(X) {
    var j = this.__data__;
    return Ye ? j[X] !== void 0 : rt.call(j, X);
  }
  function En(X, j) {
    var K = this.__data__;
    return (K[X] = Ye && j === void 0 ? i : j), this;
  }
  (zt.prototype.clear = Zt),
    (zt.prototype.delete = $t),
    (zt.prototype.get = Vr),
    (zt.prototype.has = $n),
    (zt.prototype.set = En);
  function In(X) {
    var j = -1,
      K = X ? X.length : 0;
    for (this.clear(); ++j < K; ) {
      var ce = X[j];
      this.set(ce[0], ce[1]);
    }
  }
  function as() {
    this.__data__ = [];
  }
  function os(X) {
    var j = this.__data__,
      K = $s(j, X);
    if (K < 0) return !1;
    var ce = j.length - 1;
    return K == ce ? j.pop() : en.call(j, K, 1), !0;
  }
  function ls(X) {
    var j = this.__data__,
      K = $s(j, X);
    return K < 0 ? void 0 : j[K][1];
  }
  function us(X) {
    return $s(this.__data__, X) > -1;
  }
  function Or(X, j) {
    var K = this.__data__,
      ce = $s(K, X);
    return ce < 0 ? K.push([X, j]) : (K[ce][1] = j), this;
  }
  (In.prototype.clear = as),
    (In.prototype.delete = os),
    (In.prototype.get = ls),
    (In.prototype.has = us),
    (In.prototype.set = Or);
  function ar(X) {
    var j = -1,
      K = X ? X.length : 0;
    for (this.clear(); ++j < K; ) {
      var ce = X[j];
      this.set(ce[0], ce[1]);
    }
  }
  function cs() {
    this.__data__ = { hash: new zt(), map: new (Pt || In)(), string: new zt() };
  }
  function lo(X) {
    return hs(this, X).delete(X);
  }
  function zi(X) {
    return hs(this, X).get(X);
  }
  function la(X) {
    return hs(this, X).has(X);
  }
  function xi(X, j) {
    return hs(this, X).set(X, j), this;
  }
  (ar.prototype.clear = cs),
    (ar.prototype.delete = lo),
    (ar.prototype.get = zi),
    (ar.prototype.has = la),
    (ar.prototype.set = xi);
  function ci(X) {
    var j = -1,
      K = X ? X.length : 0;
    for (this.__data__ = new ar(); ++j < K; ) this.add(X[j]);
  }
  function ua(X) {
    return this.__data__.set(X, i), this;
  }
  function Ra(X) {
    return this.__data__.has(X);
  }
  (ci.prototype.add = ci.prototype.push = ua), (ci.prototype.has = Ra);
  function pr(X) {
    this.__data__ = new In(X);
  }
  function uo() {
    this.__data__ = new In();
  }
  function fs(X) {
    return this.__data__.delete(X);
  }
  function co(X) {
    return this.__data__.get(X);
  }
  function lc(X) {
    return this.__data__.has(X);
  }
  function ds(X, j) {
    var K = this.__data__;
    if (K instanceof In) {
      var ce = K.__data__;
      if (!Pt || ce.length < n - 1) return ce.push([X, j]), this;
      K = this.__data__ = new ar(ce);
    }
    return K.set(X, j), this;
  }
  (pr.prototype.clear = uo),
    (pr.prototype.delete = fs),
    (pr.prototype.get = co),
    (pr.prototype.has = lc),
    (pr.prototype.set = ds);
  function cu(X, j) {
    var K = kt(X) || St(X) ? et(X.length, String) : [],
      ce = K.length,
      Ee = !!ce;
    for (var Ne in X)
      (j || rt.call(X, Ne)) &&
        !(Ee && (Ne == "length" || js(Ne, ce))) &&
        K.push(Ne);
    return K;
  }
  function $s(X, j) {
    for (var K = X.length; K--; ) if (Me(X[K][0], j)) return K;
    return -1;
  }
  function Al(X, j, K, ce) {
    return (
      fo(X, function (Ee, Ne, Ie) {
        j(ce, Ee, K(Ee), Ie);
      }),
      ce
    );
  }
  var fo = Il(ho),
    Cl = Go();
  function ho(X, j) {
    return X && Cl(X, j, zs);
  }
  function Ma(X, j) {
    j = Hs(j, X) ? [j] : kl(j);
    for (var K = 0, ce = j.length; X != null && K < ce; ) X = X[pe(j[K++])];
    return K && K == ce ? X : void 0;
  }
  function po(X) {
    return Dt.call(X);
  }
  function jo(X, j) {
    return X != null && j in Object(X);
  }
  function Ho(X, j, K, ce, Ee) {
    return X === j
      ? !0
      : X == null || j == null || (!pn(X) && !xn(j))
      ? X !== X && j !== j
      : La(X, j, Ho, K, ce, Ee);
  }
  function La(X, j, K, ce, Ee, Ne) {
    var Ie = kt(X),
      xt = kt(j),
      Kt = f,
      ln = f;
    Ie || ((Kt = Gr(X)), (Kt = Kt == u ? v : Kt)),
      xt || ((ln = Gr(j)), (ln = ln == u ? v : ln));
    var Tn = Kt == v && !Re(X),
      On = ln == v && !Re(j),
      wn = Kt == ln;
    if (wn && !Tn)
      return (
        Ne || (Ne = new pr()),
        Ie || Gi(X) ? Vi(X, j, K, ce, Ee, Ne) : Wo(X, j, Kt, K, ce, Ee, Ne)
      );
    if (!(Ee & a)) {
      var jn = Tn && rt.call(X, "__wrapped__"),
        br = On && rt.call(j, "__wrapped__");
      if (jn || br) {
        var Pr = jn ? X.value() : X,
          Br = br ? j.value() : j;
        return Ne || (Ne = new pr()), K(Pr, Br, ce, Ee, Ne);
      }
    }
    return wn ? (Ne || (Ne = new pr()), qo(X, j, K, ce, Ee, Ne)) : !1;
  }
  function fu(X, j, K, ce) {
    var Ee = K.length,
      Ne = Ee,
      Ie = !ce;
    if (X == null) return !Ne;
    for (X = Object(X); Ee--; ) {
      var xt = K[Ee];
      if (Ie && xt[2] ? xt[1] !== X[xt[0]] : !(xt[0] in X)) return !1;
    }
    for (; ++Ee < Ne; ) {
      xt = K[Ee];
      var Kt = xt[0],
        ln = X[Kt],
        Tn = xt[1];
      if (Ie && xt[2]) {
        if (ln === void 0 && !(Kt in X)) return !1;
      } else {
        var On = new pr();
        if (ce) var wn = ce(ln, Tn, Kt, X, j, On);
        if (!(wn === void 0 ? Ho(Tn, ln, ce, s | a, On) : wn)) return !1;
      }
    }
    return !0;
  }
  function du(X) {
    if (!pn(X) || yu(X)) return !1;
    var j = tn(X) || Re(X) ? Ht : se;
    return j.test(q(X));
  }
  function zo(X) {
    return xn(X) && Kn(X.length) && !!Q[Dt.call(X)];
  }
  function Ba(X) {
    return typeof X == "function"
      ? X
      : X == null
      ? fi
      : typeof X == "object"
      ? kt(X)
        ? pu(X[0], X[1])
        : hu(X)
      : L1(X);
  }
  function Mi(X) {
    if (!vu(X)) return Tr(X);
    var j = [];
    for (var K in Object(X)) rt.call(X, K) && K != "constructor" && j.push(K);
    return j;
  }
  function hu(X) {
    var j = gu(X);
    return j.length == 1 && j[0][2]
      ? Un(j[0][0], j[0][1])
      : function (K) {
          return K === X || fu(K, X, j);
        };
  }
  function pu(X, j) {
    return Hs(X) && qn(j)
      ? Un(pe(X), j)
      : function (K) {
          var ce = $a(K, X);
          return ce === void 0 && ce === j
            ? uc(K, X)
            : Ho(j, ce, void 0, s | a);
        };
  }
  function Us(X) {
    return function (j) {
      return Ma(j, X);
    };
  }
  function Vo(X) {
    if (typeof X == "string") return X;
    if (Sr(X)) return pt ? pt.call(X) : "";
    var j = X + "";
    return j == "0" && 1 / X == -o ? "-0" : j;
  }
  function kl(X) {
    return kt(X) ? X : re(X);
  }
  function mu(X, j) {
    return function (K, ce) {
      var Ee = kt(K) ? Ft : Al,
        Ne = j ? j() : {};
      return Ee(K, X, Ba(ce), Ne);
    };
  }
  function Il(X, j) {
    return function (K, ce) {
      if (K == null) return K;
      if (!_t(K)) return X(K, ce);
      for (
        var Ee = K.length, Ne = j ? Ee : -1, Ie = Object(K);
        (j ? Ne-- : ++Ne < Ee) && ce(Ie[Ne], Ne, Ie) !== !1;

      );
      return K;
    };
  }
  function Go(X) {
    return function (j, K, ce) {
      for (var Ee = -1, Ne = Object(j), Ie = ce(j), xt = Ie.length; xt--; ) {
        var Kt = Ie[X ? xt : ++Ee];
        if (K(Ne[Kt], Kt, Ne) === !1) break;
      }
      return j;
    };
  }
  function Vi(X, j, K, ce, Ee, Ne) {
    var Ie = Ee & a,
      xt = X.length,
      Kt = j.length;
    if (xt != Kt && !(Ie && Kt > xt)) return !1;
    var ln = Ne.get(X);
    if (ln && Ne.get(j)) return ln == j;
    var Tn = -1,
      On = !0,
      wn = Ee & s ? new ci() : void 0;
    for (Ne.set(X, j), Ne.set(j, X); ++Tn < xt; ) {
      var jn = X[Tn],
        br = j[Tn];
      if (ce) var Pr = Ie ? ce(br, jn, Tn, j, X, Ne) : ce(jn, br, Tn, X, j, Ne);
      if (Pr !== void 0) {
        if (Pr) continue;
        On = !1;
        break;
      }
      if (wn) {
        if (
          !Nt(j, function (Br, qi) {
            if (!wn.has(qi) && (jn === Br || K(jn, Br, ce, Ee, Ne)))
              return wn.add(qi);
          })
        ) {
          On = !1;
          break;
        }
      } else if (!(jn === br || K(jn, br, ce, Ee, Ne))) {
        On = !1;
        break;
      }
    }
    return Ne.delete(X), Ne.delete(j), On;
  }
  function Wo(X, j, K, ce, Ee, Ne, Ie) {
    switch (K) {
      case N:
        if (X.byteLength != j.byteLength || X.byteOffset != j.byteOffset)
          return !1;
        (X = X.buffer), (j = j.buffer);
      case A:
        return !(X.byteLength != j.byteLength || !ce(new sr(X), new sr(j)));
      case c:
      case d:
      case y:
        return Me(+X, +j);
      case p:
        return X.name == j.name && X.message == j.message;
      case S:
      case P:
        return X == j + "";
      case w:
        var xt = me;
      case D:
        var Kt = Ne & a;
        if ((xt || (xt = De), X.size != j.size && !Kt)) return !1;
        var ln = Ie.get(X);
        if (ln) return ln == j;
        (Ne |= s), Ie.set(X, j);
        var Tn = Vi(xt(X), xt(j), ce, Ee, Ne, Ie);
        return Ie.delete(X), Tn;
      case x:
        if (ot) return ot.call(X) == ot.call(j);
    }
    return !1;
  }
  function qo(X, j, K, ce, Ee, Ne) {
    var Ie = Ee & a,
      xt = zs(X),
      Kt = xt.length,
      ln = zs(j),
      Tn = ln.length;
    if (Kt != Tn && !Ie) return !1;
    for (var On = Kt; On--; ) {
      var wn = xt[On];
      if (!(Ie ? wn in j : rt.call(j, wn))) return !1;
    }
    var jn = Ne.get(X);
    if (jn && Ne.get(j)) return jn == j;
    var br = !0;
    Ne.set(X, j), Ne.set(j, X);
    for (var Pr = Ie; ++On < Kt; ) {
      wn = xt[On];
      var Br = X[wn],
        qi = j[wn];
      if (ce) var mo = Ie ? ce(qi, Br, wn, j, X, Ne) : ce(Br, qi, wn, X, j, Ne);
      if (!(mo === void 0 ? Br === qi || K(Br, qi, ce, Ee, Ne) : mo)) {
        br = !1;
        break;
      }
      Pr || (Pr = wn == "constructor");
    }
    if (br && !Pr) {
      var bu = X.constructor,
        go = j.constructor;
      bu != go &&
        "constructor" in X &&
        "constructor" in j &&
        !(
          typeof bu == "function" &&
          bu instanceof bu &&
          typeof go == "function" &&
          go instanceof go
        ) &&
        (br = !1);
    }
    return Ne.delete(X), Ne.delete(j), br;
  }
  function hs(X, j) {
    var K = X.__data__;
    return Fa(j) ? K[typeof j == "string" ? "string" : "hash"] : K.map;
  }
  function gu(X) {
    for (var j = zs(X), K = j.length; K--; ) {
      var ce = j[K],
        Ee = X[ce];
      j[K] = [ce, Ee, qn(Ee)];
    }
    return j;
  }
  function Qr(X, j) {
    var K = vt(X, j);
    return du(K) ? K : void 0;
  }
  var Gr = po;
  ((on && Gr(new on(new ArrayBuffer(1))) != N) ||
    (Pt && Gr(new Pt()) != w) ||
    (fn && Gr(fn.resolve()) != E) ||
    (Wt && Gr(new Wt()) != D) ||
    (qt && Gr(new qt()) != _)) &&
    (Gr = function (X) {
      var j = Dt.call(X),
        K = j == v ? X.constructor : void 0,
        ce = K ? q(K) : void 0;
      if (ce)
        switch (ce) {
          case xe:
            return N;
          case nt:
            return w;
          case gt:
            return E;
          case ht:
            return D;
          case wt:
            return _;
        }
      return j;
    });
  function ps(X, j, K) {
    j = Hs(j, X) ? [j] : kl(j);
    for (var ce, Ee = -1, Ie = j.length; ++Ee < Ie; ) {
      var Ne = pe(j[Ee]);
      if (!(ce = X != null && K(X, Ne))) break;
      X = X[Ne];
    }
    if (ce) return ce;
    var Ie = X ? X.length : 0;
    return !!Ie && Kn(Ie) && js(Ne, Ie) && (kt(X) || St(X));
  }
  function js(X, j) {
    return (
      (j = j ?? l),
      !!j &&
        (typeof X == "number" || Y.test(X)) &&
        X > -1 &&
        X % 1 == 0 &&
        X < j
    );
  }
  function Hs(X, j) {
    if (kt(X)) return !1;
    var K = typeof X;
    return K == "number" ||
      K == "symbol" ||
      K == "boolean" ||
      X == null ||
      Sr(X)
      ? !0
      : V.test(X) || !R.test(X) || (j != null && X in Object(j));
  }
  function Fa(X) {
    var j = typeof X;
    return j == "string" || j == "number" || j == "symbol" || j == "boolean"
      ? X !== "__proto__"
      : X === null;
  }
  function yu(X) {
    return !!jt && jt in X;
  }
  function vu(X) {
    var j = X && X.constructor,
      K = (typeof j == "function" && j.prototype) || Ke;
    return X === K;
  }
  function qn(X) {
    return X === X && !pn(X);
  }
  function Un(X, j) {
    return function (K) {
      return K == null ? !1 : K[X] === j && (j !== void 0 || X in Object(K));
    };
  }
  var re = ve(function (X) {
    X = Wi(X);
    var j = [];
    return (
      oe.test(X) && j.push(""),
      X.replace(le, function (K, ce, Ee, Ne) {
        j.push(Ee ? Ne.replace(z, "$1") : ce || K);
      }),
      j
    );
  });
  function pe(X) {
    if (typeof X == "string" || Sr(X)) return X;
    var j = X + "";
    return j == "0" && 1 / X == -o ? "-0" : j;
  }
  function q(X) {
    if (X != null) {
      try {
        return ct.call(X);
      } catch {}
      try {
        return X + "";
      } catch {}
    }
    return "";
  }
  var ie = mu(
    function (X, j, K) {
      X[K ? 0 : 1].push(j);
    },
    function () {
      return [[], []];
    }
  );
  function ve(X, j) {
    if (typeof X != "function" || (j && typeof j != "function"))
      throw new TypeError(r);
    var K = function () {
      var ce = arguments,
        Ee = j ? j.apply(this, ce) : ce[0],
        Ne = K.cache;
      if (Ne.has(Ee)) return Ne.get(Ee);
      var Ie = X.apply(this, ce);
      return (K.cache = Ne.set(Ee, Ie)), Ie;
    };
    return (K.cache = new (ve.Cache || ar)()), K;
  }
  ve.Cache = ar;
  function Me(X, j) {
    return X === j || (X !== X && j !== j);
  }
  function St(X) {
    return (
      Et(X) &&
      rt.call(X, "callee") &&
      (!Bt.call(X, "callee") || Dt.call(X) == u)
    );
  }
  var kt = Array.isArray;
  function _t(X) {
    return X != null && Kn(X.length) && !tn(X);
  }
  function Et(X) {
    return xn(X) && _t(X);
  }
  function tn(X) {
    var j = pn(X) ? Dt.call(X) : "";
    return j == m || j == g;
  }
  function Kn(X) {
    return typeof X == "number" && X > -1 && X % 1 == 0 && X <= l;
  }
  function pn(X) {
    var j = typeof X;
    return !!X && (j == "object" || j == "function");
  }
  function xn(X) {
    return !!X && typeof X == "object";
  }
  function Sr(X) {
    return typeof X == "symbol" || (xn(X) && Dt.call(X) == x);
  }
  var Gi = Rt ? st(Rt) : zo;
  function Wi(X) {
    return X == null ? "" : Vo(X);
  }
  function $a(X, j, K) {
    var ce = X == null ? void 0 : Ma(X, j);
    return ce === void 0 ? K : ce;
  }
  function uc(X, j) {
    return X != null && ps(X, j, jo);
  }
  function zs(X) {
    return _t(X) ? cu(X) : Mi(X);
  }
  function fi(X) {
    return X;
  }
  function L1(X) {
    return Hs(X) ? Ot(pe(X)) : Us(X);
  }
  t.exports = ie;
})(i5, i5.exports);
var tle = i5.exports;
const nle = oa(tle);
var B7 = { exports: {} };
const rle = {},
  ile = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: rle },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  pj = w9(ile);
B7.exports;
(function (t) {
  (function (e, n) {
    function r(M, T) {
      if (!M) throw new Error(T || "Assertion failed");
    }
    function i(M, T) {
      M.super_ = T;
      var O = function () {};
      (O.prototype = T.prototype),
        (M.prototype = new O()),
        (M.prototype.constructor = M);
    }
    function s(M, T, O) {
      if (s.isBN(M)) return M;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        M !== null &&
          ((T === "le" || T === "be") && ((O = T), (T = 10)),
          this._init(M || 0, T || 10, O || "be"));
    }
    typeof e == "object" ? (e.exports = s) : (n.BN = s),
      (s.BN = s),
      (s.wordSize = 26);
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u"
        ? (a = window.Buffer)
        : (a = pj.Buffer);
    } catch {}
    (s.isBN = function (T) {
      return T instanceof s
        ? !0
        : T !== null &&
            typeof T == "object" &&
            T.constructor.wordSize === s.wordSize &&
            Array.isArray(T.words);
    }),
      (s.max = function (T, O) {
        return T.cmp(O) > 0 ? T : O;
      }),
      (s.min = function (T, O) {
        return T.cmp(O) < 0 ? T : O;
      }),
      (s.prototype._init = function (T, O, I) {
        if (typeof T == "number") return this._initNumber(T, O, I);
        if (typeof T == "object") return this._initArray(T, O, I);
        O === "hex" && (O = 16),
          r(O === (O | 0) && O >= 2 && O <= 36),
          (T = T.toString().replace(/\s+/g, ""));
        var k = 0;
        T[0] === "-" && (k++, (this.negative = 1)),
          k < T.length &&
            (O === 16
              ? this._parseHex(T, k, I)
              : (this._parseBase(T, O, k),
                I === "le" && this._initArray(this.toArray(), O, I)));
      }),
      (s.prototype._initNumber = function (T, O, I) {
        T < 0 && ((this.negative = 1), (T = -T)),
          T < 67108864
            ? ((this.words = [T & 67108863]), (this.length = 1))
            : T < 4503599627370496
            ? ((this.words = [T & 67108863, (T / 67108864) & 67108863]),
              (this.length = 2))
            : (r(T < 9007199254740992),
              (this.words = [T & 67108863, (T / 67108864) & 67108863, 1]),
              (this.length = 3)),
          I === "le" && this._initArray(this.toArray(), O, I);
      }),
      (s.prototype._initArray = function (T, O, I) {
        if ((r(typeof T.length == "number"), T.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(T.length / 3)),
          (this.words = new Array(this.length));
        for (var k = 0; k < this.length; k++) this.words[k] = 0;
        var L,
          U,
          $ = 0;
        if (I === "be")
          for (k = T.length - 1, L = 0; k >= 0; k -= 3)
            (U = T[k] | (T[k - 1] << 8) | (T[k - 2] << 16)),
              (this.words[L] |= (U << $) & 67108863),
              (this.words[L + 1] = (U >>> (26 - $)) & 67108863),
              ($ += 24),
              $ >= 26 && (($ -= 26), L++);
        else if (I === "le")
          for (k = 0, L = 0; k < T.length; k += 3)
            (U = T[k] | (T[k + 1] << 8) | (T[k + 2] << 16)),
              (this.words[L] |= (U << $) & 67108863),
              (this.words[L + 1] = (U >>> (26 - $)) & 67108863),
              ($ += 24),
              $ >= 26 && (($ -= 26), L++);
        return this.strip();
      });
    function o(M, T) {
      var O = M.charCodeAt(T);
      return O >= 65 && O <= 70
        ? O - 55
        : O >= 97 && O <= 102
        ? O - 87
        : (O - 48) & 15;
    }
    function l(M, T, O) {
      var I = o(M, O);
      return O - 1 >= T && (I |= o(M, O - 1) << 4), I;
    }
    s.prototype._parseHex = function (T, O, I) {
      (this.length = Math.ceil((T.length - O) / 6)),
        (this.words = new Array(this.length));
      for (var k = 0; k < this.length; k++) this.words[k] = 0;
      var L = 0,
        U = 0,
        $;
      if (I === "be")
        for (k = T.length - 1; k >= O; k -= 2)
          ($ = l(T, O, k) << L),
            (this.words[U] |= $ & 67108863),
            L >= 18
              ? ((L -= 18), (U += 1), (this.words[U] |= $ >>> 26))
              : (L += 8);
      else {
        var B = T.length - O;
        for (k = B % 2 === 0 ? O + 1 : O; k < T.length; k += 2)
          ($ = l(T, O, k) << L),
            (this.words[U] |= $ & 67108863),
            L >= 18
              ? ((L -= 18), (U += 1), (this.words[U] |= $ >>> 26))
              : (L += 8);
      }
      this.strip();
    };
    function u(M, T, O, I) {
      for (var k = 0, L = Math.min(M.length, O), U = T; U < L; U++) {
        var $ = M.charCodeAt(U) - 48;
        (k *= I),
          $ >= 49
            ? (k += $ - 49 + 10)
            : $ >= 17
            ? (k += $ - 17 + 10)
            : (k += $);
      }
      return k;
    }
    (s.prototype._parseBase = function (T, O, I) {
      (this.words = [0]), (this.length = 1);
      for (var k = 0, L = 1; L <= 67108863; L *= O) k++;
      k--, (L = (L / O) | 0);
      for (
        var U = T.length - I,
          $ = U % k,
          B = Math.min(U, U - $) + I,
          R = 0,
          V = I;
        V < B;
        V += k
      )
        (R = u(T, V, V + k, O)),
          this.imuln(L),
          this.words[0] + R < 67108864 ? (this.words[0] += R) : this._iaddn(R);
      if ($ !== 0) {
        var oe = 1;
        for (R = u(T, V, T.length, O), V = 0; V < $; V++) oe *= O;
        this.imuln(oe),
          this.words[0] + R < 67108864 ? (this.words[0] += R) : this._iaddn(R);
      }
      this.strip();
    }),
      (s.prototype.copy = function (T) {
        T.words = new Array(this.length);
        for (var O = 0; O < this.length; O++) T.words[O] = this.words[O];
        (T.length = this.length),
          (T.negative = this.negative),
          (T.red = this.red);
      }),
      (s.prototype.clone = function () {
        var T = new s(null);
        return this.copy(T), T;
      }),
      (s.prototype._expand = function (T) {
        for (; this.length < T; ) this.words[this.length++] = 0;
        return this;
      }),
      (s.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (s.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      (s.prototype.inspect = function () {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      });
    var f = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      c = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      d = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (s.prototype.toString = function (T, O) {
      (T = T || 10), (O = O | 0 || 1);
      var I;
      if (T === 16 || T === "hex") {
        I = "";
        for (var k = 0, L = 0, U = 0; U < this.length; U++) {
          var $ = this.words[U],
            B = ((($ << k) | L) & 16777215).toString(16);
          (L = ($ >>> (24 - k)) & 16777215),
            L !== 0 || U !== this.length - 1
              ? (I = f[6 - B.length] + B + I)
              : (I = B + I),
            (k += 2),
            k >= 26 && ((k -= 26), U--);
        }
        for (L !== 0 && (I = L.toString(16) + I); I.length % O !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (T === (T | 0) && T >= 2 && T <= 36) {
        var R = c[T],
          V = d[T];
        I = "";
        var oe = this.clone();
        for (oe.negative = 0; !oe.isZero(); ) {
          var le = oe.modn(V).toString(T);
          (oe = oe.idivn(V)),
            oe.isZero() ? (I = le + I) : (I = f[R - le.length] + le + I);
        }
        for (this.isZero() && (I = "0" + I); I.length % O !== 0; ) I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      r(!1, "Base should be between 2 and 36");
    }),
      (s.prototype.toNumber = function () {
        var T = this.words[0];
        return (
          this.length === 2
            ? (T += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (T += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              r(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -T : T
        );
      }),
      (s.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (s.prototype.toBuffer = function (T, O) {
        return r(typeof a < "u"), this.toArrayLike(a, T, O);
      }),
      (s.prototype.toArray = function (T, O) {
        return this.toArrayLike(Array, T, O);
      }),
      (s.prototype.toArrayLike = function (T, O, I) {
        var k = this.byteLength(),
          L = I || Math.max(1, k);
        r(k <= L, "byte array longer than desired length"),
          r(L > 0, "Requested array length <= 0"),
          this.strip();
        var U = O === "le",
          $ = new T(L),
          B,
          R,
          V = this.clone();
        if (U) {
          for (R = 0; !V.isZero(); R++)
            (B = V.andln(255)), V.iushrn(8), ($[R] = B);
          for (; R < L; R++) $[R] = 0;
        } else {
          for (R = 0; R < L - k; R++) $[R] = 0;
          for (R = 0; !V.isZero(); R++)
            (B = V.andln(255)), V.iushrn(8), ($[L - R - 1] = B);
        }
        return $;
      }),
      Math.clz32
        ? (s.prototype._countBits = function (T) {
            return 32 - Math.clz32(T);
          })
        : (s.prototype._countBits = function (T) {
            var O = T,
              I = 0;
            return (
              O >= 4096 && ((I += 13), (O >>>= 13)),
              O >= 64 && ((I += 7), (O >>>= 7)),
              O >= 8 && ((I += 4), (O >>>= 4)),
              O >= 2 && ((I += 2), (O >>>= 2)),
              I + O
            );
          }),
      (s.prototype._zeroBits = function (T) {
        if (T === 0) return 26;
        var O = T,
          I = 0;
        return (
          O & 8191 || ((I += 13), (O >>>= 13)),
          O & 127 || ((I += 7), (O >>>= 7)),
          O & 15 || ((I += 4), (O >>>= 4)),
          O & 3 || ((I += 2), (O >>>= 2)),
          O & 1 || I++,
          I
        );
      }),
      (s.prototype.bitLength = function () {
        var T = this.words[this.length - 1],
          O = this._countBits(T);
        return (this.length - 1) * 26 + O;
      });
    function p(M) {
      for (var T = new Array(M.bitLength()), O = 0; O < T.length; O++) {
        var I = (O / 26) | 0,
          k = O % 26;
        T[O] = (M.words[I] & (1 << k)) >>> k;
      }
      return T;
    }
    (s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var T = 0, O = 0; O < this.length; O++) {
        var I = this._zeroBits(this.words[O]);
        if (((T += I), I !== 26)) break;
      }
      return T;
    }),
      (s.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (s.prototype.toTwos = function (T) {
        return this.negative !== 0
          ? this.abs().inotn(T).iaddn(1)
          : this.clone();
      }),
      (s.prototype.fromTwos = function (T) {
        return this.testn(T - 1) ? this.notn(T).iaddn(1).ineg() : this.clone();
      }),
      (s.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (s.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (s.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (s.prototype.iuor = function (T) {
        for (; this.length < T.length; ) this.words[this.length++] = 0;
        for (var O = 0; O < T.length; O++)
          this.words[O] = this.words[O] | T.words[O];
        return this.strip();
      }),
      (s.prototype.ior = function (T) {
        return r((this.negative | T.negative) === 0), this.iuor(T);
      }),
      (s.prototype.or = function (T) {
        return this.length > T.length
          ? this.clone().ior(T)
          : T.clone().ior(this);
      }),
      (s.prototype.uor = function (T) {
        return this.length > T.length
          ? this.clone().iuor(T)
          : T.clone().iuor(this);
      }),
      (s.prototype.iuand = function (T) {
        var O;
        this.length > T.length ? (O = T) : (O = this);
        for (var I = 0; I < O.length; I++)
          this.words[I] = this.words[I] & T.words[I];
        return (this.length = O.length), this.strip();
      }),
      (s.prototype.iand = function (T) {
        return r((this.negative | T.negative) === 0), this.iuand(T);
      }),
      (s.prototype.and = function (T) {
        return this.length > T.length
          ? this.clone().iand(T)
          : T.clone().iand(this);
      }),
      (s.prototype.uand = function (T) {
        return this.length > T.length
          ? this.clone().iuand(T)
          : T.clone().iuand(this);
      }),
      (s.prototype.iuxor = function (T) {
        var O, I;
        this.length > T.length ? ((O = this), (I = T)) : ((O = T), (I = this));
        for (var k = 0; k < I.length; k++)
          this.words[k] = O.words[k] ^ I.words[k];
        if (this !== O) for (; k < O.length; k++) this.words[k] = O.words[k];
        return (this.length = O.length), this.strip();
      }),
      (s.prototype.ixor = function (T) {
        return r((this.negative | T.negative) === 0), this.iuxor(T);
      }),
      (s.prototype.xor = function (T) {
        return this.length > T.length
          ? this.clone().ixor(T)
          : T.clone().ixor(this);
      }),
      (s.prototype.uxor = function (T) {
        return this.length > T.length
          ? this.clone().iuxor(T)
          : T.clone().iuxor(this);
      }),
      (s.prototype.inotn = function (T) {
        r(typeof T == "number" && T >= 0);
        var O = Math.ceil(T / 26) | 0,
          I = T % 26;
        this._expand(O), I > 0 && O--;
        for (var k = 0; k < O; k++) this.words[k] = ~this.words[k] & 67108863;
        return (
          I > 0 && (this.words[k] = ~this.words[k] & (67108863 >> (26 - I))),
          this.strip()
        );
      }),
      (s.prototype.notn = function (T) {
        return this.clone().inotn(T);
      }),
      (s.prototype.setn = function (T, O) {
        r(typeof T == "number" && T >= 0);
        var I = (T / 26) | 0,
          k = T % 26;
        return (
          this._expand(I + 1),
          O
            ? (this.words[I] = this.words[I] | (1 << k))
            : (this.words[I] = this.words[I] & ~(1 << k)),
          this.strip()
        );
      }),
      (s.prototype.iadd = function (T) {
        var O;
        if (this.negative !== 0 && T.negative === 0)
          return (
            (this.negative = 0),
            (O = this.isub(T)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && T.negative !== 0)
          return (
            (T.negative = 0),
            (O = this.isub(T)),
            (T.negative = 1),
            O._normSign()
          );
        var I, k;
        this.length > T.length ? ((I = this), (k = T)) : ((I = T), (k = this));
        for (var L = 0, U = 0; U < k.length; U++)
          (O = (I.words[U] | 0) + (k.words[U] | 0) + L),
            (this.words[U] = O & 67108863),
            (L = O >>> 26);
        for (; L !== 0 && U < I.length; U++)
          (O = (I.words[U] | 0) + L),
            (this.words[U] = O & 67108863),
            (L = O >>> 26);
        if (((this.length = I.length), L !== 0))
          (this.words[this.length] = L), this.length++;
        else if (I !== this)
          for (; U < I.length; U++) this.words[U] = I.words[U];
        return this;
      }),
      (s.prototype.add = function (T) {
        var O;
        return T.negative !== 0 && this.negative === 0
          ? ((T.negative = 0), (O = this.sub(T)), (T.negative ^= 1), O)
          : T.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (O = T.sub(this)), (this.negative = 1), O)
          : this.length > T.length
          ? this.clone().iadd(T)
          : T.clone().iadd(this);
      }),
      (s.prototype.isub = function (T) {
        if (T.negative !== 0) {
          T.negative = 0;
          var O = this.iadd(T);
          return (T.negative = 1), O._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(T),
            (this.negative = 1),
            this._normSign()
          );
        var I = this.cmp(T);
        if (I === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var k, L;
        I > 0 ? ((k = this), (L = T)) : ((k = T), (L = this));
        for (var U = 0, $ = 0; $ < L.length; $++)
          (O = (k.words[$] | 0) - (L.words[$] | 0) + U),
            (U = O >> 26),
            (this.words[$] = O & 67108863);
        for (; U !== 0 && $ < k.length; $++)
          (O = (k.words[$] | 0) + U),
            (U = O >> 26),
            (this.words[$] = O & 67108863);
        if (U === 0 && $ < k.length && k !== this)
          for (; $ < k.length; $++) this.words[$] = k.words[$];
        return (
          (this.length = Math.max(this.length, $)),
          k !== this && (this.negative = 1),
          this.strip()
        );
      }),
      (s.prototype.sub = function (T) {
        return this.clone().isub(T);
      });
    function m(M, T, O) {
      O.negative = T.negative ^ M.negative;
      var I = (M.length + T.length) | 0;
      (O.length = I), (I = (I - 1) | 0);
      var k = M.words[0] | 0,
        L = T.words[0] | 0,
        U = k * L,
        $ = U & 67108863,
        B = (U / 67108864) | 0;
      O.words[0] = $;
      for (var R = 1; R < I; R++) {
        for (
          var V = B >>> 26,
            oe = B & 67108863,
            le = Math.min(R, T.length - 1),
            fe = Math.max(0, R - M.length + 1);
          fe <= le;
          fe++
        ) {
          var z = (R - fe) | 0;
          (k = M.words[z] | 0),
            (L = T.words[fe] | 0),
            (U = k * L + oe),
            (V += (U / 67108864) | 0),
            (oe = U & 67108863);
        }
        (O.words[R] = oe | 0), (B = V | 0);
      }
      return B !== 0 ? (O.words[R] = B | 0) : O.length--, O.strip();
    }
    var g = function (T, O, I) {
      var k = T.words,
        L = O.words,
        U = I.words,
        $ = 0,
        B,
        R,
        V,
        oe = k[0] | 0,
        le = oe & 8191,
        fe = oe >>> 13,
        z = k[1] | 0,
        se = z & 8191,
        Y = z >>> 13,
        Q = k[2] | 0,
        ee = Q & 8191,
        F = Q >>> 13,
        te = k[3] | 0,
        he = te & 8191,
        Te = te >>> 13,
        Ce = k[4] | 0,
        ke = Ce & 8191,
        at = Ce >>> 13,
        Rt = k[5] | 0,
        Ft = Rt & 8191,
        Nt = Rt >>> 13,
        Ot = k[6] | 0,
        et = Ot & 8191,
        st = Ot >>> 13,
        vt = k[7] | 0,
        Re = vt & 8191,
        me = vt >>> 13,
        $e = k[8] | 0,
        De = $e & 8191,
        je = $e >>> 13,
        lt = k[9] | 0,
        Ke = lt & 8191,
        tt = lt >>> 13,
        jt = L[0] | 0,
        ct = jt & 8191,
        rt = jt >>> 13,
        Dt = L[1] | 0,
        Ht = Dt & 8191,
        Yt = Dt >>> 13,
        sr = L[2] | 0,
        Bt = sr & 8191,
        en = sr >>> 13,
        Tr = L[3] | 0,
        on = Tr & 8191,
        Pt = Tr >>> 13,
        fn = L[4] | 0,
        Wt = fn & 8191,
        qt = fn >>> 13,
        Ye = L[5] | 0,
        xe = Ye & 8191,
        nt = Ye >>> 13,
        gt = L[6] | 0,
        ht = gt & 8191,
        wt = gt >>> 13,
        rn = L[7] | 0,
        ot = rn & 8191,
        pt = rn >>> 13,
        zt = L[8] | 0,
        Zt = zt & 8191,
        $t = zt >>> 13,
        Vr = L[9] | 0,
        $n = Vr & 8191,
        En = Vr >>> 13;
      (I.negative = T.negative ^ O.negative),
        (I.length = 19),
        (B = Math.imul(le, ct)),
        (R = Math.imul(le, rt)),
        (R = (R + Math.imul(fe, ct)) | 0),
        (V = Math.imul(fe, rt));
      var In = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (In >>> 26)) | 0),
        (In &= 67108863),
        (B = Math.imul(se, ct)),
        (R = Math.imul(se, rt)),
        (R = (R + Math.imul(Y, ct)) | 0),
        (V = Math.imul(Y, rt)),
        (B = (B + Math.imul(le, Ht)) | 0),
        (R = (R + Math.imul(le, Yt)) | 0),
        (R = (R + Math.imul(fe, Ht)) | 0),
        (V = (V + Math.imul(fe, Yt)) | 0);
      var as = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (as >>> 26)) | 0),
        (as &= 67108863),
        (B = Math.imul(ee, ct)),
        (R = Math.imul(ee, rt)),
        (R = (R + Math.imul(F, ct)) | 0),
        (V = Math.imul(F, rt)),
        (B = (B + Math.imul(se, Ht)) | 0),
        (R = (R + Math.imul(se, Yt)) | 0),
        (R = (R + Math.imul(Y, Ht)) | 0),
        (V = (V + Math.imul(Y, Yt)) | 0),
        (B = (B + Math.imul(le, Bt)) | 0),
        (R = (R + Math.imul(le, en)) | 0),
        (R = (R + Math.imul(fe, Bt)) | 0),
        (V = (V + Math.imul(fe, en)) | 0);
      var os = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (os >>> 26)) | 0),
        (os &= 67108863),
        (B = Math.imul(he, ct)),
        (R = Math.imul(he, rt)),
        (R = (R + Math.imul(Te, ct)) | 0),
        (V = Math.imul(Te, rt)),
        (B = (B + Math.imul(ee, Ht)) | 0),
        (R = (R + Math.imul(ee, Yt)) | 0),
        (R = (R + Math.imul(F, Ht)) | 0),
        (V = (V + Math.imul(F, Yt)) | 0),
        (B = (B + Math.imul(se, Bt)) | 0),
        (R = (R + Math.imul(se, en)) | 0),
        (R = (R + Math.imul(Y, Bt)) | 0),
        (V = (V + Math.imul(Y, en)) | 0),
        (B = (B + Math.imul(le, on)) | 0),
        (R = (R + Math.imul(le, Pt)) | 0),
        (R = (R + Math.imul(fe, on)) | 0),
        (V = (V + Math.imul(fe, Pt)) | 0);
      var ls = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (ls >>> 26)) | 0),
        (ls &= 67108863),
        (B = Math.imul(ke, ct)),
        (R = Math.imul(ke, rt)),
        (R = (R + Math.imul(at, ct)) | 0),
        (V = Math.imul(at, rt)),
        (B = (B + Math.imul(he, Ht)) | 0),
        (R = (R + Math.imul(he, Yt)) | 0),
        (R = (R + Math.imul(Te, Ht)) | 0),
        (V = (V + Math.imul(Te, Yt)) | 0),
        (B = (B + Math.imul(ee, Bt)) | 0),
        (R = (R + Math.imul(ee, en)) | 0),
        (R = (R + Math.imul(F, Bt)) | 0),
        (V = (V + Math.imul(F, en)) | 0),
        (B = (B + Math.imul(se, on)) | 0),
        (R = (R + Math.imul(se, Pt)) | 0),
        (R = (R + Math.imul(Y, on)) | 0),
        (V = (V + Math.imul(Y, Pt)) | 0),
        (B = (B + Math.imul(le, Wt)) | 0),
        (R = (R + Math.imul(le, qt)) | 0),
        (R = (R + Math.imul(fe, Wt)) | 0),
        (V = (V + Math.imul(fe, qt)) | 0);
      var us = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (us >>> 26)) | 0),
        (us &= 67108863),
        (B = Math.imul(Ft, ct)),
        (R = Math.imul(Ft, rt)),
        (R = (R + Math.imul(Nt, ct)) | 0),
        (V = Math.imul(Nt, rt)),
        (B = (B + Math.imul(ke, Ht)) | 0),
        (R = (R + Math.imul(ke, Yt)) | 0),
        (R = (R + Math.imul(at, Ht)) | 0),
        (V = (V + Math.imul(at, Yt)) | 0),
        (B = (B + Math.imul(he, Bt)) | 0),
        (R = (R + Math.imul(he, en)) | 0),
        (R = (R + Math.imul(Te, Bt)) | 0),
        (V = (V + Math.imul(Te, en)) | 0),
        (B = (B + Math.imul(ee, on)) | 0),
        (R = (R + Math.imul(ee, Pt)) | 0),
        (R = (R + Math.imul(F, on)) | 0),
        (V = (V + Math.imul(F, Pt)) | 0),
        (B = (B + Math.imul(se, Wt)) | 0),
        (R = (R + Math.imul(se, qt)) | 0),
        (R = (R + Math.imul(Y, Wt)) | 0),
        (V = (V + Math.imul(Y, qt)) | 0),
        (B = (B + Math.imul(le, xe)) | 0),
        (R = (R + Math.imul(le, nt)) | 0),
        (R = (R + Math.imul(fe, xe)) | 0),
        (V = (V + Math.imul(fe, nt)) | 0);
      var Or = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (B = Math.imul(et, ct)),
        (R = Math.imul(et, rt)),
        (R = (R + Math.imul(st, ct)) | 0),
        (V = Math.imul(st, rt)),
        (B = (B + Math.imul(Ft, Ht)) | 0),
        (R = (R + Math.imul(Ft, Yt)) | 0),
        (R = (R + Math.imul(Nt, Ht)) | 0),
        (V = (V + Math.imul(Nt, Yt)) | 0),
        (B = (B + Math.imul(ke, Bt)) | 0),
        (R = (R + Math.imul(ke, en)) | 0),
        (R = (R + Math.imul(at, Bt)) | 0),
        (V = (V + Math.imul(at, en)) | 0),
        (B = (B + Math.imul(he, on)) | 0),
        (R = (R + Math.imul(he, Pt)) | 0),
        (R = (R + Math.imul(Te, on)) | 0),
        (V = (V + Math.imul(Te, Pt)) | 0),
        (B = (B + Math.imul(ee, Wt)) | 0),
        (R = (R + Math.imul(ee, qt)) | 0),
        (R = (R + Math.imul(F, Wt)) | 0),
        (V = (V + Math.imul(F, qt)) | 0),
        (B = (B + Math.imul(se, xe)) | 0),
        (R = (R + Math.imul(se, nt)) | 0),
        (R = (R + Math.imul(Y, xe)) | 0),
        (V = (V + Math.imul(Y, nt)) | 0),
        (B = (B + Math.imul(le, ht)) | 0),
        (R = (R + Math.imul(le, wt)) | 0),
        (R = (R + Math.imul(fe, ht)) | 0),
        (V = (V + Math.imul(fe, wt)) | 0);
      var ar = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (B = Math.imul(Re, ct)),
        (R = Math.imul(Re, rt)),
        (R = (R + Math.imul(me, ct)) | 0),
        (V = Math.imul(me, rt)),
        (B = (B + Math.imul(et, Ht)) | 0),
        (R = (R + Math.imul(et, Yt)) | 0),
        (R = (R + Math.imul(st, Ht)) | 0),
        (V = (V + Math.imul(st, Yt)) | 0),
        (B = (B + Math.imul(Ft, Bt)) | 0),
        (R = (R + Math.imul(Ft, en)) | 0),
        (R = (R + Math.imul(Nt, Bt)) | 0),
        (V = (V + Math.imul(Nt, en)) | 0),
        (B = (B + Math.imul(ke, on)) | 0),
        (R = (R + Math.imul(ke, Pt)) | 0),
        (R = (R + Math.imul(at, on)) | 0),
        (V = (V + Math.imul(at, Pt)) | 0),
        (B = (B + Math.imul(he, Wt)) | 0),
        (R = (R + Math.imul(he, qt)) | 0),
        (R = (R + Math.imul(Te, Wt)) | 0),
        (V = (V + Math.imul(Te, qt)) | 0),
        (B = (B + Math.imul(ee, xe)) | 0),
        (R = (R + Math.imul(ee, nt)) | 0),
        (R = (R + Math.imul(F, xe)) | 0),
        (V = (V + Math.imul(F, nt)) | 0),
        (B = (B + Math.imul(se, ht)) | 0),
        (R = (R + Math.imul(se, wt)) | 0),
        (R = (R + Math.imul(Y, ht)) | 0),
        (V = (V + Math.imul(Y, wt)) | 0),
        (B = (B + Math.imul(le, ot)) | 0),
        (R = (R + Math.imul(le, pt)) | 0),
        (R = (R + Math.imul(fe, ot)) | 0),
        (V = (V + Math.imul(fe, pt)) | 0);
      var cs = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (cs >>> 26)) | 0),
        (cs &= 67108863),
        (B = Math.imul(De, ct)),
        (R = Math.imul(De, rt)),
        (R = (R + Math.imul(je, ct)) | 0),
        (V = Math.imul(je, rt)),
        (B = (B + Math.imul(Re, Ht)) | 0),
        (R = (R + Math.imul(Re, Yt)) | 0),
        (R = (R + Math.imul(me, Ht)) | 0),
        (V = (V + Math.imul(me, Yt)) | 0),
        (B = (B + Math.imul(et, Bt)) | 0),
        (R = (R + Math.imul(et, en)) | 0),
        (R = (R + Math.imul(st, Bt)) | 0),
        (V = (V + Math.imul(st, en)) | 0),
        (B = (B + Math.imul(Ft, on)) | 0),
        (R = (R + Math.imul(Ft, Pt)) | 0),
        (R = (R + Math.imul(Nt, on)) | 0),
        (V = (V + Math.imul(Nt, Pt)) | 0),
        (B = (B + Math.imul(ke, Wt)) | 0),
        (R = (R + Math.imul(ke, qt)) | 0),
        (R = (R + Math.imul(at, Wt)) | 0),
        (V = (V + Math.imul(at, qt)) | 0),
        (B = (B + Math.imul(he, xe)) | 0),
        (R = (R + Math.imul(he, nt)) | 0),
        (R = (R + Math.imul(Te, xe)) | 0),
        (V = (V + Math.imul(Te, nt)) | 0),
        (B = (B + Math.imul(ee, ht)) | 0),
        (R = (R + Math.imul(ee, wt)) | 0),
        (R = (R + Math.imul(F, ht)) | 0),
        (V = (V + Math.imul(F, wt)) | 0),
        (B = (B + Math.imul(se, ot)) | 0),
        (R = (R + Math.imul(se, pt)) | 0),
        (R = (R + Math.imul(Y, ot)) | 0),
        (V = (V + Math.imul(Y, pt)) | 0),
        (B = (B + Math.imul(le, Zt)) | 0),
        (R = (R + Math.imul(le, $t)) | 0),
        (R = (R + Math.imul(fe, Zt)) | 0),
        (V = (V + Math.imul(fe, $t)) | 0);
      var lo = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (lo >>> 26)) | 0),
        (lo &= 67108863),
        (B = Math.imul(Ke, ct)),
        (R = Math.imul(Ke, rt)),
        (R = (R + Math.imul(tt, ct)) | 0),
        (V = Math.imul(tt, rt)),
        (B = (B + Math.imul(De, Ht)) | 0),
        (R = (R + Math.imul(De, Yt)) | 0),
        (R = (R + Math.imul(je, Ht)) | 0),
        (V = (V + Math.imul(je, Yt)) | 0),
        (B = (B + Math.imul(Re, Bt)) | 0),
        (R = (R + Math.imul(Re, en)) | 0),
        (R = (R + Math.imul(me, Bt)) | 0),
        (V = (V + Math.imul(me, en)) | 0),
        (B = (B + Math.imul(et, on)) | 0),
        (R = (R + Math.imul(et, Pt)) | 0),
        (R = (R + Math.imul(st, on)) | 0),
        (V = (V + Math.imul(st, Pt)) | 0),
        (B = (B + Math.imul(Ft, Wt)) | 0),
        (R = (R + Math.imul(Ft, qt)) | 0),
        (R = (R + Math.imul(Nt, Wt)) | 0),
        (V = (V + Math.imul(Nt, qt)) | 0),
        (B = (B + Math.imul(ke, xe)) | 0),
        (R = (R + Math.imul(ke, nt)) | 0),
        (R = (R + Math.imul(at, xe)) | 0),
        (V = (V + Math.imul(at, nt)) | 0),
        (B = (B + Math.imul(he, ht)) | 0),
        (R = (R + Math.imul(he, wt)) | 0),
        (R = (R + Math.imul(Te, ht)) | 0),
        (V = (V + Math.imul(Te, wt)) | 0),
        (B = (B + Math.imul(ee, ot)) | 0),
        (R = (R + Math.imul(ee, pt)) | 0),
        (R = (R + Math.imul(F, ot)) | 0),
        (V = (V + Math.imul(F, pt)) | 0),
        (B = (B + Math.imul(se, Zt)) | 0),
        (R = (R + Math.imul(se, $t)) | 0),
        (R = (R + Math.imul(Y, Zt)) | 0),
        (V = (V + Math.imul(Y, $t)) | 0),
        (B = (B + Math.imul(le, $n)) | 0),
        (R = (R + Math.imul(le, En)) | 0),
        (R = (R + Math.imul(fe, $n)) | 0),
        (V = (V + Math.imul(fe, En)) | 0);
      var zi = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (zi >>> 26)) | 0),
        (zi &= 67108863),
        (B = Math.imul(Ke, Ht)),
        (R = Math.imul(Ke, Yt)),
        (R = (R + Math.imul(tt, Ht)) | 0),
        (V = Math.imul(tt, Yt)),
        (B = (B + Math.imul(De, Bt)) | 0),
        (R = (R + Math.imul(De, en)) | 0),
        (R = (R + Math.imul(je, Bt)) | 0),
        (V = (V + Math.imul(je, en)) | 0),
        (B = (B + Math.imul(Re, on)) | 0),
        (R = (R + Math.imul(Re, Pt)) | 0),
        (R = (R + Math.imul(me, on)) | 0),
        (V = (V + Math.imul(me, Pt)) | 0),
        (B = (B + Math.imul(et, Wt)) | 0),
        (R = (R + Math.imul(et, qt)) | 0),
        (R = (R + Math.imul(st, Wt)) | 0),
        (V = (V + Math.imul(st, qt)) | 0),
        (B = (B + Math.imul(Ft, xe)) | 0),
        (R = (R + Math.imul(Ft, nt)) | 0),
        (R = (R + Math.imul(Nt, xe)) | 0),
        (V = (V + Math.imul(Nt, nt)) | 0),
        (B = (B + Math.imul(ke, ht)) | 0),
        (R = (R + Math.imul(ke, wt)) | 0),
        (R = (R + Math.imul(at, ht)) | 0),
        (V = (V + Math.imul(at, wt)) | 0),
        (B = (B + Math.imul(he, ot)) | 0),
        (R = (R + Math.imul(he, pt)) | 0),
        (R = (R + Math.imul(Te, ot)) | 0),
        (V = (V + Math.imul(Te, pt)) | 0),
        (B = (B + Math.imul(ee, Zt)) | 0),
        (R = (R + Math.imul(ee, $t)) | 0),
        (R = (R + Math.imul(F, Zt)) | 0),
        (V = (V + Math.imul(F, $t)) | 0),
        (B = (B + Math.imul(se, $n)) | 0),
        (R = (R + Math.imul(se, En)) | 0),
        (R = (R + Math.imul(Y, $n)) | 0),
        (V = (V + Math.imul(Y, En)) | 0);
      var la = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (la >>> 26)) | 0),
        (la &= 67108863),
        (B = Math.imul(Ke, Bt)),
        (R = Math.imul(Ke, en)),
        (R = (R + Math.imul(tt, Bt)) | 0),
        (V = Math.imul(tt, en)),
        (B = (B + Math.imul(De, on)) | 0),
        (R = (R + Math.imul(De, Pt)) | 0),
        (R = (R + Math.imul(je, on)) | 0),
        (V = (V + Math.imul(je, Pt)) | 0),
        (B = (B + Math.imul(Re, Wt)) | 0),
        (R = (R + Math.imul(Re, qt)) | 0),
        (R = (R + Math.imul(me, Wt)) | 0),
        (V = (V + Math.imul(me, qt)) | 0),
        (B = (B + Math.imul(et, xe)) | 0),
        (R = (R + Math.imul(et, nt)) | 0),
        (R = (R + Math.imul(st, xe)) | 0),
        (V = (V + Math.imul(st, nt)) | 0),
        (B = (B + Math.imul(Ft, ht)) | 0),
        (R = (R + Math.imul(Ft, wt)) | 0),
        (R = (R + Math.imul(Nt, ht)) | 0),
        (V = (V + Math.imul(Nt, wt)) | 0),
        (B = (B + Math.imul(ke, ot)) | 0),
        (R = (R + Math.imul(ke, pt)) | 0),
        (R = (R + Math.imul(at, ot)) | 0),
        (V = (V + Math.imul(at, pt)) | 0),
        (B = (B + Math.imul(he, Zt)) | 0),
        (R = (R + Math.imul(he, $t)) | 0),
        (R = (R + Math.imul(Te, Zt)) | 0),
        (V = (V + Math.imul(Te, $t)) | 0),
        (B = (B + Math.imul(ee, $n)) | 0),
        (R = (R + Math.imul(ee, En)) | 0),
        (R = (R + Math.imul(F, $n)) | 0),
        (V = (V + Math.imul(F, En)) | 0);
      var xi = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (xi >>> 26)) | 0),
        (xi &= 67108863),
        (B = Math.imul(Ke, on)),
        (R = Math.imul(Ke, Pt)),
        (R = (R + Math.imul(tt, on)) | 0),
        (V = Math.imul(tt, Pt)),
        (B = (B + Math.imul(De, Wt)) | 0),
        (R = (R + Math.imul(De, qt)) | 0),
        (R = (R + Math.imul(je, Wt)) | 0),
        (V = (V + Math.imul(je, qt)) | 0),
        (B = (B + Math.imul(Re, xe)) | 0),
        (R = (R + Math.imul(Re, nt)) | 0),
        (R = (R + Math.imul(me, xe)) | 0),
        (V = (V + Math.imul(me, nt)) | 0),
        (B = (B + Math.imul(et, ht)) | 0),
        (R = (R + Math.imul(et, wt)) | 0),
        (R = (R + Math.imul(st, ht)) | 0),
        (V = (V + Math.imul(st, wt)) | 0),
        (B = (B + Math.imul(Ft, ot)) | 0),
        (R = (R + Math.imul(Ft, pt)) | 0),
        (R = (R + Math.imul(Nt, ot)) | 0),
        (V = (V + Math.imul(Nt, pt)) | 0),
        (B = (B + Math.imul(ke, Zt)) | 0),
        (R = (R + Math.imul(ke, $t)) | 0),
        (R = (R + Math.imul(at, Zt)) | 0),
        (V = (V + Math.imul(at, $t)) | 0),
        (B = (B + Math.imul(he, $n)) | 0),
        (R = (R + Math.imul(he, En)) | 0),
        (R = (R + Math.imul(Te, $n)) | 0),
        (V = (V + Math.imul(Te, En)) | 0);
      var ci = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (ci >>> 26)) | 0),
        (ci &= 67108863),
        (B = Math.imul(Ke, Wt)),
        (R = Math.imul(Ke, qt)),
        (R = (R + Math.imul(tt, Wt)) | 0),
        (V = Math.imul(tt, qt)),
        (B = (B + Math.imul(De, xe)) | 0),
        (R = (R + Math.imul(De, nt)) | 0),
        (R = (R + Math.imul(je, xe)) | 0),
        (V = (V + Math.imul(je, nt)) | 0),
        (B = (B + Math.imul(Re, ht)) | 0),
        (R = (R + Math.imul(Re, wt)) | 0),
        (R = (R + Math.imul(me, ht)) | 0),
        (V = (V + Math.imul(me, wt)) | 0),
        (B = (B + Math.imul(et, ot)) | 0),
        (R = (R + Math.imul(et, pt)) | 0),
        (R = (R + Math.imul(st, ot)) | 0),
        (V = (V + Math.imul(st, pt)) | 0),
        (B = (B + Math.imul(Ft, Zt)) | 0),
        (R = (R + Math.imul(Ft, $t)) | 0),
        (R = (R + Math.imul(Nt, Zt)) | 0),
        (V = (V + Math.imul(Nt, $t)) | 0),
        (B = (B + Math.imul(ke, $n)) | 0),
        (R = (R + Math.imul(ke, En)) | 0),
        (R = (R + Math.imul(at, $n)) | 0),
        (V = (V + Math.imul(at, En)) | 0);
      var ua = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (ua >>> 26)) | 0),
        (ua &= 67108863),
        (B = Math.imul(Ke, xe)),
        (R = Math.imul(Ke, nt)),
        (R = (R + Math.imul(tt, xe)) | 0),
        (V = Math.imul(tt, nt)),
        (B = (B + Math.imul(De, ht)) | 0),
        (R = (R + Math.imul(De, wt)) | 0),
        (R = (R + Math.imul(je, ht)) | 0),
        (V = (V + Math.imul(je, wt)) | 0),
        (B = (B + Math.imul(Re, ot)) | 0),
        (R = (R + Math.imul(Re, pt)) | 0),
        (R = (R + Math.imul(me, ot)) | 0),
        (V = (V + Math.imul(me, pt)) | 0),
        (B = (B + Math.imul(et, Zt)) | 0),
        (R = (R + Math.imul(et, $t)) | 0),
        (R = (R + Math.imul(st, Zt)) | 0),
        (V = (V + Math.imul(st, $t)) | 0),
        (B = (B + Math.imul(Ft, $n)) | 0),
        (R = (R + Math.imul(Ft, En)) | 0),
        (R = (R + Math.imul(Nt, $n)) | 0),
        (V = (V + Math.imul(Nt, En)) | 0);
      var Ra = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (Ra >>> 26)) | 0),
        (Ra &= 67108863),
        (B = Math.imul(Ke, ht)),
        (R = Math.imul(Ke, wt)),
        (R = (R + Math.imul(tt, ht)) | 0),
        (V = Math.imul(tt, wt)),
        (B = (B + Math.imul(De, ot)) | 0),
        (R = (R + Math.imul(De, pt)) | 0),
        (R = (R + Math.imul(je, ot)) | 0),
        (V = (V + Math.imul(je, pt)) | 0),
        (B = (B + Math.imul(Re, Zt)) | 0),
        (R = (R + Math.imul(Re, $t)) | 0),
        (R = (R + Math.imul(me, Zt)) | 0),
        (V = (V + Math.imul(me, $t)) | 0),
        (B = (B + Math.imul(et, $n)) | 0),
        (R = (R + Math.imul(et, En)) | 0),
        (R = (R + Math.imul(st, $n)) | 0),
        (V = (V + Math.imul(st, En)) | 0);
      var pr = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (pr >>> 26)) | 0),
        (pr &= 67108863),
        (B = Math.imul(Ke, ot)),
        (R = Math.imul(Ke, pt)),
        (R = (R + Math.imul(tt, ot)) | 0),
        (V = Math.imul(tt, pt)),
        (B = (B + Math.imul(De, Zt)) | 0),
        (R = (R + Math.imul(De, $t)) | 0),
        (R = (R + Math.imul(je, Zt)) | 0),
        (V = (V + Math.imul(je, $t)) | 0),
        (B = (B + Math.imul(Re, $n)) | 0),
        (R = (R + Math.imul(Re, En)) | 0),
        (R = (R + Math.imul(me, $n)) | 0),
        (V = (V + Math.imul(me, En)) | 0);
      var uo = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (uo >>> 26)) | 0),
        (uo &= 67108863),
        (B = Math.imul(Ke, Zt)),
        (R = Math.imul(Ke, $t)),
        (R = (R + Math.imul(tt, Zt)) | 0),
        (V = Math.imul(tt, $t)),
        (B = (B + Math.imul(De, $n)) | 0),
        (R = (R + Math.imul(De, En)) | 0),
        (R = (R + Math.imul(je, $n)) | 0),
        (V = (V + Math.imul(je, En)) | 0);
      var fs = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      ($ = (((V + (R >>> 13)) | 0) + (fs >>> 26)) | 0),
        (fs &= 67108863),
        (B = Math.imul(Ke, $n)),
        (R = Math.imul(Ke, En)),
        (R = (R + Math.imul(tt, $n)) | 0),
        (V = Math.imul(tt, En));
      var co = ((($ + B) | 0) + ((R & 8191) << 13)) | 0;
      return (
        ($ = (((V + (R >>> 13)) | 0) + (co >>> 26)) | 0),
        (co &= 67108863),
        (U[0] = In),
        (U[1] = as),
        (U[2] = os),
        (U[3] = ls),
        (U[4] = us),
        (U[5] = Or),
        (U[6] = ar),
        (U[7] = cs),
        (U[8] = lo),
        (U[9] = zi),
        (U[10] = la),
        (U[11] = xi),
        (U[12] = ci),
        (U[13] = ua),
        (U[14] = Ra),
        (U[15] = pr),
        (U[16] = uo),
        (U[17] = fs),
        (U[18] = co),
        $ !== 0 && ((U[19] = $), I.length++),
        I
      );
    };
    Math.imul || (g = m);
    function w(M, T, O) {
      (O.negative = T.negative ^ M.negative), (O.length = M.length + T.length);
      for (var I = 0, k = 0, L = 0; L < O.length - 1; L++) {
        var U = k;
        k = 0;
        for (
          var $ = I & 67108863,
            B = Math.min(L, T.length - 1),
            R = Math.max(0, L - M.length + 1);
          R <= B;
          R++
        ) {
          var V = L - R,
            oe = M.words[V] | 0,
            le = T.words[R] | 0,
            fe = oe * le,
            z = fe & 67108863;
          (U = (U + ((fe / 67108864) | 0)) | 0),
            (z = (z + $) | 0),
            ($ = z & 67108863),
            (U = (U + (z >>> 26)) | 0),
            (k += U >>> 26),
            (U &= 67108863);
        }
        (O.words[L] = $), (I = U), (U = k);
      }
      return I !== 0 ? (O.words[L] = I) : O.length--, O.strip();
    }
    function y(M, T, O) {
      var I = new v();
      return I.mulp(M, T, O);
    }
    s.prototype.mulTo = function (T, O) {
      var I,
        k = this.length + T.length;
      return (
        this.length === 10 && T.length === 10
          ? (I = g(this, T, O))
          : k < 63
          ? (I = m(this, T, O))
          : k < 1024
          ? (I = w(this, T, O))
          : (I = y(this, T, O)),
        I
      );
    };
    function v(M, T) {
      (this.x = M), (this.y = T);
    }
    (v.prototype.makeRBT = function (T) {
      for (
        var O = new Array(T), I = s.prototype._countBits(T) - 1, k = 0;
        k < T;
        k++
      )
        O[k] = this.revBin(k, I, T);
      return O;
    }),
      (v.prototype.revBin = function (T, O, I) {
        if (T === 0 || T === I - 1) return T;
        for (var k = 0, L = 0; L < O; L++)
          (k |= (T & 1) << (O - L - 1)), (T >>= 1);
        return k;
      }),
      (v.prototype.permute = function (T, O, I, k, L, U) {
        for (var $ = 0; $ < U; $++) (k[$] = O[T[$]]), (L[$] = I[T[$]]);
      }),
      (v.prototype.transform = function (T, O, I, k, L, U) {
        this.permute(U, T, O, I, k, L);
        for (var $ = 1; $ < L; $ <<= 1)
          for (
            var B = $ << 1,
              R = Math.cos((2 * Math.PI) / B),
              V = Math.sin((2 * Math.PI) / B),
              oe = 0;
            oe < L;
            oe += B
          )
            for (var le = R, fe = V, z = 0; z < $; z++) {
              var se = I[oe + z],
                Y = k[oe + z],
                Q = I[oe + z + $],
                ee = k[oe + z + $],
                F = le * Q - fe * ee;
              (ee = le * ee + fe * Q),
                (Q = F),
                (I[oe + z] = se + Q),
                (k[oe + z] = Y + ee),
                (I[oe + z + $] = se - Q),
                (k[oe + z + $] = Y - ee),
                z !== B &&
                  ((F = R * le - V * fe), (fe = R * fe + V * le), (le = F));
            }
      }),
      (v.prototype.guessLen13b = function (T, O) {
        var I = Math.max(O, T) | 1,
          k = I & 1,
          L = 0;
        for (I = (I / 2) | 0; I; I = I >>> 1) L++;
        return 1 << (L + 1 + k);
      }),
      (v.prototype.conjugate = function (T, O, I) {
        if (!(I <= 1))
          for (var k = 0; k < I / 2; k++) {
            var L = T[k];
            (T[k] = T[I - k - 1]),
              (T[I - k - 1] = L),
              (L = O[k]),
              (O[k] = -O[I - k - 1]),
              (O[I - k - 1] = -L);
          }
      }),
      (v.prototype.normalize13b = function (T, O) {
        for (var I = 0, k = 0; k < O / 2; k++) {
          var L =
            Math.round(T[2 * k + 1] / O) * 8192 + Math.round(T[2 * k] / O) + I;
          (T[k] = L & 67108863),
            L < 67108864 ? (I = 0) : (I = (L / 67108864) | 0);
        }
        return T;
      }),
      (v.prototype.convert13b = function (T, O, I, k) {
        for (var L = 0, U = 0; U < O; U++)
          (L = L + (T[U] | 0)),
            (I[2 * U] = L & 8191),
            (L = L >>> 13),
            (I[2 * U + 1] = L & 8191),
            (L = L >>> 13);
        for (U = 2 * O; U < k; ++U) I[U] = 0;
        r(L === 0), r((L & -8192) === 0);
      }),
      (v.prototype.stub = function (T) {
        for (var O = new Array(T), I = 0; I < T; I++) O[I] = 0;
        return O;
      }),
      (v.prototype.mulp = function (T, O, I) {
        var k = 2 * this.guessLen13b(T.length, O.length),
          L = this.makeRBT(k),
          U = this.stub(k),
          $ = new Array(k),
          B = new Array(k),
          R = new Array(k),
          V = new Array(k),
          oe = new Array(k),
          le = new Array(k),
          fe = I.words;
        (fe.length = k),
          this.convert13b(T.words, T.length, $, k),
          this.convert13b(O.words, O.length, V, k),
          this.transform($, U, B, R, k, L),
          this.transform(V, U, oe, le, k, L);
        for (var z = 0; z < k; z++) {
          var se = B[z] * oe[z] - R[z] * le[z];
          (R[z] = B[z] * le[z] + R[z] * oe[z]), (B[z] = se);
        }
        return (
          this.conjugate(B, R, k),
          this.transform(B, R, fe, U, k, L),
          this.conjugate(fe, U, k),
          this.normalize13b(fe, k),
          (I.negative = T.negative ^ O.negative),
          (I.length = T.length + O.length),
          I.strip()
        );
      }),
      (s.prototype.mul = function (T) {
        var O = new s(null);
        return (O.words = new Array(this.length + T.length)), this.mulTo(T, O);
      }),
      (s.prototype.mulf = function (T) {
        var O = new s(null);
        return (O.words = new Array(this.length + T.length)), y(this, T, O);
      }),
      (s.prototype.imul = function (T) {
        return this.clone().mulTo(T, this);
      }),
      (s.prototype.imuln = function (T) {
        r(typeof T == "number"), r(T < 67108864);
        for (var O = 0, I = 0; I < this.length; I++) {
          var k = (this.words[I] | 0) * T,
            L = (k & 67108863) + (O & 67108863);
          (O >>= 26),
            (O += (k / 67108864) | 0),
            (O += L >>> 26),
            (this.words[I] = L & 67108863);
        }
        return O !== 0 && ((this.words[I] = O), this.length++), this;
      }),
      (s.prototype.muln = function (T) {
        return this.clone().imuln(T);
      }),
      (s.prototype.sqr = function () {
        return this.mul(this);
      }),
      (s.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (s.prototype.pow = function (T) {
        var O = p(T);
        if (O.length === 0) return new s(1);
        for (var I = this, k = 0; k < O.length && O[k] === 0; k++, I = I.sqr());
        if (++k < O.length)
          for (var L = I.sqr(); k < O.length; k++, L = L.sqr())
            O[k] !== 0 && (I = I.mul(L));
        return I;
      }),
      (s.prototype.iushln = function (T) {
        r(typeof T == "number" && T >= 0);
        var O = T % 26,
          I = (T - O) / 26,
          k = (67108863 >>> (26 - O)) << (26 - O),
          L;
        if (O !== 0) {
          var U = 0;
          for (L = 0; L < this.length; L++) {
            var $ = this.words[L] & k,
              B = ((this.words[L] | 0) - $) << O;
            (this.words[L] = B | U), (U = $ >>> (26 - O));
          }
          U && ((this.words[L] = U), this.length++);
        }
        if (I !== 0) {
          for (L = this.length - 1; L >= 0; L--)
            this.words[L + I] = this.words[L];
          for (L = 0; L < I; L++) this.words[L] = 0;
          this.length += I;
        }
        return this.strip();
      }),
      (s.prototype.ishln = function (T) {
        return r(this.negative === 0), this.iushln(T);
      }),
      (s.prototype.iushrn = function (T, O, I) {
        r(typeof T == "number" && T >= 0);
        var k;
        O ? (k = (O - (O % 26)) / 26) : (k = 0);
        var L = T % 26,
          U = Math.min((T - L) / 26, this.length),
          $ = 67108863 ^ ((67108863 >>> L) << L),
          B = I;
        if (((k -= U), (k = Math.max(0, k)), B)) {
          for (var R = 0; R < U; R++) B.words[R] = this.words[R];
          B.length = U;
        }
        if (U !== 0)
          if (this.length > U)
            for (this.length -= U, R = 0; R < this.length; R++)
              this.words[R] = this.words[R + U];
          else (this.words[0] = 0), (this.length = 1);
        var V = 0;
        for (R = this.length - 1; R >= 0 && (V !== 0 || R >= k); R--) {
          var oe = this.words[R] | 0;
          (this.words[R] = (V << (26 - L)) | (oe >>> L)), (V = oe & $);
        }
        return (
          B && V !== 0 && (B.words[B.length++] = V),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (s.prototype.ishrn = function (T, O, I) {
        return r(this.negative === 0), this.iushrn(T, O, I);
      }),
      (s.prototype.shln = function (T) {
        return this.clone().ishln(T);
      }),
      (s.prototype.ushln = function (T) {
        return this.clone().iushln(T);
      }),
      (s.prototype.shrn = function (T) {
        return this.clone().ishrn(T);
      }),
      (s.prototype.ushrn = function (T) {
        return this.clone().iushrn(T);
      }),
      (s.prototype.testn = function (T) {
        r(typeof T == "number" && T >= 0);
        var O = T % 26,
          I = (T - O) / 26,
          k = 1 << O;
        if (this.length <= I) return !1;
        var L = this.words[I];
        return !!(L & k);
      }),
      (s.prototype.imaskn = function (T) {
        r(typeof T == "number" && T >= 0);
        var O = T % 26,
          I = (T - O) / 26;
        if (
          (r(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= I)
        )
          return this;
        if (
          (O !== 0 && I++, (this.length = Math.min(I, this.length)), O !== 0)
        ) {
          var k = 67108863 ^ ((67108863 >>> O) << O);
          this.words[this.length - 1] &= k;
        }
        return this.strip();
      }),
      (s.prototype.maskn = function (T) {
        return this.clone().imaskn(T);
      }),
      (s.prototype.iaddn = function (T) {
        return (
          r(typeof T == "number"),
          r(T < 67108864),
          T < 0
            ? this.isubn(-T)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) < T
              ? ((this.words[0] = T - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(T), (this.negative = 1), this)
            : this._iaddn(T)
        );
      }),
      (s.prototype._iaddn = function (T) {
        this.words[0] += T;
        for (var O = 0; O < this.length && this.words[O] >= 67108864; O++)
          (this.words[O] -= 67108864),
            O === this.length - 1
              ? (this.words[O + 1] = 1)
              : this.words[O + 1]++;
        return (this.length = Math.max(this.length, O + 1)), this;
      }),
      (s.prototype.isubn = function (T) {
        if ((r(typeof T == "number"), r(T < 67108864), T < 0))
          return this.iaddn(-T);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(T), (this.negative = 1), this;
        if (((this.words[0] -= T), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var O = 0; O < this.length && this.words[O] < 0; O++)
            (this.words[O] += 67108864), (this.words[O + 1] -= 1);
        return this.strip();
      }),
      (s.prototype.addn = function (T) {
        return this.clone().iaddn(T);
      }),
      (s.prototype.subn = function (T) {
        return this.clone().isubn(T);
      }),
      (s.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (s.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (s.prototype._ishlnsubmul = function (T, O, I) {
        var k = T.length + I,
          L;
        this._expand(k);
        var U,
          $ = 0;
        for (L = 0; L < T.length; L++) {
          U = (this.words[L + I] | 0) + $;
          var B = (T.words[L] | 0) * O;
          (U -= B & 67108863),
            ($ = (U >> 26) - ((B / 67108864) | 0)),
            (this.words[L + I] = U & 67108863);
        }
        for (; L < this.length - I; L++)
          (U = (this.words[L + I] | 0) + $),
            ($ = U >> 26),
            (this.words[L + I] = U & 67108863);
        if ($ === 0) return this.strip();
        for (r($ === -1), $ = 0, L = 0; L < this.length; L++)
          (U = -(this.words[L] | 0) + $),
            ($ = U >> 26),
            (this.words[L] = U & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (s.prototype._wordDiv = function (T, O) {
        var I = this.length - T.length,
          k = this.clone(),
          L = T,
          U = L.words[L.length - 1] | 0,
          $ = this._countBits(U);
        (I = 26 - $),
          I !== 0 &&
            ((L = L.ushln(I)), k.iushln(I), (U = L.words[L.length - 1] | 0));
        var B = k.length - L.length,
          R;
        if (O !== "mod") {
          (R = new s(null)),
            (R.length = B + 1),
            (R.words = new Array(R.length));
          for (var V = 0; V < R.length; V++) R.words[V] = 0;
        }
        var oe = k.clone()._ishlnsubmul(L, 1, B);
        oe.negative === 0 && ((k = oe), R && (R.words[B] = 1));
        for (var le = B - 1; le >= 0; le--) {
          var fe =
            (k.words[L.length + le] | 0) * 67108864 +
            (k.words[L.length + le - 1] | 0);
          for (
            fe = Math.min((fe / U) | 0, 67108863), k._ishlnsubmul(L, fe, le);
            k.negative !== 0;

          )
            fe--,
              (k.negative = 0),
              k._ishlnsubmul(L, 1, le),
              k.isZero() || (k.negative ^= 1);
          R && (R.words[le] = fe);
        }
        return (
          R && R.strip(),
          k.strip(),
          O !== "div" && I !== 0 && k.iushrn(I),
          { div: R || null, mod: k }
        );
      }),
      (s.prototype.divmod = function (T, O, I) {
        if ((r(!T.isZero()), this.isZero()))
          return { div: new s(0), mod: new s(0) };
        var k, L, U;
        return this.negative !== 0 && T.negative === 0
          ? ((U = this.neg().divmod(T, O)),
            O !== "mod" && (k = U.div.neg()),
            O !== "div" &&
              ((L = U.mod.neg()), I && L.negative !== 0 && L.iadd(T)),
            { div: k, mod: L })
          : this.negative === 0 && T.negative !== 0
          ? ((U = this.divmod(T.neg(), O)),
            O !== "mod" && (k = U.div.neg()),
            { div: k, mod: U.mod })
          : this.negative & T.negative
          ? ((U = this.neg().divmod(T.neg(), O)),
            O !== "div" &&
              ((L = U.mod.neg()), I && L.negative !== 0 && L.isub(T)),
            { div: U.div, mod: L })
          : T.length > this.length || this.cmp(T) < 0
          ? { div: new s(0), mod: this }
          : T.length === 1
          ? O === "div"
            ? { div: this.divn(T.words[0]), mod: null }
            : O === "mod"
            ? { div: null, mod: new s(this.modn(T.words[0])) }
            : { div: this.divn(T.words[0]), mod: new s(this.modn(T.words[0])) }
          : this._wordDiv(T, O);
      }),
      (s.prototype.div = function (T) {
        return this.divmod(T, "div", !1).div;
      }),
      (s.prototype.mod = function (T) {
        return this.divmod(T, "mod", !1).mod;
      }),
      (s.prototype.umod = function (T) {
        return this.divmod(T, "mod", !0).mod;
      }),
      (s.prototype.divRound = function (T) {
        var O = this.divmod(T);
        if (O.mod.isZero()) return O.div;
        var I = O.div.negative !== 0 ? O.mod.isub(T) : O.mod,
          k = T.ushrn(1),
          L = T.andln(1),
          U = I.cmp(k);
        return U < 0 || (L === 1 && U === 0)
          ? O.div
          : O.div.negative !== 0
          ? O.div.isubn(1)
          : O.div.iaddn(1);
      }),
      (s.prototype.modn = function (T) {
        r(T <= 67108863);
        for (var O = (1 << 26) % T, I = 0, k = this.length - 1; k >= 0; k--)
          I = (O * I + (this.words[k] | 0)) % T;
        return I;
      }),
      (s.prototype.idivn = function (T) {
        r(T <= 67108863);
        for (var O = 0, I = this.length - 1; I >= 0; I--) {
          var k = (this.words[I] | 0) + O * 67108864;
          (this.words[I] = (k / T) | 0), (O = k % T);
        }
        return this.strip();
      }),
      (s.prototype.divn = function (T) {
        return this.clone().idivn(T);
      }),
      (s.prototype.egcd = function (T) {
        r(T.negative === 0), r(!T.isZero());
        var O = this,
          I = T.clone();
        O.negative !== 0 ? (O = O.umod(T)) : (O = O.clone());
        for (
          var k = new s(1), L = new s(0), U = new s(0), $ = new s(1), B = 0;
          O.isEven() && I.isEven();

        )
          O.iushrn(1), I.iushrn(1), ++B;
        for (var R = I.clone(), V = O.clone(); !O.isZero(); ) {
          for (
            var oe = 0, le = 1;
            !(O.words[0] & le) && oe < 26;
            ++oe, le <<= 1
          );
          if (oe > 0)
            for (O.iushrn(oe); oe-- > 0; )
              (k.isOdd() || L.isOdd()) && (k.iadd(R), L.isub(V)),
                k.iushrn(1),
                L.iushrn(1);
          for (var fe = 0, z = 1; !(I.words[0] & z) && fe < 26; ++fe, z <<= 1);
          if (fe > 0)
            for (I.iushrn(fe); fe-- > 0; )
              (U.isOdd() || $.isOdd()) && (U.iadd(R), $.isub(V)),
                U.iushrn(1),
                $.iushrn(1);
          O.cmp(I) >= 0
            ? (O.isub(I), k.isub(U), L.isub($))
            : (I.isub(O), U.isub(k), $.isub(L));
        }
        return { a: U, b: $, gcd: I.iushln(B) };
      }),
      (s.prototype._invmp = function (T) {
        r(T.negative === 0), r(!T.isZero());
        var O = this,
          I = T.clone();
        O.negative !== 0 ? (O = O.umod(T)) : (O = O.clone());
        for (
          var k = new s(1), L = new s(0), U = I.clone();
          O.cmpn(1) > 0 && I.cmpn(1) > 0;

        ) {
          for (var $ = 0, B = 1; !(O.words[0] & B) && $ < 26; ++$, B <<= 1);
          if ($ > 0)
            for (O.iushrn($); $-- > 0; ) k.isOdd() && k.iadd(U), k.iushrn(1);
          for (var R = 0, V = 1; !(I.words[0] & V) && R < 26; ++R, V <<= 1);
          if (R > 0)
            for (I.iushrn(R); R-- > 0; ) L.isOdd() && L.iadd(U), L.iushrn(1);
          O.cmp(I) >= 0 ? (O.isub(I), k.isub(L)) : (I.isub(O), L.isub(k));
        }
        var oe;
        return (
          O.cmpn(1) === 0 ? (oe = k) : (oe = L),
          oe.cmpn(0) < 0 && oe.iadd(T),
          oe
        );
      }),
      (s.prototype.gcd = function (T) {
        if (this.isZero()) return T.abs();
        if (T.isZero()) return this.abs();
        var O = this.clone(),
          I = T.clone();
        (O.negative = 0), (I.negative = 0);
        for (var k = 0; O.isEven() && I.isEven(); k++) O.iushrn(1), I.iushrn(1);
        do {
          for (; O.isEven(); ) O.iushrn(1);
          for (; I.isEven(); ) I.iushrn(1);
          var L = O.cmp(I);
          if (L < 0) {
            var U = O;
            (O = I), (I = U);
          } else if (L === 0 || I.cmpn(1) === 0) break;
          O.isub(I);
        } while (!0);
        return I.iushln(k);
      }),
      (s.prototype.invm = function (T) {
        return this.egcd(T).a.umod(T);
      }),
      (s.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (s.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (s.prototype.andln = function (T) {
        return this.words[0] & T;
      }),
      (s.prototype.bincn = function (T) {
        r(typeof T == "number");
        var O = T % 26,
          I = (T - O) / 26,
          k = 1 << O;
        if (this.length <= I)
          return this._expand(I + 1), (this.words[I] |= k), this;
        for (var L = k, U = I; L !== 0 && U < this.length; U++) {
          var $ = this.words[U] | 0;
          ($ += L), (L = $ >>> 26), ($ &= 67108863), (this.words[U] = $);
        }
        return L !== 0 && ((this.words[U] = L), this.length++), this;
      }),
      (s.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (s.prototype.cmpn = function (T) {
        var O = T < 0;
        if (this.negative !== 0 && !O) return -1;
        if (this.negative === 0 && O) return 1;
        this.strip();
        var I;
        if (this.length > 1) I = 1;
        else {
          O && (T = -T), r(T <= 67108863, "Number is too big");
          var k = this.words[0] | 0;
          I = k === T ? 0 : k < T ? -1 : 1;
        }
        return this.negative !== 0 ? -I | 0 : I;
      }),
      (s.prototype.cmp = function (T) {
        if (this.negative !== 0 && T.negative === 0) return -1;
        if (this.negative === 0 && T.negative !== 0) return 1;
        var O = this.ucmp(T);
        return this.negative !== 0 ? -O | 0 : O;
      }),
      (s.prototype.ucmp = function (T) {
        if (this.length > T.length) return 1;
        if (this.length < T.length) return -1;
        for (var O = 0, I = this.length - 1; I >= 0; I--) {
          var k = this.words[I] | 0,
            L = T.words[I] | 0;
          if (k !== L) {
            k < L ? (O = -1) : k > L && (O = 1);
            break;
          }
        }
        return O;
      }),
      (s.prototype.gtn = function (T) {
        return this.cmpn(T) === 1;
      }),
      (s.prototype.gt = function (T) {
        return this.cmp(T) === 1;
      }),
      (s.prototype.gten = function (T) {
        return this.cmpn(T) >= 0;
      }),
      (s.prototype.gte = function (T) {
        return this.cmp(T) >= 0;
      }),
      (s.prototype.ltn = function (T) {
        return this.cmpn(T) === -1;
      }),
      (s.prototype.lt = function (T) {
        return this.cmp(T) === -1;
      }),
      (s.prototype.lten = function (T) {
        return this.cmpn(T) <= 0;
      }),
      (s.prototype.lte = function (T) {
        return this.cmp(T) <= 0;
      }),
      (s.prototype.eqn = function (T) {
        return this.cmpn(T) === 0;
      }),
      (s.prototype.eq = function (T) {
        return this.cmp(T) === 0;
      }),
      (s.red = function (T) {
        return new A(T);
      }),
      (s.prototype.toRed = function (T) {
        return (
          r(!this.red, "Already a number in reduction context"),
          r(this.negative === 0, "red works only with positives"),
          T.convertTo(this)._forceRed(T)
        );
      }),
      (s.prototype.fromRed = function () {
        return (
          r(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (s.prototype._forceRed = function (T) {
        return (this.red = T), this;
      }),
      (s.prototype.forceRed = function (T) {
        return (
          r(!this.red, "Already a number in reduction context"),
          this._forceRed(T)
        );
      }),
      (s.prototype.redAdd = function (T) {
        return (
          r(this.red, "redAdd works only with red numbers"),
          this.red.add(this, T)
        );
      }),
      (s.prototype.redIAdd = function (T) {
        return (
          r(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, T)
        );
      }),
      (s.prototype.redSub = function (T) {
        return (
          r(this.red, "redSub works only with red numbers"),
          this.red.sub(this, T)
        );
      }),
      (s.prototype.redISub = function (T) {
        return (
          r(this.red, "redISub works only with red numbers"),
          this.red.isub(this, T)
        );
      }),
      (s.prototype.redShl = function (T) {
        return (
          r(this.red, "redShl works only with red numbers"),
          this.red.shl(this, T)
        );
      }),
      (s.prototype.redMul = function (T) {
        return (
          r(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, T),
          this.red.mul(this, T)
        );
      }),
      (s.prototype.redIMul = function (T) {
        return (
          r(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, T),
          this.red.imul(this, T)
        );
      }),
      (s.prototype.redSqr = function () {
        return (
          r(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (s.prototype.redISqr = function () {
        return (
          r(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (s.prototype.redSqrt = function () {
        return (
          r(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (s.prototype.redInvm = function () {
        return (
          r(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (s.prototype.redNeg = function () {
        return (
          r(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (s.prototype.redPow = function (T) {
        return (
          r(this.red && !T.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, T)
        );
      });
    var E = { k256: null, p224: null, p192: null, p25519: null };
    function S(M, T) {
      (this.name = M),
        (this.p = new s(T, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new s(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (S.prototype._tmp = function () {
      var T = new s(null);
      return (T.words = new Array(Math.ceil(this.n / 13))), T;
    }),
      (S.prototype.ireduce = function (T) {
        var O = T,
          I;
        do
          this.split(O, this.tmp),
            (O = this.imulK(O)),
            (O = O.iadd(this.tmp)),
            (I = O.bitLength());
        while (I > this.n);
        var k = I < this.n ? -1 : O.ucmp(this.p);
        return (
          k === 0
            ? ((O.words[0] = 0), (O.length = 1))
            : k > 0
            ? O.isub(this.p)
            : O.strip !== void 0
            ? O.strip()
            : O._strip(),
          O
        );
      }),
      (S.prototype.split = function (T, O) {
        T.iushrn(this.n, 0, O);
      }),
      (S.prototype.imulK = function (T) {
        return T.imul(this.k);
      });
    function D() {
      S.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(D, S),
      (D.prototype.split = function (T, O) {
        for (var I = 4194303, k = Math.min(T.length, 9), L = 0; L < k; L++)
          O.words[L] = T.words[L];
        if (((O.length = k), T.length <= 9)) {
          (T.words[0] = 0), (T.length = 1);
          return;
        }
        var U = T.words[9];
        for (O.words[O.length++] = U & I, L = 10; L < T.length; L++) {
          var $ = T.words[L] | 0;
          (T.words[L - 10] = (($ & I) << 4) | (U >>> 22)), (U = $);
        }
        (U >>>= 22),
          (T.words[L - 10] = U),
          U === 0 && T.length > 10 ? (T.length -= 10) : (T.length -= 9);
      }),
      (D.prototype.imulK = function (T) {
        (T.words[T.length] = 0), (T.words[T.length + 1] = 0), (T.length += 2);
        for (var O = 0, I = 0; I < T.length; I++) {
          var k = T.words[I] | 0;
          (O += k * 977),
            (T.words[I] = O & 67108863),
            (O = k * 64 + ((O / 67108864) | 0));
        }
        return (
          T.words[T.length - 1] === 0 &&
            (T.length--, T.words[T.length - 1] === 0 && T.length--),
          T
        );
      });
    function P() {
      S.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(P, S);
    function x() {
      S.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(x, S);
    function _() {
      S.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(_, S),
      (_.prototype.imulK = function (T) {
        for (var O = 0, I = 0; I < T.length; I++) {
          var k = (T.words[I] | 0) * 19 + O,
            L = k & 67108863;
          (k >>>= 26), (T.words[I] = L), (O = k);
        }
        return O !== 0 && (T.words[T.length++] = O), T;
      }),
      (s._prime = function (T) {
        if (E[T]) return E[T];
        var O;
        if (T === "k256") O = new D();
        else if (T === "p224") O = new P();
        else if (T === "p192") O = new x();
        else if (T === "p25519") O = new _();
        else throw new Error("Unknown prime " + T);
        return (E[T] = O), O;
      });
    function A(M) {
      if (typeof M == "string") {
        var T = s._prime(M);
        (this.m = T.p), (this.prime = T);
      } else
        r(M.gtn(1), "modulus must be greater than 1"),
          (this.m = M),
          (this.prime = null);
    }
    (A.prototype._verify1 = function (T) {
      r(T.negative === 0, "red works only with positives"),
        r(T.red, "red works only with red numbers");
    }),
      (A.prototype._verify2 = function (T, O) {
        r((T.negative | O.negative) === 0, "red works only with positives"),
          r(T.red && T.red === O.red, "red works only with red numbers");
      }),
      (A.prototype.imod = function (T) {
        return this.prime
          ? this.prime.ireduce(T)._forceRed(this)
          : T.umod(this.m)._forceRed(this);
      }),
      (A.prototype.neg = function (T) {
        return T.isZero() ? T.clone() : this.m.sub(T)._forceRed(this);
      }),
      (A.prototype.add = function (T, O) {
        this._verify2(T, O);
        var I = T.add(O);
        return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
      }),
      (A.prototype.iadd = function (T, O) {
        this._verify2(T, O);
        var I = T.iadd(O);
        return I.cmp(this.m) >= 0 && I.isub(this.m), I;
      }),
      (A.prototype.sub = function (T, O) {
        this._verify2(T, O);
        var I = T.sub(O);
        return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
      }),
      (A.prototype.isub = function (T, O) {
        this._verify2(T, O);
        var I = T.isub(O);
        return I.cmpn(0) < 0 && I.iadd(this.m), I;
      }),
      (A.prototype.shl = function (T, O) {
        return this._verify1(T), this.imod(T.ushln(O));
      }),
      (A.prototype.imul = function (T, O) {
        return this._verify2(T, O), this.imod(T.imul(O));
      }),
      (A.prototype.mul = function (T, O) {
        return this._verify2(T, O), this.imod(T.mul(O));
      }),
      (A.prototype.isqr = function (T) {
        return this.imul(T, T.clone());
      }),
      (A.prototype.sqr = function (T) {
        return this.mul(T, T);
      }),
      (A.prototype.sqrt = function (T) {
        if (T.isZero()) return T.clone();
        var O = this.m.andln(3);
        if ((r(O % 2 === 1), O === 3)) {
          var I = this.m.add(new s(1)).iushrn(2);
          return this.pow(T, I);
        }
        for (var k = this.m.subn(1), L = 0; !k.isZero() && k.andln(1) === 0; )
          L++, k.iushrn(1);
        r(!k.isZero());
        var U = new s(1).toRed(this),
          $ = U.redNeg(),
          B = this.m.subn(1).iushrn(1),
          R = this.m.bitLength();
        for (R = new s(2 * R * R).toRed(this); this.pow(R, B).cmp($) !== 0; )
          R.redIAdd($);
        for (
          var V = this.pow(R, k),
            oe = this.pow(T, k.addn(1).iushrn(1)),
            le = this.pow(T, k),
            fe = L;
          le.cmp(U) !== 0;

        ) {
          for (var z = le, se = 0; z.cmp(U) !== 0; se++) z = z.redSqr();
          r(se < fe);
          var Y = this.pow(V, new s(1).iushln(fe - se - 1));
          (oe = oe.redMul(Y)), (V = Y.redSqr()), (le = le.redMul(V)), (fe = se);
        }
        return oe;
      }),
      (A.prototype.invm = function (T) {
        var O = T._invmp(this.m);
        return O.negative !== 0
          ? ((O.negative = 0), this.imod(O).redNeg())
          : this.imod(O);
      }),
      (A.prototype.pow = function (T, O) {
        if (O.isZero()) return new s(1).toRed(this);
        if (O.cmpn(1) === 0) return T.clone();
        var I = 4,
          k = new Array(1 << I);
        (k[0] = new s(1).toRed(this)), (k[1] = T);
        for (var L = 2; L < k.length; L++) k[L] = this.mul(k[L - 1], T);
        var U = k[0],
          $ = 0,
          B = 0,
          R = O.bitLength() % 26;
        for (R === 0 && (R = 26), L = O.length - 1; L >= 0; L--) {
          for (var V = O.words[L], oe = R - 1; oe >= 0; oe--) {
            var le = (V >> oe) & 1;
            if ((U !== k[0] && (U = this.sqr(U)), le === 0 && $ === 0)) {
              B = 0;
              continue;
            }
            ($ <<= 1),
              ($ |= le),
              B++,
              !(B !== I && (L !== 0 || oe !== 0)) &&
                ((U = this.mul(U, k[$])), (B = 0), ($ = 0));
          }
          R = 26;
        }
        return U;
      }),
      (A.prototype.convertTo = function (T) {
        var O = T.umod(this.m);
        return O === T ? O.clone() : O;
      }),
      (A.prototype.convertFrom = function (T) {
        var O = T.clone();
        return (O.red = null), O;
      }),
      (s.mont = function (T) {
        return new N(T);
      });
    function N(M) {
      A.call(this, M),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new s(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(N, A),
      (N.prototype.convertTo = function (T) {
        return this.imod(T.ushln(this.shift));
      }),
      (N.prototype.convertFrom = function (T) {
        var O = this.imod(T.mul(this.rinv));
        return (O.red = null), O;
      }),
      (N.prototype.imul = function (T, O) {
        if (T.isZero() || O.isZero())
          return (T.words[0] = 0), (T.length = 1), T;
        var I = T.imul(O),
          k = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          L = I.isub(k).iushrn(this.shift),
          U = L;
        return (
          L.cmp(this.m) >= 0
            ? (U = L.isub(this.m))
            : L.cmpn(0) < 0 && (U = L.iadd(this.m)),
          U._forceRed(this)
        );
      }),
      (N.prototype.mul = function (T, O) {
        if (T.isZero() || O.isZero()) return new s(0)._forceRed(this);
        var I = T.mul(O),
          k = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          L = I.isub(k).iushrn(this.shift),
          U = L;
        return (
          L.cmp(this.m) >= 0
            ? (U = L.isub(this.m))
            : L.cmpn(0) < 0 && (U = L.iadd(this.m)),
          U._forceRed(this)
        );
      }),
      (N.prototype.invm = function (T) {
        var O = this.imod(T._invmp(this.m).mul(this.r2));
        return O._forceRed(this);
      });
  })(t, Ur);
})(B7);
var sle = B7.exports;
const bn = oa(sle),
  ale = "logger/5.5.0";
let MI = !1,
  LI = !1;
const tb = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let BI = tb.default,
  M_ = null;
function ole() {
  try {
    const t = [];
    if (
      (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
        try {
          if ("test".normalize(e) !== "test") throw new Error("bad normalize");
        } catch {
          t.push(e);
        }
      }),
      t.length)
    )
      throw new Error("missing " + t.join(", "));
    if (
      String.fromCharCode(233).normalize("NFD") !==
      String.fromCharCode(101, 769)
    )
      throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const FI = ole();
var bE;
(function (t) {
  (t.DEBUG = "DEBUG"),
    (t.INFO = "INFO"),
    (t.WARNING = "WARNING"),
    (t.ERROR = "ERROR"),
    (t.OFF = "OFF");
})(bE || (bE = {}));
var wE;
(function (t) {
  (t.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
    (t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
    (t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
    (t.NETWORK_ERROR = "NETWORK_ERROR"),
    (t.SERVER_ERROR = "SERVER_ERROR"),
    (t.TIMEOUT = "TIMEOUT"),
    (t.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
    (t.NUMERIC_FAULT = "NUMERIC_FAULT"),
    (t.MISSING_NEW = "MISSING_NEW"),
    (t.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
    (t.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
    (t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
    (t.CALL_EXCEPTION = "CALL_EXCEPTION"),
    (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
    (t.NONCE_EXPIRED = "NONCE_EXPIRED"),
    (t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
    (t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
    (t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED");
})(wE || (wE = {}));
const $I = "0123456789abcdef";
class Se {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1,
    });
  }
  _log(e, n) {
    const r = e.toLowerCase();
    tb[r] == null &&
      this.throwArgumentError("invalid log level name", "logLevel", e),
      !(BI > tb[r]) && console.log.apply(console, n);
  }
  debug(...e) {
    this._log(Se.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Se.levels.INFO, e);
  }
  warn(...e) {
    this._log(Se.levels.WARNING, e);
  }
  makeError(e, n, r) {
    if (LI) return this.makeError("censored error", n, {});
    n || (n = Se.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((o) => {
      const l = r[o];
      try {
        if (l instanceof Uint8Array) {
          let u = "";
          for (let f = 0; f < l.length; f++)
            (u += $I[l[f] >> 4]), (u += $I[l[f] & 15]);
          i.push(o + "=Uint8Array(0x" + u + ")");
        } else i.push(o + "=" + JSON.stringify(l));
      } catch {
        i.push(o + "=" + JSON.stringify(r[o].toString()));
      }
    }),
      i.push(`code=${n}`),
      i.push(`version=${this.version}`);
    const s = e;
    i.length && (e += " (" + i.join(", ") + ")");
    const a = new Error(e);
    return (
      (a.reason = s),
      (a.code = n),
      Object.keys(r).forEach(function (o) {
        a[o] = r[o];
      }),
      a
    );
  }
  throwError(e, n, r) {
    throw this.makeError(e, n, r);
  }
  throwArgumentError(e, n, r) {
    return this.throwError(e, Se.errors.INVALID_ARGUMENT, {
      argument: n,
      value: r,
    });
  }
  assert(e, n, r, i) {
    e || this.throwError(n, r, i);
  }
  assertArgument(e, n, r, i) {
    e || this.throwArgumentError(n, r, i);
  }
  checkNormalize(e) {
    FI &&
      this.throwError(
        "platform missing String.prototype.normalize",
        Se.errors.UNSUPPORTED_OPERATION,
        { operation: "String.prototype.normalize", form: FI }
      );
  }
  checkSafeUint53(e, n) {
    typeof e == "number" &&
      (n == null && (n = "value not safe"),
      (e < 0 || e >= 9007199254740991) &&
        this.throwError(n, Se.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value: e,
        }),
      e % 1 &&
        this.throwError(n, Se.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value: e,
        }));
  }
  checkArgumentCount(e, n, r) {
    r ? (r = ": " + r) : (r = ""),
      e < n &&
        this.throwError("missing argument" + r, Se.errors.MISSING_ARGUMENT, {
          count: e,
          expectedCount: n,
        }),
      e > n &&
        this.throwError(
          "too many arguments" + r,
          Se.errors.UNEXPECTED_ARGUMENT,
          { count: e, expectedCount: n }
        );
  }
  checkNew(e, n) {
    (e === Object || e == null) &&
      this.throwError("missing new", Se.errors.MISSING_NEW, { name: n.name });
  }
  checkAbstract(e, n) {
    e === n
      ? this.throwError(
          "cannot instantiate abstract class " +
            JSON.stringify(n.name) +
            " directly; use a sub-class",
          Se.errors.UNSUPPORTED_OPERATION,
          { name: e.name, operation: "new" }
        )
      : (e === Object || e == null) &&
        this.throwError("missing new", Se.errors.MISSING_NEW, { name: n.name });
  }
  static globalLogger() {
    return M_ || (M_ = new Se(ale)), M_;
  }
  static setCensorship(e, n) {
    if (
      (!e &&
        n &&
        this.globalLogger().throwError(
          "cannot permanently disable censorship",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "setCensorship" }
        ),
      MI)
    ) {
      if (!e) return;
      this.globalLogger().throwError(
        "error censorship permanent",
        Se.errors.UNSUPPORTED_OPERATION,
        { operation: "setCensorship" }
      );
    }
    (LI = !!e), (MI = !!n);
  }
  static setLogLevel(e) {
    const n = tb[e.toLowerCase()];
    if (n == null) {
      Se.globalLogger().warn("invalid log level - " + e);
      return;
    }
    BI = n;
  }
  static from(e) {
    return new Se(e);
  }
}
Se.errors = wE;
Se.levels = bE;
const lle = "bytes/5.5.0",
  gi = new Se(lle);
function mj(t) {
  return !!t.toHexString;
}
function l0(t) {
  return (
    t.slice ||
      (t.slice = function () {
        const e = Array.prototype.slice.call(arguments);
        return l0(new Uint8Array(Array.prototype.slice.apply(t, e)));
      }),
    t
  );
}
function F7(t) {
  return (cr(t) && !(t.length % 2)) || Pw(t);
}
function UI(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function Pw(t) {
  if (t == null) return !1;
  if (t.constructor === Uint8Array) return !0;
  if (typeof t == "string" || !UI(t.length) || t.length < 0) return !1;
  for (let e = 0; e < t.length; e++) {
    const n = t[e];
    if (!UI(n) || n < 0 || n >= 256) return !1;
  }
  return !0;
}
function hn(t, e) {
  if ((e || (e = {}), typeof t == "number")) {
    gi.checkSafeUint53(t, "invalid arrayify value");
    const n = [];
    for (; t; ) n.unshift(t & 255), (t = parseInt(String(t / 256)));
    return n.length === 0 && n.push(0), l0(new Uint8Array(n));
  }
  if (
    (e.allowMissingPrefix &&
      typeof t == "string" &&
      t.substring(0, 2) !== "0x" &&
      (t = "0x" + t),
    mj(t) && (t = t.toHexString()),
    cr(t))
  ) {
    let n = t.substring(2);
    n.length % 2 &&
      (e.hexPad === "left"
        ? (n = "0x0" + n.substring(2))
        : e.hexPad === "right"
        ? (n += "0")
        : gi.throwArgumentError("hex data is odd-length", "value", t));
    const r = [];
    for (let i = 0; i < n.length; i += 2)
      r.push(parseInt(n.substring(i, i + 2), 16));
    return l0(new Uint8Array(r));
  }
  return Pw(t)
    ? l0(new Uint8Array(t))
    : gi.throwArgumentError("invalid arrayify value", "value", t);
}
function fl(t) {
  const e = t.map((i) => hn(i)),
    n = e.reduce((i, s) => i + s.length, 0),
    r = new Uint8Array(n);
  return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), l0(r);
}
function F0(t) {
  let e = hn(t);
  if (e.length === 0) return e;
  let n = 0;
  for (; n < e.length && e[n] === 0; ) n++;
  return n && (e = e.slice(n)), e;
}
function ule(t, e) {
  (t = hn(t)),
    t.length > e &&
      gi.throwArgumentError("value out of range", "value", arguments[0]);
  const n = new Uint8Array(e);
  return n.set(t, e - t.length), l0(n);
}
function cr(t, e) {
  return !(
    typeof t != "string" ||
    !t.match(/^0x[0-9A-Fa-f]*$/) ||
    (e && t.length !== 2 + 2 * e)
  );
}
const L_ = "0123456789abcdef";
function Qt(t, e) {
  if ((e || (e = {}), typeof t == "number")) {
    gi.checkSafeUint53(t, "invalid hexlify value");
    let n = "";
    for (; t; ) (n = L_[t & 15] + n), (t = Math.floor(t / 16));
    return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00";
  }
  if (typeof t == "bigint")
    return (t = t.toString(16)), t.length % 2 ? "0x0" + t : "0x" + t;
  if (
    (e.allowMissingPrefix &&
      typeof t == "string" &&
      t.substring(0, 2) !== "0x" &&
      (t = "0x" + t),
    mj(t))
  )
    return t.toHexString();
  if (cr(t))
    return (
      t.length % 2 &&
        (e.hexPad === "left"
          ? (t = "0x0" + t.substring(2))
          : e.hexPad === "right"
          ? (t += "0")
          : gi.throwArgumentError("hex data is odd-length", "value", t)),
      t.toLowerCase()
    );
  if (Pw(t)) {
    let n = "0x";
    for (let r = 0; r < t.length; r++) {
      let i = t[r];
      n += L_[(i & 240) >> 4] + L_[i & 15];
    }
    return n;
  }
  return gi.throwArgumentError("invalid hexlify value", "value", t);
}
function xy(t) {
  if (typeof t != "string") t = Qt(t);
  else if (!cr(t) || t.length % 2) return null;
  return (t.length - 2) / 2;
}
function jc(t, e, n) {
  return (
    typeof t != "string"
      ? (t = Qt(t))
      : (!cr(t) || t.length % 2) &&
        gi.throwArgumentError("invalid hexData", "value", t),
    (e = 2 + 2 * e),
    n != null ? "0x" + t.substring(e, 2 + 2 * n) : "0x" + t.substring(e)
  );
}
function Ql(t) {
  let e = "0x";
  return (
    t.forEach((n) => {
      e += Qt(n).substring(2);
    }),
    e
  );
}
function $7(t) {
  const e = cle(Qt(t, { hexPad: "left" }));
  return e === "0x" ? "0x0" : e;
}
function cle(t) {
  typeof t != "string" && (t = Qt(t)),
    cr(t) || gi.throwArgumentError("invalid hex string", "value", t),
    (t = t.substring(2));
  let e = 0;
  for (; e < t.length && t[e] === "0"; ) e++;
  return "0x" + t.substring(e);
}
function Ni(t, e) {
  for (
    typeof t != "string"
      ? (t = Qt(t))
      : cr(t) || gi.throwArgumentError("invalid hex string", "value", t),
      t.length > 2 * e + 2 &&
        gi.throwArgumentError("value out of range", "value", arguments[1]);
    t.length < 2 * e + 2;

  )
    t = "0x0" + t.substring(2);
  return t;
}
function Nw(t) {
  const e = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0 };
  if (F7(t)) {
    const n = hn(t);
    n.length !== 65 &&
      gi.throwArgumentError(
        "invalid signature string; must be 65 bytes",
        "signature",
        t
      ),
      (e.r = Qt(n.slice(0, 32))),
      (e.s = Qt(n.slice(32, 64))),
      (e.v = n[64]),
      e.v < 27 &&
        (e.v === 0 || e.v === 1
          ? (e.v += 27)
          : gi.throwArgumentError("signature invalid v byte", "signature", t)),
      (e.recoveryParam = 1 - (e.v % 2)),
      e.recoveryParam && (n[32] |= 128),
      (e._vs = Qt(n.slice(32, 64)));
  } else {
    if (
      ((e.r = t.r),
      (e.s = t.s),
      (e.v = t.v),
      (e.recoveryParam = t.recoveryParam),
      (e._vs = t._vs),
      e._vs != null)
    ) {
      const i = ule(hn(e._vs), 32);
      e._vs = Qt(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null
        ? (e.recoveryParam = s)
        : e.recoveryParam !== s &&
          gi.throwArgumentError(
            "signature recoveryParam mismatch _vs",
            "signature",
            t
          ),
        (i[0] &= 127);
      const a = Qt(i);
      e.s == null
        ? (e.s = a)
        : e.s !== a &&
          gi.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null
        ? gi.throwArgumentError(
            "signature missing v and recoveryParam",
            "signature",
            t
          )
        : e.v === 0 || e.v === 1
        ? (e.recoveryParam = e.v)
        : (e.recoveryParam = 1 - (e.v % 2));
    else if (e.v == null) e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2);
      e.recoveryParam !== i &&
        gi.throwArgumentError(
          "signature recoveryParam mismatch v",
          "signature",
          t
        );
    }
    e.r == null || !cr(e.r)
      ? gi.throwArgumentError("signature missing or invalid r", "signature", t)
      : (e.r = Ni(e.r, 32)),
      e.s == null || !cr(e.s)
        ? gi.throwArgumentError(
            "signature missing or invalid s",
            "signature",
            t
          )
        : (e.s = Ni(e.s, 32));
    const n = hn(e.s);
    n[0] >= 128 &&
      gi.throwArgumentError("signature s out of range", "signature", t),
      e.recoveryParam && (n[0] |= 128);
    const r = Qt(n);
    e._vs &&
      (cr(e._vs) ||
        gi.throwArgumentError("signature invalid _vs", "signature", t),
      (e._vs = Ni(e._vs, 32))),
      e._vs == null
        ? (e._vs = r)
        : e._vs !== r &&
          gi.throwArgumentError(
            "signature _vs mismatch v and s",
            "signature",
            t
          );
  }
  return e;
}
const fle = "bignumber/5.5.0";
var s5 = bn.BN;
const Iu = new Se(fle),
  B_ = {},
  jI = 9007199254740991;
let HI = !1;
class dt {
  constructor(e, n) {
    Iu.checkNew(new.target, dt),
      e !== B_ &&
        Iu.throwError(
          "cannot call constructor directly; use BigNumber.from",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "new (BigNumber)" }
        ),
      (this._hex = n),
      (this._isBigNumber = !0),
      Object.freeze(this);
  }
  fromTwos(e) {
    return Va(zn(this).fromTwos(e));
  }
  toTwos(e) {
    return Va(zn(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? dt.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Va(zn(this).add(zn(e)));
  }
  sub(e) {
    return Va(zn(this).sub(zn(e)));
  }
  div(e) {
    return (
      dt.from(e).isZero() && tl("division by zero", "div"),
      Va(zn(this).div(zn(e)))
    );
  }
  mul(e) {
    return Va(zn(this).mul(zn(e)));
  }
  mod(e) {
    const n = zn(e);
    return (
      n.isNeg() && tl("cannot modulo negative values", "mod"),
      Va(zn(this).umod(n))
    );
  }
  pow(e) {
    const n = zn(e);
    return (
      n.isNeg() && tl("cannot raise to negative values", "pow"),
      Va(zn(this).pow(n))
    );
  }
  and(e) {
    const n = zn(e);
    return (
      (this.isNegative() || n.isNeg()) &&
        tl("cannot 'and' negative values", "and"),
      Va(zn(this).and(n))
    );
  }
  or(e) {
    const n = zn(e);
    return (
      (this.isNegative() || n.isNeg()) &&
        tl("cannot 'or' negative values", "or"),
      Va(zn(this).or(n))
    );
  }
  xor(e) {
    const n = zn(e);
    return (
      (this.isNegative() || n.isNeg()) &&
        tl("cannot 'xor' negative values", "xor"),
      Va(zn(this).xor(n))
    );
  }
  mask(e) {
    return (
      (this.isNegative() || e < 0) && tl("cannot mask negative values", "mask"),
      Va(zn(this).maskn(e))
    );
  }
  shl(e) {
    return (
      (this.isNegative() || e < 0) && tl("cannot shift negative values", "shl"),
      Va(zn(this).shln(e))
    );
  }
  shr(e) {
    return (
      (this.isNegative() || e < 0) && tl("cannot shift negative values", "shr"),
      Va(zn(this).shrn(e))
    );
  }
  eq(e) {
    return zn(this).eq(zn(e));
  }
  lt(e) {
    return zn(this).lt(zn(e));
  }
  lte(e) {
    return zn(this).lte(zn(e));
  }
  gt(e) {
    return zn(this).gt(zn(e));
  }
  gte(e) {
    return zn(this).gte(zn(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return zn(this).isZero();
  }
  toNumber() {
    try {
      return zn(this).toNumber();
    } catch {
      tl("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {}
    return Iu.throwError(
      "this platform does not support BigInt",
      Se.errors.UNSUPPORTED_OPERATION,
      { value: this.toString() }
    );
  }
  toString() {
    return (
      arguments.length > 0 &&
        (arguments[0] === 10
          ? HI ||
            ((HI = !0),
            Iu.warn(
              "BigNumber.toString does not accept any parameters; base-10 is assumed"
            ))
          : arguments[0] === 16
          ? Iu.throwError(
              "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
              Se.errors.UNEXPECTED_ARGUMENT,
              {}
            )
          : Iu.throwError(
              "BigNumber.toString does not accept parameters",
              Se.errors.UNEXPECTED_ARGUMENT,
              {}
            )),
      zn(this).toString(10)
    );
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof dt) return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i)
        ? new dt(B_, $g(e))
        : e.match(/^-?[0-9]+$/)
        ? new dt(B_, $g(new s5(e)))
        : Iu.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return (
        e % 1 && tl("underflow", "BigNumber.from", e),
        (e >= jI || e <= -jI) && tl("overflow", "BigNumber.from", e),
        dt.from(String(e))
      );
    const n = e;
    if (typeof n == "bigint") return dt.from(n.toString());
    if (Pw(n)) return dt.from(Qt(n));
    if (n)
      if (n.toHexString) {
        const r = n.toHexString();
        if (typeof r == "string") return dt.from(r);
      } else {
        let r = n._hex;
        if (
          (r == null && n.type === "BigNumber" && (r = n.hex),
          typeof r == "string" &&
            (cr(r) || (r[0] === "-" && cr(r.substring(1)))))
        )
          return dt.from(r);
      }
    return Iu.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function $g(t) {
  if (typeof t != "string") return $g(t.toString(16));
  if (t[0] === "-")
    return (
      (t = t.substring(1)),
      t[0] === "-" && Iu.throwArgumentError("invalid hex", "value", t),
      (t = $g(t)),
      t === "0x00" ? t : "-" + t
    );
  if ((t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x")) return "0x00";
  for (
    t.length % 2 && (t = "0x0" + t.substring(2));
    t.length > 4 && t.substring(0, 4) === "0x00";

  )
    t = "0x" + t.substring(4);
  return t;
}
function Va(t) {
  return dt.from($g(t));
}
function zn(t) {
  const e = dt.from(t).toHexString();
  return e[0] === "-"
    ? new s5("-" + e.substring(3), 16)
    : new s5(e.substring(2), 16);
}
function tl(t, e, n) {
  const r = { fault: t, operation: e };
  return (
    n != null && (r.value = n), Iu.throwError(t, Se.errors.NUMERIC_FAULT, r)
  );
}
function dle(t) {
  return new s5(t, 36).toString(16);
}
const hle = "properties/5.5.0";
var ple =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const a5 = new Se(hle);
function Je(t, e, n) {
  Object.defineProperty(t, e, { enumerable: !0, value: n, writable: !1 });
}
function $u(t, e) {
  for (let n = 0; n < 32; n++) {
    if (t[e]) return t[e];
    if (!t.prototype || typeof t.prototype != "object") break;
    t = Object.getPrototypeOf(t.prototype).constructor;
  }
  return null;
}
function Fi(t) {
  return ple(this, void 0, void 0, function* () {
    const e = Object.keys(t).map((r) => {
      const i = t[r];
      return Promise.resolve(i).then((s) => ({ key: r, value: s }));
    });
    return (yield Promise.all(e)).reduce(
      (r, i) => ((r[i.key] = i.value), r),
      {}
    );
  });
}
function mle(t, e) {
  (!t || typeof t != "object") &&
    a5.throwArgumentError("invalid object", "object", t),
    Object.keys(t).forEach((n) => {
      e[n] ||
        a5.throwArgumentError(
          "invalid object key - " + n,
          "transaction:" + n,
          t
        );
    });
}
function xs(t) {
  const e = {};
  for (const n in t) e[n] = t[n];
  return e;
}
const gle = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function gj(t) {
  if (t == null || gle[typeof t]) return !0;
  if (Array.isArray(t) || typeof t == "object") {
    if (!Object.isFrozen(t)) return !1;
    const e = Object.keys(t);
    for (let n = 0; n < e.length; n++) {
      let r = null;
      try {
        r = t[e[n]];
      } catch {
        continue;
      }
      if (!gj(r)) return !1;
    }
    return !0;
  }
  return a5.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
}
function yle(t) {
  if (gj(t)) return t;
  if (Array.isArray(t)) return Object.freeze(t.map((e) => Zc(e)));
  if (typeof t == "object") {
    const e = {};
    for (const n in t) {
      const r = t[n];
      r !== void 0 && Je(e, n, Zc(r));
    }
    return e;
  }
  return a5.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
}
function Zc(t) {
  return yle(t);
}
class Ty {
  constructor(e) {
    for (const n in e) this[n] = Zc(e[n]);
  }
}
const Sy = "abi/5.5.0",
  Yn = new Se(Sy),
  yh = {};
let zI = { calldata: !0, memory: !0, storage: !0 },
  vle = { calldata: !0, memory: !0 };
function iv(t, e) {
  if (t === "bytes" || t === "string") {
    if (zI[e]) return !0;
  } else if (t === "address") {
    if (e === "payable") return !0;
  } else if ((t.indexOf("[") >= 0 || t === "tuple") && vle[e]) return !0;
  return (
    (zI[e] || e === "payable") &&
      Yn.throwArgumentError("invalid modifier", "name", e),
    !1
  );
}
function ble(t, e) {
  let n = t;
  function r(o) {
    Yn.throwArgumentError(`unexpected character at position ${o}`, "param", t);
  }
  t = t.replace(/\s/g, " ");
  function i(o) {
    let l = { type: "", name: "", parent: o, state: { allowType: !0 } };
    return e && (l.indexed = !1), l;
  }
  let s = { type: "", name: "", state: { allowType: !0 } },
    a = s;
  for (let o = 0; o < t.length; o++) {
    let l = t[o];
    switch (l) {
      case "(":
        a.state.allowType && a.type === ""
          ? (a.type = "tuple")
          : a.state.allowParams || r(o),
          (a.state.allowType = !1),
          (a.type = Ap(a.type)),
          (a.components = [i(a)]),
          (a = a.components[0]);
        break;
      case ")":
        delete a.state,
          a.name === "indexed" && (e || r(o), (a.indexed = !0), (a.name = "")),
          iv(a.type, a.name) && (a.name = ""),
          (a.type = Ap(a.type));
        let u = a;
        (a = a.parent),
          a || r(o),
          delete u.parent,
          (a.state.allowParams = !1),
          (a.state.allowName = !0),
          (a.state.allowArray = !0);
        break;
      case ",":
        delete a.state,
          a.name === "indexed" && (e || r(o), (a.indexed = !0), (a.name = "")),
          iv(a.type, a.name) && (a.name = ""),
          (a.type = Ap(a.type));
        let f = i(a.parent);
        a.parent.components.push(f), delete a.parent, (a = f);
        break;
      case " ":
        a.state.allowType &&
          a.type !== "" &&
          ((a.type = Ap(a.type)),
          delete a.state.allowType,
          (a.state.allowName = !0),
          (a.state.allowParams = !0)),
          a.state.allowName &&
            a.name !== "" &&
            (a.name === "indexed"
              ? (e || r(o), a.indexed && r(o), (a.indexed = !0), (a.name = ""))
              : iv(a.type, a.name)
              ? (a.name = "")
              : (a.state.allowName = !1));
        break;
      case "[":
        a.state.allowArray || r(o),
          (a.type += l),
          (a.state.allowArray = !1),
          (a.state.allowName = !1),
          (a.state.readArray = !0);
        break;
      case "]":
        a.state.readArray || r(o),
          (a.type += l),
          (a.state.readArray = !1),
          (a.state.allowArray = !0),
          (a.state.allowName = !0);
        break;
      default:
        a.state.allowType
          ? ((a.type += l),
            (a.state.allowParams = !0),
            (a.state.allowArray = !0))
          : a.state.allowName
          ? ((a.name += l), delete a.state.allowArray)
          : a.state.readArray
          ? (a.type += l)
          : r(o);
    }
  }
  return (
    a.parent && Yn.throwArgumentError("unexpected eof", "param", t),
    delete s.state,
    a.name === "indexed"
      ? (e || r(n.length - 7),
        a.indexed && r(n.length - 7),
        (a.indexed = !0),
        (a.name = ""))
      : iv(a.type, a.name) && (a.name = ""),
    (s.type = Ap(s.type)),
    s
  );
}
function nb(t, e) {
  for (let n in e) Je(t, n, e[n]);
}
const lr = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json",
  }),
  wle = new RegExp(/^(.*)\[([0-9]*)\]$/);
let Vu = class kf {
  constructor(e, n) {
    e !== yh &&
      Yn.throwError("use fromString", Se.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()",
      }),
      nb(this, n);
    let r = this.type.match(wle);
    r
      ? nb(this, {
          arrayLength: parseInt(r[2] || "-1"),
          arrayChildren: kf.fromObject({
            type: r[1],
            components: this.components,
          }),
          baseType: "array",
        })
      : nb(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  format(e) {
    if (
      (e || (e = lr.sighash),
      lr[e] || Yn.throwArgumentError("invalid format type", "format", e),
      e === lr.json)
    ) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0,
      };
      return (
        typeof this.indexed == "boolean" && (r.indexed = this.indexed),
        this.components &&
          (r.components = this.components.map((i) => JSON.parse(i.format(e)))),
        JSON.stringify(r)
      );
    }
    let n = "";
    return (
      this.baseType === "array"
        ? ((n += this.arrayChildren.format(e)),
          (n +=
            "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
        : this.baseType === "tuple"
        ? (e !== lr.sighash && (n += this.type),
          (n +=
            "(" +
            this.components
              .map((r) => r.format(e))
              .join(e === lr.full ? ", " : ",") +
            ")"))
        : (n += this.type),
      e !== lr.sighash &&
        (this.indexed === !0 && (n += " indexed"),
        e === lr.full && this.name && (n += " " + this.name)),
      n
    );
  }
  static from(e, n) {
    return typeof e == "string" ? kf.fromString(e, n) : kf.fromObject(e);
  }
  static fromObject(e) {
    return kf.isParamType(e)
      ? e
      : new kf(yh, {
          name: e.name || null,
          type: Ap(e.type),
          indexed: e.indexed == null ? null : !!e.indexed,
          components: e.components ? e.components.map(kf.fromObject) : null,
        });
  }
  static fromString(e, n) {
    function r(i) {
      return kf.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components,
      });
    }
    return r(ble(e, !!n));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
};
function Ug(t, e) {
  return Ele(t).map((n) => Vu.fromString(n, e));
}
let Dw = class Bm {
    constructor(e, n) {
      e !== yh &&
        Yn.throwError(
          "use a static from method",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "new Fragment()" }
        ),
        nb(this, n),
        (this._isFragment = !0),
        Object.freeze(this);
    }
    static from(e) {
      return Bm.isFragment(e)
        ? e
        : typeof e == "string"
        ? Bm.fromString(e)
        : Bm.fromObject(e);
    }
    static fromObject(e) {
      if (Bm.isFragment(e)) return e;
      switch (e.type) {
        case "function":
          return l5.fromObject(e);
        case "event":
          return _E.fromObject(e);
        case "constructor":
          return o5.fromObject(e);
        case "error":
          return GI.fromObject(e);
        case "fallback":
        case "receive":
          return null;
      }
      return Yn.throwArgumentError("invalid fragment object", "value", e);
    }
    static fromString(e) {
      return (
        (e = e.replace(/\s/g, " ")),
        (e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
        (e = e.trim()),
        e.split(" ")[0] === "event"
          ? _E.fromString(e.substring(5).trim())
          : e.split(" ")[0] === "function"
          ? l5.fromString(e.substring(8).trim())
          : e.split("(")[0].trim() === "constructor"
          ? o5.fromString(e.trim())
          : e.split(" ")[0] === "error"
          ? GI.fromString(e.substring(5).trim())
          : Yn.throwArgumentError("unsupported fragment", "value", e)
      );
    }
    static isFragment(e) {
      return !!(e && e._isFragment);
    }
  },
  _E = class Ep extends Dw {
    format(e) {
      if (
        (e || (e = lr.sighash),
        lr[e] || Yn.throwArgumentError("invalid format type", "format", e),
        e === lr.json)
      )
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        });
      let n = "";
      return (
        e !== lr.sighash && (n += "event "),
        (n +=
          this.name +
          "(" +
          this.inputs.map((r) => r.format(e)).join(e === lr.full ? ", " : ",") +
          ") "),
        e !== lr.sighash && this.anonymous && (n += "anonymous "),
        n.trim()
      );
    }
    static from(e) {
      return typeof e == "string" ? Ep.fromString(e) : Ep.fromObject(e);
    }
    static fromObject(e) {
      if (Ep.isEventFragment(e)) return e;
      e.type !== "event" &&
        Yn.throwArgumentError("invalid event object", "value", e);
      const n = {
        name: jg(e.name),
        anonymous: e.anonymous,
        inputs: e.inputs ? e.inputs.map(Vu.fromObject) : [],
        type: "event",
      };
      return new Ep(yh, n);
    }
    static fromString(e) {
      let n = e.match(Hg);
      n || Yn.throwArgumentError("invalid event string", "value", e);
      let r = !1;
      return (
        n[3].split(" ").forEach((i) => {
          switch (i.trim()) {
            case "anonymous":
              r = !0;
              break;
            case "":
              break;
            default:
              Yn.warn("unknown modifier: " + i);
          }
        }),
        Ep.fromObject({
          name: n[1].trim(),
          anonymous: r,
          inputs: Ug(n[2], !0),
          type: "event",
        })
      );
    }
    static isEventFragment(e) {
      return e && e._isFragment && e.type === "event";
    }
  };
function yj(t, e) {
  e.gas = null;
  let n = t.split("@");
  return n.length !== 1
    ? (n.length > 2 &&
        Yn.throwArgumentError(
          "invalid human-readable ABI signature",
          "value",
          t
        ),
      n[1].match(/^[0-9]+$/) ||
        Yn.throwArgumentError(
          "invalid human-readable ABI signature gas",
          "value",
          t
        ),
      (e.gas = dt.from(n[1])),
      n[0])
    : t;
}
function vj(t, e) {
  (e.constant = !1),
    (e.payable = !1),
    (e.stateMutability = "nonpayable"),
    t.split(" ").forEach((n) => {
      switch (n.trim()) {
        case "constant":
          e.constant = !0;
          break;
        case "payable":
          (e.payable = !0), (e.stateMutability = "payable");
          break;
        case "nonpayable":
          (e.payable = !1), (e.stateMutability = "nonpayable");
          break;
        case "pure":
          (e.constant = !0), (e.stateMutability = "pure");
          break;
        case "view":
          (e.constant = !0), (e.stateMutability = "view");
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + n);
      }
    });
}
function bj(t) {
  let e = { constant: !1, payable: !0, stateMutability: "payable" };
  return (
    t.stateMutability != null
      ? ((e.stateMutability = t.stateMutability),
        (e.constant =
          e.stateMutability === "view" || e.stateMutability === "pure"),
        t.constant != null &&
          !!t.constant !== e.constant &&
          Yn.throwArgumentError(
            "cannot have constant function with mutability " +
              e.stateMutability,
            "value",
            t
          ),
        (e.payable = e.stateMutability === "payable"),
        t.payable != null &&
          !!t.payable !== e.payable &&
          Yn.throwArgumentError(
            "cannot have payable function with mutability " + e.stateMutability,
            "value",
            t
          ))
      : t.payable != null
      ? ((e.payable = !!t.payable),
        t.constant == null &&
          !e.payable &&
          t.type !== "constructor" &&
          Yn.throwArgumentError(
            "unable to determine stateMutability",
            "value",
            t
          ),
        (e.constant = !!t.constant),
        e.constant
          ? (e.stateMutability = "view")
          : (e.stateMutability = e.payable ? "payable" : "nonpayable"),
        e.payable &&
          e.constant &&
          Yn.throwArgumentError(
            "cannot have constant payable function",
            "value",
            t
          ))
      : t.constant != null
      ? ((e.constant = !!t.constant),
        (e.payable = !e.constant),
        (e.stateMutability = e.constant ? "view" : "payable"))
      : t.type !== "constructor" &&
        Yn.throwArgumentError(
          "unable to determine stateMutability",
          "value",
          t
        ),
    e
  );
}
let o5 = class xp extends Dw {
    format(e) {
      if (
        (e || (e = lr.sighash),
        lr[e] || Yn.throwArgumentError("invalid format type", "format", e),
        e === lr.json)
      )
        return JSON.stringify({
          type: "constructor",
          stateMutability:
            this.stateMutability !== "nonpayable"
              ? this.stateMutability
              : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        });
      e === lr.sighash &&
        Yn.throwError(
          "cannot format a constructor for sighash",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "format(sighash)" }
        );
      let n =
        "constructor(" +
        this.inputs.map((r) => r.format(e)).join(e === lr.full ? ", " : ",") +
        ") ";
      return (
        this.stateMutability &&
          this.stateMutability !== "nonpayable" &&
          (n += this.stateMutability + " "),
        n.trim()
      );
    }
    static from(e) {
      return typeof e == "string" ? xp.fromString(e) : xp.fromObject(e);
    }
    static fromObject(e) {
      if (xp.isConstructorFragment(e)) return e;
      e.type !== "constructor" &&
        Yn.throwArgumentError("invalid constructor object", "value", e);
      let n = bj(e);
      n.constant &&
        Yn.throwArgumentError("constructor cannot be constant", "value", e);
      const r = {
        name: null,
        type: e.type,
        inputs: e.inputs ? e.inputs.map(Vu.fromObject) : [],
        payable: n.payable,
        stateMutability: n.stateMutability,
        gas: e.gas ? dt.from(e.gas) : null,
      };
      return new xp(yh, r);
    }
    static fromString(e) {
      let n = { type: "constructor" };
      e = yj(e, n);
      let r = e.match(Hg);
      return (
        (!r || r[1].trim() !== "constructor") &&
          Yn.throwArgumentError("invalid constructor string", "value", e),
        (n.inputs = Ug(r[2].trim(), !1)),
        vj(r[3].trim(), n),
        xp.fromObject(n)
      );
    }
    static isConstructorFragment(e) {
      return e && e._isFragment && e.type === "constructor";
    }
  },
  l5 = class Tp extends o5 {
    format(e) {
      if (
        (e || (e = lr.sighash),
        lr[e] || Yn.throwArgumentError("invalid format type", "format", e),
        e === lr.json)
      )
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability:
            this.stateMutability !== "nonpayable"
              ? this.stateMutability
              : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
          outputs: this.outputs.map((r) => JSON.parse(r.format(e))),
        });
      let n = "";
      return (
        e !== lr.sighash && (n += "function "),
        (n +=
          this.name +
          "(" +
          this.inputs.map((r) => r.format(e)).join(e === lr.full ? ", " : ",") +
          ") "),
        e !== lr.sighash &&
          (this.stateMutability
            ? this.stateMutability !== "nonpayable" &&
              (n += this.stateMutability + " ")
            : this.constant && (n += "view "),
          this.outputs &&
            this.outputs.length &&
            (n +=
              "returns (" +
              this.outputs.map((r) => r.format(e)).join(", ") +
              ") "),
          this.gas != null && (n += "@" + this.gas.toString() + " ")),
        n.trim()
      );
    }
    static from(e) {
      return typeof e == "string" ? Tp.fromString(e) : Tp.fromObject(e);
    }
    static fromObject(e) {
      if (Tp.isFunctionFragment(e)) return e;
      e.type !== "function" &&
        Yn.throwArgumentError("invalid function object", "value", e);
      let n = bj(e);
      const r = {
        type: e.type,
        name: jg(e.name),
        constant: n.constant,
        inputs: e.inputs ? e.inputs.map(Vu.fromObject) : [],
        outputs: e.outputs ? e.outputs.map(Vu.fromObject) : [],
        payable: n.payable,
        stateMutability: n.stateMutability,
        gas: e.gas ? dt.from(e.gas) : null,
      };
      return new Tp(yh, r);
    }
    static fromString(e) {
      let n = { type: "function" };
      e = yj(e, n);
      let r = e.split(" returns ");
      r.length > 2 &&
        Yn.throwArgumentError("invalid function string", "value", e);
      let i = r[0].match(Hg);
      if (
        (i || Yn.throwArgumentError("invalid function signature", "value", e),
        (n.name = i[1].trim()),
        n.name && jg(n.name),
        (n.inputs = Ug(i[2], !1)),
        vj(i[3].trim(), n),
        r.length > 1)
      ) {
        let s = r[1].match(Hg);
        (s[1].trim() != "" || s[3].trim() != "") &&
          Yn.throwArgumentError("unexpected tokens", "value", e),
          (n.outputs = Ug(s[2], !1));
      } else n.outputs = [];
      return Tp.fromObject(n);
    }
    static isFunctionFragment(e) {
      return e && e._isFragment && e.type === "function";
    }
  };
function VI(t) {
  const e = t.format();
  return (
    (e === "Error(string)" || e === "Panic(uint256)") &&
      Yn.throwArgumentError(
        `cannot specify user defined ${e} error`,
        "fragment",
        t
      ),
    t
  );
}
let GI = class Sp extends Dw {
  format(e) {
    if (
      (e || (e = lr.sighash),
      lr[e] || Yn.throwArgumentError("invalid format type", "format", e),
      e === lr.json)
    )
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    let n = "";
    return (
      e !== lr.sighash && (n += "error "),
      (n +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(e)).join(e === lr.full ? ", " : ",") +
        ") "),
      n.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? Sp.fromString(e) : Sp.fromObject(e);
  }
  static fromObject(e) {
    if (Sp.isErrorFragment(e)) return e;
    e.type !== "error" &&
      Yn.throwArgumentError("invalid error object", "value", e);
    const n = {
      type: e.type,
      name: jg(e.name),
      inputs: e.inputs ? e.inputs.map(Vu.fromObject) : [],
    };
    return VI(new Sp(yh, n));
  }
  static fromString(e) {
    let n = { type: "error" },
      r = e.match(Hg);
    return (
      r || Yn.throwArgumentError("invalid error signature", "value", e),
      (n.name = r[1].trim()),
      n.name && jg(n.name),
      (n.inputs = Ug(r[2], !1)),
      VI(Sp.fromObject(n))
    );
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
};
function Ap(t) {
  return (
    t.match(/^uint($|[^1-9])/)
      ? (t = "uint256" + t.substring(4))
      : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)),
    t
  );
}
const _le = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function jg(t) {
  return (
    (!t || !t.match(_le)) &&
      Yn.throwArgumentError(`invalid identifier "${t}"`, "value", t),
    t
  );
}
const Hg = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function Ele(t) {
  t = t.trim();
  let e = [],
    n = "",
    r = 0;
  for (let i = 0; i < t.length; i++) {
    let s = t[i];
    s === "," && r === 0
      ? (e.push(n), (n = ""))
      : ((n += s),
        s === "("
          ? r++
          : s === ")" &&
            (r--,
            r === -1 &&
              Yn.throwArgumentError("unbalanced parenthesis", "value", t)));
  }
  return n && e.push(n), e;
}
const U7 = new Se(Sy);
function xle(t) {
  const e = [],
    n = function (r, i) {
      if (Array.isArray(i))
        for (let s in i) {
          const a = r.slice();
          a.push(s);
          try {
            n(a, i[s]);
          } catch (o) {
            e.push({ path: a, error: o });
          }
        }
    };
  return n([], t), e;
}
let af = class {
    constructor(e, n, r, i) {
      (this.name = e),
        (this.type = n),
        (this.localName = r),
        (this.dynamic = i);
    }
    _throwError(e, n) {
      U7.throwArgumentError(e, this.localName, n);
    }
  },
  EE = class {
    constructor(e) {
      Je(this, "wordSize", e || 32),
        (this._data = []),
        (this._dataLength = 0),
        (this._padding = new Uint8Array(e));
    }
    get data() {
      return Ql(this._data);
    }
    get length() {
      return this._dataLength;
    }
    _writeData(e) {
      return this._data.push(e), (this._dataLength += e.length), e.length;
    }
    appendWriter(e) {
      return this._writeData(fl(e._data));
    }
    writeBytes(e) {
      let n = hn(e);
      const r = n.length % this.wordSize;
      return r && (n = fl([n, this._padding.slice(r)])), this._writeData(n);
    }
    _getValue(e) {
      let n = hn(dt.from(e));
      return (
        n.length > this.wordSize &&
          U7.throwError("value out-of-bounds", Se.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: n.length,
          }),
        n.length % this.wordSize &&
          (n = fl([this._padding.slice(n.length % this.wordSize), n])),
        n
      );
    }
    writeValue(e) {
      return this._writeData(this._getValue(e));
    }
    writeUpdatableValue() {
      const e = this._data.length;
      return (
        this._data.push(this._padding),
        (this._dataLength += this.wordSize),
        (n) => {
          this._data[e] = this._getValue(n);
        }
      );
    }
  },
  Tle = class xE {
    constructor(e, n, r, i) {
      Je(this, "_data", hn(e)),
        Je(this, "wordSize", n || 32),
        Je(this, "_coerceFunc", r),
        Je(this, "allowLoose", i),
        (this._offset = 0);
    }
    get data() {
      return Qt(this._data);
    }
    get consumed() {
      return this._offset;
    }
    static coerce(e, n) {
      let r = e.match("^u?int([0-9]+)$");
      return r && parseInt(r[1]) <= 48 && (n = n.toNumber()), n;
    }
    coerce(e, n) {
      return this._coerceFunc ? this._coerceFunc(e, n) : xE.coerce(e, n);
    }
    _peekBytes(e, n, r) {
      let i = Math.ceil(n / this.wordSize) * this.wordSize;
      return (
        this._offset + i > this._data.length &&
          (this.allowLoose && r && this._offset + n <= this._data.length
            ? (i = n)
            : U7.throwError("data out-of-bounds", Se.errors.BUFFER_OVERRUN, {
                length: this._data.length,
                offset: this._offset + i,
              })),
        this._data.slice(this._offset, this._offset + i)
      );
    }
    subReader(e) {
      return new xE(
        this._data.slice(this._offset + e),
        this.wordSize,
        this._coerceFunc,
        this.allowLoose
      );
    }
    readBytes(e, n) {
      let r = this._peekBytes(0, e, !!n);
      return (this._offset += r.length), r.slice(0, e);
    }
    readValue() {
      return dt.from(this.readBytes(this.wordSize));
    }
  };
var wj = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ (function (t) {
  (function () {
    var e = "input is invalid type",
      n = "finalize already called",
      r = typeof window == "object",
      i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == "object",
      a =
        !i.JS_SHA3_NO_NODE_JS &&
        typeof process == "object" &&
        process.versions &&
        process.versions.node;
    a ? (i = Ur) : s && (i = self);
    var o = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
      l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
      u = "0123456789abcdef".split(""),
      f = [31, 7936, 2031616, 520093696],
      c = [4, 1024, 262144, 67108864],
      d = [1, 256, 65536, 16777216],
      p = [6, 1536, 393216, 100663296],
      m = [0, 8, 16, 24],
      g = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
        2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136,
        0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
        2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648,
        32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896,
        2147483648, 2147483649, 0, 2147516424, 2147483648,
      ],
      w = [224, 256, 384, 512],
      y = [128, 256],
      v = ["hex", "buffer", "arrayBuffer", "array", "digest"],
      E = { 128: 168, 256: 136 };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (z) {
        return Object.prototype.toString.call(z) === "[object Array]";
      }),
      l &&
        (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (z) {
          return (
            typeof z == "object" &&
            z.buffer &&
            z.buffer.constructor === ArrayBuffer
          );
        });
    for (
      var S = function (z, se, Y) {
          return function (Q) {
            return new oe(z, se, z).update(Q)[Y]();
          };
        },
        D = function (z, se, Y) {
          return function (Q, ee) {
            return new oe(z, se, ee).update(Q)[Y]();
          };
        },
        P = function (z, se, Y) {
          return function (Q, ee, F, te) {
            return I["cshake" + z].update(Q, ee, F, te)[Y]();
          };
        },
        x = function (z, se, Y) {
          return function (Q, ee, F, te) {
            return I["kmac" + z].update(Q, ee, F, te)[Y]();
          };
        },
        _ = function (z, se, Y, Q) {
          for (var ee = 0; ee < v.length; ++ee) {
            var F = v[ee];
            z[F] = se(Y, Q, F);
          }
          return z;
        },
        A = function (z, se) {
          var Y = S(z, se, "hex");
          return (
            (Y.create = function () {
              return new oe(z, se, z);
            }),
            (Y.update = function (Q) {
              return Y.create().update(Q);
            }),
            _(Y, S, z, se)
          );
        },
        N = function (z, se) {
          var Y = D(z, se, "hex");
          return (
            (Y.create = function (Q) {
              return new oe(z, se, Q);
            }),
            (Y.update = function (Q, ee) {
              return Y.create(ee).update(Q);
            }),
            _(Y, D, z, se)
          );
        },
        M = function (z, se) {
          var Y = E[z],
            Q = P(z, se, "hex");
          return (
            (Q.create = function (ee, F, te) {
              return !F && !te
                ? I["shake" + z].create(ee)
                : new oe(z, se, ee).bytepad([F, te], Y);
            }),
            (Q.update = function (ee, F, te, he) {
              return Q.create(F, te, he).update(ee);
            }),
            _(Q, P, z, se)
          );
        },
        T = function (z, se) {
          var Y = E[z],
            Q = x(z, se, "hex");
          return (
            (Q.create = function (ee, F, te) {
              return new le(z, se, F).bytepad(["KMAC", te], Y).bytepad([ee], Y);
            }),
            (Q.update = function (ee, F, te, he) {
              return Q.create(ee, te, he).update(F);
            }),
            _(Q, x, z, se)
          );
        },
        O = [
          { name: "keccak", padding: d, bits: w, createMethod: A },
          { name: "sha3", padding: p, bits: w, createMethod: A },
          { name: "shake", padding: f, bits: y, createMethod: N },
          { name: "cshake", padding: c, bits: y, createMethod: M },
          { name: "kmac", padding: c, bits: y, createMethod: T },
        ],
        I = {},
        k = [],
        L = 0;
      L < O.length;
      ++L
    )
      for (var U = O[L], $ = U.bits, B = 0; B < $.length; ++B) {
        var R = U.name + "_" + $[B];
        if (
          (k.push(R),
          (I[R] = U.createMethod($[B], U.padding)),
          U.name !== "sha3")
        ) {
          var V = U.name + $[B];
          k.push(V), (I[V] = I[R]);
        }
      }
    function oe(z, se, Y) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = se),
        (this.outputBits = Y),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (z << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = Y >> 5),
        (this.extraBytes = (Y & 31) >> 3);
      for (var Q = 0; Q < 50; ++Q) this.s[Q] = 0;
    }
    (oe.prototype.update = function (z) {
      if (this.finalized) throw new Error(n);
      var se,
        Y = typeof z;
      if (Y !== "string") {
        if (Y === "object") {
          if (z === null) throw new Error(e);
          if (l && z.constructor === ArrayBuffer) z = new Uint8Array(z);
          else if (!Array.isArray(z) && (!l || !ArrayBuffer.isView(z)))
            throw new Error(e);
        } else throw new Error(e);
        se = !0;
      }
      for (
        var Q = this.blocks,
          ee = this.byteCount,
          F = z.length,
          te = this.blockCount,
          he = 0,
          Te = this.s,
          Ce,
          ke;
        he < F;

      ) {
        if (this.reset)
          for (this.reset = !1, Q[0] = this.block, Ce = 1; Ce < te + 1; ++Ce)
            Q[Ce] = 0;
        if (se)
          for (Ce = this.start; he < F && Ce < ee; ++he)
            Q[Ce >> 2] |= z[he] << m[Ce++ & 3];
        else
          for (Ce = this.start; he < F && Ce < ee; ++he)
            (ke = z.charCodeAt(he)),
              ke < 128
                ? (Q[Ce >> 2] |= ke << m[Ce++ & 3])
                : ke < 2048
                ? ((Q[Ce >> 2] |= (192 | (ke >> 6)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | (ke & 63)) << m[Ce++ & 3]))
                : ke < 55296 || ke >= 57344
                ? ((Q[Ce >> 2] |= (224 | (ke >> 12)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | ((ke >> 6) & 63)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | (ke & 63)) << m[Ce++ & 3]))
                : ((ke =
                    65536 +
                    (((ke & 1023) << 10) | (z.charCodeAt(++he) & 1023))),
                  (Q[Ce >> 2] |= (240 | (ke >> 18)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | ((ke >> 12) & 63)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | ((ke >> 6) & 63)) << m[Ce++ & 3]),
                  (Q[Ce >> 2] |= (128 | (ke & 63)) << m[Ce++ & 3]));
        if (((this.lastByteIndex = Ce), Ce >= ee)) {
          for (this.start = Ce - ee, this.block = Q[te], Ce = 0; Ce < te; ++Ce)
            Te[Ce] ^= Q[Ce];
          fe(Te), (this.reset = !0);
        } else this.start = Ce;
      }
      return this;
    }),
      (oe.prototype.encode = function (z, se) {
        var Y = z & 255,
          Q = 1,
          ee = [Y];
        for (z = z >> 8, Y = z & 255; Y > 0; )
          ee.unshift(Y), (z = z >> 8), (Y = z & 255), ++Q;
        return se ? ee.push(Q) : ee.unshift(Q), this.update(ee), ee.length;
      }),
      (oe.prototype.encodeString = function (z) {
        var se,
          Y = typeof z;
        if (Y !== "string") {
          if (Y === "object") {
            if (z === null) throw new Error(e);
            if (l && z.constructor === ArrayBuffer) z = new Uint8Array(z);
            else if (!Array.isArray(z) && (!l || !ArrayBuffer.isView(z)))
              throw new Error(e);
          } else throw new Error(e);
          se = !0;
        }
        var Q = 0,
          ee = z.length;
        if (se) Q = ee;
        else
          for (var F = 0; F < z.length; ++F) {
            var te = z.charCodeAt(F);
            te < 128
              ? (Q += 1)
              : te < 2048
              ? (Q += 2)
              : te < 55296 || te >= 57344
              ? (Q += 3)
              : ((te =
                  65536 + (((te & 1023) << 10) | (z.charCodeAt(++F) & 1023))),
                (Q += 4));
          }
        return (Q += this.encode(Q * 8)), this.update(z), Q;
      }),
      (oe.prototype.bytepad = function (z, se) {
        for (var Y = this.encode(se), Q = 0; Q < z.length; ++Q)
          Y += this.encodeString(z[Q]);
        var ee = se - (Y % se),
          F = [];
        return (F.length = ee), this.update(F), this;
      }),
      (oe.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var z = this.blocks,
            se = this.lastByteIndex,
            Y = this.blockCount,
            Q = this.s;
          if (
            ((z[se >> 2] |= this.padding[se & 3]),
            this.lastByteIndex === this.byteCount)
          )
            for (z[0] = z[Y], se = 1; se < Y + 1; ++se) z[se] = 0;
          for (z[Y - 1] |= 2147483648, se = 0; se < Y; ++se) Q[se] ^= z[se];
          fe(Q);
        }
      }),
      (oe.prototype.toString = oe.prototype.hex =
        function () {
          this.finalize();
          for (
            var z = this.blockCount,
              se = this.s,
              Y = this.outputBlocks,
              Q = this.extraBytes,
              ee = 0,
              F = 0,
              te = "",
              he;
            F < Y;

          ) {
            for (ee = 0; ee < z && F < Y; ++ee, ++F)
              (he = se[ee]),
                (te +=
                  u[(he >> 4) & 15] +
                  u[he & 15] +
                  u[(he >> 12) & 15] +
                  u[(he >> 8) & 15] +
                  u[(he >> 20) & 15] +
                  u[(he >> 16) & 15] +
                  u[(he >> 28) & 15] +
                  u[(he >> 24) & 15]);
            F % z === 0 && (fe(se), (ee = 0));
          }
          return (
            Q &&
              ((he = se[ee]),
              (te += u[(he >> 4) & 15] + u[he & 15]),
              Q > 1 && (te += u[(he >> 12) & 15] + u[(he >> 8) & 15]),
              Q > 2 && (te += u[(he >> 20) & 15] + u[(he >> 16) & 15])),
            te
          );
        }),
      (oe.prototype.arrayBuffer = function () {
        this.finalize();
        var z = this.blockCount,
          se = this.s,
          Y = this.outputBlocks,
          Q = this.extraBytes,
          ee = 0,
          F = 0,
          te = this.outputBits >> 3,
          he;
        Q ? (he = new ArrayBuffer((Y + 1) << 2)) : (he = new ArrayBuffer(te));
        for (var Te = new Uint32Array(he); F < Y; ) {
          for (ee = 0; ee < z && F < Y; ++ee, ++F) Te[F] = se[ee];
          F % z === 0 && fe(se);
        }
        return Q && ((Te[ee] = se[ee]), (he = he.slice(0, te))), he;
      }),
      (oe.prototype.buffer = oe.prototype.arrayBuffer),
      (oe.prototype.digest = oe.prototype.array =
        function () {
          this.finalize();
          for (
            var z = this.blockCount,
              se = this.s,
              Y = this.outputBlocks,
              Q = this.extraBytes,
              ee = 0,
              F = 0,
              te = [],
              he,
              Te;
            F < Y;

          ) {
            for (ee = 0; ee < z && F < Y; ++ee, ++F)
              (he = F << 2),
                (Te = se[ee]),
                (te[he] = Te & 255),
                (te[he + 1] = (Te >> 8) & 255),
                (te[he + 2] = (Te >> 16) & 255),
                (te[he + 3] = (Te >> 24) & 255);
            F % z === 0 && fe(se);
          }
          return (
            Q &&
              ((he = F << 2),
              (Te = se[ee]),
              (te[he] = Te & 255),
              Q > 1 && (te[he + 1] = (Te >> 8) & 255),
              Q > 2 && (te[he + 2] = (Te >> 16) & 255)),
            te
          );
        });
    function le(z, se, Y) {
      oe.call(this, z, se, Y);
    }
    (le.prototype = new oe()),
      (le.prototype.finalize = function () {
        return (
          this.encode(this.outputBits, !0), oe.prototype.finalize.call(this)
        );
      });
    var fe = function (z) {
      var se,
        Y,
        Q,
        ee,
        F,
        te,
        he,
        Te,
        Ce,
        ke,
        at,
        Rt,
        Ft,
        Nt,
        Ot,
        et,
        st,
        vt,
        Re,
        me,
        $e,
        De,
        je,
        lt,
        Ke,
        tt,
        jt,
        ct,
        rt,
        Dt,
        Ht,
        Yt,
        sr,
        Bt,
        en,
        Tr,
        on,
        Pt,
        fn,
        Wt,
        qt,
        Ye,
        xe,
        nt,
        gt,
        ht,
        wt,
        rn,
        ot,
        pt,
        zt,
        Zt,
        $t,
        Vr,
        $n,
        En,
        In,
        as,
        os,
        ls,
        us,
        Or,
        ar;
      for (Q = 0; Q < 48; Q += 2)
        (ee = z[0] ^ z[10] ^ z[20] ^ z[30] ^ z[40]),
          (F = z[1] ^ z[11] ^ z[21] ^ z[31] ^ z[41]),
          (te = z[2] ^ z[12] ^ z[22] ^ z[32] ^ z[42]),
          (he = z[3] ^ z[13] ^ z[23] ^ z[33] ^ z[43]),
          (Te = z[4] ^ z[14] ^ z[24] ^ z[34] ^ z[44]),
          (Ce = z[5] ^ z[15] ^ z[25] ^ z[35] ^ z[45]),
          (ke = z[6] ^ z[16] ^ z[26] ^ z[36] ^ z[46]),
          (at = z[7] ^ z[17] ^ z[27] ^ z[37] ^ z[47]),
          (Rt = z[8] ^ z[18] ^ z[28] ^ z[38] ^ z[48]),
          (Ft = z[9] ^ z[19] ^ z[29] ^ z[39] ^ z[49]),
          (se = Rt ^ ((te << 1) | (he >>> 31))),
          (Y = Ft ^ ((he << 1) | (te >>> 31))),
          (z[0] ^= se),
          (z[1] ^= Y),
          (z[10] ^= se),
          (z[11] ^= Y),
          (z[20] ^= se),
          (z[21] ^= Y),
          (z[30] ^= se),
          (z[31] ^= Y),
          (z[40] ^= se),
          (z[41] ^= Y),
          (se = ee ^ ((Te << 1) | (Ce >>> 31))),
          (Y = F ^ ((Ce << 1) | (Te >>> 31))),
          (z[2] ^= se),
          (z[3] ^= Y),
          (z[12] ^= se),
          (z[13] ^= Y),
          (z[22] ^= se),
          (z[23] ^= Y),
          (z[32] ^= se),
          (z[33] ^= Y),
          (z[42] ^= se),
          (z[43] ^= Y),
          (se = te ^ ((ke << 1) | (at >>> 31))),
          (Y = he ^ ((at << 1) | (ke >>> 31))),
          (z[4] ^= se),
          (z[5] ^= Y),
          (z[14] ^= se),
          (z[15] ^= Y),
          (z[24] ^= se),
          (z[25] ^= Y),
          (z[34] ^= se),
          (z[35] ^= Y),
          (z[44] ^= se),
          (z[45] ^= Y),
          (se = Te ^ ((Rt << 1) | (Ft >>> 31))),
          (Y = Ce ^ ((Ft << 1) | (Rt >>> 31))),
          (z[6] ^= se),
          (z[7] ^= Y),
          (z[16] ^= se),
          (z[17] ^= Y),
          (z[26] ^= se),
          (z[27] ^= Y),
          (z[36] ^= se),
          (z[37] ^= Y),
          (z[46] ^= se),
          (z[47] ^= Y),
          (se = ke ^ ((ee << 1) | (F >>> 31))),
          (Y = at ^ ((F << 1) | (ee >>> 31))),
          (z[8] ^= se),
          (z[9] ^= Y),
          (z[18] ^= se),
          (z[19] ^= Y),
          (z[28] ^= se),
          (z[29] ^= Y),
          (z[38] ^= se),
          (z[39] ^= Y),
          (z[48] ^= se),
          (z[49] ^= Y),
          (Nt = z[0]),
          (Ot = z[1]),
          (ht = (z[11] << 4) | (z[10] >>> 28)),
          (wt = (z[10] << 4) | (z[11] >>> 28)),
          (ct = (z[20] << 3) | (z[21] >>> 29)),
          (rt = (z[21] << 3) | (z[20] >>> 29)),
          (ls = (z[31] << 9) | (z[30] >>> 23)),
          (us = (z[30] << 9) | (z[31] >>> 23)),
          (Ye = (z[40] << 18) | (z[41] >>> 14)),
          (xe = (z[41] << 18) | (z[40] >>> 14)),
          (Bt = (z[2] << 1) | (z[3] >>> 31)),
          (en = (z[3] << 1) | (z[2] >>> 31)),
          (et = (z[13] << 12) | (z[12] >>> 20)),
          (st = (z[12] << 12) | (z[13] >>> 20)),
          (rn = (z[22] << 10) | (z[23] >>> 22)),
          (ot = (z[23] << 10) | (z[22] >>> 22)),
          (Dt = (z[33] << 13) | (z[32] >>> 19)),
          (Ht = (z[32] << 13) | (z[33] >>> 19)),
          (Or = (z[42] << 2) | (z[43] >>> 30)),
          (ar = (z[43] << 2) | (z[42] >>> 30)),
          (Vr = (z[5] << 30) | (z[4] >>> 2)),
          ($n = (z[4] << 30) | (z[5] >>> 2)),
          (Tr = (z[14] << 6) | (z[15] >>> 26)),
          (on = (z[15] << 6) | (z[14] >>> 26)),
          (vt = (z[25] << 11) | (z[24] >>> 21)),
          (Re = (z[24] << 11) | (z[25] >>> 21)),
          (pt = (z[34] << 15) | (z[35] >>> 17)),
          (zt = (z[35] << 15) | (z[34] >>> 17)),
          (Yt = (z[45] << 29) | (z[44] >>> 3)),
          (sr = (z[44] << 29) | (z[45] >>> 3)),
          (lt = (z[6] << 28) | (z[7] >>> 4)),
          (Ke = (z[7] << 28) | (z[6] >>> 4)),
          (En = (z[17] << 23) | (z[16] >>> 9)),
          (In = (z[16] << 23) | (z[17] >>> 9)),
          (Pt = (z[26] << 25) | (z[27] >>> 7)),
          (fn = (z[27] << 25) | (z[26] >>> 7)),
          (me = (z[36] << 21) | (z[37] >>> 11)),
          ($e = (z[37] << 21) | (z[36] >>> 11)),
          (Zt = (z[47] << 24) | (z[46] >>> 8)),
          ($t = (z[46] << 24) | (z[47] >>> 8)),
          (nt = (z[8] << 27) | (z[9] >>> 5)),
          (gt = (z[9] << 27) | (z[8] >>> 5)),
          (tt = (z[18] << 20) | (z[19] >>> 12)),
          (jt = (z[19] << 20) | (z[18] >>> 12)),
          (as = (z[29] << 7) | (z[28] >>> 25)),
          (os = (z[28] << 7) | (z[29] >>> 25)),
          (Wt = (z[38] << 8) | (z[39] >>> 24)),
          (qt = (z[39] << 8) | (z[38] >>> 24)),
          (De = (z[48] << 14) | (z[49] >>> 18)),
          (je = (z[49] << 14) | (z[48] >>> 18)),
          (z[0] = Nt ^ (~et & vt)),
          (z[1] = Ot ^ (~st & Re)),
          (z[10] = lt ^ (~tt & ct)),
          (z[11] = Ke ^ (~jt & rt)),
          (z[20] = Bt ^ (~Tr & Pt)),
          (z[21] = en ^ (~on & fn)),
          (z[30] = nt ^ (~ht & rn)),
          (z[31] = gt ^ (~wt & ot)),
          (z[40] = Vr ^ (~En & as)),
          (z[41] = $n ^ (~In & os)),
          (z[2] = et ^ (~vt & me)),
          (z[3] = st ^ (~Re & $e)),
          (z[12] = tt ^ (~ct & Dt)),
          (z[13] = jt ^ (~rt & Ht)),
          (z[22] = Tr ^ (~Pt & Wt)),
          (z[23] = on ^ (~fn & qt)),
          (z[32] = ht ^ (~rn & pt)),
          (z[33] = wt ^ (~ot & zt)),
          (z[42] = En ^ (~as & ls)),
          (z[43] = In ^ (~os & us)),
          (z[4] = vt ^ (~me & De)),
          (z[5] = Re ^ (~$e & je)),
          (z[14] = ct ^ (~Dt & Yt)),
          (z[15] = rt ^ (~Ht & sr)),
          (z[24] = Pt ^ (~Wt & Ye)),
          (z[25] = fn ^ (~qt & xe)),
          (z[34] = rn ^ (~pt & Zt)),
          (z[35] = ot ^ (~zt & $t)),
          (z[44] = as ^ (~ls & Or)),
          (z[45] = os ^ (~us & ar)),
          (z[6] = me ^ (~De & Nt)),
          (z[7] = $e ^ (~je & Ot)),
          (z[16] = Dt ^ (~Yt & lt)),
          (z[17] = Ht ^ (~sr & Ke)),
          (z[26] = Wt ^ (~Ye & Bt)),
          (z[27] = qt ^ (~xe & en)),
          (z[36] = pt ^ (~Zt & nt)),
          (z[37] = zt ^ (~$t & gt)),
          (z[46] = ls ^ (~Or & Vr)),
          (z[47] = us ^ (~ar & $n)),
          (z[8] = De ^ (~Nt & et)),
          (z[9] = je ^ (~Ot & st)),
          (z[18] = Yt ^ (~lt & tt)),
          (z[19] = sr ^ (~Ke & jt)),
          (z[28] = Ye ^ (~Bt & Tr)),
          (z[29] = xe ^ (~en & on)),
          (z[38] = Zt ^ (~nt & ht)),
          (z[39] = $t ^ (~gt & wt)),
          (z[48] = Or ^ (~Vr & En)),
          (z[49] = ar ^ (~$n & In)),
          (z[0] ^= g[Q]),
          (z[1] ^= g[Q + 1]);
    };
    if (o) t.exports = I;
    else for (L = 0; L < k.length; ++L) i[k[L]] = I[k[L]];
  })();
})(wj);
var Sle = wj.exports;
const Ale = oa(Sle);
function Ji(t) {
  return "0x" + Ale.keccak_256(hn(t));
}
const Cle = "rlp/5.5.0",
  Nu = new Se(Cle);
function WI(t) {
  const e = [];
  for (; t; ) e.unshift(t & 255), (t >>= 8);
  return e;
}
function qI(t, e, n) {
  let r = 0;
  for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
  return r;
}
function _j(t) {
  if (Array.isArray(t)) {
    let r = [];
    if (
      (t.forEach(function (s) {
        r = r.concat(_j(s));
      }),
      r.length <= 55)
    )
      return r.unshift(192 + r.length), r;
    const i = WI(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  F7(t) || Nu.throwArgumentError("RLP object must be BytesLike", "object", t);
  const e = Array.prototype.slice.call(hn(t));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  const n = WI(e.length);
  return n.unshift(183 + n.length), n.concat(e);
}
function Rw(t) {
  return Qt(_j(t));
}
function KI(t, e, n, r) {
  const i = [];
  for (; n < e + 1 + r; ) {
    const s = Ej(t, n);
    i.push(s.result),
      (n += s.consumed),
      n > e + 1 + r &&
        Nu.throwError("child data too short", Se.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + r, result: i };
}
function Ej(t, e) {
  if (
    (t.length === 0 &&
      Nu.throwError("data too short", Se.errors.BUFFER_OVERRUN, {}),
    t[e] >= 248)
  ) {
    const n = t[e] - 247;
    e + 1 + n > t.length &&
      Nu.throwError(
        "data short segment too short",
        Se.errors.BUFFER_OVERRUN,
        {}
      );
    const r = qI(t, e + 1, n);
    return (
      e + 1 + n + r > t.length &&
        Nu.throwError(
          "data long segment too short",
          Se.errors.BUFFER_OVERRUN,
          {}
        ),
      KI(t, e, e + 1 + n, n + r)
    );
  } else if (t[e] >= 192) {
    const n = t[e] - 192;
    return (
      e + 1 + n > t.length &&
        Nu.throwError("data array too short", Se.errors.BUFFER_OVERRUN, {}),
      KI(t, e, e + 1, n)
    );
  } else if (t[e] >= 184) {
    const n = t[e] - 183;
    e + 1 + n > t.length &&
      Nu.throwError("data array too short", Se.errors.BUFFER_OVERRUN, {});
    const r = qI(t, e + 1, n);
    e + 1 + n + r > t.length &&
      Nu.throwError("data array too short", Se.errors.BUFFER_OVERRUN, {});
    const i = Qt(t.slice(e + 1 + n, e + 1 + n + r));
    return { consumed: 1 + n + r, result: i };
  } else if (t[e] >= 128) {
    const n = t[e] - 128;
    e + 1 + n > t.length &&
      Nu.throwError("data too short", Se.errors.BUFFER_OVERRUN, {});
    const r = Qt(t.slice(e + 1, e + 1 + n));
    return { consumed: 1 + n, result: r };
  }
  return { consumed: 1, result: Qt(t[e]) };
}
function j7(t) {
  const e = hn(t),
    n = Ej(e, 0);
  return (
    n.consumed !== e.length &&
      Nu.throwArgumentError("invalid rlp data", "data", t),
    n.result
  );
}
const kle = "address/5.5.0",
  Gp = new Se(kle);
function XI(t) {
  cr(t, 20) || Gp.throwArgumentError("invalid address", "address", t),
    (t = t.toLowerCase());
  const e = t.substring(2).split(""),
    n = new Uint8Array(40);
  for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
  const r = hn(Ji(n));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
      (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const Ile = 9007199254740991;
function Ole(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const H7 = {};
for (let t = 0; t < 10; t++) H7[String(t)] = String(t);
for (let t = 0; t < 26; t++) H7[String.fromCharCode(65 + t)] = String(10 + t);
const ZI = Math.floor(Ole(Ile));
function Ple(t) {
  (t = t.toUpperCase()), (t = t.substring(4) + t.substring(0, 2) + "00");
  let e = t
    .split("")
    .map((r) => H7[r])
    .join("");
  for (; e.length >= ZI; ) {
    let r = e.substring(0, ZI);
    e = (parseInt(r, 10) % 97) + e.substring(r.length);
  }
  let n = String(98 - (parseInt(e, 10) % 97));
  for (; n.length < 2; ) n = "0" + n;
  return n;
}
function As(t) {
  let e = null;
  if (
    (typeof t != "string" &&
      Gp.throwArgumentError("invalid address", "address", t),
    t.match(/^(0x)?[0-9a-fA-F]{40}$/))
  )
    t.substring(0, 2) !== "0x" && (t = "0x" + t),
      (e = XI(t)),
      t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) &&
        e !== t &&
        Gp.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (
      t.substring(2, 4) !== Ple(t) &&
        Gp.throwArgumentError("bad icap checksum", "address", t),
        e = dle(t.substring(4));
      e.length < 40;

    )
      e = "0" + e;
    e = XI("0x" + e);
  } else Gp.throwArgumentError("invalid address", "address", t);
  return e;
}
function Nle(t) {
  try {
    return As(t), !0;
  } catch {}
  return !1;
}
function xj(t) {
  let e = null;
  try {
    e = As(t.from);
  } catch {
    Gp.throwArgumentError("missing from address", "transaction", t);
  }
  const n = F0(hn(dt.from(t.nonce).toHexString()));
  return As(jc(Ji(Rw([e, n])), 12));
}
let Dle = class extends af {
    constructor(e) {
      super("address", "address", e, !1);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(e, n) {
      try {
        n = As(n);
      } catch (r) {
        this._throwError(r.message, n);
      }
      return e.writeValue(n);
    }
    decode(e) {
      return As(Ni(e.readValue().toHexString(), 20));
    }
  },
  Rle = class extends af {
    constructor(e) {
      super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(e, n) {
      return this.coder.encode(e, n);
    }
    decode(e) {
      return this.coder.decode(e);
    }
  };
const Wp = new Se(Sy);
function Tj(t, e, n) {
  let r = null;
  if (Array.isArray(n)) r = n;
  else if (n && typeof n == "object") {
    let l = {};
    r = e.map((u) => {
      const f = u.localName;
      return (
        f ||
          Wp.throwError(
            "cannot encode object for signature with missing names",
            Se.errors.INVALID_ARGUMENT,
            { argument: "values", coder: u, value: n }
          ),
        l[f] &&
          Wp.throwError(
            "cannot encode object for signature with duplicate names",
            Se.errors.INVALID_ARGUMENT,
            { argument: "values", coder: u, value: n }
          ),
        (l[f] = !0),
        n[f]
      );
    });
  } else Wp.throwArgumentError("invalid tuple value", "tuple", n);
  e.length !== r.length &&
    Wp.throwArgumentError("types/value length mismatch", "tuple", n);
  let i = new EE(t.wordSize),
    s = new EE(t.wordSize),
    a = [];
  e.forEach((l, u) => {
    let f = r[u];
    if (l.dynamic) {
      let c = s.length;
      l.encode(s, f);
      let d = i.writeUpdatableValue();
      a.push((p) => {
        d(p + c);
      });
    } else l.encode(i, f);
  }),
    a.forEach((l) => {
      l(i.length);
    });
  let o = t.appendWriter(i);
  return (o += t.appendWriter(s)), o;
}
function Sj(t, e) {
  let n = [],
    r = t.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = t.readValue(),
        l = r.subReader(o.toNumber());
      try {
        a = s.decode(l);
      } catch (u) {
        if (u.code === Se.errors.BUFFER_OVERRUN) throw u;
        (a = u),
          (a.baseType = s.name),
          (a.name = s.localName),
          (a.type = s.type);
      }
    } else
      try {
        a = s.decode(t);
      } catch (o) {
        if (o.code === Se.errors.BUFFER_OVERRUN) throw o;
        (a = o),
          (a.baseType = s.name),
          (a.name = s.localName),
          (a.type = s.type);
      }
    a != null && n.push(a);
  });
  const i = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || i[o] !== 1 || (o === "length" && (o = "_length"), n[o] != null))
      return;
    const l = n[a];
    l instanceof Error
      ? Object.defineProperty(n, o, {
          enumerable: !0,
          get: () => {
            throw l;
          },
        })
      : (n[o] = l);
  });
  for (let s = 0; s < n.length; s++) {
    const a = n[s];
    a instanceof Error &&
      Object.defineProperty(n, s, {
        enumerable: !0,
        get: () => {
          throw a;
        },
      });
  }
  return Object.freeze(n);
}
let Mle = class extends af {
    constructor(e, n, r) {
      const i = e.type + "[" + (n >= 0 ? n : "") + "]",
        s = n === -1 || e.dynamic;
      super("array", i, r, s), (this.coder = e), (this.length = n);
    }
    defaultValue() {
      const e = this.coder.defaultValue(),
        n = [];
      for (let r = 0; r < this.length; r++) n.push(e);
      return n;
    }
    encode(e, n) {
      Array.isArray(n) || this._throwError("expected array value", n);
      let r = this.length;
      r === -1 && ((r = n.length), e.writeValue(n.length)),
        Wp.checkArgumentCount(
          n.length,
          r,
          "coder array" + (this.localName ? " " + this.localName : "")
        );
      let i = [];
      for (let s = 0; s < n.length; s++) i.push(this.coder);
      return Tj(e, i, n);
    }
    decode(e) {
      let n = this.length;
      n === -1 &&
        ((n = e.readValue().toNumber()),
        n * 32 > e._data.length &&
          Wp.throwError("insufficient data length", Se.errors.BUFFER_OVERRUN, {
            length: e._data.length,
            count: n,
          }));
      let r = [];
      for (let i = 0; i < n; i++) r.push(new Rle(this.coder));
      return e.coerce(this.name, Sj(e, r));
    }
  },
  Lle = class extends af {
    constructor(e) {
      super("bool", "bool", e, !1);
    }
    defaultValue() {
      return !1;
    }
    encode(e, n) {
      return e.writeValue(n ? 1 : 0);
    }
    decode(e) {
      return e.coerce(this.type, !e.readValue().isZero());
    }
  },
  Aj = class extends af {
    constructor(e, n) {
      super(e, e, n, !0);
    }
    defaultValue() {
      return "0x";
    }
    encode(e, n) {
      n = hn(n);
      let r = e.writeValue(n.length);
      return (r += e.writeBytes(n)), r;
    }
    decode(e) {
      return e.readBytes(e.readValue().toNumber(), !0);
    }
  },
  Ble = class extends Aj {
    constructor(e) {
      super("bytes", e);
    }
    decode(e) {
      return e.coerce(this.name, Qt(super.decode(e)));
    }
  },
  Fle = class extends af {
    constructor(e, n) {
      let r = "bytes" + String(e);
      super(r, r, n, !1), (this.size = e);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
        0,
        2 + this.size * 2
      );
    }
    encode(e, n) {
      let r = hn(n);
      return (
        r.length !== this.size && this._throwError("incorrect data length", n),
        e.writeBytes(r)
      );
    }
    decode(e) {
      return e.coerce(this.name, Qt(e.readBytes(this.size)));
    }
  },
  $le = class extends af {
    constructor(e) {
      super("null", "", e, !1);
    }
    defaultValue() {
      return null;
    }
    encode(e, n) {
      return n != null && this._throwError("not null", n), e.writeBytes([]);
    }
    decode(e) {
      return e.readBytes(0), e.coerce(this.name, null);
    }
  };
const Ule = "0x0000000000000000000000000000000000000000",
  jle = dt.from(-1),
  Cj = dt.from(0),
  Hle = dt.from(1),
  zle = dt.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  Vle = "0x0000000000000000000000000000000000000000000000000000000000000000";
let Gle = class extends af {
  constructor(e, n, r) {
    const i = (n ? "int" : "uint") + e * 8;
    super(i, i, r, !1), (this.size = e), (this.signed = n);
  }
  defaultValue() {
    return 0;
  }
  encode(e, n) {
    let r = dt.from(n),
      i = zle.mask(e.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(Hle).mul(jle))) &&
        this._throwError("value out-of-bounds", n);
    } else
      (r.lt(Cj) || r.gt(i.mask(this.size * 8))) &&
        this._throwError("value out-of-bounds", n);
    return (
      (r = r.toTwos(this.size * 8).mask(this.size * 8)),
      this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
      e.writeValue(r)
    );
  }
  decode(e) {
    let n = e.readValue().mask(this.size * 8);
    return (
      this.signed && (n = n.fromTwos(this.size * 8)), e.coerce(this.name, n)
    );
  }
};
const Wle = "strings/5.5.0",
  kj = new Se(Wle);
var $0;
(function (t) {
  (t.current = ""),
    (t.NFC = "NFC"),
    (t.NFD = "NFD"),
    (t.NFKC = "NFKC"),
    (t.NFKD = "NFKD");
})($0 || ($0 = {}));
var Ao;
(function (t) {
  (t.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
    (t.BAD_PREFIX = "bad codepoint prefix"),
    (t.OVERRUN = "string overrun"),
    (t.MISSING_CONTINUE = "missing continuation byte"),
    (t.OUT_OF_RANGE = "out of UTF-8 range"),
    (t.UTF16_SURROGATE = "UTF-16 surrogate"),
    (t.OVERLONG = "overlong representation");
})(Ao || (Ao = {}));
function qle(t, e, n, r, i) {
  return kj.throwArgumentError(
    `invalid codepoint at offset ${e}; ${t}`,
    "bytes",
    n
  );
}
function Ij(t, e, n, r, i) {
  if (t === Ao.BAD_PREFIX || t === Ao.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < n.length && n[a] >> 6 === 2; a++) s++;
    return s;
  }
  return t === Ao.OVERRUN ? n.length - e - 1 : 0;
}
function Kle(t, e, n, r, i) {
  return t === Ao.OVERLONG ? (r.push(i), 0) : (r.push(65533), Ij(t, e, n));
}
const Xle = Object.freeze({ error: qle, ignore: Ij, replace: Kle });
function Oj(t, e) {
  e == null && (e = Xle.error), (t = hn(t));
  const n = [];
  let r = 0;
  for (; r < t.length; ) {
    const i = t[r++];
    if (!(i >> 7)) {
      n.push(i);
      continue;
    }
    let s = null,
      a = null;
    if ((i & 224) === 192) (s = 1), (a = 127);
    else if ((i & 240) === 224) (s = 2), (a = 2047);
    else if ((i & 248) === 240) (s = 3), (a = 65535);
    else {
      (i & 192) === 128
        ? (r += e(Ao.UNEXPECTED_CONTINUE, r - 1, t, n))
        : (r += e(Ao.BAD_PREFIX, r - 1, t, n));
      continue;
    }
    if (r - 1 + s >= t.length) {
      r += e(Ao.OVERRUN, r - 1, t, n);
      continue;
    }
    let o = i & ((1 << (8 - s - 1)) - 1);
    for (let l = 0; l < s; l++) {
      let u = t[r];
      if ((u & 192) != 128) {
        (r += e(Ao.MISSING_CONTINUE, r, t, n)), (o = null);
        break;
      }
      (o = (o << 6) | (u & 63)), r++;
    }
    if (o !== null) {
      if (o > 1114111) {
        r += e(Ao.OUT_OF_RANGE, r - 1 - s, t, n, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        r += e(Ao.UTF16_SURROGATE, r - 1 - s, t, n, o);
        continue;
      }
      if (o <= a) {
        r += e(Ao.OVERLONG, r - 1 - s, t, n, o);
        continue;
      }
      n.push(o);
    }
  }
  return n;
}
function Yc(t, e = $0.current) {
  e != $0.current && (kj.checkNormalize(), (t = t.normalize(e)));
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const i = t.charCodeAt(r);
    if (i < 128) n.push(i);
    else if (i < 2048) n.push((i >> 6) | 192), n.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = t.charCodeAt(r);
      if (r >= t.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      n.push((a >> 18) | 240),
        n.push(((a >> 12) & 63) | 128),
        n.push(((a >> 6) & 63) | 128),
        n.push((a & 63) | 128);
    } else
      n.push((i >> 12) | 224),
        n.push(((i >> 6) & 63) | 128),
        n.push((i & 63) | 128);
  }
  return hn(n);
}
function TE(t) {
  return t
    .map((e) =>
      e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536),
          String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))
    )
    .join("");
}
function p1(t, e) {
  return TE(Oj(t, e));
}
function YI(t, e = $0.current) {
  return Oj(Yc(t, e));
}
function Zle(t) {
  if (t.length % 4 !== 0) throw new Error("bad data");
  let e = [];
  for (let n = 0; n < t.length; n += 4)
    e.push(parseInt(t.substring(n, n + 4), 16));
  return e;
}
function z7(t, e) {
  e ||
    (e = function (i) {
      return [parseInt(i, 16)];
    });
  let n = 0,
    r = {};
  return (
    t.split(",").forEach((i) => {
      let s = i.split(":");
      (n += parseInt(s[0], 16)), (r[n] = e(s[1]));
    }),
    r
  );
}
function Pj(t) {
  let e = 0;
  return t.split(",").map((n) => {
    let r = n.split("-");
    r.length === 1 ? (r[1] = "0") : r[1] === "" && (r[1] = "1");
    let i = e + parseInt(r[0], 16);
    return (e = parseInt(r[1], 16)), { l: i, h: e };
  });
}
function V7(t, e) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    if (((n += i.l), t >= n && t <= n + i.h && (t - n) % (i.d || 1) === 0)) {
      if (i.e && i.e.indexOf(t - n) !== -1) continue;
      return i;
    }
  }
  return null;
}
const Yle = Pj(
    "221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"
  ),
  Qle = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff"
    .split(",")
    .map((t) => parseInt(t, 16)),
  Jle = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 },
  ],
  eue = z7(
    "b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"
  ),
  tue = z7(
    "179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"
  ),
  nue = z7(
    "df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D",
    Zle
  ),
  rue = Pj(
    "80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001"
  );
function iue(t) {
  return t.reduce(
    (e, n) => (
      n.forEach((r) => {
        e.push(r);
      }),
      e
    ),
    []
  );
}
function sue(t) {
  return !!V7(t, Yle);
}
function aue(t) {
  let e = V7(t, Jle);
  if (e) return [t + e.s];
  let n = eue[t];
  if (n) return n;
  let r = tue[t];
  if (r) return [t + r[0]];
  let i = nue[t];
  return i || null;
}
function oue(t) {
  return !!V7(t, rue);
}
function lue(t) {
  if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase();
  let e = YI(t);
  (e = iue(
    e.map((r) => {
      if (Qle.indexOf(r) >= 0) return [];
      if (r >= 65024 && r <= 65039) return [];
      let i = aue(r);
      return i || [r];
    })
  )),
    (e = YI(TE(e), $0.NFKC)),
    e.forEach((r) => {
      if (oue(r)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }),
    e.forEach((r) => {
      if (sue(r)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    });
  let n = TE(e);
  if (
    n.substring(0, 1) === "-" ||
    n.substring(2, 4) === "--" ||
    n.substring(n.length - 1) === "-"
  )
    throw new Error("invalid hyphen");
  if (n.length > 63) throw new Error("too long");
  return n;
}
let uue = class extends Aj {
    constructor(e) {
      super("string", e);
    }
    defaultValue() {
      return "";
    }
    encode(e, n) {
      return super.encode(e, Yc(n));
    }
    decode(e) {
      return p1(super.decode(e));
    }
  },
  sv = class extends af {
    constructor(e, n) {
      let r = !1;
      const i = [];
      e.forEach((a) => {
        a.dynamic && (r = !0), i.push(a.type);
      });
      const s = "tuple(" + i.join(",") + ")";
      super("tuple", s, n, r), (this.coders = e);
    }
    defaultValue() {
      const e = [];
      this.coders.forEach((r) => {
        e.push(r.defaultValue());
      });
      const n = this.coders.reduce((r, i) => {
        const s = i.localName;
        return s && (r[s] || (r[s] = 0), r[s]++), r;
      }, {});
      return (
        this.coders.forEach((r, i) => {
          let s = r.localName;
          !s ||
            n[s] !== 1 ||
            (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
        }),
        Object.freeze(e)
      );
    }
    encode(e, n) {
      return Tj(e, this.coders, n);
    }
    decode(e) {
      return e.coerce(this.name, Sj(e, this.coders));
    }
  };
const lm = new Se(Sy),
  cue = new RegExp(/^bytes([0-9]*)$/),
  fue = new RegExp(/^(u?int)([0-9]*)$/);
let due = class Nj {
  constructor(e) {
    lm.checkNew(new.target, Nj), Je(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new Dle(e.name);
      case "bool":
        return new Lle(e.name);
      case "string":
        return new uue(e.name);
      case "bytes":
        return new Ble(e.name);
      case "array":
        return new Mle(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new sv(
          (e.components || []).map((r) => this._getCoder(r)),
          e.name
        );
      case "":
        return new $le(e.name);
    }
    let n = e.type.match(fue);
    if (n) {
      let r = parseInt(n[2] || "256");
      return (
        (r === 0 || r > 256 || r % 8 !== 0) &&
          lm.throwArgumentError("invalid " + n[1] + " bit length", "param", e),
        new Gle(r / 8, n[1] === "int", e.name)
      );
    }
    if (((n = e.type.match(cue)), n)) {
      let r = parseInt(n[1]);
      return (
        (r === 0 || r > 32) &&
          lm.throwArgumentError("invalid bytes length", "param", e),
        new Fle(r, e.name)
      );
    }
    return lm.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, n) {
    return new Tle(e, this._getWordSize(), this.coerceFunc, n);
  }
  _getWriter() {
    return new EE(this._getWordSize());
  }
  getDefaultValue(e) {
    const n = e.map((i) => this._getCoder(Vu.from(i)));
    return new sv(n, "_").defaultValue();
  }
  encode(e, n) {
    e.length !== n.length &&
      lm.throwError(
        "types/values length mismatch",
        Se.errors.INVALID_ARGUMENT,
        {
          count: { types: e.length, values: n.length },
          value: { types: e, values: n },
        }
      );
    const r = e.map((a) => this._getCoder(Vu.from(a))),
      i = new sv(r, "_"),
      s = this._getWriter();
    return i.encode(s, n), s.data;
  }
  decode(e, n, r) {
    const i = e.map((a) => this._getCoder(Vu.from(a)));
    return new sv(i, "_").decode(this._getReader(hn(n), r));
  }
};
const hue = new due();
function qp(t) {
  return Ji(Yc(t));
}
const Dj = "hash/5.5.0",
  QI = new Se(Dj),
  Rj = new Uint8Array(32);
Rj.fill(0);
const pue = new RegExp("^((.*)\\.)?([^.]+)$");
function u5(t) {
  typeof t != "string" &&
    QI.throwArgumentError("invalid ENS name; not a string", "name", t);
  let e = t,
    n = Rj;
  for (; e.length; ) {
    const r = e.match(pue);
    (r == null || r[2] === "") &&
      QI.throwArgumentError(
        "invalid ENS address; missing component",
        "name",
        t
      );
    const i = Yc(lue(r[3]));
    (n = Ji(fl([n, Ji(i)]))), (e = r[2] || "");
  }
  return Qt(n);
}
var mue =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const ni = new Se(Dj),
  Mj = new Uint8Array(32);
Mj.fill(0);
const gue = dt.from(-1),
  Lj = dt.from(0),
  Bj = dt.from(1),
  yue = dt.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function vue(t) {
  const e = hn(t),
    n = e.length % 32;
  return n ? Ql([e, Mj.slice(n)]) : Qt(e);
}
const bue = Ni(Bj.toHexString(), 32),
  wue = Ni(Lj.toHexString(), 32),
  JI = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  F_ = ["name", "version", "chainId", "verifyingContract", "salt"];
function eO(t) {
  return function (e) {
    return (
      typeof e != "string" &&
        ni.throwArgumentError(
          `invalid domain value for ${JSON.stringify(t)}`,
          `domain.${t}`,
          e
        ),
      e
    );
  };
}
const _ue = {
  name: eO("name"),
  version: eO("version"),
  chainId: function (t) {
    try {
      return dt.from(t).toString();
    } catch {}
    return ni.throwArgumentError(
      'invalid domain value for "chainId"',
      "domain.chainId",
      t
    );
  },
  verifyingContract: function (t) {
    try {
      return As(t).toLowerCase();
    } catch {}
    return ni.throwArgumentError(
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      t
    );
  },
  salt: function (t) {
    try {
      const e = hn(t);
      if (e.length !== 32) throw new Error("bad length");
      return Qt(e);
    } catch {}
    return ni.throwArgumentError(
      'invalid domain value "salt"',
      "domain.salt",
      t
    );
  },
};
function $_(t) {
  {
    const e = t.match(/^(u?)int(\d*)$/);
    if (e) {
      const n = e[1] === "",
        r = parseInt(e[2] || "256");
      (r % 8 !== 0 || r > 256 || (e[2] && e[2] !== String(r))) &&
        ni.throwArgumentError("invalid numeric width", "type", t);
      const i = yue.mask(n ? r - 1 : r),
        s = n ? i.add(Bj).mul(gue) : Lj;
      return function (a) {
        const o = dt.from(a);
        return (
          (o.lt(s) || o.gt(i)) &&
            ni.throwArgumentError(`value out-of-bounds for ${t}`, "value", a),
          Ni(o.toTwos(256).toHexString(), 32)
        );
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const n = parseInt(e[1]);
      return (
        (n === 0 || n > 32 || e[1] !== String(n)) &&
          ni.throwArgumentError("invalid bytes width", "type", t),
        function (r) {
          return (
            hn(r).length !== n &&
              ni.throwArgumentError(`invalid length for ${t}`, "value", r),
            vue(r)
          );
        }
      );
    }
  }
  switch (t) {
    case "address":
      return function (e) {
        return Ni(As(e), 32);
      };
    case "bool":
      return function (e) {
        return e ? bue : wue;
      };
    case "bytes":
      return function (e) {
        return Ji(e);
      };
    case "string":
      return function (e) {
        return qp(e);
      };
  }
  return null;
}
function tO(t, e) {
  return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
let nO = class $l {
  constructor(e) {
    Je(this, "types", Object.freeze(Zc(e))),
      Je(this, "_encoderCache", {}),
      Je(this, "_types", {});
    const n = {},
      r = {},
      i = {};
    Object.keys(e).forEach((o) => {
      (n[o] = {}), (r[o] = []), (i[o] = {});
    });
    for (const o in e) {
      const l = {};
      e[o].forEach((u) => {
        l[u.name] &&
          ni.throwArgumentError(
            `duplicate variable name ${JSON.stringify(
              u.name
            )} in ${JSON.stringify(o)}`,
            "types",
            e
          ),
          (l[u.name] = !0);
        const f = u.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        f === o &&
          ni.throwArgumentError(
            `circular type reference to ${JSON.stringify(f)}`,
            "types",
            e
          ),
          !$_(f) &&
            (r[f] ||
              ni.throwArgumentError(
                `unknown type ${JSON.stringify(f)}`,
                "types",
                e
              ),
            r[f].push(o),
            (n[o][f] = !0));
      });
    }
    const s = Object.keys(r).filter((o) => r[o].length === 0);
    s.length === 0
      ? ni.throwArgumentError("missing primary type", "types", e)
      : s.length > 1 &&
        ni.throwArgumentError(
          `ambiguous primary types or unused types: ${s
            .map((o) => JSON.stringify(o))
            .join(", ")}`,
          "types",
          e
        ),
      Je(this, "primaryType", s[0]);
    function a(o, l) {
      l[o] &&
        ni.throwArgumentError(
          `circular type reference to ${JSON.stringify(o)}`,
          "types",
          e
        ),
        (l[o] = !0),
        Object.keys(n[o]).forEach((u) => {
          r[u] &&
            (a(u, l),
            Object.keys(l).forEach((f) => {
              i[f][u] = !0;
            }));
        }),
        delete l[o];
    }
    a(this.primaryType, {});
    for (const o in i) {
      const l = Object.keys(i[o]);
      l.sort(),
        (this._types[o] = tO(o, e[o]) + l.map((u) => tO(u, e[u])).join(""));
    }
  }
  getEncoder(e) {
    let n = this._encoderCache[e];
    return n || (n = this._encoderCache[e] = this._getEncoder(e)), n;
  }
  _getEncoder(e) {
    {
      const i = $_(e);
      if (i) return i;
    }
    const n = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (n) {
      const i = n[1],
        s = this.getEncoder(i),
        a = parseInt(n[3]);
      return (o) => {
        a >= 0 &&
          o.length !== a &&
          ni.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            o
          );
        let l = o.map(s);
        return this._types[i] && (l = l.map(Ji)), Ji(Ql(l));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = qp(this._types[e]);
      return (s) => {
        const a = r.map(({ name: o, type: l }) => {
          const u = this.getEncoder(l)(s[o]);
          return this._types[l] ? Ji(u) : u;
        });
        return a.unshift(i), Ql(a);
      };
    }
    return ni.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const n = this._types[e];
    return (
      n ||
        ni.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e),
      n
    );
  }
  encodeData(e, n) {
    return this.getEncoder(e)(n);
  }
  hashStruct(e, n) {
    return Ji(this.encodeData(e, n));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, n, r) {
    if ($_(e)) return r(e, n);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const a = i[1],
        o = parseInt(i[3]);
      return (
        o >= 0 &&
          n.length !== o &&
          ni.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            n
          ),
        n.map((l) => this._visit(a, l, r))
      );
    }
    const s = this.types[e];
    return s
      ? s.reduce(
          (a, { name: o, type: l }) => ((a[o] = this._visit(l, n[o], r)), a),
          {}
        )
      : ni.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, n) {
    return this._visit(this.primaryType, e, n);
  }
  static from(e) {
    return new $l(e);
  }
  static getPrimaryType(e) {
    return $l.from(e).primaryType;
  }
  static hashStruct(e, n, r) {
    return $l.from(n).hashStruct(e, r);
  }
  static hashDomain(e) {
    const n = [];
    for (const r in e) {
      const i = JI[r];
      i ||
        ni.throwArgumentError(
          `invalid typed-data domain key: ${JSON.stringify(r)}`,
          "domain",
          e
        ),
        n.push({ name: r, type: i });
    }
    return (
      n.sort((r, i) => F_.indexOf(r.name) - F_.indexOf(i.name)),
      $l.hashStruct("EIP712Domain", { EIP712Domain: n }, e)
    );
  }
  static encode(e, n, r) {
    return Ql(["0x1901", $l.hashDomain(e), $l.from(n).hash(r)]);
  }
  static hash(e, n, r) {
    return Ji($l.encode(e, n, r));
  }
  static resolveNames(e, n, r, i) {
    return mue(this, void 0, void 0, function* () {
      e = xs(e);
      const s = {};
      e.verifyingContract &&
        !cr(e.verifyingContract, 20) &&
        (s[e.verifyingContract] = "0x");
      const a = $l.from(n);
      a.visit(r, (o, l) => (o === "address" && !cr(l, 20) && (s[l] = "0x"), l));
      for (const o in s) s[o] = yield i(o);
      return (
        e.verifyingContract &&
          s[e.verifyingContract] &&
          (e.verifyingContract = s[e.verifyingContract]),
        (r = a.visit(r, (o, l) => (o === "address" && s[l] ? s[l] : l))),
        { domain: e, value: r }
      );
    });
  }
  static getPayload(e, n, r) {
    $l.hashDomain(e);
    const i = {},
      s = [];
    F_.forEach((l) => {
      const u = e[l];
      u != null && ((i[l] = _ue[l](u)), s.push({ name: l, type: JI[l] }));
    });
    const a = $l.from(n),
      o = xs(n);
    return (
      o.EIP712Domain
        ? ni.throwArgumentError(
            "types must not contain EIP712Domain type",
            "types.EIP712Domain",
            n
          )
        : (o.EIP712Domain = s),
      a.encode(r),
      {
        types: o,
        domain: i,
        primaryType: a.primaryType,
        message: a.visit(r, (l, u) => {
          if (l.match(/^bytes(\d*)/)) return Qt(hn(u));
          if (l.match(/^u?int/)) return dt.from(u).toString();
          switch (l) {
            case "address":
              return u.toLowerCase();
            case "bool":
              return !!u;
            case "string":
              return (
                typeof u != "string" &&
                  ni.throwArgumentError("invalid string", "value", u),
                u
              );
          }
          return ni.throwArgumentError("unsupported type", "type", l);
        }),
      }
    );
  }
};
const Wr = new Se(Sy);
let Eue = class extends Ty {},
  xue = class extends Ty {},
  Tue = class extends Ty {},
  SE = class extends Ty {
    static isIndexed(e) {
      return !!(e && e._isIndexed);
    }
  };
const Sue = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: !0,
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
  },
};
function rO(t, e) {
  const n = new Error(
    `deferred error during ABI decoding triggered accessing ${t}`
  );
  return (n.error = e), n;
}
let iO = class Fj {
  constructor(e) {
    Wr.checkNew(new.target, Fj);
    let n = [];
    typeof e == "string" ? (n = JSON.parse(e)) : (n = e),
      Je(
        this,
        "fragments",
        n.map((r) => Dw.from(r)).filter((r) => r != null)
      ),
      Je(this, "_abiCoder", $u(new.target, "getAbiCoder")()),
      Je(this, "functions", {}),
      Je(this, "errors", {}),
      Je(this, "events", {}),
      Je(this, "structs", {}),
      this.fragments.forEach((r) => {
        let i = null;
        switch (r.type) {
          case "constructor":
            if (this.deploy) {
              Wr.warn("duplicate definition - constructor");
              return;
            }
            Je(this, "deploy", r);
            return;
          case "function":
            i = this.functions;
            break;
          case "event":
            i = this.events;
            break;
          case "error":
            i = this.errors;
            break;
          default:
            return;
        }
        let s = r.format();
        if (i[s]) {
          Wr.warn("duplicate definition - " + s);
          return;
        }
        i[s] = r;
      }),
      this.deploy ||
        Je(this, "deploy", o5.from({ payable: !1, type: "constructor" })),
      Je(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = lr.full),
      e === lr.sighash &&
        Wr.throwArgumentError(
          "interface does not support formatting sighash",
          "format",
          e
        );
    const n = this.fragments.map((r) => r.format(e));
    return e === lr.json ? JSON.stringify(n.map((r) => JSON.parse(r))) : n;
  }
  static getAbiCoder() {
    return hue;
  }
  static getAddress(e) {
    return As(e);
  }
  static getSighash(e) {
    return jc(qp(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return qp(e.format());
  }
  getFunction(e) {
    if (cr(e)) {
      for (const r in this.functions)
        if (e === this.getSighash(r)) return this.functions[r];
      Wr.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        i = Object.keys(this.functions).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Wr.throwArgumentError("no matching function", "name", r)
          : i.length > 1 &&
            Wr.throwArgumentError("multiple matching functions", "name", r),
        this.functions[i[0]]
      );
    }
    const n = this.functions[l5.fromString(e).format()];
    return (
      n || Wr.throwArgumentError("no matching function", "signature", e), n
    );
  }
  getEvent(e) {
    if (cr(e)) {
      const r = e.toLowerCase();
      for (const i in this.events)
        if (r === this.getEventTopic(i)) return this.events[i];
      Wr.throwArgumentError("no matching event", "topichash", r);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        i = Object.keys(this.events).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Wr.throwArgumentError("no matching event", "name", r)
          : i.length > 1 &&
            Wr.throwArgumentError("multiple matching events", "name", r),
        this.events[i[0]]
      );
    }
    const n = this.events[_E.fromString(e).format()];
    return n || Wr.throwArgumentError("no matching event", "signature", e), n;
  }
  getError(e) {
    if (cr(e)) {
      const r = $u(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (e === r(s)) return this.errors[i];
      }
      Wr.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        i = Object.keys(this.errors).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Wr.throwArgumentError("no matching error", "name", r)
          : i.length > 1 &&
            Wr.throwArgumentError("multiple matching errors", "name", r),
        this.errors[i[0]]
      );
    }
    const n = this.errors[l5.fromString(e).format()];
    return n || Wr.throwArgumentError("no matching error", "signature", e), n;
  }
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (n) {
        try {
          e = this.getError(e);
        } catch {
          throw n;
        }
      }
    return $u(this.constructor, "getSighash")(e);
  }
  getEventTopic(e) {
    return (
      typeof e == "string" && (e = this.getEvent(e)),
      $u(this.constructor, "getEventTopic")(e)
    );
  }
  _decodeParams(e, n) {
    return this._abiCoder.decode(e, n);
  }
  _encodeParams(e, n) {
    return this._abiCoder.encode(e, n);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, n) {
    typeof e == "string" && (e = this.getError(e));
    const r = hn(n);
    return (
      Qt(r.slice(0, 4)) !== this.getSighash(e) &&
        Wr.throwArgumentError(
          `data signature does not match error ${e.name}.`,
          "data",
          Qt(r)
        ),
      this._decodeParams(e.inputs, r.slice(4))
    );
  }
  encodeErrorResult(e, n) {
    return (
      typeof e == "string" && (e = this.getError(e)),
      Qt(fl([this.getSighash(e), this._encodeParams(e.inputs, n || [])]))
    );
  }
  decodeFunctionData(e, n) {
    typeof e == "string" && (e = this.getFunction(e));
    const r = hn(n);
    return (
      Qt(r.slice(0, 4)) !== this.getSighash(e) &&
        Wr.throwArgumentError(
          `data signature does not match function ${e.name}.`,
          "data",
          Qt(r)
        ),
      this._decodeParams(e.inputs, r.slice(4))
    );
  }
  encodeFunctionData(e, n) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      Qt(fl([this.getSighash(e), this._encodeParams(e.inputs, n || [])]))
    );
  }
  decodeFunctionResult(e, n) {
    typeof e == "string" && (e = this.getFunction(e));
    let r = hn(n),
      i = null,
      s = null,
      a = null,
      o = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, r);
        } catch {}
        break;
      case 4: {
        const l = Qt(r.slice(0, 4)),
          u = Sue[l];
        if (u)
          (s = this._abiCoder.decode(u.inputs, r.slice(4))),
            (a = u.name),
            (o = u.signature),
            u.reason && (i = s[0]);
        else
          try {
            const f = this.getError(l);
            (s = this._abiCoder.decode(f.inputs, r.slice(4))),
              (a = f.name),
              (o = f.format());
          } catch (f) {
            console.log(f);
          }
        break;
      }
    }
    return Wr.throwError("call revert exception", Se.errors.CALL_EXCEPTION, {
      method: e.format(),
      errorArgs: s,
      errorName: a,
      errorSignature: o,
      reason: i,
    });
  }
  encodeFunctionResult(e, n) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      Qt(this._abiCoder.encode(e.outputs, n || []))
    );
  }
  encodeFilterTopics(e, n) {
    typeof e == "string" && (e = this.getEvent(e)),
      n.length > e.inputs.length &&
        Wr.throwError(
          "too many arguments for " + e.format(),
          Se.errors.UNEXPECTED_ARGUMENT,
          { argument: "values", value: n }
        );
    let r = [];
    e.anonymous || r.push(this.getEventTopic(e));
    const i = (s, a) =>
      s.type === "string"
        ? qp(a)
        : s.type === "bytes"
        ? Ji(Qt(a))
        : (s.type === "address" && this._abiCoder.encode(["address"], [a]),
          Ni(Qt(a), 32));
    for (
      n.forEach((s, a) => {
        let o = e.inputs[a];
        if (!o.indexed) {
          s != null &&
            Wr.throwArgumentError(
              "cannot filter non-indexed parameters; must be null",
              "contract." + o.name,
              s
            );
          return;
        }
        s == null
          ? r.push(null)
          : o.baseType === "array" || o.baseType === "tuple"
          ? Wr.throwArgumentError(
              "filtering with tuples or arrays not supported",
              "contract." + o.name,
              s
            )
          : Array.isArray(s)
          ? r.push(s.map((l) => i(o, l)))
          : r.push(i(o, s));
      });
      r.length && r[r.length - 1] === null;

    )
      r.pop();
    return r;
  }
  encodeEventLog(e, n) {
    typeof e == "string" && (e = this.getEvent(e));
    const r = [],
      i = [],
      s = [];
    return (
      e.anonymous || r.push(this.getEventTopic(e)),
      n.length !== e.inputs.length &&
        Wr.throwArgumentError("event arguments/values mismatch", "values", n),
      e.inputs.forEach((a, o) => {
        const l = n[o];
        if (a.indexed)
          if (a.type === "string") r.push(qp(l));
          else if (a.type === "bytes") r.push(Ji(l));
          else {
            if (a.baseType === "tuple" || a.baseType === "array")
              throw new Error("not implemented");
            r.push(this._abiCoder.encode([a.type], [l]));
          }
        else i.push(a), s.push(l);
      }),
      { data: this._abiCoder.encode(i, s), topics: r }
    );
  }
  decodeEventLog(e, n, r) {
    if (
      (typeof e == "string" && (e = this.getEvent(e)),
      r != null && !e.anonymous)
    ) {
      let d = this.getEventTopic(e);
      (!cr(r[0], 32) || r[0].toLowerCase() !== d) &&
        Wr.throwError("fragment/topic mismatch", Se.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: d,
          value: r[0],
        }),
        (r = r.slice(1));
    }
    let i = [],
      s = [],
      a = [];
    e.inputs.forEach((d, p) => {
      d.indexed
        ? d.type === "string" ||
          d.type === "bytes" ||
          d.baseType === "tuple" ||
          d.baseType === "array"
          ? (i.push(Vu.fromObject({ type: "bytes32", name: d.name })),
            a.push(!0))
          : (i.push(d), a.push(!1))
        : (s.push(d), a.push(!1));
    });
    let o = r != null ? this._abiCoder.decode(i, fl(r)) : null,
      l = this._abiCoder.decode(s, n, !0),
      u = [],
      f = 0,
      c = 0;
    e.inputs.forEach((d, p) => {
      if (d.indexed)
        if (o == null) u[p] = new SE({ _isIndexed: !0, hash: null });
        else if (a[p]) u[p] = new SE({ _isIndexed: !0, hash: o[c++] });
        else
          try {
            u[p] = o[c++];
          } catch (m) {
            u[p] = m;
          }
      else
        try {
          u[p] = l[f++];
        } catch (m) {
          u[p] = m;
        }
      if (d.name && u[d.name] == null) {
        const m = u[p];
        m instanceof Error
          ? Object.defineProperty(u, d.name, {
              enumerable: !0,
              get: () => {
                throw rO(`property ${JSON.stringify(d.name)}`, m);
              },
            })
          : (u[d.name] = m);
      }
    });
    for (let d = 0; d < u.length; d++) {
      const p = u[d];
      p instanceof Error &&
        Object.defineProperty(u, d, {
          enumerable: !0,
          get: () => {
            throw rO(`index ${d}`, p);
          },
        });
    }
    return Object.freeze(u);
  }
  parseTransaction(e) {
    let n = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return n
      ? new xue({
          args: this._abiCoder.decode(n.inputs, "0x" + e.data.substring(10)),
          functionFragment: n,
          name: n.name,
          signature: n.format(),
          sighash: this.getSighash(n),
          value: dt.from(e.value || "0"),
        })
      : null;
  }
  parseLog(e) {
    let n = this.getEvent(e.topics[0]);
    return !n || n.anonymous
      ? null
      : new Eue({
          eventFragment: n,
          name: n.name,
          signature: n.format(),
          topic: this.getEventTopic(n),
          args: this.decodeEventLog(n, e.data, e.topics),
        });
  }
  parseError(e) {
    const n = Qt(e);
    let r = this.getError(n.substring(0, 10).toLowerCase());
    return r
      ? new Tue({
          args: this._abiCoder.decode(r.inputs, "0x" + n.substring(10)),
          errorFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
        })
      : null;
  }
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
};
const Aue = "abstract-provider/5.5.1";
var Cue =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const kue = new Se(Aue);
class Iue extends Ty {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
class zg {
  constructor() {
    kue.checkAbstract(new.target, zg), Je(this, "_isProvider", !0);
  }
  getFeeData() {
    return Cue(this, void 0, void 0, function* () {
      const { block: e, gasPrice: n } = yield Fi({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((s) => null),
      });
      let r = null,
        i = null;
      return (
        e &&
          e.baseFeePerGas &&
          ((i = dt.from("2500000000")), (r = e.baseFeePerGas.mul(2).add(i))),
        { maxFeePerGas: r, maxPriorityFeePerGas: i, gasPrice: n }
      );
    });
  }
  addListener(e, n) {
    return this.on(e, n);
  }
  removeListener(e, n) {
    return this.off(e, n);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
}
const Oue = "abstract-signer/5.5.0";
var Ll =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const Eo = new Se(Oue),
  Pue = [
    "accessList",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value",
  ],
  Nue = [
    Se.errors.INSUFFICIENT_FUNDS,
    Se.errors.NONCE_EXPIRED,
    Se.errors.REPLACEMENT_UNDERPRICED,
  ];
class Ay {
  constructor() {
    Eo.checkAbstract(new.target, Ay), Je(this, "_isSigner", !0);
  }
  getBalance(e) {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getBalance"),
        yield this.provider.getBalance(this.getAddress(), e)
      );
    });
  }
  getTransactionCount(e) {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getTransactionCount"),
        yield this.provider.getTransactionCount(this.getAddress(), e)
      );
    });
  }
  estimateGas(e) {
    return Ll(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const n = yield Fi(this.checkTransaction(e));
      return yield this.provider.estimateGas(n);
    });
  }
  call(e, n) {
    return Ll(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield Fi(this.checkTransaction(e));
      return yield this.provider.call(r, n);
    });
  }
  sendTransaction(e) {
    return Ll(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const n = yield this.populateTransaction(e),
        r = yield this.signTransaction(n);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getChainId"),
        (yield this.provider.getNetwork()).chainId
      );
    });
  }
  getGasPrice() {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
      );
    });
  }
  getFeeData() {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getFeeData"), yield this.provider.getFeeData()
      );
    });
  }
  resolveName(e) {
    return Ll(this, void 0, void 0, function* () {
      return (
        this._checkProvider("resolveName"), yield this.provider.resolveName(e)
      );
    });
  }
  checkTransaction(e) {
    for (const r in e)
      Pue.indexOf(r) === -1 &&
        Eo.throwArgumentError(
          "invalid transaction key: " + r,
          "transaction",
          e
        );
    const n = xs(e);
    return (
      n.from == null
        ? (n.from = this.getAddress())
        : (n.from = Promise.all([
            Promise.resolve(n.from),
            this.getAddress(),
          ]).then(
            (r) => (
              r[0].toLowerCase() !== r[1].toLowerCase() &&
                Eo.throwArgumentError(
                  "from address mismatch",
                  "transaction",
                  e
                ),
              r[0]
            )
          )),
      n
    );
  }
  populateTransaction(e) {
    return Ll(this, void 0, void 0, function* () {
      const n = yield Fi(this.checkTransaction(e));
      n.to != null &&
        ((n.to = Promise.resolve(n.to).then((i) =>
          Ll(this, void 0, void 0, function* () {
            if (i == null) return null;
            const s = yield this.resolveName(i);
            return (
              s == null &&
                Eo.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  i
                ),
              s
            );
          })
        )),
        n.to.catch((i) => {}));
      const r = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
      if (
        (n.gasPrice != null && (n.type === 2 || r)
          ? Eo.throwArgumentError(
              "eip-1559 transaction do not support gasPrice",
              "transaction",
              e
            )
          : (n.type === 0 || n.type === 1) &&
            r &&
            Eo.throwArgumentError(
              "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
              "transaction",
              e
            ),
        (n.type === 2 || n.type == null) &&
          n.maxFeePerGas != null &&
          n.maxPriorityFeePerGas != null)
      )
        n.type = 2;
      else if (n.type === 0 || n.type === 1)
        n.gasPrice == null && (n.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (n.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (((n.type = 2), n.gasPrice != null)) {
              const s = n.gasPrice;
              delete n.gasPrice,
                (n.maxFeePerGas = s),
                (n.maxPriorityFeePerGas = s);
            } else
              n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas),
                n.maxPriorityFeePerGas == null &&
                  (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null
              ? (r &&
                  Eo.throwError(
                    "network does not support EIP-1559",
                    Se.errors.UNSUPPORTED_OPERATION,
                    { operation: "populateTransaction" }
                  ),
                n.gasPrice == null && (n.gasPrice = i.gasPrice),
                (n.type = 0))
              : Eo.throwError(
                  "failed to get consistent fee data",
                  Se.errors.UNSUPPORTED_OPERATION,
                  { operation: "signer.getFeeData" }
                );
        else
          n.type === 2 &&
            (n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas),
            n.maxPriorityFeePerGas == null &&
              (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return (
        n.nonce == null && (n.nonce = this.getTransactionCount("pending")),
        n.gasLimit == null &&
          (n.gasLimit = this.estimateGas(n).catch((i) => {
            if (Nue.indexOf(i.code) >= 0) throw i;
            return Eo.throwError(
              "cannot estimate gas; transaction may fail or may require manual gas limit",
              Se.errors.UNPREDICTABLE_GAS_LIMIT,
              { error: i, tx: n }
            );
          })),
        n.chainId == null
          ? (n.chainId = this.getChainId())
          : (n.chainId = Promise.all([
              Promise.resolve(n.chainId),
              this.getChainId(),
            ]).then(
              (i) => (
                i[1] !== 0 &&
                  i[0] !== i[1] &&
                  Eo.throwArgumentError(
                    "chainId address mismatch",
                    "transaction",
                    e
                  ),
                i[0]
              )
            )),
        yield Fi(n)
      );
    });
  }
  _checkProvider(e) {
    this.provider ||
      Eo.throwError("missing provider", Se.errors.UNSUPPORTED_OPERATION, {
        operation: e || "_checkProvider",
      });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class c5 extends Ay {
  constructor(e, n) {
    Eo.checkNew(new.target, c5),
      super(),
      Je(this, "address", e),
      Je(this, "provider", n || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, n) {
    return Promise.resolve().then(() => {
      Eo.throwError(e, Se.errors.UNSUPPORTED_OPERATION, { operation: n });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, n, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new c5(this.address, e);
  }
}
var $j = {},
  Wn = {},
  Cy = Uj;
function Uj(t, e) {
  if (!t) throw new Error(e || "Assertion failed");
}
Uj.equal = function (e, n, r) {
  if (e != n) throw new Error(r || "Assertion failed: " + e + " != " + n);
};
var AE = { exports: {} };
typeof Object.create == "function"
  ? (AE.exports = function (e, n) {
      n &&
        ((e.super_ = n),
        (e.prototype = Object.create(n.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (AE.exports = function (e, n) {
      if (n) {
        e.super_ = n;
        var r = function () {};
        (r.prototype = n.prototype),
          (e.prototype = new r()),
          (e.prototype.constructor = e);
      }
    });
var Due = AE.exports,
  Rue = Cy,
  Mue = Due;
Wn.inherits = Mue;
function Lue(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length
    ? !1
    : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function Bue(t, e) {
  if (Array.isArray(t)) return t.slice();
  if (!t) return [];
  var n = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (
          t = t.replace(/[^a-z0-9]+/gi, ""),
            t.length % 2 !== 0 && (t = "0" + t),
            i = 0;
          i < t.length;
          i += 2
        )
          n.push(parseInt(t[i] + t[i + 1], 16));
    } else
      for (var r = 0, i = 0; i < t.length; i++) {
        var s = t.charCodeAt(i);
        s < 128
          ? (n[r++] = s)
          : s < 2048
          ? ((n[r++] = (s >> 6) | 192), (n[r++] = (s & 63) | 128))
          : Lue(t, i)
          ? ((s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023)),
            (n[r++] = (s >> 18) | 240),
            (n[r++] = ((s >> 12) & 63) | 128),
            (n[r++] = ((s >> 6) & 63) | 128),
            (n[r++] = (s & 63) | 128))
          : ((n[r++] = (s >> 12) | 224),
            (n[r++] = ((s >> 6) & 63) | 128),
            (n[r++] = (s & 63) | 128));
      }
  else for (i = 0; i < t.length; i++) n[i] = t[i] | 0;
  return n;
}
Wn.toArray = Bue;
function Fue(t) {
  for (var e = "", n = 0; n < t.length; n++) e += Hj(t[n].toString(16));
  return e;
}
Wn.toHex = Fue;
function jj(t) {
  var e =
    (t >>> 24) |
    ((t >>> 8) & 65280) |
    ((t << 8) & 16711680) |
    ((t & 255) << 24);
  return e >>> 0;
}
Wn.htonl = jj;
function $ue(t, e) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    e === "little" && (i = jj(i)), (n += zj(i.toString(16)));
  }
  return n;
}
Wn.toHex32 = $ue;
function Hj(t) {
  return t.length === 1 ? "0" + t : t;
}
Wn.zero2 = Hj;
function zj(t) {
  return t.length === 7
    ? "0" + t
    : t.length === 6
    ? "00" + t
    : t.length === 5
    ? "000" + t
    : t.length === 4
    ? "0000" + t
    : t.length === 3
    ? "00000" + t
    : t.length === 2
    ? "000000" + t
    : t.length === 1
    ? "0000000" + t
    : t;
}
Wn.zero8 = zj;
function Uue(t, e, n, r) {
  var i = n - e;
  Rue(i % 4 === 0);
  for (var s = new Array(i / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var l;
    r === "big"
      ? (l = (t[o] << 24) | (t[o + 1] << 16) | (t[o + 2] << 8) | t[o + 3])
      : (l = (t[o + 3] << 24) | (t[o + 2] << 16) | (t[o + 1] << 8) | t[o]),
      (s[a] = l >>> 0);
  }
  return s;
}
Wn.join32 = Uue;
function jue(t, e) {
  for (
    var n = new Array(t.length * 4), r = 0, i = 0;
    r < t.length;
    r++, i += 4
  ) {
    var s = t[r];
    e === "big"
      ? ((n[i] = s >>> 24),
        (n[i + 1] = (s >>> 16) & 255),
        (n[i + 2] = (s >>> 8) & 255),
        (n[i + 3] = s & 255))
      : ((n[i + 3] = s >>> 24),
        (n[i + 2] = (s >>> 16) & 255),
        (n[i + 1] = (s >>> 8) & 255),
        (n[i] = s & 255));
  }
  return n;
}
Wn.split32 = jue;
function Hue(t, e) {
  return (t >>> e) | (t << (32 - e));
}
Wn.rotr32 = Hue;
function zue(t, e) {
  return (t << e) | (t >>> (32 - e));
}
Wn.rotl32 = zue;
function Vue(t, e) {
  return (t + e) >>> 0;
}
Wn.sum32 = Vue;
function Gue(t, e, n) {
  return (t + e + n) >>> 0;
}
Wn.sum32_3 = Gue;
function Wue(t, e, n, r) {
  return (t + e + n + r) >>> 0;
}
Wn.sum32_4 = Wue;
function que(t, e, n, r, i) {
  return (t + e + n + r + i) >>> 0;
}
Wn.sum32_5 = que;
function Kue(t, e, n, r) {
  var i = t[e],
    s = t[e + 1],
    a = (r + s) >>> 0,
    o = (a < r ? 1 : 0) + n + i;
  (t[e] = o >>> 0), (t[e + 1] = a);
}
Wn.sum64 = Kue;
function Xue(t, e, n, r) {
  var i = (e + r) >>> 0,
    s = (i < e ? 1 : 0) + t + n;
  return s >>> 0;
}
Wn.sum64_hi = Xue;
function Zue(t, e, n, r) {
  var i = e + r;
  return i >>> 0;
}
Wn.sum64_lo = Zue;
function Yue(t, e, n, r, i, s, a, o) {
  var l = 0,
    u = e;
  (u = (u + r) >>> 0),
    (l += u < e ? 1 : 0),
    (u = (u + s) >>> 0),
    (l += u < s ? 1 : 0),
    (u = (u + o) >>> 0),
    (l += u < o ? 1 : 0);
  var f = t + n + i + a + l;
  return f >>> 0;
}
Wn.sum64_4_hi = Yue;
function Que(t, e, n, r, i, s, a, o) {
  var l = e + r + s + o;
  return l >>> 0;
}
Wn.sum64_4_lo = Que;
function Jue(t, e, n, r, i, s, a, o, l, u) {
  var f = 0,
    c = e;
  (c = (c + r) >>> 0),
    (f += c < e ? 1 : 0),
    (c = (c + s) >>> 0),
    (f += c < s ? 1 : 0),
    (c = (c + o) >>> 0),
    (f += c < o ? 1 : 0),
    (c = (c + u) >>> 0),
    (f += c < u ? 1 : 0);
  var d = t + n + i + a + l + f;
  return d >>> 0;
}
Wn.sum64_5_hi = Jue;
function ece(t, e, n, r, i, s, a, o, l, u) {
  var f = e + r + s + o + u;
  return f >>> 0;
}
Wn.sum64_5_lo = ece;
function tce(t, e, n) {
  var r = (e << (32 - n)) | (t >>> n);
  return r >>> 0;
}
Wn.rotr64_hi = tce;
function nce(t, e, n) {
  var r = (t << (32 - n)) | (e >>> n);
  return r >>> 0;
}
Wn.rotr64_lo = nce;
function rce(t, e, n) {
  return t >>> n;
}
Wn.shr64_hi = rce;
function ice(t, e, n) {
  var r = (t << (32 - n)) | (e >>> n);
  return r >>> 0;
}
Wn.shr64_lo = ice;
var m1 = {},
  sO = Wn,
  sce = Cy;
function Mw() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = "big"),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
m1.BlockHash = Mw;
Mw.prototype.update = function (e, n) {
  if (
    ((e = sO.toArray(e, n)),
    this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
    (this.pendingTotal += e.length),
    this.pending.length >= this._delta8)
  ) {
    e = this.pending;
    var r = e.length % this._delta8;
    (this.pending = e.slice(e.length - r, e.length)),
      this.pending.length === 0 && (this.pending = null),
      (e = sO.join32(e, 0, e.length - r, this.endian));
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
Mw.prototype.digest = function (e) {
  return this.update(this._pad()), sce(this.pending === null), this._digest(e);
};
Mw.prototype._pad = function () {
  var e = this.pendingTotal,
    n = this._delta8,
    r = n - ((e + this.padLength) % n),
    i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++) i[s] = 0;
  if (((e <<= 3), this.endian === "big")) {
    for (var a = 8; a < this.padLength; a++) i[s++] = 0;
    (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = (e >>> 24) & 255),
      (i[s++] = (e >>> 16) & 255),
      (i[s++] = (e >>> 8) & 255),
      (i[s++] = e & 255);
  } else
    for (
      i[s++] = e & 255,
        i[s++] = (e >>> 8) & 255,
        i[s++] = (e >>> 16) & 255,
        i[s++] = (e >>> 24) & 255,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        a = 8;
      a < this.padLength;
      a++
    )
      i[s++] = 0;
  return i;
};
var g1 = {},
  sc = {},
  ace = Wn,
  Gu = ace.rotr32;
function oce(t, e, n, r) {
  if (t === 0) return Vj(e, n, r);
  if (t === 1 || t === 3) return Wj(e, n, r);
  if (t === 2) return Gj(e, n, r);
}
sc.ft_1 = oce;
function Vj(t, e, n) {
  return (t & e) ^ (~t & n);
}
sc.ch32 = Vj;
function Gj(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n);
}
sc.maj32 = Gj;
function Wj(t, e, n) {
  return t ^ e ^ n;
}
sc.p32 = Wj;
function lce(t) {
  return Gu(t, 2) ^ Gu(t, 13) ^ Gu(t, 22);
}
sc.s0_256 = lce;
function uce(t) {
  return Gu(t, 6) ^ Gu(t, 11) ^ Gu(t, 25);
}
sc.s1_256 = uce;
function cce(t) {
  return Gu(t, 7) ^ Gu(t, 18) ^ (t >>> 3);
}
sc.g0_256 = cce;
function fce(t) {
  return Gu(t, 17) ^ Gu(t, 19) ^ (t >>> 10);
}
sc.g1_256 = fce;
var U0 = Wn,
  dce = m1,
  hce = sc,
  U_ = U0.rotl32,
  um = U0.sum32,
  pce = U0.sum32_5,
  mce = hce.ft_1,
  qj = dce.BlockHash,
  gce = [1518500249, 1859775393, 2400959708, 3395469782];
function Zu() {
  if (!(this instanceof Zu)) return new Zu();
  qj.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.W = new Array(80));
}
U0.inherits(Zu, qj);
var yce = Zu;
Zu.blockSize = 512;
Zu.outSize = 160;
Zu.hmacStrength = 80;
Zu.padLength = 64;
Zu.prototype._update = function (e, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = e[n + i];
  for (; i < r.length; i++)
    r[i] = U_(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    l = this.h[3],
    u = this.h[4];
  for (i = 0; i < r.length; i++) {
    var f = ~~(i / 20),
      c = pce(U_(s, 5), mce(f, a, o, l), u, r[i], gce[f]);
    (u = l), (l = o), (o = U_(a, 30)), (a = s), (s = c);
  }
  (this.h[0] = um(this.h[0], s)),
    (this.h[1] = um(this.h[1], a)),
    (this.h[2] = um(this.h[2], o)),
    (this.h[3] = um(this.h[3], l)),
    (this.h[4] = um(this.h[4], u));
};
Zu.prototype._digest = function (e) {
  return e === "hex" ? U0.toHex32(this.h, "big") : U0.split32(this.h, "big");
};
var j0 = Wn,
  vce = m1,
  y1 = sc,
  bce = Cy,
  Bl = j0.sum32,
  wce = j0.sum32_4,
  _ce = j0.sum32_5,
  Ece = y1.ch32,
  xce = y1.maj32,
  Tce = y1.s0_256,
  Sce = y1.s1_256,
  Ace = y1.g0_256,
  Cce = y1.g1_256,
  Kj = vce.BlockHash,
  kce = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ];
function Yu() {
  if (!(this instanceof Yu)) return new Yu();
  Kj.call(this),
    (this.h = [
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    (this.k = kce),
    (this.W = new Array(64));
}
j0.inherits(Yu, Kj);
var Xj = Yu;
Yu.blockSize = 512;
Yu.outSize = 256;
Yu.hmacStrength = 192;
Yu.padLength = 64;
Yu.prototype._update = function (e, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = e[n + i];
  for (; i < r.length; i++)
    r[i] = wce(Cce(r[i - 2]), r[i - 7], Ace(r[i - 15]), r[i - 16]);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    l = this.h[3],
    u = this.h[4],
    f = this.h[5],
    c = this.h[6],
    d = this.h[7];
  for (bce(this.k.length === r.length), i = 0; i < r.length; i++) {
    var p = _ce(d, Sce(u), Ece(u, f, c), this.k[i], r[i]),
      m = Bl(Tce(s), xce(s, a, o));
    (d = c),
      (c = f),
      (f = u),
      (u = Bl(l, p)),
      (l = o),
      (o = a),
      (a = s),
      (s = Bl(p, m));
  }
  (this.h[0] = Bl(this.h[0], s)),
    (this.h[1] = Bl(this.h[1], a)),
    (this.h[2] = Bl(this.h[2], o)),
    (this.h[3] = Bl(this.h[3], l)),
    (this.h[4] = Bl(this.h[4], u)),
    (this.h[5] = Bl(this.h[5], f)),
    (this.h[6] = Bl(this.h[6], c)),
    (this.h[7] = Bl(this.h[7], d));
};
Yu.prototype._digest = function (e) {
  return e === "hex" ? j0.toHex32(this.h, "big") : j0.split32(this.h, "big");
};
var CE = Wn,
  Zj = Xj;
function Qc() {
  if (!(this instanceof Qc)) return new Qc();
  Zj.call(this),
    (this.h = [
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
      1694076839, 3204075428,
    ]);
}
CE.inherits(Qc, Zj);
var Ice = Qc;
Qc.blockSize = 512;
Qc.outSize = 224;
Qc.hmacStrength = 192;
Qc.padLength = 64;
Qc.prototype._digest = function (e) {
  return e === "hex"
    ? CE.toHex32(this.h.slice(0, 7), "big")
    : CE.split32(this.h.slice(0, 7), "big");
};
var io = Wn,
  Oce = m1,
  Pce = Cy,
  Wu = io.rotr64_hi,
  qu = io.rotr64_lo,
  Yj = io.shr64_hi,
  Qj = io.shr64_lo,
  Ef = io.sum64,
  j_ = io.sum64_hi,
  H_ = io.sum64_lo,
  Nce = io.sum64_4_hi,
  Dce = io.sum64_4_lo,
  Rce = io.sum64_5_hi,
  Mce = io.sum64_5_lo,
  Jj = Oce.BlockHash,
  Lce = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ];
function ou() {
  if (!(this instanceof ou)) return new ou();
  Jj.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = Lce),
    (this.W = new Array(160));
}
io.inherits(ou, Jj);
var eH = ou;
ou.blockSize = 1024;
ou.outSize = 512;
ou.hmacStrength = 192;
ou.padLength = 128;
ou.prototype._prepareBlock = function (e, n) {
  for (var r = this.W, i = 0; i < 32; i++) r[i] = e[n + i];
  for (; i < r.length; i += 2) {
    var s = qce(r[i - 4], r[i - 3]),
      a = Kce(r[i - 4], r[i - 3]),
      o = r[i - 14],
      l = r[i - 13],
      u = Gce(r[i - 30], r[i - 29]),
      f = Wce(r[i - 30], r[i - 29]),
      c = r[i - 32],
      d = r[i - 31];
    (r[i] = Nce(s, a, o, l, u, f, c, d)),
      (r[i + 1] = Dce(s, a, o, l, u, f, c, d));
  }
};
ou.prototype._update = function (e, n) {
  this._prepareBlock(e, n);
  var r = this.W,
    i = this.h[0],
    s = this.h[1],
    a = this.h[2],
    o = this.h[3],
    l = this.h[4],
    u = this.h[5],
    f = this.h[6],
    c = this.h[7],
    d = this.h[8],
    p = this.h[9],
    m = this.h[10],
    g = this.h[11],
    w = this.h[12],
    y = this.h[13],
    v = this.h[14],
    E = this.h[15];
  Pce(this.k.length === r.length);
  for (var S = 0; S < r.length; S += 2) {
    var D = v,
      P = E,
      x = zce(d, p),
      _ = Vce(d, p),
      A = Bce(d, p, m, g, w),
      N = Fce(d, p, m, g, w, y),
      M = this.k[S],
      T = this.k[S + 1],
      O = r[S],
      I = r[S + 1],
      k = Rce(D, P, x, _, A, N, M, T, O, I),
      L = Mce(D, P, x, _, A, N, M, T, O, I);
    (D = jce(i, s)),
      (P = Hce(i, s)),
      (x = $ce(i, s, a, o, l)),
      (_ = Uce(i, s, a, o, l, u));
    var U = j_(D, P, x, _),
      $ = H_(D, P, x, _);
    (v = w),
      (E = y),
      (w = m),
      (y = g),
      (m = d),
      (g = p),
      (d = j_(f, c, k, L)),
      (p = H_(c, c, k, L)),
      (f = l),
      (c = u),
      (l = a),
      (u = o),
      (a = i),
      (o = s),
      (i = j_(k, L, U, $)),
      (s = H_(k, L, U, $));
  }
  Ef(this.h, 0, i, s),
    Ef(this.h, 2, a, o),
    Ef(this.h, 4, l, u),
    Ef(this.h, 6, f, c),
    Ef(this.h, 8, d, p),
    Ef(this.h, 10, m, g),
    Ef(this.h, 12, w, y),
    Ef(this.h, 14, v, E);
};
ou.prototype._digest = function (e) {
  return e === "hex" ? io.toHex32(this.h, "big") : io.split32(this.h, "big");
};
function Bce(t, e, n, r, i) {
  var s = (t & n) ^ (~t & i);
  return s < 0 && (s += 4294967296), s;
}
function Fce(t, e, n, r, i, s) {
  var a = (e & r) ^ (~e & s);
  return a < 0 && (a += 4294967296), a;
}
function $ce(t, e, n, r, i) {
  var s = (t & n) ^ (t & i) ^ (n & i);
  return s < 0 && (s += 4294967296), s;
}
function Uce(t, e, n, r, i, s) {
  var a = (e & r) ^ (e & s) ^ (r & s);
  return a < 0 && (a += 4294967296), a;
}
function jce(t, e) {
  var n = Wu(t, e, 28),
    r = Wu(e, t, 2),
    i = Wu(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Hce(t, e) {
  var n = qu(t, e, 28),
    r = qu(e, t, 2),
    i = qu(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function zce(t, e) {
  var n = Wu(t, e, 14),
    r = Wu(t, e, 18),
    i = Wu(e, t, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Vce(t, e) {
  var n = qu(t, e, 14),
    r = qu(t, e, 18),
    i = qu(e, t, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Gce(t, e) {
  var n = Wu(t, e, 1),
    r = Wu(t, e, 8),
    i = Yj(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Wce(t, e) {
  var n = qu(t, e, 1),
    r = qu(t, e, 8),
    i = Qj(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function qce(t, e) {
  var n = Wu(t, e, 19),
    r = Wu(e, t, 29),
    i = Yj(t, e, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Kce(t, e) {
  var n = qu(t, e, 19),
    r = qu(e, t, 29),
    i = Qj(t, e, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
var kE = Wn,
  tH = eH;
function Jc() {
  if (!(this instanceof Jc)) return new Jc();
  tH.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
      355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
      3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
kE.inherits(Jc, tH);
var Xce = Jc;
Jc.blockSize = 1024;
Jc.outSize = 384;
Jc.hmacStrength = 192;
Jc.padLength = 128;
Jc.prototype._digest = function (e) {
  return e === "hex"
    ? kE.toHex32(this.h.slice(0, 12), "big")
    : kE.split32(this.h.slice(0, 12), "big");
};
g1.sha1 = yce;
g1.sha224 = Ice;
g1.sha256 = Xj;
g1.sha384 = Xce;
g1.sha512 = eH;
var nH = {},
  vh = Wn,
  Zce = m1,
  av = vh.rotl32,
  aO = vh.sum32,
  cm = vh.sum32_3,
  oO = vh.sum32_4,
  rH = Zce.BlockHash;
function Qu() {
  if (!(this instanceof Qu)) return new Qu();
  rH.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.endian = "little");
}
vh.inherits(Qu, rH);
nH.ripemd160 = Qu;
Qu.blockSize = 512;
Qu.outSize = 160;
Qu.hmacStrength = 192;
Qu.padLength = 64;
Qu.prototype._update = function (e, n) {
  for (
    var r = this.h[0],
      i = this.h[1],
      s = this.h[2],
      a = this.h[3],
      o = this.h[4],
      l = r,
      u = i,
      f = s,
      c = a,
      d = o,
      p = 0;
    p < 80;
    p++
  ) {
    var m = aO(av(oO(r, lO(p, i, s, a), e[Jce[p] + n], Yce(p)), tfe[p]), o);
    (r = o),
      (o = a),
      (a = av(s, 10)),
      (s = i),
      (i = m),
      (m = aO(
        av(oO(l, lO(79 - p, u, f, c), e[efe[p] + n], Qce(p)), nfe[p]),
        d
      )),
      (l = d),
      (d = c),
      (c = av(f, 10)),
      (f = u),
      (u = m);
  }
  (m = cm(this.h[1], s, c)),
    (this.h[1] = cm(this.h[2], a, d)),
    (this.h[2] = cm(this.h[3], o, l)),
    (this.h[3] = cm(this.h[4], r, u)),
    (this.h[4] = cm(this.h[0], i, f)),
    (this.h[0] = m);
};
Qu.prototype._digest = function (e) {
  return e === "hex"
    ? vh.toHex32(this.h, "little")
    : vh.split32(this.h, "little");
};
function lO(t, e, n, r) {
  return t <= 15
    ? e ^ n ^ r
    : t <= 31
    ? (e & n) | (~e & r)
    : t <= 47
    ? (e | ~n) ^ r
    : t <= 63
    ? (e & r) | (n & ~r)
    : e ^ (n | ~r);
}
function Yce(t) {
  return t <= 15
    ? 0
    : t <= 31
    ? 1518500249
    : t <= 47
    ? 1859775393
    : t <= 63
    ? 2400959708
    : 2840853838;
}
function Qce(t) {
  return t <= 15
    ? 1352829926
    : t <= 31
    ? 1548603684
    : t <= 47
    ? 1836072691
    : t <= 63
    ? 2053994217
    : 0;
}
var Jce = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6,
    15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13,
    11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9,
    7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  efe = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,
    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10,
    0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10,
    4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  tfe = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9,
    7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13,
    6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9,
    15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  nfe = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,
    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,
    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,
    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  rfe = Wn,
  ife = Cy;
function H0(t, e, n) {
  if (!(this instanceof H0)) return new H0(t, e, n);
  (this.Hash = t),
    (this.blockSize = t.blockSize / 8),
    (this.outSize = t.outSize / 8),
    (this.inner = null),
    (this.outer = null),
    this._init(rfe.toArray(e, n));
}
var sfe = H0;
H0.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
    ife(e.length <= this.blockSize);
  for (var n = e.length; n < this.blockSize; n++) e.push(0);
  for (n = 0; n < e.length; n++) e[n] ^= 54;
  for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++)
    e[n] ^= 106;
  this.outer = new this.Hash().update(e);
};
H0.prototype.update = function (e, n) {
  return this.inner.update(e, n), this;
};
H0.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (t) {
  var e = t;
  (e.utils = Wn),
    (e.common = m1),
    (e.sha = g1),
    (e.ripemd = nH),
    (e.hmac = sfe),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})($j);
const Ou = oa($j);
function v1(t, e, n) {
  return (
    (n = {
      path: e,
      exports: {},
      require: function (r, i) {
        return afe(r, i ?? n.path);
      },
    }),
    t(n, n.exports),
    n.exports
  );
}
function afe() {
  throw new Error(
    "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
  );
}
var G7 = iH;
function iH(t, e) {
  if (!t) throw new Error(e || "Assertion failed");
}
iH.equal = function (e, n, r) {
  if (e != n) throw new Error(r || "Assertion failed: " + e + " != " + n);
};
var Jl = v1(function (t, e) {
    var n = e;
    function r(a, o) {
      if (Array.isArray(a)) return a.slice();
      if (!a) return [];
      var l = [];
      if (typeof a != "string") {
        for (var u = 0; u < a.length; u++) l[u] = a[u] | 0;
        return l;
      }
      if (o === "hex") {
        (a = a.replace(/[^a-z0-9]+/gi, "")),
          a.length % 2 !== 0 && (a = "0" + a);
        for (var u = 0; u < a.length; u += 2)
          l.push(parseInt(a[u] + a[u + 1], 16));
      } else
        for (var u = 0; u < a.length; u++) {
          var f = a.charCodeAt(u),
            c = f >> 8,
            d = f & 255;
          c ? l.push(c, d) : l.push(d);
        }
      return l;
    }
    n.toArray = r;
    function i(a) {
      return a.length === 1 ? "0" + a : a;
    }
    n.zero2 = i;
    function s(a) {
      for (var o = "", l = 0; l < a.length; l++) o += i(a[l].toString(16));
      return o;
    }
    (n.toHex = s),
      (n.encode = function (o, l) {
        return l === "hex" ? s(o) : o;
      });
  }),
  Bo = v1(function (t, e) {
    var n = e;
    (n.assert = G7),
      (n.toArray = Jl.toArray),
      (n.zero2 = Jl.zero2),
      (n.toHex = Jl.toHex),
      (n.encode = Jl.encode);
    function r(l, u, f) {
      var c = new Array(Math.max(l.bitLength(), f) + 1);
      c.fill(0);
      for (var d = 1 << (u + 1), p = l.clone(), m = 0; m < c.length; m++) {
        var g,
          w = p.andln(d - 1);
        p.isOdd()
          ? (w > (d >> 1) - 1 ? (g = (d >> 1) - w) : (g = w), p.isubn(g))
          : (g = 0),
          (c[m] = g),
          p.iushrn(1);
      }
      return c;
    }
    n.getNAF = r;
    function i(l, u) {
      var f = [[], []];
      (l = l.clone()), (u = u.clone());
      for (var c = 0, d = 0, p; l.cmpn(-c) > 0 || u.cmpn(-d) > 0; ) {
        var m = (l.andln(3) + c) & 3,
          g = (u.andln(3) + d) & 3;
        m === 3 && (m = -1), g === 3 && (g = -1);
        var w;
        m & 1
          ? ((p = (l.andln(7) + c) & 7),
            (p === 3 || p === 5) && g === 2 ? (w = -m) : (w = m))
          : (w = 0),
          f[0].push(w);
        var y;
        g & 1
          ? ((p = (u.andln(7) + d) & 7),
            (p === 3 || p === 5) && m === 2 ? (y = -g) : (y = g))
          : (y = 0),
          f[1].push(y),
          2 * c === w + 1 && (c = 1 - c),
          2 * d === y + 1 && (d = 1 - d),
          l.iushrn(1),
          u.iushrn(1);
      }
      return f;
    }
    n.getJSF = i;
    function s(l, u, f) {
      var c = "_" + u;
      l.prototype[u] = function () {
        return this[c] !== void 0 ? this[c] : (this[c] = f.call(this));
      };
    }
    n.cachedProperty = s;
    function a(l) {
      return typeof l == "string" ? n.toArray(l, "hex") : l;
    }
    n.parseBytes = a;
    function o(l) {
      return new bn(l, "hex", "le");
    }
    n.intFromLE = o;
  }),
  f5 = Bo.getNAF,
  ofe = Bo.getJSF,
  d5 = Bo.assert;
function wd(t, e) {
  (this.type = t),
    (this.p = new bn(e.p, 16)),
    (this.red = e.prime ? bn.red(e.prime) : bn.mont(this.p)),
    (this.zero = new bn(0).toRed(this.red)),
    (this.one = new bn(1).toRed(this.red)),
    (this.two = new bn(2).toRed(this.red)),
    (this.n = e.n && new bn(e.n, 16)),
    (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0
    ? (this.redN = null)
    : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var Bh = wd;
wd.prototype.point = function () {
  throw new Error("Not implemented");
};
wd.prototype.validate = function () {
  throw new Error("Not implemented");
};
wd.prototype._fixedNafMul = function (e, n) {
  d5(e.precomputed);
  var r = e._getDoubles(),
    i = f5(n, 1, this._bitLength),
    s = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [],
    o,
    l;
  for (o = 0; o < i.length; o += r.step) {
    l = 0;
    for (var u = o + r.step - 1; u >= o; u--) l = (l << 1) + i[u];
    a.push(l);
  }
  for (
    var f = this.jpoint(null, null, null),
      c = this.jpoint(null, null, null),
      d = s;
    d > 0;
    d--
  ) {
    for (o = 0; o < a.length; o++)
      (l = a[o]),
        l === d
          ? (c = c.mixedAdd(r.points[o]))
          : l === -d && (c = c.mixedAdd(r.points[o].neg()));
    f = f.add(c);
  }
  return f.toP();
};
wd.prototype._wnafMul = function (e, n) {
  var r = 4,
    i = e._getNAFPoints(r);
  r = i.wnd;
  for (
    var s = i.points,
      a = f5(n, r, this._bitLength),
      o = this.jpoint(null, null, null),
      l = a.length - 1;
    l >= 0;
    l--
  ) {
    for (var u = 0; l >= 0 && a[l] === 0; l--) u++;
    if ((l >= 0 && u++, (o = o.dblp(u)), l < 0)) break;
    var f = a[l];
    d5(f !== 0),
      e.type === "affine"
        ? f > 0
          ? (o = o.mixedAdd(s[(f - 1) >> 1]))
          : (o = o.mixedAdd(s[(-f - 1) >> 1].neg()))
        : f > 0
        ? (o = o.add(s[(f - 1) >> 1]))
        : (o = o.add(s[(-f - 1) >> 1].neg()));
  }
  return e.type === "affine" ? o.toP() : o;
};
wd.prototype._wnafMulAdd = function (e, n, r, i, s) {
  var a = this._wnafT1,
    o = this._wnafT2,
    l = this._wnafT3,
    u = 0,
    f,
    c,
    d;
  for (f = 0; f < i; f++) {
    d = n[f];
    var p = d._getNAFPoints(e);
    (a[f] = p.wnd), (o[f] = p.points);
  }
  for (f = i - 1; f >= 1; f -= 2) {
    var m = f - 1,
      g = f;
    if (a[m] !== 1 || a[g] !== 1) {
      (l[m] = f5(r[m], a[m], this._bitLength)),
        (l[g] = f5(r[g], a[g], this._bitLength)),
        (u = Math.max(l[m].length, u)),
        (u = Math.max(l[g].length, u));
      continue;
    }
    var w = [n[m], null, null, n[g]];
    n[m].y.cmp(n[g].y) === 0
      ? ((w[1] = n[m].add(n[g])), (w[2] = n[m].toJ().mixedAdd(n[g].neg())))
      : n[m].y.cmp(n[g].y.redNeg()) === 0
      ? ((w[1] = n[m].toJ().mixedAdd(n[g])), (w[2] = n[m].add(n[g].neg())))
      : ((w[1] = n[m].toJ().mixedAdd(n[g])),
        (w[2] = n[m].toJ().mixedAdd(n[g].neg())));
    var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
      v = ofe(r[m], r[g]);
    for (
      u = Math.max(v[0].length, u),
        l[m] = new Array(u),
        l[g] = new Array(u),
        c = 0;
      c < u;
      c++
    ) {
      var E = v[0][c] | 0,
        S = v[1][c] | 0;
      (l[m][c] = y[(E + 1) * 3 + (S + 1)]), (l[g][c] = 0), (o[m] = w);
    }
  }
  var D = this.jpoint(null, null, null),
    P = this._wnafT4;
  for (f = u; f >= 0; f--) {
    for (var x = 0; f >= 0; ) {
      var _ = !0;
      for (c = 0; c < i; c++) (P[c] = l[c][f] | 0), P[c] !== 0 && (_ = !1);
      if (!_) break;
      x++, f--;
    }
    if ((f >= 0 && x++, (D = D.dblp(x)), f < 0)) break;
    for (c = 0; c < i; c++) {
      var A = P[c];
      A !== 0 &&
        (A > 0
          ? (d = o[c][(A - 1) >> 1])
          : A < 0 && (d = o[c][(-A - 1) >> 1].neg()),
        d.type === "affine" ? (D = D.mixedAdd(d)) : (D = D.add(d)));
    }
  }
  for (f = 0; f < i; f++) o[f] = null;
  return s ? D : D.toP();
};
function El(t, e) {
  (this.curve = t), (this.type = e), (this.precomputed = null);
}
wd.BasePoint = El;
El.prototype.eq = function () {
  throw new Error("Not implemented");
};
El.prototype.validate = function () {
  return this.curve.validate(this);
};
wd.prototype.decodePoint = function (e, n) {
  e = Bo.toArray(e, n);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6
      ? d5(e[e.length - 1] % 2 === 0)
      : e[0] === 7 && d5(e[e.length - 1] % 2 === 1);
    var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
    return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
El.prototype.encodeCompressed = function (e) {
  return this.encode(e, !0);
};
El.prototype._encode = function (e) {
  var n = this.curve.p.byteLength(),
    r = this.getX().toArray("be", n);
  return e
    ? [this.getY().isEven() ? 2 : 3].concat(r)
    : [4].concat(r, this.getY().toArray("be", n));
};
El.prototype.encode = function (e, n) {
  return Bo.encode(this._encode(n), e);
};
El.prototype.precompute = function (e) {
  if (this.precomputed) return this;
  var n = { doubles: null, naf: null, beta: null };
  return (
    (n.naf = this._getNAFPoints(8)),
    (n.doubles = this._getDoubles(4, e)),
    (n.beta = this._getBeta()),
    (this.precomputed = n),
    this
  );
};
El.prototype._hasDoubles = function (e) {
  if (!this.precomputed) return !1;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : !1;
};
El.prototype._getDoubles = function (e, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < n; s += e) {
    for (var a = 0; a < e; a++) i = i.dbl();
    r.push(i);
  }
  return { step: e, points: r };
};
El.prototype._getNAFPoints = function (e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (
    var n = [this], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1;
    s < r;
    s++
  )
    n[s] = n[s - 1].add(i);
  return { wnd: e, points: n };
};
El.prototype._getBeta = function () {
  return null;
};
El.prototype.dblp = function (e) {
  for (var n = this, r = 0; r < e; r++) n = n.dbl();
  return n;
};
var W7 = v1(function (t) {
    typeof Object.create == "function"
      ? (t.exports = function (n, r) {
          r &&
            ((n.super_ = r),
            (n.prototype = Object.create(r.prototype, {
              constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (t.exports = function (n, r) {
          if (r) {
            n.super_ = r;
            var i = function () {};
            (i.prototype = r.prototype),
              (n.prototype = new i()),
              (n.prototype.constructor = n);
          }
        });
  }),
  lfe = Bo.assert;
function xl(t) {
  Bh.call(this, "short", t),
    (this.a = new bn(t.a, 16).toRed(this.red)),
    (this.b = new bn(t.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(t)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
W7(xl, Bh);
var ufe = xl;
xl.prototype._getEndomorphism = function (e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, r;
    if (e.beta) n = new bn(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      (n = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (n = n.toRed(this.red));
    }
    if (e.lambda) r = new bn(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(n)) === 0
        ? (r = s[0])
        : ((r = s[1]), lfe(this.g.mul(r).x.cmp(this.g.x.redMul(n)) === 0));
    }
    var a;
    return (
      e.basis
        ? (a = e.basis.map(function (o) {
            return { a: new bn(o.a, 16), b: new bn(o.b, 16) };
          }))
        : (a = this._getEndoBasis(r)),
      { beta: n, lambda: r, basis: a }
    );
  }
};
xl.prototype._getEndoRoots = function (e) {
  var n = e === this.p ? this.red : bn.mont(e),
    r = new bn(2).toRed(n).redInvm(),
    i = r.redNeg(),
    s = new bn(3).toRed(n).redNeg().redSqrt().redMul(r),
    a = i.redAdd(s).fromRed(),
    o = i.redSub(s).fromRed();
  return [a, o];
};
xl.prototype._getEndoBasis = function (e) {
  for (
    var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
      r = e,
      i = this.n.clone(),
      s = new bn(1),
      a = new bn(0),
      o = new bn(0),
      l = new bn(1),
      u,
      f,
      c,
      d,
      p,
      m,
      g,
      w = 0,
      y,
      v;
    r.cmpn(0) !== 0;

  ) {
    var E = i.div(r);
    (y = i.sub(E.mul(r))), (v = o.sub(E.mul(s)));
    var S = l.sub(E.mul(a));
    if (!c && y.cmp(n) < 0) (u = g.neg()), (f = s), (c = y.neg()), (d = v);
    else if (c && ++w === 2) break;
    (g = y), (i = r), (r = y), (o = s), (s = v), (l = a), (a = S);
  }
  (p = y.neg()), (m = v);
  var D = c.sqr().add(d.sqr()),
    P = p.sqr().add(m.sqr());
  return (
    P.cmp(D) >= 0 && ((p = u), (m = f)),
    c.negative && ((c = c.neg()), (d = d.neg())),
    p.negative && ((p = p.neg()), (m = m.neg())),
    [
      { a: c, b: d },
      { a: p, b: m },
    ]
  );
};
xl.prototype._endoSplit = function (e) {
  var n = this.endo.basis,
    r = n[0],
    i = n[1],
    s = i.b.mul(e).divRound(this.n),
    a = r.b.neg().mul(e).divRound(this.n),
    o = s.mul(r.a),
    l = a.mul(i.a),
    u = s.mul(r.b),
    f = a.mul(i.b),
    c = e.sub(o).sub(l),
    d = u.add(f).neg();
  return { k1: c, k2: d };
};
xl.prototype.pointFromX = function (e, n) {
  (e = new bn(e, 16)), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
    i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return ((n && !s) || (!n && s)) && (i = i.redNeg()), this.point(e, i);
};
xl.prototype.validate = function (e) {
  if (e.inf) return !0;
  var n = e.x,
    r = e.y,
    i = this.a.redMul(n),
    s = n.redSqr().redMul(n).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0;
};
xl.prototype._endoWnafMulAdd = function (e, n, r) {
  for (
    var i = this._endoWnafT1, s = this._endoWnafT2, a = 0;
    a < e.length;
    a++
  ) {
    var o = this._endoSplit(n[a]),
      l = e[a],
      u = l._getBeta();
    o.k1.negative && (o.k1.ineg(), (l = l.neg(!0))),
      o.k2.negative && (o.k2.ineg(), (u = u.neg(!0))),
      (i[a * 2] = l),
      (i[a * 2 + 1] = u),
      (s[a * 2] = o.k1),
      (s[a * 2 + 1] = o.k2);
  }
  for (var f = this._wnafMulAdd(1, i, s, a * 2, r), c = 0; c < a * 2; c++)
    (i[c] = null), (s[c] = null);
  return f;
};
function Cs(t, e, n, r) {
  Bh.BasePoint.call(this, t, "affine"),
    e === null && n === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new bn(e, 16)),
        (this.y = new bn(n, 16)),
        r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
W7(Cs, Bh.BasePoint);
xl.prototype.point = function (e, n, r) {
  return new Cs(this, e, n, r);
};
xl.prototype.pointFromJSON = function (e, n) {
  return Cs.fromJSON(this, e, n);
};
Cs.prototype._getBeta = function () {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve,
        i = function (s) {
          return r.point(s.x.redMul(r.endo.beta), s.y);
        };
      (e.beta = n),
        (n.precomputed = {
          beta: null,
          naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(i),
          },
        });
    }
    return n;
  }
};
Cs.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
Cs.fromJSON = function (e, n, r) {
  typeof n == "string" && (n = JSON.parse(n));
  var i = e.point(n[0], n[1], r);
  if (!n[2]) return i;
  function s(o) {
    return e.point(o[0], o[1], r);
  }
  var a = n[2];
  return (
    (i.precomputed = {
      beta: null,
      doubles: a.doubles && {
        step: a.doubles.step,
        points: [i].concat(a.doubles.points.map(s)),
      },
      naf: a.naf && { wnd: a.naf.wnd, points: [i].concat(a.naf.points.map(s)) },
    }),
    i
  );
};
Cs.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC Point Infinity>"
    : "<EC Point x: " +
        this.x.fromRed().toString(16, 2) +
        " y: " +
        this.y.fromRed().toString(16, 2) +
        ">";
};
Cs.prototype.isInfinity = function () {
  return this.inf;
};
Cs.prototype.add = function (e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var n = this.y.redSub(e.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()));
  var r = n.redSqr().redISub(this.x).redISub(e.x),
    i = n.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i);
};
Cs.prototype.dbl = function () {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var n = this.curve.a,
    r = this.x.redSqr(),
    i = e.redInvm(),
    s = r.redAdd(r).redIAdd(r).redIAdd(n).redMul(i),
    a = s.redSqr().redISub(this.x.redAdd(this.x)),
    o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
Cs.prototype.getX = function () {
  return this.x.fromRed();
};
Cs.prototype.getY = function () {
  return this.y.fromRed();
};
Cs.prototype.mul = function (e) {
  return (
    (e = new bn(e, 16)),
    this.isInfinity()
      ? this
      : this._hasDoubles(e)
      ? this.curve._fixedNafMul(this, e)
      : this.curve.endo
      ? this.curve._endoWnafMulAdd([this], [e])
      : this.curve._wnafMul(this, e)
  );
};
Cs.prototype.mulAdd = function (e, n, r) {
  var i = [this, n],
    s = [e, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, s)
    : this.curve._wnafMulAdd(1, i, s, 2);
};
Cs.prototype.jmulAdd = function (e, n, r) {
  var i = [this, n],
    s = [e, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, s, !0)
    : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Cs.prototype.eq = function (e) {
  return (
    this === e ||
    (this.inf === e.inf &&
      (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
  );
};
Cs.prototype.neg = function (e) {
  if (this.inf) return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed,
      i = function (s) {
        return s.neg();
      };
    n.precomputed = {
      naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(i) },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i),
      },
    };
  }
  return n;
};
Cs.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Ms(t, e, n, r) {
  Bh.BasePoint.call(this, t, "jacobian"),
    e === null && n === null && r === null
      ? ((this.x = this.curve.one),
        (this.y = this.curve.one),
        (this.z = new bn(0)))
      : ((this.x = new bn(e, 16)),
        (this.y = new bn(n, 16)),
        (this.z = new bn(r, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
W7(Ms, Bh.BasePoint);
xl.prototype.jpoint = function (e, n, r) {
  return new Ms(this, e, n, r);
};
Ms.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(),
    n = e.redSqr(),
    r = this.x.redMul(n),
    i = this.y.redMul(n).redMul(e);
  return this.curve.point(r, i);
};
Ms.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Ms.prototype.add = function (e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var n = e.z.redSqr(),
    r = this.z.redSqr(),
    i = this.x.redMul(n),
    s = e.x.redMul(r),
    a = this.y.redMul(n.redMul(e.z)),
    o = e.y.redMul(r.redMul(this.z)),
    l = i.redSub(s),
    u = a.redSub(o);
  if (l.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var f = l.redSqr(),
    c = f.redMul(l),
    d = i.redMul(f),
    p = u.redSqr().redIAdd(c).redISub(d).redISub(d),
    m = u.redMul(d.redISub(p)).redISub(a.redMul(c)),
    g = this.z.redMul(e.z).redMul(l);
  return this.curve.jpoint(p, m, g);
};
Ms.prototype.mixedAdd = function (e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var n = this.z.redSqr(),
    r = this.x,
    i = e.x.redMul(n),
    s = this.y,
    a = e.y.redMul(n).redMul(this.z),
    o = r.redSub(i),
    l = s.redSub(a);
  if (o.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var u = o.redSqr(),
    f = u.redMul(o),
    c = r.redMul(u),
    d = l.redSqr().redIAdd(f).redISub(c).redISub(c),
    p = l.redMul(c.redISub(d)).redISub(s.redMul(f)),
    m = this.z.redMul(o);
  return this.curve.jpoint(d, p, m);
};
Ms.prototype.dblp = function (e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (n = 0; n < e; n++) r = r.dbl();
    return r;
  }
  var i = this.curve.a,
    s = this.curve.tinv,
    a = this.x,
    o = this.y,
    l = this.z,
    u = l.redSqr().redSqr(),
    f = o.redAdd(o);
  for (n = 0; n < e; n++) {
    var c = a.redSqr(),
      d = f.redSqr(),
      p = d.redSqr(),
      m = c.redAdd(c).redIAdd(c).redIAdd(i.redMul(u)),
      g = a.redMul(d),
      w = m.redSqr().redISub(g.redAdd(g)),
      y = g.redISub(w),
      v = m.redMul(y);
    v = v.redIAdd(v).redISub(p);
    var E = f.redMul(l);
    n + 1 < e && (u = u.redMul(p)), (a = w), (l = E), (f = v);
  }
  return this.curve.jpoint(a, f.redMul(s), l);
};
Ms.prototype.dbl = function () {
  return this.isInfinity()
    ? this
    : this.curve.zeroA
    ? this._zeroDbl()
    : this.curve.threeA
    ? this._threeDbl()
    : this._dbl();
};
Ms.prototype._zeroDbl = function () {
  var e, n, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var l = i.redAdd(i).redIAdd(i),
      u = l.redSqr().redISub(o).redISub(o),
      f = a.redIAdd(a);
    (f = f.redIAdd(f)),
      (f = f.redIAdd(f)),
      (e = u),
      (n = l.redMul(o.redISub(u)).redISub(f)),
      (r = this.y.redAdd(this.y));
  } else {
    var c = this.x.redSqr(),
      d = this.y.redSqr(),
      p = d.redSqr(),
      m = this.x.redAdd(d).redSqr().redISub(c).redISub(p);
    m = m.redIAdd(m);
    var g = c.redAdd(c).redIAdd(c),
      w = g.redSqr(),
      y = p.redIAdd(p);
    (y = y.redIAdd(y)),
      (y = y.redIAdd(y)),
      (e = w.redISub(m).redISub(m)),
      (n = g.redMul(m.redISub(e)).redISub(y)),
      (r = this.y.redMul(this.z)),
      (r = r.redIAdd(r));
  }
  return this.curve.jpoint(e, n, r);
};
Ms.prototype._threeDbl = function () {
  var e, n, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
      u = l.redSqr().redISub(o).redISub(o);
    e = u;
    var f = a.redIAdd(a);
    (f = f.redIAdd(f)),
      (f = f.redIAdd(f)),
      (n = l.redMul(o.redISub(u)).redISub(f)),
      (r = this.y.redAdd(this.y));
  } else {
    var c = this.z.redSqr(),
      d = this.y.redSqr(),
      p = this.x.redMul(d),
      m = this.x.redSub(c).redMul(this.x.redAdd(c));
    m = m.redAdd(m).redIAdd(m);
    var g = p.redIAdd(p);
    g = g.redIAdd(g);
    var w = g.redAdd(g);
    (e = m.redSqr().redISub(w)),
      (r = this.y.redAdd(this.z).redSqr().redISub(d).redISub(c));
    var y = d.redSqr();
    (y = y.redIAdd(y)),
      (y = y.redIAdd(y)),
      (y = y.redIAdd(y)),
      (n = m.redMul(g.redISub(e)).redISub(y));
  }
  return this.curve.jpoint(e, n, r);
};
Ms.prototype._dbl = function () {
  var e = this.curve.a,
    n = this.x,
    r = this.y,
    i = this.z,
    s = i.redSqr().redSqr(),
    a = n.redSqr(),
    o = r.redSqr(),
    l = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)),
    u = n.redAdd(n);
  u = u.redIAdd(u);
  var f = u.redMul(o),
    c = l.redSqr().redISub(f.redAdd(f)),
    d = f.redISub(c),
    p = o.redSqr();
  (p = p.redIAdd(p)), (p = p.redIAdd(p)), (p = p.redIAdd(p));
  var m = l.redMul(d).redISub(p),
    g = r.redAdd(r).redMul(i);
  return this.curve.jpoint(c, m, g);
};
Ms.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(),
    n = this.y.redSqr(),
    r = this.z.redSqr(),
    i = n.redSqr(),
    s = e.redAdd(e).redIAdd(e),
    a = s.redSqr(),
    o = this.x.redAdd(n).redSqr().redISub(e).redISub(i);
  (o = o.redIAdd(o)), (o = o.redAdd(o).redIAdd(o)), (o = o.redISub(a));
  var l = o.redSqr(),
    u = i.redIAdd(i);
  (u = u.redIAdd(u)), (u = u.redIAdd(u)), (u = u.redIAdd(u));
  var f = s.redIAdd(o).redSqr().redISub(a).redISub(l).redISub(u),
    c = n.redMul(f);
  (c = c.redIAdd(c)), (c = c.redIAdd(c));
  var d = this.x.redMul(l).redISub(c);
  (d = d.redIAdd(d)), (d = d.redIAdd(d));
  var p = this.y.redMul(f.redMul(u.redISub(f)).redISub(o.redMul(l)));
  (p = p.redIAdd(p)), (p = p.redIAdd(p)), (p = p.redIAdd(p));
  var m = this.z.redAdd(o).redSqr().redISub(r).redISub(l);
  return this.curve.jpoint(d, p, m);
};
Ms.prototype.mul = function (e, n) {
  return (e = new bn(e, n)), this.curve._wnafMul(this, e);
};
Ms.prototype.eq = function (e) {
  if (e.type === "affine") return this.eq(e.toJ());
  if (this === e) return !0;
  var n = this.z.redSqr(),
    r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(n)).cmpn(0) !== 0) return !1;
  var i = n.redMul(this.z),
    s = r.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
Ms.prototype.eqXToP = function (e) {
  var n = this.z.redSqr(),
    r = e.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(r) === 0) return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(n); ; ) {
    if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1;
    if ((r.redIAdd(s), this.x.cmp(r) === 0)) return !0;
  }
};
Ms.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC JPoint Infinity>"
    : "<EC JPoint x: " +
        this.x.toString(16, 2) +
        " y: " +
        this.y.toString(16, 2) +
        " z: " +
        this.z.toString(16, 2) +
        ">";
};
Ms.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0;
};
var rb = v1(function (t, e) {
    var n = e;
    (n.base = Bh), (n.short = ufe), (n.mont = null), (n.edwards = null);
  }),
  ib = v1(function (t, e) {
    var n = e,
      r = Bo.assert;
    function i(o) {
      o.type === "short"
        ? (this.curve = new rb.short(o))
        : o.type === "edwards"
        ? (this.curve = new rb.edwards(o))
        : (this.curve = new rb.mont(o)),
        (this.g = this.curve.g),
        (this.n = this.curve.n),
        (this.hash = o.hash),
        r(this.g.validate(), "Invalid curve"),
        r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    n.PresetCurve = i;
    function s(o, l) {
      Object.defineProperty(n, o, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var u = new i(l);
          return (
            Object.defineProperty(n, o, {
              configurable: !0,
              enumerable: !0,
              value: u,
            }),
            u
          );
        },
      });
    }
    s("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Ou.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811",
      ],
    }),
      s("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: Ou.sha256,
        gRed: !1,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
        ],
      }),
      s("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: Ou.sha256,
        gRed: !1,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
        ],
      }),
      s("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: Ou.sha384,
        gRed: !1,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
        ],
      }),
      s("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: Ou.sha512,
        gRed: !1,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
        ],
      }),
      s("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Ou.sha256,
        gRed: !1,
        g: ["9"],
      }),
      s("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Ou.sha256,
        gRed: !1,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658",
        ],
      });
    var a;
    try {
      a = null.crash();
    } catch {
      a = void 0;
    }
    s("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Ou.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda:
        "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3",
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15",
        },
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        a,
      ],
    });
  });
function ld(t) {
  if (!(this instanceof ld)) return new ld(t);
  (this.hash = t.hash),
    (this.predResist = !!t.predResist),
    (this.outLen = this.hash.outSize),
    (this.minEntropy = t.minEntropy || this.hash.hmacStrength),
    (this._reseed = null),
    (this.reseedInterval = null),
    (this.K = null),
    (this.V = null);
  var e = Jl.toArray(t.entropy, t.entropyEnc || "hex"),
    n = Jl.toArray(t.nonce, t.nonceEnc || "hex"),
    r = Jl.toArray(t.pers, t.persEnc || "hex");
  G7(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ),
    this._init(e, n, r);
}
var sH = ld;
ld.prototype._init = function (e, n, r) {
  var i = e.concat(n).concat(r);
  (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
  for (var s = 0; s < this.V.length; s++) (this.K[s] = 0), (this.V[s] = 1);
  this._update(i), (this._reseed = 1), (this.reseedInterval = 281474976710656);
};
ld.prototype._hmac = function () {
  return new Ou.hmac(this.hash, this.K);
};
ld.prototype._update = function (e) {
  var n = this._hmac().update(this.V).update([0]);
  e && (n = n.update(e)),
    (this.K = n.digest()),
    (this.V = this._hmac().update(this.V).digest()),
    e &&
      ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()),
      (this.V = this._hmac().update(this.V).digest()));
};
ld.prototype.reseed = function (e, n, r, i) {
  typeof n != "string" && ((i = r), (r = n), (n = null)),
    (e = Jl.toArray(e, n)),
    (r = Jl.toArray(r, i)),
    G7(
      e.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ),
    this._update(e.concat(r || [])),
    (this._reseed = 1);
};
ld.prototype.generate = function (e, n, r, i) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof n != "string" && ((i = r), (r = n), (n = null)),
    r && ((r = Jl.toArray(r, i || "hex")), this._update(r));
  for (var s = []; s.length < e; )
    (this.V = this._hmac().update(this.V).digest()), (s = s.concat(this.V));
  var a = s.slice(0, e);
  return this._update(r), this._reseed++, Jl.encode(a, n);
};
var IE = Bo.assert;
function ia(t, e) {
  (this.ec = t),
    (this.priv = null),
    (this.pub = null),
    e.priv && this._importPrivate(e.priv, e.privEnc),
    e.pub && this._importPublic(e.pub, e.pubEnc);
}
var q7 = ia;
ia.fromPublic = function (e, n, r) {
  return n instanceof ia ? n : new ia(e, { pub: n, pubEnc: r });
};
ia.fromPrivate = function (e, n, r) {
  return n instanceof ia ? n : new ia(e, { priv: n, privEnc: r });
};
ia.prototype.validate = function () {
  var e = this.getPublic();
  return e.isInfinity()
    ? { result: !1, reason: "Invalid public key" }
    : e.validate()
    ? e.mul(this.ec.curve.n).isInfinity()
      ? { result: !0, reason: null }
      : { result: !1, reason: "Public key * N != O" }
    : { result: !1, reason: "Public key is not a point" };
};
ia.prototype.getPublic = function (e, n) {
  return (
    typeof e == "string" && ((n = e), (e = null)),
    this.pub || (this.pub = this.ec.g.mul(this.priv)),
    n ? this.pub.encode(n, e) : this.pub
  );
};
ia.prototype.getPrivate = function (e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
ia.prototype._importPrivate = function (e, n) {
  (this.priv = new bn(e, n || 16)),
    (this.priv = this.priv.umod(this.ec.curve.n));
};
ia.prototype._importPublic = function (e, n) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont"
      ? IE(e.x, "Need x coordinate")
      : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") &&
        IE(e.x && e.y, "Need both x and y coordinate"),
      (this.pub = this.ec.curve.point(e.x, e.y));
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, n);
};
ia.prototype.derive = function (e) {
  return (
    e.validate() || IE(e.validate(), "public point not validated"),
    e.mul(this.priv).getX()
  );
};
ia.prototype.sign = function (e, n, r) {
  return this.ec.sign(e, this, n, r);
};
ia.prototype.verify = function (e, n) {
  return this.ec.verify(e, n, this);
};
ia.prototype.inspect = function () {
  return (
    "<Key priv: " +
    (this.priv && this.priv.toString(16, 2)) +
    " pub: " +
    (this.pub && this.pub.inspect()) +
    " >"
  );
};
var cfe = Bo.assert;
function Lw(t, e) {
  if (t instanceof Lw) return t;
  this._importDER(t, e) ||
    (cfe(t.r && t.s, "Signature without r or s"),
    (this.r = new bn(t.r, 16)),
    (this.s = new bn(t.s, 16)),
    t.recoveryParam === void 0
      ? (this.recoveryParam = null)
      : (this.recoveryParam = t.recoveryParam));
}
var Bw = Lw;
function ffe() {
  this.place = 0;
}
function z_(t, e) {
  var n = t[e.place++];
  if (!(n & 128)) return n;
  var r = n & 15;
  if (r === 0 || r > 4) return !1;
  for (var i = 0, s = 0, a = e.place; s < r; s++, a++)
    (i <<= 8), (i |= t[a]), (i >>>= 0);
  return i <= 127 ? !1 : ((e.place = a), i);
}
function uO(t) {
  for (var e = 0, n = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < n; ) e++;
  return e === 0 ? t : t.slice(e);
}
Lw.prototype._importDER = function (e, n) {
  e = Bo.toArray(e, n);
  var r = new ffe();
  if (e[r.place++] !== 48) return !1;
  var i = z_(e, r);
  if (i === !1 || i + r.place !== e.length || e[r.place++] !== 2) return !1;
  var s = z_(e, r);
  if (s === !1) return !1;
  var a = e.slice(r.place, s + r.place);
  if (((r.place += s), e[r.place++] !== 2)) return !1;
  var o = z_(e, r);
  if (o === !1 || e.length !== o + r.place) return !1;
  var l = e.slice(r.place, o + r.place);
  if (a[0] === 0)
    if (a[1] & 128) a = a.slice(1);
    else return !1;
  if (l[0] === 0)
    if (l[1] & 128) l = l.slice(1);
    else return !1;
  return (
    (this.r = new bn(a)), (this.s = new bn(l)), (this.recoveryParam = null), !0
  );
};
function V_(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var n = 1 + ((Math.log(e) / Math.LN2) >>> 3);
  for (t.push(n | 128); --n; ) t.push((e >>> (n << 3)) & 255);
  t.push(e);
}
Lw.prototype.toDER = function (e) {
  var n = this.r.toArray(),
    r = this.s.toArray();
  for (
    n[0] & 128 && (n = [0].concat(n)),
      r[0] & 128 && (r = [0].concat(r)),
      n = uO(n),
      r = uO(r);
    !r[0] && !(r[1] & 128);

  )
    r = r.slice(1);
  var i = [2];
  V_(i, n.length), (i = i.concat(n)), i.push(2), V_(i, r.length);
  var s = i.concat(r),
    a = [48];
  return V_(a, s.length), (a = a.concat(s)), Bo.encode(a, e);
};
var dfe = function () {
    throw new Error("unsupported");
  },
  aH = Bo.assert;
function yl(t) {
  if (!(this instanceof yl)) return new yl(t);
  typeof t == "string" &&
    (aH(Object.prototype.hasOwnProperty.call(ib, t), "Unknown curve " + t),
    (t = ib[t])),
    t instanceof ib.PresetCurve && (t = { curve: t }),
    (this.curve = t.curve.curve),
    (this.n = this.curve.n),
    (this.nh = this.n.ushrn(1)),
    (this.g = this.curve.g),
    (this.g = t.curve.g),
    this.g.precompute(t.curve.n.bitLength() + 1),
    (this.hash = t.hash || t.curve.hash);
}
var hfe = yl;
yl.prototype.keyPair = function (e) {
  return new q7(this, e);
};
yl.prototype.keyFromPrivate = function (e, n) {
  return q7.fromPrivate(this, e, n);
};
yl.prototype.keyFromPublic = function (e, n) {
  return q7.fromPublic(this, e, n);
};
yl.prototype.genKeyPair = function (e) {
  e || (e = {});
  for (
    var n = new sH({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || "utf8",
        entropy: e.entropy || dfe(this.hash.hmacStrength),
        entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
        nonce: this.n.toArray(),
      }),
      r = this.n.byteLength(),
      i = this.n.sub(new bn(2));
    ;

  ) {
    var s = new bn(n.generate(r));
    if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s);
  }
};
yl.prototype._truncateToN = function (e, n) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return (
    r > 0 && (e = e.ushrn(r)), !n && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
  );
};
yl.prototype.sign = function (e, n, r, i) {
  typeof r == "object" && ((i = r), (r = null)),
    i || (i = {}),
    (n = this.keyFromPrivate(n, r)),
    (e = this._truncateToN(new bn(e, 16)));
  for (
    var s = this.n.byteLength(),
      a = n.getPrivate().toArray("be", s),
      o = e.toArray("be", s),
      l = new sH({
        hash: this.hash,
        entropy: a,
        nonce: o,
        pers: i.pers,
        persEnc: i.persEnc || "utf8",
      }),
      u = this.n.sub(new bn(1)),
      f = 0;
    ;
    f++
  ) {
    var c = i.k ? i.k(f) : new bn(l.generate(this.n.byteLength()));
    if (((c = this._truncateToN(c, !0)), !(c.cmpn(1) <= 0 || c.cmp(u) >= 0))) {
      var d = this.g.mul(c);
      if (!d.isInfinity()) {
        var p = d.getX(),
          m = p.umod(this.n);
        if (m.cmpn(0) !== 0) {
          var g = c.invm(this.n).mul(m.mul(n.getPrivate()).iadd(e));
          if (((g = g.umod(this.n)), g.cmpn(0) !== 0)) {
            var w = (d.getY().isOdd() ? 1 : 0) | (p.cmp(m) !== 0 ? 2 : 0);
            return (
              i.canonical &&
                g.cmp(this.nh) > 0 &&
                ((g = this.n.sub(g)), (w ^= 1)),
              new Bw({ r: m, s: g, recoveryParam: w })
            );
          }
        }
      }
    }
  }
};
yl.prototype.verify = function (e, n, r, i) {
  (e = this._truncateToN(new bn(e, 16))),
    (r = this.keyFromPublic(r, i)),
    (n = new Bw(n, "hex"));
  var s = n.r,
    a = n.s;
  if (
    s.cmpn(1) < 0 ||
    s.cmp(this.n) >= 0 ||
    a.cmpn(1) < 0 ||
    a.cmp(this.n) >= 0
  )
    return !1;
  var o = a.invm(this.n),
    l = o.mul(e).umod(this.n),
    u = o.mul(s).umod(this.n),
    f;
  return this.curve._maxwellTrick
    ? ((f = this.g.jmulAdd(l, r.getPublic(), u)),
      f.isInfinity() ? !1 : f.eqXToP(s))
    : ((f = this.g.mulAdd(l, r.getPublic(), u)),
      f.isInfinity() ? !1 : f.getX().umod(this.n).cmp(s) === 0);
};
yl.prototype.recoverPubKey = function (t, e, n, r) {
  aH((3 & n) === n, "The recovery param is more than two bits"),
    (e = new Bw(e, r));
  var i = this.n,
    s = new bn(t),
    a = e.r,
    o = e.s,
    l = n & 1,
    u = n >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u)
    throw new Error("Unable to find sencond key candinate");
  u
    ? (a = this.curve.pointFromX(a.add(this.curve.n), l))
    : (a = this.curve.pointFromX(a, l));
  var f = e.r.invm(i),
    c = i.sub(s).mul(f).umod(i),
    d = o.mul(f).umod(i);
  return this.g.mulAdd(c, a, d);
};
yl.prototype.getKeyRecoveryParam = function (t, e, n, r) {
  if (((e = new Bw(e, r)), e.recoveryParam !== null)) return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(n)) return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var pfe = v1(function (t, e) {
    var n = e;
    (n.version = "6.5.4"),
      (n.utils = Bo),
      (n.rand = function () {
        throw new Error("unsupported");
      }),
      (n.curve = rb),
      (n.curves = ib),
      (n.ec = hfe),
      (n.eddsa = null);
  }),
  mfe = pfe.ec;
const gfe = "signing-key/5.5.0",
  oH = new Se(gfe);
let G_ = null;
function Du() {
  return G_ || (G_ = new mfe("secp256k1")), G_;
}
let yfe = class {
  constructor(e) {
    Je(this, "curve", "secp256k1"), Je(this, "privateKey", Qt(e));
    const n = Du().keyFromPrivate(hn(this.privateKey));
    Je(this, "publicKey", "0x" + n.getPublic(!1, "hex")),
      Je(this, "compressedPublicKey", "0x" + n.getPublic(!0, "hex")),
      Je(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const n = Du().keyFromPublic(hn(this.publicKey)),
      r = Du().keyFromPublic(hn(e));
    return "0x" + n.pub.add(r.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const n = Du().keyFromPrivate(hn(this.privateKey)),
      r = hn(e);
    r.length !== 32 && oH.throwArgumentError("bad digest length", "digest", e);
    const i = n.sign(r, { canonical: !0 });
    return Nw({
      recoveryParam: i.recoveryParam,
      r: Ni("0x" + i.r.toString(16), 32),
      s: Ni("0x" + i.s.toString(16), 32),
    });
  }
  computeSharedSecret(e) {
    const n = Du().keyFromPrivate(hn(this.privateKey)),
      r = Du().keyFromPublic(hn(lH(e)));
    return Ni("0x" + n.derive(r.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
};
function vfe(t, e) {
  const n = Nw(e),
    r = { r: hn(n.r), s: hn(n.s) };
  return "0x" + Du().recoverPubKey(hn(t), r, n.recoveryParam).encode("hex", !1);
}
function lH(t, e) {
  const n = hn(t);
  if (n.length === 32) {
    const r = new yfe(n);
    return e ? "0x" + Du().keyFromPrivate(n).getPublic(!0, "hex") : r.publicKey;
  } else {
    if (n.length === 33)
      return e ? Qt(n) : "0x" + Du().keyFromPublic(n).getPublic(!1, "hex");
    if (n.length === 65)
      return e ? "0x" + Du().keyFromPublic(n).getPublic(!0, "hex") : Qt(n);
  }
  return oH.throwArgumentError(
    "invalid public or private key",
    "key",
    "[REDACTED]"
  );
}
const bfe = "transactions/5.5.0",
  of = new Se(bfe);
var cO;
(function (t) {
  (t[(t.legacy = 0)] = "legacy"),
    (t[(t.eip2930 = 1)] = "eip2930"),
    (t[(t.eip1559 = 2)] = "eip1559");
})(cO || (cO = {}));
function K7(t) {
  return t === "0x" ? null : As(t);
}
function ea(t) {
  return t === "0x" ? Cj : dt.from(t);
}
function wfe(t) {
  const e = lH(t);
  return As(jc(Ji(jc(e, 1)), 12));
}
function uH(t, e) {
  return wfe(vfe(hn(t), e));
}
function Co(t, e) {
  const n = F0(dt.from(t).toHexString());
  return (
    n.length > 32 &&
      of.throwArgumentError("invalid length for " + e, "transaction:" + e, t),
    n
  );
}
function W_(t, e) {
  return {
    address: As(t),
    storageKeys: (e || []).map(
      (n, r) => (
        xy(n) !== 32 &&
          of.throwArgumentError(
            "invalid access list storageKey",
            `accessList[${t}:${r}]`,
            n
          ),
        n.toLowerCase()
      )
    ),
  };
}
function b1(t) {
  if (Array.isArray(t))
    return t.map((n, r) =>
      Array.isArray(n)
        ? (n.length > 2 &&
            of.throwArgumentError(
              "access list expected to be [ address, storageKeys[] ]",
              `value[${r}]`,
              n
            ),
          W_(n[0], n[1]))
        : W_(n.address, n.storageKeys)
    );
  const e = Object.keys(t).map((n) => {
    const r = t[n].reduce((i, s) => ((i[s] = !0), i), {});
    return W_(n, Object.keys(r).sort());
  });
  return e.sort((n, r) => n.address.localeCompare(r.address)), e;
}
function cH(t) {
  return b1(t).map((e) => [e.address, e.storageKeys]);
}
function _fe(t, e) {
  if (t.gasPrice != null) {
    const r = dt.from(t.gasPrice),
      i = dt.from(t.maxFeePerGas || 0);
    r.eq(i) ||
      of.throwArgumentError(
        "mismatch EIP-1559 gasPrice != maxFeePerGas",
        "tx",
        { gasPrice: r, maxFeePerGas: i }
      );
  }
  const n = [
    Co(t.chainId || 0, "chainId"),
    Co(t.nonce || 0, "nonce"),
    Co(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Co(t.maxFeePerGas || 0, "maxFeePerGas"),
    Co(t.gasLimit || 0, "gasLimit"),
    t.to != null ? As(t.to) : "0x",
    Co(t.value || 0, "value"),
    t.data || "0x",
    cH(t.accessList || []),
  ];
  if (e) {
    const r = Nw(e);
    n.push(Co(r.recoveryParam, "recoveryParam")),
      n.push(F0(r.r)),
      n.push(F0(r.s));
  }
  return Ql(["0x02", Rw(n)]);
}
function Efe(t, e) {
  const n = [
    Co(t.chainId || 0, "chainId"),
    Co(t.nonce || 0, "nonce"),
    Co(t.gasPrice || 0, "gasPrice"),
    Co(t.gasLimit || 0, "gasLimit"),
    t.to != null ? As(t.to) : "0x",
    Co(t.value || 0, "value"),
    t.data || "0x",
    cH(t.accessList || []),
  ];
  if (e) {
    const r = Nw(e);
    n.push(Co(r.recoveryParam, "recoveryParam")),
      n.push(F0(r.r)),
      n.push(F0(r.s));
  }
  return Ql(["0x01", Rw(n)]);
}
function fH(t, e, n) {
  try {
    const r = ea(e[0]).toNumber();
    if (r !== 0 && r !== 1) throw new Error("bad recid");
    t.v = r;
  } catch {
    of.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  (t.r = Ni(e[1], 32)), (t.s = Ni(e[2], 32));
  try {
    const r = Ji(n(t));
    t.from = uH(r, { r: t.r, s: t.s, recoveryParam: t.v });
  } catch (r) {
    console.log(r);
  }
}
function xfe(t) {
  const e = j7(t.slice(1));
  e.length !== 9 &&
    e.length !== 12 &&
    of.throwArgumentError(
      "invalid component count for transaction type: 2",
      "payload",
      Qt(t)
    );
  const n = ea(e[2]),
    r = ea(e[3]),
    i = {
      type: 2,
      chainId: ea(e[0]).toNumber(),
      nonce: ea(e[1]).toNumber(),
      maxPriorityFeePerGas: n,
      maxFeePerGas: r,
      gasPrice: null,
      gasLimit: ea(e[4]),
      to: K7(e[5]),
      value: ea(e[6]),
      data: e[7],
      accessList: b1(e[8]),
    };
  return e.length === 9 || ((i.hash = Ji(t)), fH(i, e.slice(9), _fe)), i;
}
function Tfe(t) {
  const e = j7(t.slice(1));
  e.length !== 8 &&
    e.length !== 11 &&
    of.throwArgumentError(
      "invalid component count for transaction type: 1",
      "payload",
      Qt(t)
    );
  const n = {
    type: 1,
    chainId: ea(e[0]).toNumber(),
    nonce: ea(e[1]).toNumber(),
    gasPrice: ea(e[2]),
    gasLimit: ea(e[3]),
    to: K7(e[4]),
    value: ea(e[5]),
    data: e[6],
    accessList: b1(e[7]),
  };
  return e.length === 8 || ((n.hash = Ji(t)), fH(n, e.slice(8), Efe)), n;
}
function Sfe(t) {
  const e = j7(t);
  e.length !== 9 &&
    e.length !== 6 &&
    of.throwArgumentError("invalid raw transaction", "rawTransaction", t);
  const n = {
    nonce: ea(e[0]).toNumber(),
    gasPrice: ea(e[1]),
    gasLimit: ea(e[2]),
    to: K7(e[3]),
    value: ea(e[4]),
    data: e[5],
    chainId: 0,
  };
  if (e.length === 6) return n;
  try {
    n.v = dt.from(e[6]).toNumber();
  } catch (r) {
    return console.log(r), n;
  }
  if (
    ((n.r = Ni(e[7], 32)),
    (n.s = Ni(e[8], 32)),
    dt.from(n.r).isZero() && dt.from(n.s).isZero())
  )
    (n.chainId = n.v), (n.v = 0);
  else {
    (n.chainId = Math.floor((n.v - 35) / 2)), n.chainId < 0 && (n.chainId = 0);
    let r = n.v - 27;
    const i = e.slice(0, 6);
    n.chainId !== 0 &&
      (i.push(Qt(n.chainId)),
      i.push("0x"),
      i.push("0x"),
      (r -= n.chainId * 2 + 8));
    const s = Ji(Rw(i));
    try {
      n.from = uH(s, { r: Qt(n.r), s: Qt(n.s), recoveryParam: r });
    } catch (a) {
      console.log(a);
    }
    n.hash = Ji(t);
  }
  return (n.type = null), n;
}
function Afe(t) {
  const e = hn(t);
  if (e[0] > 127) return Sfe(e);
  switch (e[0]) {
    case 1:
      return Tfe(e);
    case 2:
      return xfe(e);
  }
  return of.throwError(
    `unsupported transaction type: ${e[0]}`,
    Se.errors.UNSUPPORTED_OPERATION,
    { operation: "parseTransaction", transactionType: e[0] }
  );
}
const Cfe = "contracts/5.5.0";
var bh =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const yi = new Se(Cfe);
function h5(t, e) {
  return bh(this, void 0, void 0, function* () {
    const n = yield e;
    typeof n != "string" &&
      yi.throwArgumentError("invalid address or ENS name", "name", n);
    try {
      return As(n);
    } catch {}
    t ||
      yi.throwError(
        "a provider or signer is needed to resolve ENS names",
        Se.errors.UNSUPPORTED_OPERATION,
        { operation: "resolveName" }
      );
    const r = yield t.resolveName(n);
    return (
      r == null &&
        yi.throwArgumentError(
          "resolver or addr is not configured for ENS name",
          "name",
          n
        ),
      r
    );
  });
}
function sb(t, e, n) {
  return bh(this, void 0, void 0, function* () {
    return Array.isArray(n)
      ? yield Promise.all(
          n.map((r, i) => sb(t, Array.isArray(e) ? e[i] : e[r.name], r))
        )
      : n.type === "address"
      ? yield h5(t, e)
      : n.type === "tuple"
      ? yield sb(t, e, n.components)
      : n.baseType === "array"
      ? Array.isArray(e)
        ? yield Promise.all(e.map((r) => sb(t, r, n.arrayChildren)))
        : Promise.reject(
            yi.makeError(
              "invalid value for array",
              Se.errors.INVALID_ARGUMENT,
              { argument: "value", value: e }
            )
          )
      : e;
  });
}
function Fw(t, e, n) {
  return bh(this, void 0, void 0, function* () {
    let r = {};
    n.length === e.inputs.length + 1 &&
      typeof n[n.length - 1] == "object" &&
      (r = xs(n.pop())),
      yi.checkArgumentCount(n.length, e.inputs.length, "passed to contract"),
      t.signer
        ? r.from
          ? (r.from = Fi({
              override: h5(t.signer, r.from),
              signer: t.signer.getAddress(),
            }).then((u) =>
              bh(this, void 0, void 0, function* () {
                return (
                  As(u.signer) !== u.override &&
                    yi.throwError(
                      "Contract with a Signer cannot override from",
                      Se.errors.UNSUPPORTED_OPERATION,
                      { operation: "overrides.from" }
                    ),
                  u.override
                );
              })
            ))
          : (r.from = t.signer.getAddress())
        : r.from && (r.from = h5(t.provider, r.from));
    const i = yield Fi({
        args: sb(t.signer || t.provider, n, e.inputs),
        address: t.resolvedAddress,
        overrides: Fi(r) || {},
      }),
      s = t.interface.encodeFunctionData(e, i.args),
      a = { data: s, to: i.address },
      o = i.overrides;
    if (
      (o.nonce != null && (a.nonce = dt.from(o.nonce).toNumber()),
      o.gasLimit != null && (a.gasLimit = dt.from(o.gasLimit)),
      o.gasPrice != null && (a.gasPrice = dt.from(o.gasPrice)),
      o.maxFeePerGas != null && (a.maxFeePerGas = dt.from(o.maxFeePerGas)),
      o.maxPriorityFeePerGas != null &&
        (a.maxPriorityFeePerGas = dt.from(o.maxPriorityFeePerGas)),
      o.from != null && (a.from = o.from),
      o.type != null && (a.type = o.type),
      o.accessList != null && (a.accessList = b1(o.accessList)),
      a.gasLimit == null && e.gas != null)
    ) {
      let u = 21e3;
      const f = hn(s);
      for (let c = 0; c < f.length; c++) (u += 4), f[c] && (u += 64);
      a.gasLimit = dt.from(e.gas).add(u);
    }
    if (o.value) {
      const u = dt.from(o.value);
      !u.isZero() &&
        !e.payable &&
        yi.throwError(
          "non-payable method cannot override value",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "overrides.value", value: r.value }
        ),
        (a.value = u);
    }
    o.customData && (a.customData = xs(o.customData)),
      delete r.nonce,
      delete r.gasLimit,
      delete r.gasPrice,
      delete r.from,
      delete r.value,
      delete r.type,
      delete r.accessList,
      delete r.maxFeePerGas,
      delete r.maxPriorityFeePerGas,
      delete r.customData;
    const l = Object.keys(r).filter((u) => r[u] != null);
    return (
      l.length &&
        yi.throwError(
          `cannot override ${l.map((u) => JSON.stringify(u)).join(",")}`,
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "overrides", overrides: l }
        ),
      a
    );
  });
}
function kfe(t, e) {
  return function (...n) {
    return Fw(t, e, n);
  };
}
function Ife(t, e) {
  const n = t.signer || t.provider;
  return function (...r) {
    return bh(this, void 0, void 0, function* () {
      n ||
        yi.throwError(
          "estimate require a provider or signer",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "estimateGas" }
        );
      const i = yield Fw(t, e, r);
      return yield n.estimateGas(i);
    });
  };
}
function Ofe(t, e) {
  const n = e.wait.bind(e);
  e.wait = (r) =>
    n(r).then(
      (i) => (
        (i.events = i.logs.map((s) => {
          let a = Zc(s),
            o = null;
          try {
            o = t.interface.parseLog(s);
          } catch {}
          return (
            o &&
              ((a.args = o.args),
              (a.decode = (l, u) =>
                t.interface.decodeEventLog(o.eventFragment, l, u)),
              (a.event = o.name),
              (a.eventSignature = o.signature)),
            (a.removeListener = () => t.provider),
            (a.getBlock = () => t.provider.getBlock(i.blockHash)),
            (a.getTransaction = () =>
              t.provider.getTransaction(i.transactionHash)),
            (a.getTransactionReceipt = () => Promise.resolve(i)),
            a
          );
        })),
        i
      )
    );
}
function dH(t, e, n) {
  const r = t.signer || t.provider;
  return function (...i) {
    return bh(this, void 0, void 0, function* () {
      let s;
      if (
        i.length === e.inputs.length + 1 &&
        typeof i[i.length - 1] == "object"
      ) {
        const l = xs(i.pop());
        l.blockTag != null && (s = yield l.blockTag),
          delete l.blockTag,
          i.push(l);
      }
      t.deployTransaction != null && (yield t._deployed(s));
      const a = yield Fw(t, e, i),
        o = yield r.call(a, s);
      try {
        let l = t.interface.decodeFunctionResult(e, o);
        return n && e.outputs.length === 1 && (l = l[0]), l;
      } catch (l) {
        throw (
          (l.code === Se.errors.CALL_EXCEPTION &&
            ((l.address = t.address), (l.args = i), (l.transaction = a)),
          l)
        );
      }
    });
  };
}
function Pfe(t, e) {
  return function (...n) {
    return bh(this, void 0, void 0, function* () {
      t.signer ||
        yi.throwError(
          "sending a transaction requires a signer",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "sendTransaction" }
        ),
        t.deployTransaction != null && (yield t._deployed());
      const r = yield Fw(t, e, n),
        i = yield t.signer.sendTransaction(r);
      return Ofe(t, i), i;
    });
  };
}
function fO(t, e, n) {
  return e.constant ? dH(t, e, n) : Pfe(t, e);
}
function hH(t) {
  return t.address && (t.topics == null || t.topics.length === 0)
    ? "*"
    : (t.address || "*") +
        "@" +
        (t.topics
          ? t.topics.map((e) => (Array.isArray(e) ? e.join("|") : e)).join(":")
          : "");
}
class Vg {
  constructor(e, n) {
    Je(this, "tag", e), Je(this, "filter", n), (this._listeners = []);
  }
  addListener(e, n) {
    this._listeners.push({ listener: e, once: n });
  }
  removeListener(e) {
    let n = !1;
    this._listeners = this._listeners.filter((r) =>
      n || r.listener !== e ? !0 : ((n = !0), !1)
    );
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const n = this.listenerCount();
    return (
      (this._listeners = this._listeners.filter((r) => {
        const i = e.slice();
        return (
          setTimeout(() => {
            r.listener.apply(this, i);
          }, 0),
          !r.once
        );
      })),
      n
    );
  }
  prepareEvent(e) {}
  getEmit(e) {
    return [e];
  }
}
class Nfe extends Vg {
  constructor() {
    super("error", null);
  }
}
class dO extends Vg {
  constructor(e, n, r, i) {
    const s = { address: e };
    let a = n.getEventTopic(r);
    i
      ? (a !== i[0] && yi.throwArgumentError("topic mismatch", "topics", i),
        (s.topics = i.slice()))
      : (s.topics = [a]),
      super(hH(s), s),
      Je(this, "address", e),
      Je(this, "interface", n),
      Je(this, "fragment", r);
  }
  prepareEvent(e) {
    super.prepareEvent(e),
      (e.event = this.fragment.name),
      (e.eventSignature = this.fragment.format()),
      (e.decode = (n, r) => this.interface.decodeEventLog(this.fragment, n, r));
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (n) {
      (e.args = null), (e.decodeError = n);
    }
  }
  getEmit(e) {
    const n = xle(e.args);
    if (n.length) throw n[0].error;
    const r = (e.args || []).slice();
    return r.push(e), r;
  }
}
class hO extends Vg {
  constructor(e, n) {
    super("*", { address: e }),
      Je(this, "address", e),
      Je(this, "interface", n);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const n = this.interface.parseLog(e);
      (e.event = n.name),
        (e.eventSignature = n.signature),
        (e.decode = (r, i) =>
          this.interface.decodeEventLog(n.eventFragment, r, i)),
        (e.args = n.args);
    } catch {}
  }
}
let Dfe = class {
    constructor(e, n, r) {
      yi.checkNew(new.target, pH),
        Je(this, "interface", $u(new.target, "getInterface")(n)),
        r == null
          ? (Je(this, "provider", null), Je(this, "signer", null))
          : Ay.isSigner(r)
          ? (Je(this, "provider", r.provider || null), Je(this, "signer", r))
          : zg.isProvider(r)
          ? (Je(this, "provider", r), Je(this, "signer", null))
          : yi.throwArgumentError(
              "invalid signer or provider",
              "signerOrProvider",
              r
            ),
        Je(this, "callStatic", {}),
        Je(this, "estimateGas", {}),
        Je(this, "functions", {}),
        Je(this, "populateTransaction", {}),
        Je(this, "filters", {});
      {
        const a = {};
        Object.keys(this.interface.events).forEach((o) => {
          const l = this.interface.events[o];
          Je(this.filters, o, (...u) => ({
            address: this.address,
            topics: this.interface.encodeFilterTopics(l, u),
          })),
            a[l.name] || (a[l.name] = []),
            a[l.name].push(o);
        }),
          Object.keys(a).forEach((o) => {
            const l = a[o];
            l.length === 1
              ? Je(this.filters, o, this.filters[l[0]])
              : yi.warn(`Duplicate definition of ${o} (${l.join(", ")})`);
          });
      }
      if (
        (Je(this, "_runningEvents", {}),
        Je(this, "_wrappedEmits", {}),
        e == null &&
          yi.throwArgumentError(
            "invalid contract address or ENS name",
            "addressOrName",
            e
          ),
        Je(this, "address", e),
        this.provider)
      )
        Je(this, "resolvedAddress", h5(this.provider, e));
      else
        try {
          Je(this, "resolvedAddress", Promise.resolve(As(e)));
        } catch {
          yi.throwError(
            "provider is required to use ENS name as contract address",
            Se.errors.UNSUPPORTED_OPERATION,
            { operation: "new Contract" }
          );
        }
      const i = {},
        s = {};
      Object.keys(this.interface.functions).forEach((a) => {
        const o = this.interface.functions[a];
        if (s[a]) {
          yi.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
          return;
        }
        s[a] = !0;
        {
          const l = o.name;
          i[`%${l}`] || (i[`%${l}`] = []), i[`%${l}`].push(a);
        }
        this[a] == null && Je(this, a, fO(this, o, !0)),
          this.functions[a] == null && Je(this.functions, a, fO(this, o, !1)),
          this.callStatic[a] == null && Je(this.callStatic, a, dH(this, o, !0)),
          this.populateTransaction[a] == null &&
            Je(this.populateTransaction, a, kfe(this, o)),
          this.estimateGas[a] == null && Je(this.estimateGas, a, Ife(this, o));
      }),
        Object.keys(i).forEach((a) => {
          const o = i[a];
          if (o.length > 1) return;
          a = a.substring(1);
          const l = o[0];
          try {
            this[a] == null && Je(this, a, this[l]);
          } catch {}
          this.functions[a] == null && Je(this.functions, a, this.functions[l]),
            this.callStatic[a] == null &&
              Je(this.callStatic, a, this.callStatic[l]),
            this.populateTransaction[a] == null &&
              Je(this.populateTransaction, a, this.populateTransaction[l]),
            this.estimateGas[a] == null &&
              Je(this.estimateGas, a, this.estimateGas[l]);
        });
    }
    static getContractAddress(e) {
      return xj(e);
    }
    static getInterface(e) {
      return iO.isInterface(e) ? e : new iO(e);
    }
    deployed() {
      return this._deployed();
    }
    _deployed(e) {
      return (
        this._deployedPromise ||
          (this.deployTransaction
            ? (this._deployedPromise = this.deployTransaction
                .wait()
                .then(() => this))
            : (this._deployedPromise = this.provider
                .getCode(this.address, e)
                .then(
                  (n) => (
                    n === "0x" &&
                      yi.throwError(
                        "contract not deployed",
                        Se.errors.UNSUPPORTED_OPERATION,
                        {
                          contractAddress: this.address,
                          operation: "getDeployed",
                        }
                      ),
                    this
                  )
                ))),
        this._deployedPromise
      );
    }
    fallback(e) {
      this.signer ||
        yi.throwError(
          "sending a transactions require a signer",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "sendTransaction(fallback)" }
        );
      const n = xs(e || {});
      return (
        ["from", "to"].forEach(function (r) {
          n[r] != null &&
            yi.throwError(
              "cannot override " + r,
              Se.errors.UNSUPPORTED_OPERATION,
              { operation: r }
            );
        }),
        (n.to = this.resolvedAddress),
        this.deployed().then(() => this.signer.sendTransaction(n))
      );
    }
    connect(e) {
      typeof e == "string" && (e = new c5(e, this.provider));
      const n = new this.constructor(this.address, this.interface, e);
      return (
        this.deployTransaction &&
          Je(n, "deployTransaction", this.deployTransaction),
        n
      );
    }
    attach(e) {
      return new this.constructor(
        e,
        this.interface,
        this.signer || this.provider
      );
    }
    static isIndexed(e) {
      return SE.isIndexed(e);
    }
    _normalizeRunningEvent(e) {
      return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
    }
    _getRunningEvent(e) {
      if (typeof e == "string") {
        if (e === "error") return this._normalizeRunningEvent(new Nfe());
        if (e === "event")
          return this._normalizeRunningEvent(new Vg("event", null));
        if (e === "*")
          return this._normalizeRunningEvent(
            new hO(this.address, this.interface)
          );
        const n = this.interface.getEvent(e);
        return this._normalizeRunningEvent(
          new dO(this.address, this.interface, n)
        );
      }
      if (e.topics && e.topics.length > 0) {
        try {
          const r = e.topics[0];
          if (typeof r != "string") throw new Error("invalid topic");
          const i = this.interface.getEvent(r);
          return this._normalizeRunningEvent(
            new dO(this.address, this.interface, i, e.topics)
          );
        } catch {}
        const n = { address: this.address, topics: e.topics };
        return this._normalizeRunningEvent(new Vg(hH(n), n));
      }
      return this._normalizeRunningEvent(new hO(this.address, this.interface));
    }
    _checkRunningEvents(e) {
      if (e.listenerCount() === 0) {
        delete this._runningEvents[e.tag];
        const n = this._wrappedEmits[e.tag];
        n &&
          e.filter &&
          (this.provider.off(e.filter, n), delete this._wrappedEmits[e.tag]);
      }
    }
    _wrapEvent(e, n, r) {
      const i = Zc(n);
      return (
        (i.removeListener = () => {
          r && (e.removeListener(r), this._checkRunningEvents(e));
        }),
        (i.getBlock = () => this.provider.getBlock(n.blockHash)),
        (i.getTransaction = () =>
          this.provider.getTransaction(n.transactionHash)),
        (i.getTransactionReceipt = () =>
          this.provider.getTransactionReceipt(n.transactionHash)),
        e.prepareEvent(i),
        i
      );
    }
    _addEventListener(e, n, r) {
      if (
        (this.provider ||
          yi.throwError(
            "events require a provider or a signer with a provider",
            Se.errors.UNSUPPORTED_OPERATION,
            { operation: "once" }
          ),
        e.addListener(n, r),
        (this._runningEvents[e.tag] = e),
        !this._wrappedEmits[e.tag])
      ) {
        const i = (s) => {
          let a = this._wrapEvent(e, s, n);
          if (a.decodeError == null)
            try {
              const o = e.getEmit(a);
              this.emit(e.filter, ...o);
            } catch (o) {
              a.decodeError = o.error;
            }
          e.filter != null && this.emit("event", a),
            a.decodeError != null && this.emit("error", a.decodeError, a);
        };
        (this._wrappedEmits[e.tag] = i),
          e.filter != null && this.provider.on(e.filter, i);
      }
    }
    queryFilter(e, n, r) {
      const i = this._getRunningEvent(e),
        s = xs(i.filter);
      return (
        typeof n == "string" && cr(n, 32)
          ? (r != null &&
              yi.throwArgumentError(
                "cannot specify toBlock with blockhash",
                "toBlock",
                r
              ),
            (s.blockHash = n))
          : ((s.fromBlock = n ?? 0), (s.toBlock = r ?? "latest")),
        this.provider
          .getLogs(s)
          .then((a) => a.map((o) => this._wrapEvent(i, o, null)))
      );
    }
    on(e, n) {
      return this._addEventListener(this._getRunningEvent(e), n, !1), this;
    }
    once(e, n) {
      return this._addEventListener(this._getRunningEvent(e), n, !0), this;
    }
    emit(e, ...n) {
      if (!this.provider) return !1;
      const r = this._getRunningEvent(e),
        i = r.run(n) > 0;
      return this._checkRunningEvents(r), i;
    }
    listenerCount(e) {
      return this.provider
        ? e == null
          ? Object.keys(this._runningEvents).reduce(
              (n, r) => n + this._runningEvents[r].listenerCount(),
              0
            )
          : this._getRunningEvent(e).listenerCount()
        : 0;
    }
    listeners(e) {
      if (!this.provider) return [];
      if (e == null) {
        const n = [];
        for (let r in this._runningEvents)
          this._runningEvents[r].listeners().forEach((i) => {
            n.push(i);
          });
        return n;
      }
      return this._getRunningEvent(e).listeners();
    }
    removeAllListeners(e) {
      if (!this.provider) return this;
      if (e == null) {
        for (const r in this._runningEvents) {
          const i = this._runningEvents[r];
          i.removeAllListeners(), this._checkRunningEvents(i);
        }
        return this;
      }
      const n = this._getRunningEvent(e);
      return n.removeAllListeners(), this._checkRunningEvents(n), this;
    }
    off(e, n) {
      if (!this.provider) return this;
      const r = this._getRunningEvent(e);
      return r.removeListener(n), this._checkRunningEvents(r), this;
    }
    removeListener(e, n) {
      return this.off(e, n);
    }
  },
  pH = class extends Dfe {};
class mH {
  constructor(e) {
    Je(this, "alphabet", e),
      Je(this, "base", e.length),
      Je(this, "_alphabetMap", {}),
      Je(this, "_leader", e.charAt(0));
    for (let n = 0; n < e.length; n++) this._alphabetMap[e.charAt(n)] = n;
  }
  encode(e) {
    let n = hn(e);
    if (n.length === 0) return "";
    let r = [0];
    for (let s = 0; s < n.length; ++s) {
      let a = n[s];
      for (let o = 0; o < r.length; ++o)
        (a += r[o] << 8), (r[o] = a % this.base), (a = (a / this.base) | 0);
      for (; a > 0; ) r.push(a % this.base), (a = (a / this.base) | 0);
    }
    let i = "";
    for (let s = 0; n[s] === 0 && s < n.length - 1; ++s) i += this._leader;
    for (let s = r.length - 1; s >= 0; --s) i += this.alphabet[r[s]];
    return i;
  }
  decode(e) {
    if (typeof e != "string") throw new TypeError("Expected String");
    let n = [];
    if (e.length === 0) return new Uint8Array(n);
    n.push(0);
    for (let r = 0; r < e.length; r++) {
      let i = this._alphabetMap[e[r]];
      if (i === void 0) throw new Error("Non-base" + this.base + " character");
      let s = i;
      for (let a = 0; a < n.length; ++a)
        (s += n[a] * this.base), (n[a] = s & 255), (s >>= 8);
      for (; s > 0; ) n.push(s & 255), (s >>= 8);
    }
    for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r) n.push(0);
    return hn(new Uint8Array(n.reverse()));
  }
}
new mH("abcdefghijklmnopqrstuvwxyz234567");
const gH = new mH("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function pO(t) {
  return "0x" + Ou.sha256().update(hn(t)).digest("hex");
}
const Rfe = "networks/5.5.2",
  mO = new Se(Rfe);
function Mfe(t) {
  return t && typeof t.renetwork == "function";
}
function u0(t) {
  const e = function (n, r) {
    r == null && (r = {});
    const i = [];
    if (n.InfuraProvider)
      try {
        i.push(new n.InfuraProvider(t, r.infura));
      } catch {}
    if (n.EtherscanProvider)
      try {
        i.push(new n.EtherscanProvider(t, r.etherscan));
      } catch {}
    if (n.AlchemyProvider)
      try {
        i.push(new n.AlchemyProvider(t, r.alchemy));
      } catch {}
    if (n.PocketProvider) {
      const s = ["goerli", "ropsten", "rinkeby"];
      try {
        const a = new n.PocketProvider(t);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {}
    }
    if (n.CloudflareProvider)
      try {
        i.push(new n.CloudflareProvider(t));
      } catch {}
    if (i.length === 0) return null;
    if (n.FallbackProvider) {
      let s = 1;
      return (
        r.quorum != null ? (s = r.quorum) : t === "homestead" && (s = 2),
        new n.FallbackProvider(i, s)
      );
    }
    return i[0];
  };
  return (
    (e.renetwork = function (n) {
      return u0(n);
    }),
    e
  );
}
function p5(t, e) {
  const n = function (r, i) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(t, e) : null;
  };
  return (
    (n.renetwork = function (r) {
      return p5(t, r);
    }),
    n
  );
}
const gO = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: u0("homestead"),
  },
  yO = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: u0("ropsten"),
  },
  vO = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: p5(
      "https://www.ethercluster.com/mordor",
      "classicMordor"
    ),
  },
  ov = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead: gO,
    mainnet: gO,
    morden: { chainId: 2, name: "morden" },
    ropsten: yO,
    testnet: yO,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: u0("rinkeby"),
    },
    kovan: { chainId: 42, name: "kovan", _defaultProvider: u0("kovan") },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: u0("goerli"),
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: p5("https://www.ethercluster.com/etc", "classic"),
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor: vO,
    classicTestnet: vO,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: p5(
        "https://www.ethercluster.com/kotti",
        "classicKotti"
      ),
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: { chainId: 137, name: "matic" },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: { chainId: 10, name: "optimism" },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" },
  };
function Lfe(t) {
  if (t == null) return null;
  if (typeof t == "number") {
    for (const r in ov) {
      const i = ov[r];
      if (i.chainId === t)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null,
        };
    }
    return { chainId: t, name: "unknown" };
  }
  if (typeof t == "string") {
    const r = ov[t];
    return r == null
      ? null
      : {
          name: r.name,
          chainId: r.chainId,
          ensAddress: r.ensAddress,
          _defaultProvider: r._defaultProvider || null,
        };
  }
  const e = ov[t.name];
  if (!e)
    return (
      typeof t.chainId != "number" &&
        mO.throwArgumentError("invalid network chainId", "network", t),
      t
    );
  t.chainId !== 0 &&
    t.chainId !== e.chainId &&
    mO.throwArgumentError("network chainId mismatch", "network", t);
  let n = t._defaultProvider || null;
  return (
    n == null &&
      e._defaultProvider &&
      (Mfe(e._defaultProvider)
        ? (n = e._defaultProvider.renetwork(t))
        : (n = e._defaultProvider)),
    {
      name: t.name,
      chainId: e.chainId,
      ensAddress: t.ensAddress || e.ensAddress || null,
      _defaultProvider: n,
    }
  );
}
function Bfe(t) {
  t = atob(t);
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t.charCodeAt(n));
  return hn(e);
}
function Ffe(t) {
  t = hn(t);
  let e = "";
  for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
  return btoa(e);
}
const $fe = "web/5.5.1";
var Ufe =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
function jfe(t, e) {
  return Ufe(this, void 0, void 0, function* () {
    e == null && (e = {});
    const n = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0,
    };
    e.skipFetchSetup !== !0 &&
      ((n.mode = "cors"),
      (n.cache = "no-cache"),
      (n.credentials = "same-origin"),
      (n.redirect = "follow"),
      (n.referrer = "client"));
    const r = yield fetch(t, n),
      i = yield r.arrayBuffer(),
      s = {};
    return (
      r.headers.forEach
        ? r.headers.forEach((a, o) => {
            s[o.toLowerCase()] = a;
          })
        : r.headers.keys().forEach((a) => {
            s[a.toLowerCase()] = r.headers.get(a);
          }),
      {
        headers: s,
        statusCode: r.status,
        statusMessage: r.statusText,
        body: hn(new Uint8Array(i)),
      }
    );
  });
}
var Hfe =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const Ul = new Se($fe);
function bO(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function xf(t, e) {
  if (t == null) return null;
  if (typeof t == "string") return t;
  if (F7(t)) {
    if (
      e &&
      (e.split("/")[0] === "text" ||
        e.split(";")[0].trim() === "application/json")
    )
      try {
        return p1(t);
      } catch {}
    return Qt(t);
  }
  return t;
}
function zfe(t, e, n) {
  const r =
    typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12;
  Ul.assertArgument(
    r > 0 && r % 1 === 0,
    "invalid connection throttle limit",
    "connection.throttleLimit",
    r
  );
  const i = typeof t == "object" ? t.throttleCallback : null,
    s =
      typeof t == "object" && typeof t.throttleSlotInterval == "number"
        ? t.throttleSlotInterval
        : 100;
  Ul.assertArgument(
    s > 0 && s % 1 === 0,
    "invalid connection throttle slot interval",
    "connection.throttleSlotInterval",
    s
  );
  const a = {};
  let o = null;
  const l = { method: "GET" };
  let u = !1,
    f = 2 * 60 * 1e3;
  if (typeof t == "string") o = t;
  else if (typeof t == "object") {
    if (
      ((t == null || t.url == null) &&
        Ul.throwArgumentError("missing URL", "connection.url", t),
      (o = t.url),
      typeof t.timeout == "number" && t.timeout > 0 && (f = t.timeout),
      t.headers)
    )
      for (const w in t.headers)
        (a[w.toLowerCase()] = { key: w, value: String(t.headers[w]) }),
          ["if-none-match", "if-modified-since"].indexOf(w.toLowerCase()) >=
            0 && (u = !0);
    if (((l.allowGzip = !!t.allowGzip), t.user != null && t.password != null)) {
      o.substring(0, 6) !== "https:" &&
        t.allowInsecureAuthentication !== !0 &&
        Ul.throwError(
          "basic authentication requires a secure https url",
          Se.errors.INVALID_ARGUMENT,
          { argument: "url", url: o, user: t.user, password: "[REDACTED]" }
        );
      const w = t.user + ":" + t.password;
      a.authorization = { key: "Authorization", value: "Basic " + Ffe(Yc(w)) };
    }
  }
  const c = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
    d = o ? o.match(c) : null;
  if (d)
    try {
      const w = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": d[1] },
        body: Bfe(d[2]),
      };
      let y = w.body;
      return n && (y = n(w.body, w)), Promise.resolve(y);
    } catch (w) {
      Ul.throwError("processing response error", Se.errors.SERVER_ERROR, {
        body: xf(d[1], d[2]),
        error: w,
        requestBody: null,
        requestMethod: "GET",
        url: o,
      });
    }
  e &&
    ((l.method = "POST"),
    (l.body = e),
    a["content-type"] == null &&
      (a["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream",
      }),
    a["content-length"] == null &&
      (a["content-length"] = {
        key: "Content-Length",
        value: String(e.length),
      }));
  const p = {};
  Object.keys(a).forEach((w) => {
    const y = a[w];
    p[y.key] = y.value;
  }),
    (l.headers = p);
  const m = (function () {
      let w = null;
      return {
        promise: new Promise(function (E, S) {
          f &&
            (w = setTimeout(() => {
              w != null &&
                ((w = null),
                S(
                  Ul.makeError("timeout", Se.errors.TIMEOUT, {
                    requestBody: xf(l.body, p["content-type"]),
                    requestMethod: l.method,
                    timeout: f,
                    url: o,
                  })
                ));
            }, f));
        }),
        cancel: function () {
          w != null && (clearTimeout(w), (w = null));
        },
      };
    })(),
    g = (function () {
      return Hfe(this, void 0, void 0, function* () {
        for (let w = 0; w < r; w++) {
          let y = null;
          try {
            if (((y = yield jfe(o, l)), w < r)) {
              if (y.statusCode === 301 || y.statusCode === 302) {
                const E = y.headers.location || "";
                if (l.method === "GET" && E.match(/^https:/)) {
                  o = y.headers.location;
                  continue;
                }
              } else if (y.statusCode === 429) {
                let E = !0;
                if ((i && (E = yield i(w, o)), E)) {
                  let S = 0;
                  const D = y.headers["retry-after"];
                  typeof D == "string" && D.match(/^[1-9][0-9]*$/)
                    ? (S = parseInt(D) * 1e3)
                    : (S =
                        s * parseInt(String(Math.random() * Math.pow(2, w)))),
                    yield bO(S);
                  continue;
                }
              }
            }
          } catch (E) {
            (y = E.response),
              y == null &&
                (m.cancel(),
                Ul.throwError("missing response", Se.errors.SERVER_ERROR, {
                  requestBody: xf(l.body, p["content-type"]),
                  requestMethod: l.method,
                  serverError: E,
                  url: o,
                }));
          }
          let v = y.body;
          if (
            (u && y.statusCode === 304
              ? (v = null)
              : (y.statusCode < 200 || y.statusCode >= 300) &&
                (m.cancel(),
                Ul.throwError("bad response", Se.errors.SERVER_ERROR, {
                  status: y.statusCode,
                  headers: y.headers,
                  body: xf(v, y.headers ? y.headers["content-type"] : null),
                  requestBody: xf(l.body, p["content-type"]),
                  requestMethod: l.method,
                  url: o,
                })),
            n)
          )
            try {
              const E = yield n(v, y);
              return m.cancel(), E;
            } catch (E) {
              if (E.throttleRetry && w < r) {
                let S = !0;
                if ((i && (S = yield i(w, o)), S)) {
                  const D =
                    s * parseInt(String(Math.random() * Math.pow(2, w)));
                  yield bO(D);
                  continue;
                }
              }
              m.cancel(),
                Ul.throwError(
                  "processing response error",
                  Se.errors.SERVER_ERROR,
                  {
                    body: xf(v, y.headers ? y.headers["content-type"] : null),
                    error: E,
                    requestBody: xf(l.body, p["content-type"]),
                    requestMethod: l.method,
                    url: o,
                  }
                );
            }
          return m.cancel(), v;
        }
        return Ul.throwError("failed response", Se.errors.SERVER_ERROR, {
          requestBody: xf(l.body, p["content-type"]),
          requestMethod: l.method,
          url: o,
        });
      });
    })();
  return Promise.race([m.promise, g]);
}
function yH(t, e, n) {
  let r = (s, a) => {
      let o = null;
      if (s != null)
        try {
          o = JSON.parse(p1(s));
        } catch (l) {
          Ul.throwError("invalid JSON", Se.errors.SERVER_ERROR, {
            body: s,
            error: l,
          });
        }
      return n && (o = n(o, a)), o;
    },
    i = null;
  if (e != null) {
    i = Yc(e);
    const s = typeof t == "string" ? { url: t } : xs(t);
    s.headers
      ? Object.keys(s.headers).filter((o) => o.toLowerCase() === "content-type")
          .length !== 0 ||
        ((s.headers = xs(s.headers)),
        (s.headers["content-type"] = "application/json"))
      : (s.headers = { "content-type": "application/json" }),
      (t = s);
  }
  return zfe(t, i, r);
}
function Fm(t, e) {
  return (
    e || (e = {}),
    (e = xs(e)),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function (n, r) {
      let i = null,
        s = !1;
      const a = () => (s ? !1 : ((s = !0), i && clearTimeout(i), !0));
      e.timeout &&
        (i = setTimeout(() => {
          a() && r(new Error("timeout"));
        }, e.timeout));
      const o = e.retryLimit;
      let l = 0;
      function u() {
        return t().then(
          function (f) {
            if (f !== void 0) a() && n(f);
            else if (e.oncePoll) e.oncePoll.once("poll", u);
            else if (e.onceBlock) e.onceBlock.once("block", u);
            else if (!s) {
              if ((l++, l > o)) {
                a() && r(new Error("retry limit reached"));
                return;
              }
              let c =
                e.interval * parseInt(String(Math.random() * Math.pow(2, l)));
              c < e.floor && (c = e.floor),
                c > e.ceiling && (c = e.ceiling),
                setTimeout(u, c);
            }
            return null;
          },
          function (f) {
            a() && r(f);
          }
        );
      }
      u();
    })
  );
}
var m5 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
  OE = {};
for (var lv = 0; lv < m5.length; lv++) {
  var q_ = m5.charAt(lv);
  if (OE[q_] !== void 0) throw new TypeError(q_ + " is ambiguous");
  OE[q_] = lv;
}
function c0(t) {
  var e = t >> 25;
  return (
    ((t & 33554431) << 5) ^
    (-((e >> 0) & 1) & 996825010) ^
    (-((e >> 1) & 1) & 642813549) ^
    (-((e >> 2) & 1) & 513874426) ^
    (-((e >> 3) & 1) & 1027748829) ^
    (-((e >> 4) & 1) & 705979059)
  );
}
function vH(t) {
  for (var e = 1, n = 0; n < t.length; ++n) {
    var r = t.charCodeAt(n);
    if (r < 33 || r > 126) return "Invalid prefix (" + t + ")";
    e = c0(e) ^ (r >> 5);
  }
  for (e = c0(e), n = 0; n < t.length; ++n) {
    var i = t.charCodeAt(n);
    e = c0(e) ^ (i & 31);
  }
  return e;
}
function Vfe(t, e, n) {
  if (((n = n || 90), t.length + 7 + e.length > n))
    throw new TypeError("Exceeds length limit");
  t = t.toLowerCase();
  var r = vH(t);
  if (typeof r == "string") throw new Error(r);
  for (var i = t + "1", s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5) throw new Error("Non 5-bit word");
    (r = c0(r) ^ a), (i += m5.charAt(a));
  }
  for (s = 0; s < 6; ++s) r = c0(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var o = (r >> ((5 - s) * 5)) & 31;
    i += m5.charAt(o);
  }
  return i;
}
function bH(t, e) {
  if (((e = e || 90), t.length < 8)) return t + " too short";
  if (t.length > e) return "Exceeds length limit";
  var n = t.toLowerCase(),
    r = t.toUpperCase();
  if (t !== n && t !== r) return "Mixed-case string " + t;
  t = n;
  var i = t.lastIndexOf("1");
  if (i === -1) return "No separator character for " + t;
  if (i === 0) return "Missing prefix for " + t;
  var s = t.slice(0, i),
    a = t.slice(i + 1);
  if (a.length < 6) return "Data too short";
  var o = vH(s);
  if (typeof o == "string") return o;
  for (var l = [], u = 0; u < a.length; ++u) {
    var f = a.charAt(u),
      c = OE[f];
    if (c === void 0) return "Unknown character " + f;
    (o = c0(o) ^ c), !(u + 6 >= a.length) && l.push(c);
  }
  return o !== 1 ? "Invalid checksum for " + t : { prefix: s, words: l };
}
function Gfe() {
  var t = bH.apply(null, arguments);
  if (typeof t == "object") return t;
}
function Wfe(t) {
  var e = bH.apply(null, arguments);
  if (typeof e == "object") return e;
  throw new Error(e);
}
function $w(t, e, n, r) {
  for (var i = 0, s = 0, a = (1 << n) - 1, o = [], l = 0; l < t.length; ++l)
    for (i = (i << e) | t[l], s += e; s >= n; ) (s -= n), o.push((i >> s) & a);
  if (r) s > 0 && o.push((i << (n - s)) & a);
  else {
    if (s >= e) return "Excess padding";
    if ((i << (n - s)) & a) return "Non-zero padding";
  }
  return o;
}
function qfe(t) {
  var e = $w(t, 8, 5, !0);
  if (Array.isArray(e)) return e;
}
function Kfe(t) {
  var e = $w(t, 8, 5, !0);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
function Xfe(t) {
  var e = $w(t, 5, 8, !1);
  if (Array.isArray(e)) return e;
}
function Zfe(t) {
  var e = $w(t, 5, 8, !1);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
var Yfe = {
  decodeUnsafe: Gfe,
  decode: Wfe,
  encode: Vfe,
  toWordsUnsafe: qfe,
  toWords: Kfe,
  fromWordsUnsafe: Xfe,
  fromWords: Zfe,
};
const wO = oa(Yfe),
  ky = "providers/5.5.2",
  up = new Se(ky);
class Mt {
  constructor() {
    up.checkNew(new.target, Mt), (this.formats = this.getDefaultFormats());
  }
  getDefaultFormats() {
    const e = {},
      n = this.address.bind(this),
      r = this.bigNumber.bind(this),
      i = this.blockTag.bind(this),
      s = this.data.bind(this),
      a = this.hash.bind(this),
      o = this.hex.bind(this),
      l = this.number.bind(this),
      u = this.type.bind(this),
      f = (c) => this.data(c, !0);
    return (
      (e.transaction = {
        hash: a,
        type: u,
        accessList: Mt.allowNull(this.accessList.bind(this), null),
        blockHash: Mt.allowNull(a, null),
        blockNumber: Mt.allowNull(l, null),
        transactionIndex: Mt.allowNull(l, null),
        confirmations: Mt.allowNull(l, null),
        from: n,
        gasPrice: Mt.allowNull(r),
        maxPriorityFeePerGas: Mt.allowNull(r),
        maxFeePerGas: Mt.allowNull(r),
        gasLimit: r,
        to: Mt.allowNull(n, null),
        value: r,
        nonce: l,
        data: s,
        r: Mt.allowNull(this.uint256),
        s: Mt.allowNull(this.uint256),
        v: Mt.allowNull(l),
        creates: Mt.allowNull(n, null),
        raw: Mt.allowNull(s),
      }),
      (e.transactionRequest = {
        from: Mt.allowNull(n),
        nonce: Mt.allowNull(l),
        gasLimit: Mt.allowNull(r),
        gasPrice: Mt.allowNull(r),
        maxPriorityFeePerGas: Mt.allowNull(r),
        maxFeePerGas: Mt.allowNull(r),
        to: Mt.allowNull(n),
        value: Mt.allowNull(r),
        data: Mt.allowNull(f),
        type: Mt.allowNull(l),
        accessList: Mt.allowNull(this.accessList.bind(this), null),
      }),
      (e.receiptLog = {
        transactionIndex: l,
        blockNumber: l,
        transactionHash: a,
        address: n,
        topics: Mt.arrayOf(a),
        data: s,
        logIndex: l,
        blockHash: a,
      }),
      (e.receipt = {
        to: Mt.allowNull(this.address, null),
        from: Mt.allowNull(this.address, null),
        contractAddress: Mt.allowNull(n, null),
        transactionIndex: l,
        root: Mt.allowNull(o),
        gasUsed: r,
        logsBloom: Mt.allowNull(s),
        blockHash: a,
        transactionHash: a,
        logs: Mt.arrayOf(this.receiptLog.bind(this)),
        blockNumber: l,
        confirmations: Mt.allowNull(l, null),
        cumulativeGasUsed: r,
        effectiveGasPrice: Mt.allowNull(r),
        status: Mt.allowNull(l),
        type: u,
      }),
      (e.block = {
        hash: a,
        parentHash: a,
        number: l,
        timestamp: l,
        nonce: Mt.allowNull(o),
        difficulty: this.difficulty.bind(this),
        gasLimit: r,
        gasUsed: r,
        miner: n,
        extraData: s,
        transactions: Mt.allowNull(Mt.arrayOf(a)),
        baseFeePerGas: Mt.allowNull(r),
      }),
      (e.blockWithTransactions = xs(e.block)),
      (e.blockWithTransactions.transactions = Mt.allowNull(
        Mt.arrayOf(this.transactionResponse.bind(this))
      )),
      (e.filter = {
        fromBlock: Mt.allowNull(i, void 0),
        toBlock: Mt.allowNull(i, void 0),
        blockHash: Mt.allowNull(a, void 0),
        address: Mt.allowNull(n, void 0),
        topics: Mt.allowNull(this.topics.bind(this), void 0),
      }),
      (e.filterLog = {
        blockNumber: Mt.allowNull(l),
        blockHash: Mt.allowNull(a),
        transactionIndex: l,
        removed: Mt.allowNull(this.boolean.bind(this)),
        address: n,
        data: Mt.allowFalsish(s, "0x"),
        topics: Mt.arrayOf(a),
        transactionHash: a,
        logIndex: l,
      }),
      e
    );
  }
  accessList(e) {
    return b1(e || []);
  }
  number(e) {
    return e === "0x" ? 0 : dt.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : dt.from(e).toNumber();
  }
  bigNumber(e) {
    return dt.from(e);
  }
  boolean(e) {
    if (typeof e == "boolean") return e;
    if (typeof e == "string") {
      if (((e = e.toLowerCase()), e === "true")) return !0;
      if (e === "false") return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, n) {
    return typeof e == "string" &&
      (!n && e.substring(0, 2) !== "0x" && (e = "0x" + e), cr(e))
      ? e.toLowerCase()
      : up.throwArgumentError("invalid hash", "value", e);
  }
  data(e, n) {
    const r = this.hex(e, n);
    if (r.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
    return r;
  }
  address(e) {
    return As(e);
  }
  callAddress(e) {
    if (!cr(e, 32)) return null;
    const n = As(jc(e, 12));
    return n === Ule ? null : n;
  }
  contractAddress(e) {
    return xj(e);
  }
  blockTag(e) {
    if (e == null) return "latest";
    if (e === "earliest") return "0x0";
    if (e === "latest" || e === "pending") return e;
    if (typeof e == "number" || cr(e)) return $7(e);
    throw new Error("invalid blockTag");
  }
  hash(e, n) {
    const r = this.hex(e, n);
    return xy(r) !== 32 ? up.throwArgumentError("invalid hash", "value", e) : r;
  }
  difficulty(e) {
    if (e == null) return null;
    const n = dt.from(e);
    try {
      return n.toNumber();
    } catch {}
    return null;
  }
  uint256(e) {
    if (!cr(e)) throw new Error("invalid uint256");
    return Ni(e, 32);
  }
  _block(e, n) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const r = e._difficulty != null ? e._difficulty : e.difficulty,
      i = Mt.check(n, e);
    return (i._difficulty = r == null ? null : dt.from(r)), i;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  transactionRequest(e) {
    return Mt.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
      e.to &&
        dt.from(e.to).isZero() &&
        (e.to = "0x0000000000000000000000000000000000000000"),
      e.input != null && e.data == null && (e.data = e.input),
      e.to == null &&
        e.creates == null &&
        (e.creates = this.contractAddress(e)),
      (e.type === 1 || e.type === 2) &&
        e.accessList == null &&
        (e.accessList = []);
    const n = Mt.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let r = e.chainId;
      cr(r) && (r = dt.from(r).toNumber()), (n.chainId = r);
    } else {
      let r = e.networkId;
      r == null && n.v == null && (r = e.chainId),
        cr(r) && (r = dt.from(r).toNumber()),
        typeof r != "number" &&
          n.v != null &&
          ((r = (n.v - 35) / 2), r < 0 && (r = 0), (r = parseInt(r))),
        typeof r != "number" && (r = 0),
        (n.chainId = r);
    }
    return (
      n.blockHash &&
        n.blockHash.replace(/0/g, "") === "x" &&
        (n.blockHash = null),
      n
    );
  }
  transaction(e) {
    return Afe(e);
  }
  receiptLog(e) {
    return Mt.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const n = Mt.check(this.formats.receipt, e);
    if (n.root != null)
      if (n.root.length <= 4) {
        const r = dt.from(n.root).toNumber();
        r === 0 || r === 1
          ? (n.status != null &&
              n.status !== r &&
              up.throwArgumentError(
                "alt-root-status/status mismatch",
                "value",
                { root: n.root, status: n.status }
              ),
            (n.status = r),
            delete n.root)
          : up.throwArgumentError(
              "invalid alt-root-status",
              "value.root",
              n.root
            );
      } else
        n.root.length !== 66 &&
          up.throwArgumentError("invalid root hash", "value.root", n.root);
    return n.status != null && (n.byzantium = !0), n;
  }
  topics(e) {
    return Array.isArray(e)
      ? e.map((n) => this.topics(n))
      : e != null
      ? this.hash(e, !0)
      : null;
  }
  filter(e) {
    return Mt.check(this.formats.filter, e);
  }
  filterLog(e) {
    return Mt.check(this.formats.filterLog, e);
  }
  static check(e, n) {
    const r = {};
    for (const i in e)
      try {
        const s = e[i](n[i]);
        s !== void 0 && (r[i] = s);
      } catch (s) {
        throw ((s.checkKey = i), (s.checkValue = n[i]), s);
      }
    return r;
  }
  static allowNull(e, n) {
    return function (r) {
      return r == null ? n : e(r);
    };
  }
  static allowFalsish(e, n) {
    return function (r) {
      return r ? e(r) : n;
    };
  }
  static arrayOf(e) {
    return function (n) {
      if (!Array.isArray(n)) throw new Error("not an array");
      const r = [];
      return (
        n.forEach(function (i) {
          r.push(e(i));
        }),
        r
      );
    };
  }
}
var An =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const dr = new Se(ky);
function _O(t) {
  return t == null
    ? "null"
    : (xy(t) !== 32 && dr.throwArgumentError("invalid topic", "topic", t),
      t.toLowerCase());
}
function EO(t) {
  for (t = t.slice(); t.length > 0 && t[t.length - 1] == null; ) t.pop();
  return t
    .map((e) => {
      if (Array.isArray(e)) {
        const n = {};
        e.forEach((i) => {
          n[_O(i)] = !0;
        });
        const r = Object.keys(n);
        return r.sort(), r.join("|");
      } else return _O(e);
    })
    .join("&");
}
function Qfe(t) {
  return t === ""
    ? []
    : t.split(/&/g).map((e) => {
        if (e === "") return [];
        const n = e.split("|").map((r) => (r === "null" ? null : r));
        return n.length === 1 ? n[0] : n;
      });
}
function cp(t) {
  if (typeof t == "string") {
    if (((t = t.toLowerCase()), xy(t) === 32)) return "tx:" + t;
    if (t.indexOf(":") === -1) return t;
  } else {
    if (Array.isArray(t)) return "filter:*:" + EO(t);
    if (Iue.isForkEvent(t))
      throw (dr.warn("not implemented"), new Error("not implemented"));
    if (t && typeof t == "object")
      return "filter:" + (t.address || "*") + ":" + EO(t.topics || []);
  }
  throw new Error("invalid event - " + t);
}
function fm() {
  return new Date().getTime();
}
function xO(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
const Jfe = ["block", "network", "pending", "poll"];
let ede = class {
  constructor(e, n, r) {
    Je(this, "tag", e), Je(this, "listener", n), Je(this, "once", r);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter") return null;
    const n = e[1],
      r = Qfe(e[2]),
      i = {};
    return r.length > 0 && (i.topics = r), n && n !== "*" && (i.address = n), i;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || Jfe.indexOf(this.tag) >= 0;
  }
};
const tde = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" },
};
function K_(t) {
  return Ni(dt.from(t).toHexString(), 32);
}
function TO(t) {
  return gH.encode(fl([t, jc(pO(pO(t)), 0, 4)]));
}
const wH = new RegExp("^(ipfs)://(.*)$", "i"),
  SO = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    wH,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
  ];
function nde(t) {
  try {
    return p1(_H(t));
  } catch {}
  return null;
}
function _H(t) {
  if (t === "0x") return null;
  const e = dt.from(jc(t, 0, 32)).toNumber(),
    n = dt.from(jc(t, e, e + 32)).toNumber();
  return jc(t, e + 32, e + 32 + n);
}
function AO(t) {
  return `https://gateway.ipfs.io/ipfs/${t.substring(7)}`;
}
class CO {
  constructor(e, n, r, i) {
    Je(this, "provider", e),
      Je(this, "name", r),
      Je(this, "address", e.formatter.address(n)),
      Je(this, "_resolvedAddress", i);
  }
  _fetchBytes(e, n) {
    return An(this, void 0, void 0, function* () {
      const r = { to: this.address, data: Ql([e, u5(this.name), n || "0x"]) };
      try {
        return _H(yield this.provider.call(r));
      } catch (i) {
        return i.code === Se.errors.CALL_EXCEPTION, null;
      }
    });
  }
  _getAddress(e, n) {
    const r = tde[String(e)];
    if (
      (r == null &&
        dr.throwError(
          `unsupported coin type: ${e}`,
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: `getAddress(${e})` }
        ),
      r.ilk === "eth")
    )
      return this.provider.formatter.address(n);
    const i = hn(n);
    if (r.p2pkh != null) {
      const s = n.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return TO(fl([[r.p2pkh], "0x" + s[2]]));
      }
    }
    if (r.p2sh != null) {
      const s = n.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return TO(fl([[r.p2sh], "0x" + s[2]]));
      }
    }
    if (r.prefix != null) {
      const s = i[1];
      let a = i[0];
      if (
        (a === 0 ? s !== 20 && s !== 32 && (a = -1) : (a = -1),
        a >= 0 && i.length === 2 + s && s >= 1 && s <= 75)
      ) {
        const o = wO.toWords(i.slice(2));
        return o.unshift(a), wO.encode(r.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return An(this, void 0, void 0, function* () {
      if ((e == null && (e = 60), e === 60))
        try {
          const i = {
              to: this.address,
              data: "0x3b3b57de" + u5(this.name).substring(2),
            },
            s = yield this.provider.call(i);
          return s === "0x" || s === Vle
            ? null
            : this.provider.formatter.callAddress(s);
        } catch (i) {
          if (i.code === Se.errors.CALL_EXCEPTION) return null;
          throw i;
        }
      const n = yield this._fetchBytes("0xf1cb7e06", K_(e));
      if (n == null || n === "0x") return null;
      const r = this._getAddress(e, n);
      return (
        r == null &&
          dr.throwError(
            "invalid or unsupported coin data",
            Se.errors.UNSUPPORTED_OPERATION,
            { operation: `getAddress(${e})`, coinType: e, data: n }
          ),
        r
      );
    });
  }
  getAvatar() {
    return An(this, void 0, void 0, function* () {
      const e = [{ type: "name", content: this.name }];
      try {
        const n = yield this.getText("avatar");
        if (n == null) return null;
        for (let r = 0; r < SO.length; r++) {
          const i = n.match(SO[r]);
          if (i == null) continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
              return (
                e.push({ type: "url", content: n }), { linkage: e, url: n }
              );
            case "data":
              return (
                e.push({ type: "data", content: n }), { linkage: e, url: n }
              );
            case "ipfs":
              return (
                e.push({ type: "ipfs", content: n }), { linkage: e, url: AO(n) }
              );
            case "erc721":
            case "erc1155": {
              const a = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({ type: s, content: n });
              const o = this._resolvedAddress || (yield this.getAddress()),
                l = (i[2] || "").split("/");
              if (l.length !== 2) return null;
              const u = yield this.provider.formatter.address(l[0]),
                f = Ni(dt.from(l[1]).toHexString(), 32);
              if (s === "erc721") {
                const g = this.provider.formatter.callAddress(
                  yield this.provider.call({
                    to: u,
                    data: Ql(["0x6352211e", f]),
                  })
                );
                if (o !== g) return null;
                e.push({ type: "owner", content: g });
              } else if (s === "erc1155") {
                const g = dt.from(
                  yield this.provider.call({
                    to: u,
                    data: Ql(["0x00fdd58e", Ni(o, 32), f]),
                  })
                );
                if (g.isZero()) return null;
                e.push({ type: "balance", content: g.toString() });
              }
              const c = {
                to: this.provider.formatter.address(l[0]),
                data: Ql([a, f]),
              };
              let d = nde(yield this.provider.call(c));
              if (d == null) return null;
              e.push({ type: "metadata-url", content: d }),
                s === "erc1155" &&
                  ((d = d.replace("{id}", f.substring(2))),
                  e.push({ type: "metadata-url-expanded", content: d }));
              const p = yield yH(d);
              if (!p) return null;
              e.push({ type: "metadata", content: JSON.stringify(p) });
              let m = p.image;
              if (typeof m != "string") return null;
              if (!m.match(/^(https:\/\/|data:)/i)) {
                if (m.match(wH) == null) return null;
                e.push({ type: "url-ipfs", content: m }), (m = AO(m));
              }
              return (
                e.push({ type: "url", content: m }), { linkage: e, url: m }
              );
            }
          }
        }
      } catch {}
      return null;
    });
  }
  getContentHash() {
    return An(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x") return null;
      const n = e.match(
        /^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
      );
      if (n) {
        const i = parseInt(n[3], 16);
        if (n[4].length === i * 2) return "ipfs://" + gH.encode("0x" + n[1]);
      }
      const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      return r && r[1].length === 32 * 2
        ? "bzz://" + r[1]
        : dr.throwError(
            "invalid or unsupported content hash data",
            Se.errors.UNSUPPORTED_OPERATION,
            { operation: "getContentHash()", data: e }
          );
    });
  }
  getText(e) {
    return An(this, void 0, void 0, function* () {
      let n = Yc(e);
      (n = fl([K_(64), K_(n.length), n])),
        n.length % 32 !== 0 && (n = fl([n, Ni("0x", 32 - (e.length % 32))]));
      const r = yield this._fetchBytes("0x59d1d43c", Qt(n));
      return r == null || r === "0x" ? null : p1(r);
    });
  }
}
let X_ = null,
  rde = 1;
class ide extends zg {
  constructor(e) {
    if (
      (dr.checkNew(new.target, zg),
      super(),
      (this._events = []),
      (this._emitted = { block: -2 }),
      (this.formatter = new.target.getFormatter()),
      Je(this, "anyNetwork", e === "any"),
      this.anyNetwork && (e = this.detectNetwork()),
      e instanceof Promise)
    )
      (this._networkPromise = e),
        e.catch((n) => {}),
        this._ready().catch((n) => {});
    else {
      const n = $u(new.target, "getNetwork")(e);
      n
        ? (Je(this, "_network", n), this.emit("network", n, null))
        : dr.throwArgumentError("invalid network", "network", e);
    }
    (this._maxInternalBlockNumber = -1024),
      (this._lastBlockNumber = -2),
      (this._pollingInterval = 4e3),
      (this._fastQueryDate = 0);
  }
  _ready() {
    return An(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {}
        e == null && (e = yield this.detectNetwork()),
          e ||
            dr.throwError("no network detected", Se.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (this.anyNetwork ? (this._network = e) : Je(this, "_network", e),
            this.emit("network", e, null));
      }
      return this._network;
    });
  }
  get ready() {
    return Fm(() =>
      this._ready().then(
        (e) => e,
        (e) => {
          if (!(e.code === Se.errors.NETWORK_ERROR && e.event === "noNetwork"))
            throw e;
        }
      )
    );
  }
  static getFormatter() {
    return X_ == null && (X_ = new Mt()), X_;
  }
  static getNetwork(e) {
    return Lfe(e ?? "homestead");
  }
  _getInternalBlockNumber(e) {
    return An(this, void 0, void 0, function* () {
      if ((yield this._ready(), e > 0))
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (fm() - s.respTime <= e) return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i) break;
          }
        }
      const n = fm(),
        r = Fi({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then(
            (i) => null,
            (i) => i
          ),
        }).then(({ blockNumber: i, networkError: s }) => {
          if (s)
            throw (
              (this._internalBlockNumber === r &&
                (this._internalBlockNumber = null),
              s)
            );
          const a = fm();
          return (
            (i = dt.from(i).toNumber()),
            i < this._maxInternalBlockNumber &&
              (i = this._maxInternalBlockNumber),
            (this._maxInternalBlockNumber = i),
            this._setFastBlockNumber(i),
            { blockNumber: i, reqTime: n, respTime: a }
          );
        });
      return (
        (this._internalBlockNumber = r),
        r.catch((i) => {
          this._internalBlockNumber === r && (this._internalBlockNumber = null);
        }),
        (yield r).blockNumber
      );
    });
  }
  poll() {
    return An(this, void 0, void 0, function* () {
      const e = rde++,
        n = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit("error", i);
        return;
      }
      if (
        (this._setFastBlockNumber(r),
        this.emit("poll", e, r),
        r === this._lastBlockNumber)
      ) {
        this.emit("didPoll", e);
        return;
      }
      if (
        (this._emitted.block === -2 && (this._emitted.block = r - 1),
        Math.abs(this._emitted.block - r) > 1e3)
      )
        dr.warn(
          `network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`
        ),
          this.emit(
            "error",
            dr.makeError(
              "network block skew detected",
              Se.errors.NETWORK_ERROR,
              {
                blockNumber: r,
                event: "blockSkew",
                previousBlockNumber: this._emitted.block,
              }
            )
          ),
          this.emit("block", r);
      else
        for (let i = this._emitted.block + 1; i <= r; i++)
          this.emit("block", i);
      this._emitted.block !== r &&
        ((this._emitted.block = r),
        Object.keys(this._emitted).forEach((i) => {
          if (i === "block") return;
          const s = this._emitted[i];
          s !== "pending" && r - s > 12 && delete this._emitted[i];
        })),
        this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1),
        this._events.forEach((i) => {
          switch (i.type) {
            case "tx": {
              const s = i.hash;
              let a = this.getTransactionReceipt(s)
                .then(
                  (o) => (
                    !o ||
                      o.blockNumber == null ||
                      ((this._emitted["t:" + s] = o.blockNumber),
                      this.emit(s, o)),
                    null
                  )
                )
                .catch((o) => {
                  this.emit("error", o);
                });
              n.push(a);
              break;
            }
            case "filter": {
              const s = i.filter;
              (s.fromBlock = this._lastBlockNumber + 1), (s.toBlock = r);
              const a = this.getLogs(s)
                .then((o) => {
                  o.length !== 0 &&
                    o.forEach((l) => {
                      (this._emitted["b:" + l.blockHash] = l.blockNumber),
                        (this._emitted["t:" + l.transactionHash] =
                          l.blockNumber),
                        this.emit(s, l);
                    });
                })
                .catch((o) => {
                  this.emit("error", o);
                });
              n.push(a);
              break;
            }
          }
        }),
        (this._lastBlockNumber = r),
        Promise.all(n)
          .then(() => {
            this.emit("didPoll", e);
          })
          .catch((i) => {
            this.emit("error", i);
          });
    });
  }
  resetEventsBlock(e) {
    (this._lastBlockNumber = e - 1), this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return An(this, void 0, void 0, function* () {
      return dr.throwError(
        "provider does not support network detection",
        Se.errors.UNSUPPORTED_OPERATION,
        { operation: "provider.detectNetwork" }
      );
    });
  }
  getNetwork() {
    return An(this, void 0, void 0, function* () {
      const e = yield this._ready(),
        n = yield this.detectNetwork();
      if (e.chainId !== n.chainId) {
        if (this.anyNetwork)
          return (
            (this._network = n),
            (this._lastBlockNumber = -2),
            (this._fastBlockNumber = null),
            (this._fastBlockNumberPromise = null),
            (this._fastQueryDate = 0),
            (this._emitted.block = -2),
            (this._maxInternalBlockNumber = -1024),
            (this._internalBlockNumber = null),
            this.emit("network", n, e),
            yield xO(0),
            this._network
          );
        const r = dr.makeError(
          "underlying network changed",
          Se.errors.NETWORK_ERROR,
          { event: "changed", network: e, detectedNetwork: n }
        );
        throw (this.emit("error", r), r);
      }
      return e;
    });
  }
  get blockNumber() {
    return (
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
        (e) => {
          this._setFastBlockNumber(e);
        },
        (e) => {}
      ),
      this._fastBlockNumber != null ? this._fastBlockNumber : -1
    );
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller
      ? ((this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval)),
        this._bootstrapPoll ||
          (this._bootstrapPoll = setTimeout(() => {
            this.poll(),
              (this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), (this._bootstrapPoll = null);
              }, this.pollingInterval));
          }, 0)))
      : !e &&
        this._poller &&
        (clearInterval(this._poller), (this._poller = null));
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    (this._pollingInterval = e),
      this._poller &&
        (clearInterval(this._poller),
        (this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval)));
  }
  _getFastBlockNumber() {
    const e = fm();
    return (
      e - this._fastQueryDate > 2 * this._pollingInterval &&
        ((this._fastQueryDate = e),
        (this._fastBlockNumberPromise = this.getBlockNumber().then(
          (n) => (
            (this._fastBlockNumber == null || n > this._fastBlockNumber) &&
              (this._fastBlockNumber = n),
            this._fastBlockNumber
          )
        ))),
      this._fastBlockNumberPromise
    );
  }
  _setFastBlockNumber(e) {
    (this._fastBlockNumber != null && e < this._fastBlockNumber) ||
      ((this._fastQueryDate = fm()),
      (this._fastBlockNumber == null || e > this._fastBlockNumber) &&
        ((this._fastBlockNumber = e),
        (this._fastBlockNumberPromise = Promise.resolve(e))));
  }
  waitForTransaction(e, n, r) {
    return An(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, n ?? 1, r || 0, null);
    });
  }
  _waitForTransaction(e, n, r, i) {
    return An(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= n
        ? s
        : new Promise((a, o) => {
            const l = [];
            let u = !1;
            const f = function () {
                return u
                  ? !0
                  : ((u = !0),
                    l.forEach((d) => {
                      d();
                    }),
                    !1);
              },
              c = (d) => {
                d.confirmations < n || f() || a(d);
              };
            if (
              (this.on(e, c),
              l.push(() => {
                this.removeListener(e, c);
              }),
              i)
            ) {
              let d = i.startBlock,
                p = null;
              const m = (g) =>
                An(this, void 0, void 0, function* () {
                  u ||
                    (yield xO(1e3),
                    this.getTransactionCount(i.from).then(
                      (w) =>
                        An(this, void 0, void 0, function* () {
                          if (!u) {
                            if (w <= i.nonce) d = g;
                            else {
                              {
                                const y = yield this.getTransaction(e);
                                if (y && y.blockNumber != null) return;
                              }
                              for (
                                p == null &&
                                ((p = d - 3),
                                p < i.startBlock && (p = i.startBlock));
                                p <= g;

                              ) {
                                if (u) return;
                                const y = yield this.getBlockWithTransactions(
                                  p
                                );
                                for (
                                  let v = 0;
                                  v < y.transactions.length;
                                  v++
                                ) {
                                  const E = y.transactions[v];
                                  if (E.hash === e) return;
                                  if (
                                    E.from === i.from &&
                                    E.nonce === i.nonce
                                  ) {
                                    if (u) return;
                                    const S = yield this.waitForTransaction(
                                      E.hash,
                                      n
                                    );
                                    if (f()) return;
                                    let D = "replaced";
                                    E.data === i.data &&
                                    E.to === i.to &&
                                    E.value.eq(i.value)
                                      ? (D = "repriced")
                                      : E.data === "0x" &&
                                        E.from === E.to &&
                                        E.value.isZero() &&
                                        (D = "cancelled"),
                                      o(
                                        dr.makeError(
                                          "transaction was replaced",
                                          Se.errors.TRANSACTION_REPLACED,
                                          {
                                            cancelled:
                                              D === "replaced" ||
                                              D === "cancelled",
                                            reason: D,
                                            replacement:
                                              this._wrapTransaction(E),
                                            hash: e,
                                            receipt: S,
                                          }
                                        )
                                      );
                                    return;
                                  }
                                }
                                p++;
                              }
                            }
                            u || this.once("block", m);
                          }
                        }),
                      (w) => {
                        u || this.once("block", m);
                      }
                    ));
                });
              if (u) return;
              this.once("block", m),
                l.push(() => {
                  this.removeListener("block", m);
                });
            }
            if (typeof r == "number" && r > 0) {
              const d = setTimeout(() => {
                f() ||
                  o(
                    dr.makeError("timeout exceeded", Se.errors.TIMEOUT, {
                      timeout: r,
                    })
                  );
              }, r);
              d.unref && d.unref(),
                l.push(() => {
                  clearTimeout(d);
                });
            }
          });
    });
  }
  getBlockNumber() {
    return An(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return dt.from(e);
      } catch (n) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "getGasPrice", result: e, error: n }
        );
      }
    });
  }
  getBalance(e, n) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Fi({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n),
        }),
        i = yield this.perform("getBalance", r);
      try {
        return dt.from(i);
      } catch (s) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "getBalance", params: r, result: i, error: s }
        );
      }
    });
  }
  getTransactionCount(e, n) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Fi({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n),
        }),
        i = yield this.perform("getTransactionCount", r);
      try {
        return dt.from(i).toNumber();
      } catch (s) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "getTransactionCount", params: r, result: i, error: s }
        );
      }
    });
  }
  getCode(e, n) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Fi({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n),
        }),
        i = yield this.perform("getCode", r);
      try {
        return Qt(i);
      } catch (s) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "getCode", params: r, result: i, error: s }
        );
      }
    });
  }
  getStorageAt(e, n, r) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Fi({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
          position: Promise.resolve(n).then((a) => $7(a)),
        }),
        s = yield this.perform("getStorageAt", i);
      try {
        return Qt(s);
      } catch (a) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "getStorageAt", params: i, result: s, error: a }
        );
      }
    });
  }
  _wrapTransaction(e, n, r) {
    if (n != null && xy(n) !== 32)
      throw new Error("invalid response - sendTransaction");
    const i = e;
    return (
      n != null &&
        e.hash !== n &&
        dr.throwError(
          "Transaction hash mismatch from Provider.sendTransaction.",
          Se.errors.UNKNOWN_ERROR,
          { expectedHash: e.hash, returnedHash: n }
        ),
      (i.wait = (s, a) =>
        An(this, void 0, void 0, function* () {
          s == null && (s = 1), a == null && (a = 0);
          let o;
          s !== 0 &&
            r != null &&
            (o = {
              data: e.data,
              from: e.from,
              nonce: e.nonce,
              to: e.to,
              value: e.value,
              startBlock: r,
            });
          const l = yield this._waitForTransaction(e.hash, s, a, o);
          return l == null && s === 0
            ? null
            : ((this._emitted["t:" + e.hash] = l.blockNumber),
              l.status === 0 &&
                dr.throwError("transaction failed", Se.errors.CALL_EXCEPTION, {
                  transactionHash: e.hash,
                  transaction: e,
                  receipt: l,
                }),
              l);
        })),
      i
    );
  }
  sendTransaction(e) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield Promise.resolve(e).then((s) => Qt(s)),
        r = this.formatter.transaction(e);
      r.confirmations == null && (r.confirmations = 0);
      const i = yield this._getInternalBlockNumber(
        100 + 2 * this.pollingInterval
      );
      try {
        const s = yield this.perform("sendTransaction", {
          signedTransaction: n,
        });
        return this._wrapTransaction(r, s, i);
      } catch (s) {
        throw ((s.transaction = r), (s.transactionHash = r.hash), s);
      }
    });
  }
  _getTransactionRequest(e) {
    return An(this, void 0, void 0, function* () {
      const n = yield e,
        r = {};
      return (
        ["from", "to"].forEach((i) => {
          n[i] != null &&
            (r[i] = Promise.resolve(n[i]).then((s) =>
              s ? this._getAddress(s) : null
            ));
        }),
        [
          "gasLimit",
          "gasPrice",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "value",
        ].forEach((i) => {
          n[i] != null &&
            (r[i] = Promise.resolve(n[i]).then((s) => (s ? dt.from(s) : null)));
        }),
        ["type"].forEach((i) => {
          n[i] != null && (r[i] = Promise.resolve(n[i]).then((s) => s ?? null));
        }),
        n.accessList &&
          (r.accessList = this.formatter.accessList(n.accessList)),
        ["data"].forEach((i) => {
          n[i] != null &&
            (r[i] = Promise.resolve(n[i]).then((s) => (s ? Qt(s) : null)));
        }),
        this.formatter.transactionRequest(yield Fi(r))
      );
    });
  }
  _getFilter(e) {
    return An(this, void 0, void 0, function* () {
      e = yield e;
      const n = {};
      return (
        e.address != null && (n.address = this._getAddress(e.address)),
        ["blockHash", "topics"].forEach((r) => {
          e[r] != null && (n[r] = e[r]);
        }),
        ["fromBlock", "toBlock"].forEach((r) => {
          e[r] != null && (n[r] = this._getBlockTag(e[r]));
        }),
        this.formatter.filter(yield Fi(n))
      );
    });
  }
  call(e, n) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Fi({
          transaction: this._getTransactionRequest(e),
          blockTag: this._getBlockTag(n),
        }),
        i = yield this.perform("call", r);
      try {
        return Qt(i);
      } catch (s) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "call", params: r, result: i, error: s }
        );
      }
    });
  }
  estimateGas(e) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield Fi({ transaction: this._getTransactionRequest(e) }),
        r = yield this.perform("estimateGas", n);
      try {
        return dt.from(r);
      } catch (i) {
        return dr.throwError(
          "bad result from backend",
          Se.errors.SERVER_ERROR,
          { method: "estimateGas", params: n, result: r, error: i }
        );
      }
    });
  }
  _getAddress(e) {
    return An(this, void 0, void 0, function* () {
      (e = yield e),
        typeof e != "string" &&
          dr.throwArgumentError("invalid address or ENS name", "name", e);
      const n = yield this.resolveName(e);
      return (
        n == null &&
          dr.throwError(
            "ENS name not configured",
            Se.errors.UNSUPPORTED_OPERATION,
            { operation: `resolveName(${JSON.stringify(e)})` }
          ),
        n
      );
    });
  }
  _getBlock(e, n) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      let r = -128;
      const i = { includeTransactions: !!n };
      if (cr(e, 32)) i.blockHash = e;
      else
        try {
          (i.blockTag = yield this._getBlockTag(e)),
            cr(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16));
        } catch {
          dr.throwArgumentError(
            "invalid block hash or block tag",
            "blockHashOrBlockTag",
            e
          );
        }
      return Fm(
        () =>
          An(this, void 0, void 0, function* () {
            const s = yield this.perform("getBlock", i);
            if (s == null)
              return (i.blockHash != null &&
                this._emitted["b:" + i.blockHash] == null) ||
                (i.blockTag != null && r > this._emitted.block)
                ? null
                : void 0;
            if (n) {
              let a = null;
              for (let l = 0; l < s.transactions.length; l++) {
                const u = s.transactions[l];
                if (u.blockNumber == null) u.confirmations = 0;
                else if (u.confirmations == null) {
                  a == null &&
                    (a = yield this._getInternalBlockNumber(
                      100 + 2 * this.pollingInterval
                    ));
                  let f = a - u.blockNumber + 1;
                  f <= 0 && (f = 1), (u.confirmations = f);
                }
              }
              const o = this.formatter.blockWithTransactions(s);
              return (
                (o.transactions = o.transactions.map((l) =>
                  this._wrapTransaction(l)
                )),
                o
              );
            }
            return this.formatter.block(s);
          }),
        { oncePoll: this }
      );
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const n = { transactionHash: this.formatter.hash(e, !0) };
      return Fm(
        () =>
          An(this, void 0, void 0, function* () {
            const r = yield this.perform("getTransaction", n);
            if (r == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            const i = this.formatter.transactionResponse(r);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let a =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval
                )) -
                i.blockNumber +
                1;
              a <= 0 && (a = 1), (i.confirmations = a);
            }
            return this._wrapTransaction(i);
          }),
        { oncePoll: this }
      );
    });
  }
  getTransactionReceipt(e) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const n = { transactionHash: this.formatter.hash(e, !0) };
      return Fm(
        () =>
          An(this, void 0, void 0, function* () {
            const r = yield this.perform("getTransactionReceipt", n);
            if (r == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            if (r.blockHash == null) return;
            const i = this.formatter.receipt(r);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let a =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval
                )) -
                i.blockNumber +
                1;
              a <= 0 && (a = 1), (i.confirmations = a);
            }
            return i;
          }),
        { oncePoll: this }
      );
    });
  }
  getLogs(e) {
    return An(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield Fi({ filter: this._getFilter(e) }),
        r = yield this.perform("getLogs", n);
      return (
        r.forEach((i) => {
          i.removed == null && (i.removed = !1);
        }),
        Mt.arrayOf(this.formatter.filterLog.bind(this.formatter))(r)
      );
    });
  }
  getEtherPrice() {
    return An(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return An(this, void 0, void 0, function* () {
      if (((e = yield e), typeof e == "number" && e < 0)) {
        e % 1 && dr.throwArgumentError("invalid BlockTag", "blockTag", e);
        let n = yield this._getInternalBlockNumber(
          100 + 2 * this.pollingInterval
        );
        return (n += e), n < 0 && (n = 0), this.formatter.blockTag(n);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return An(this, void 0, void 0, function* () {
      try {
        const n = yield this._getResolver(e);
        return n == null ? null : new CO(this, n, e);
      } catch (n) {
        if (n.code === Se.errors.CALL_EXCEPTION) return null;
        throw n;
      }
    });
  }
  _getResolver(e) {
    return An(this, void 0, void 0, function* () {
      const n = yield this.getNetwork();
      n.ensAddress ||
        dr.throwError(
          "network does not support ENS",
          Se.errors.UNSUPPORTED_OPERATION,
          { operation: "ENS", network: n.name }
        );
      const r = { to: n.ensAddress, data: "0x0178b8bf" + u5(e).substring(2) };
      try {
        return this.formatter.callAddress(yield this.call(r));
      } catch (i) {
        if (i.code === Se.errors.CALL_EXCEPTION) return null;
        throw i;
      }
    });
  }
  resolveName(e) {
    return An(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (r) {
        if (cr(e)) throw r;
      }
      typeof e != "string" &&
        dr.throwArgumentError("invalid ENS name", "name", e);
      const n = yield this.getResolver(e);
      return n ? yield n.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return An(this, void 0, void 0, function* () {
      (e = yield e), (e = this.formatter.address(e));
      const n = e.substring(2).toLowerCase() + ".addr.reverse",
        r = yield this._getResolver(n);
      if (!r) return null;
      let i = hn(
        yield this.call({ to: r, data: "0x691f3431" + u5(n).substring(2) })
      );
      if (
        i.length < 32 ||
        !dt.from(i.slice(0, 32)).eq(32) ||
        ((i = i.slice(32)), i.length < 32)
      )
        return null;
      const s = dt.from(i.slice(0, 32)).toNumber();
      if (((i = i.slice(32)), s > i.length)) return null;
      const a = p1(i.slice(0, s));
      return (yield this.resolveName(a)) != e ? null : a;
    });
  }
  getAvatar(e) {
    return An(this, void 0, void 0, function* () {
      let n = null;
      if (cr(e)) {
        const i = this.formatter.address(e),
          s = i.substring(2).toLowerCase() + ".addr.reverse",
          a = yield this._getResolver(s);
        if (!a) return null;
        n = new CO(this, a, "_", i);
      } else if (((n = yield this.getResolver(e)), !n)) return null;
      const r = yield n.getAvatar();
      return r == null ? null : r.url;
    });
  }
  perform(e, n) {
    return dr.throwError(e + " not implemented", Se.errors.NOT_IMPLEMENTED, {
      operation: e,
    });
  }
  _startEvent(e) {
    this.polling = this._events.filter((n) => n.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((n) => n.pollable()).length > 0;
  }
  _addEventListener(e, n, r) {
    const i = new ede(cp(e), n, r);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(e, n) {
    return this._addEventListener(e, n, !1);
  }
  once(e, n) {
    return this._addEventListener(e, n, !0);
  }
  emit(e, ...n) {
    let r = !1,
      i = [],
      s = cp(e);
    return (
      (this._events = this._events.filter((a) =>
        a.tag !== s
          ? !0
          : (setTimeout(() => {
              a.listener.apply(this, n);
            }, 0),
            (r = !0),
            a.once ? (i.push(a), !1) : !0)
      )),
      i.forEach((a) => {
        this._stopEvent(a);
      }),
      r
    );
  }
  listenerCount(e) {
    if (!e) return this._events.length;
    let n = cp(e);
    return this._events.filter((r) => r.tag === n).length;
  }
  listeners(e) {
    if (e == null) return this._events.map((r) => r.listener);
    let n = cp(e);
    return this._events.filter((r) => r.tag === n).map((r) => r.listener);
  }
  off(e, n) {
    if (n == null) return this.removeAllListeners(e);
    const r = [];
    let i = !1,
      s = cp(e);
    return (
      (this._events = this._events.filter((a) =>
        a.tag !== s || a.listener != n || i ? !0 : ((i = !0), r.push(a), !1)
      )),
      r.forEach((a) => {
        this._stopEvent(a);
      }),
      this
    );
  }
  removeAllListeners(e) {
    let n = [];
    if (e == null) (n = this._events), (this._events = []);
    else {
      const r = cp(e);
      this._events = this._events.filter((i) =>
        i.tag !== r ? !0 : (n.push(i), !1)
      );
    }
    return (
      n.forEach((r) => {
        this._stopEvent(r);
      }),
      this
    );
  }
}
var Ac =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const Ps = new Se(ky),
  sde = ["call", "estimateGas"];
function EH(t, e, n) {
  if (t === "call" && e.code === Se.errors.SERVER_ERROR) {
    const s = e.error;
    if (s && s.message.match("reverted") && cr(s.data)) return s.data;
    Ps.throwError(
      "missing revert data in call exception",
      Se.errors.CALL_EXCEPTION,
      { error: e, data: "0x" }
    );
  }
  let r = e.message;
  e.code === Se.errors.SERVER_ERROR &&
  e.error &&
  typeof e.error.message == "string"
    ? (r = e.error.message)
    : typeof e.body == "string"
    ? (r = e.body)
    : typeof e.responseText == "string" && (r = e.responseText),
    (r = (r || "").toLowerCase());
  const i = n.transaction || n.signedTransaction;
  throw (
    (r.match(/insufficient funds|base fee exceeds gas limit/) &&
      Ps.throwError(
        "insufficient funds for intrinsic transaction cost",
        Se.errors.INSUFFICIENT_FUNDS,
        { error: e, method: t, transaction: i }
      ),
    r.match(/nonce too low/) &&
      Ps.throwError("nonce has already been used", Se.errors.NONCE_EXPIRED, {
        error: e,
        method: t,
        transaction: i,
      }),
    r.match(/replacement transaction underpriced/) &&
      Ps.throwError(
        "replacement fee too low",
        Se.errors.REPLACEMENT_UNDERPRICED,
        { error: e, method: t, transaction: i }
      ),
    r.match(/only replay-protected/) &&
      Ps.throwError(
        "legacy pre-eip-155 transactions not supported",
        Se.errors.UNSUPPORTED_OPERATION,
        { error: e, method: t, transaction: i }
      ),
    sde.indexOf(t) >= 0 &&
      r.match(
        /gas required exceeds allowance|always failing transaction|execution reverted/
      ) &&
      Ps.throwError(
        "cannot estimate gas; transaction may fail or may require manual gas limit",
        Se.errors.UNPREDICTABLE_GAS_LIMIT,
        { error: e, method: t, transaction: i }
      ),
    e)
  );
}
function kO(t) {
  return new Promise(function (e) {
    setTimeout(e, t);
  });
}
function ade(t) {
  if (t.error) {
    const e = new Error(t.error.message);
    throw ((e.code = t.error.code), (e.data = t.error.data), e);
  }
  return t.result;
}
function dm(t) {
  return t && t.toLowerCase();
}
const PE = {};
let xH = class TH extends Ay {
  constructor(e, n, r) {
    if ((Ps.checkNew(new.target, TH), super(), e !== PE))
      throw new Error(
        "do not call the JsonRpcSigner constructor directly; use provider.getSigner"
      );
    Je(this, "provider", n),
      r == null && (r = 0),
      typeof r == "string"
        ? (Je(this, "_address", this.provider.formatter.address(r)),
          Je(this, "_index", null))
        : typeof r == "number"
        ? (Je(this, "_index", r), Je(this, "_address", null))
        : Ps.throwArgumentError(
            "invalid address or index",
            "addressOrIndex",
            r
          );
  }
  connect(e) {
    return Ps.throwError(
      "cannot alter JSON-RPC Signer connection",
      Se.errors.UNSUPPORTED_OPERATION,
      { operation: "connect" }
    );
  }
  connectUnchecked() {
    return new ode(PE, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address
      ? Promise.resolve(this._address)
      : this.provider
          .send("eth_accounts", [])
          .then(
            (e) => (
              e.length <= this._index &&
                Ps.throwError(
                  "unknown account #" + this._index,
                  Se.errors.UNSUPPORTED_OPERATION,
                  { operation: "getAddress" }
                ),
              this.provider.formatter.address(e[this._index])
            )
          );
  }
  sendUncheckedTransaction(e) {
    e = xs(e);
    const n = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
    if (e.gasLimit == null) {
      const r = xs(e);
      (r.from = n), (e.gasLimit = this.provider.estimateGas(r));
    }
    return (
      e.to != null &&
        (e.to = Promise.resolve(e.to).then((r) =>
          Ac(this, void 0, void 0, function* () {
            if (r == null) return null;
            const i = yield this.provider.resolveName(r);
            return (
              i == null &&
                Ps.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  r
                ),
              i
            );
          })
        )),
      Fi({ tx: Fi(e), sender: n }).then(({ tx: r, sender: i }) => {
        r.from != null
          ? r.from.toLowerCase() !== i &&
            Ps.throwArgumentError("from address mismatch", "transaction", e)
          : (r.from = i);
        const s = this.provider.constructor.hexlifyTransaction(r, { from: !0 });
        return this.provider.send("eth_sendTransaction", [s]).then(
          (a) => a,
          (a) => EH("sendTransaction", a, s)
        );
      })
    );
  }
  signTransaction(e) {
    return Ps.throwError(
      "signing transactions is unsupported",
      Se.errors.UNSUPPORTED_OPERATION,
      { operation: "signTransaction" }
    );
  }
  sendTransaction(e) {
    return Ac(this, void 0, void 0, function* () {
      const n = yield this.provider._getInternalBlockNumber(
          100 + 2 * this.provider.pollingInterval
        ),
        r = yield this.sendUncheckedTransaction(e);
      try {
        return yield Fm(
          () =>
            Ac(this, void 0, void 0, function* () {
              const i = yield this.provider.getTransaction(r);
              if (i !== null) return this.provider._wrapTransaction(i, r, n);
            }),
          { oncePoll: this.provider }
        );
      } catch (i) {
        throw ((i.transactionHash = r), i);
      }
    });
  }
  signMessage(e) {
    return Ac(this, void 0, void 0, function* () {
      const n = typeof e == "string" ? Yc(e) : e,
        r = yield this.getAddress();
      return yield this.provider.send("personal_sign", [
        Qt(n),
        r.toLowerCase(),
      ]);
    });
  }
  _legacySignMessage(e) {
    return Ac(this, void 0, void 0, function* () {
      const n = typeof e == "string" ? Yc(e) : e,
        r = yield this.getAddress();
      return yield this.provider.send("eth_sign", [r.toLowerCase(), Qt(n)]);
    });
  }
  _signTypedData(e, n, r) {
    return Ac(this, void 0, void 0, function* () {
      const i = yield nO.resolveNames(e, n, r, (a) =>
          this.provider.resolveName(a)
        ),
        s = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        s.toLowerCase(),
        JSON.stringify(nO.getPayload(i.domain, n, i.value)),
      ]);
    });
  }
  unlock(e) {
    return Ac(this, void 0, void 0, function* () {
      const n = this.provider,
        r = yield this.getAddress();
      return n.send("personal_unlockAccount", [r.toLowerCase(), e, null]);
    });
  }
};
class ode extends xH {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((n) => ({
      hash: n,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (r) => this.provider.waitForTransaction(n, r),
    }));
  }
}
const lde = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
};
let SH = class AH extends ide {
  constructor(e, n) {
    Ps.checkNew(new.target, AH);
    let r = n;
    r == null &&
      (r = new Promise((i, s) => {
        setTimeout(() => {
          this.detectNetwork().then(
            (a) => {
              i(a);
            },
            (a) => {
              s(a);
            }
          );
        }, 0);
      })),
      super(r),
      e || (e = $u(this.constructor, "defaultUrl")()),
      typeof e == "string"
        ? Je(this, "connection", Object.freeze({ url: e }))
        : Je(this, "connection", Object.freeze(xs(e))),
      (this._nextId = 42);
  }
  get _cache() {
    return (
      this._eventLoopCache == null && (this._eventLoopCache = {}),
      this._eventLoopCache
    );
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return (
      this._cache.detectNetwork ||
        ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
        setTimeout(() => {
          this._cache.detectNetwork = null;
        }, 0)),
      this._cache.detectNetwork
    );
  }
  _uncachedDetectNetwork() {
    return Ac(this, void 0, void 0, function* () {
      yield kO(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {}
      }
      if (e != null) {
        const n = $u(this.constructor, "getNetwork");
        try {
          return n(dt.from(e).toNumber());
        } catch (r) {
          return Ps.throwError(
            "could not detect network",
            Se.errors.NETWORK_ERROR,
            { chainId: e, event: "invalidNetwork", serverError: r }
          );
        }
      }
      return Ps.throwError(
        "could not detect network",
        Se.errors.NETWORK_ERROR,
        { event: "noNetwork" }
      );
    });
  }
  getSigner(e) {
    return new xH(PE, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) =>
      e.map((n) => this.formatter.address(n))
    );
  }
  send(e, n) {
    const r = { method: e, params: n, id: this._nextId++, jsonrpc: "2.0" };
    this.emit("debug", { action: "request", request: Zc(r), provider: this });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (i && this._cache[e]) return this._cache[e];
    const s = yH(this.connection, JSON.stringify(r), ade).then(
      (a) => (
        this.emit("debug", {
          action: "response",
          request: r,
          response: a,
          provider: this,
        }),
        a
      ),
      (a) => {
        throw (
          (this.emit("debug", {
            action: "response",
            error: a,
            request: r,
            provider: this,
          }),
          a)
        );
      }
    );
    return (
      i &&
        ((this._cache[e] = s),
        setTimeout(() => {
          this._cache[e] = null;
        }, 0)),
      s
    );
  }
  prepareRequest(e, n) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [dm(n.address), n.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [dm(n.address), n.blockTag]];
      case "getCode":
        return ["eth_getCode", [dm(n.address), n.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [dm(n.address), n.position, n.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [n.signedTransaction]];
      case "getBlock":
        return n.blockTag
          ? ["eth_getBlockByNumber", [n.blockTag, !!n.includeTransactions]]
          : n.blockHash
          ? ["eth_getBlockByHash", [n.blockHash, !!n.includeTransactions]]
          : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [n.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [n.transactionHash]];
      case "call":
        return [
          "eth_call",
          [
            $u(this.constructor, "hexlifyTransaction")(n.transaction, {
              from: !0,
            }),
            n.blockTag,
          ],
        ];
      case "estimateGas":
        return [
          "eth_estimateGas",
          [
            $u(this.constructor, "hexlifyTransaction")(n.transaction, {
              from: !0,
            }),
          ],
        ];
      case "getLogs":
        return (
          n.filter &&
            n.filter.address != null &&
            (n.filter.address = dm(n.filter.address)),
          ["eth_getLogs", [n.filter]]
        );
    }
    return null;
  }
  perform(e, n) {
    return Ac(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const i = n.transaction;
        if (
          i &&
          i.type != null &&
          dt.from(i.type).isZero() &&
          i.maxFeePerGas == null &&
          i.maxPriorityFeePerGas == null
        ) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null &&
            s.maxPriorityFeePerGas == null &&
            ((n = xs(n)), (n.transaction = xs(i)), delete n.transaction.type);
        }
      }
      const r = this.prepareRequest(e, n);
      r == null &&
        Ps.throwError(e + " not implemented", Se.errors.NOT_IMPLEMENTED, {
          operation: e,
        });
      try {
        return yield this.send(r[0], r[1]);
      } catch (i) {
        return EH(e, i, n);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const e = this,
      n = this.send("eth_newPendingTransactionFilter", []);
    (this._pendingFilter = n),
      n
        .then(function (r) {
          function i() {
            e.send("eth_getFilterChanges", [r])
              .then(function (s) {
                if (e._pendingFilter != n) return null;
                let a = Promise.resolve();
                return (
                  s.forEach(function (o) {
                    (e._emitted["t:" + o.toLowerCase()] = "pending"),
                      (a = a.then(function () {
                        return e.getTransaction(o).then(function (l) {
                          return e.emit("pending", l), null;
                        });
                      }));
                  }),
                  a.then(function () {
                    return kO(1e3);
                  })
                );
              })
              .then(function () {
                if (e._pendingFilter != n) {
                  e.send("eth_uninstallFilter", [r]);
                  return;
                }
                return (
                  setTimeout(function () {
                    i();
                  }, 0),
                  null
                );
              })
              .catch((s) => {});
          }
          return i(), r;
        })
        .catch((r) => {});
  }
  _stopEvent(e) {
    e.tag === "pending" &&
      this.listenerCount("pending") === 0 &&
      (this._pendingFilter = null),
      super._stopEvent(e);
  }
  static hexlifyTransaction(e, n) {
    const r = xs(lde);
    if (n) for (const s in n) n[s] && (r[s] = !0);
    mle(e, r);
    const i = {};
    return (
      [
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value",
      ].forEach(function (s) {
        if (e[s] == null) return;
        const a = $7(e[s]);
        s === "gasLimit" && (s = "gas"), (i[s] = a);
      }),
      ["from", "to", "data"].forEach(function (s) {
        e[s] != null && (i[s] = Qt(e[s]));
      }),
      e.accessList && (i.accessList = b1(e.accessList)),
      i
    );
  }
};
var ude =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (a) {
            a(s);
          });
    }
    return new (n || (n = Promise))(function (s, a) {
      function o(f) {
        try {
          u(r.next(f));
        } catch (c) {
          a(c);
        }
      }
      function l(f) {
        try {
          u(r.throw(f));
        } catch (c) {
          a(c);
        }
      }
      function u(f) {
        f.done ? s(f.value) : i(f.value).then(o, l);
      }
      u((r = r.apply(t, e || [])).next());
    });
  };
const cde = new Se(ky);
class fde extends SH {
  detectNetwork() {
    const e = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork },
    });
    return ude(this, void 0, void 0, function* () {
      let n = this.network;
      return (
        n == null &&
          ((n = yield e.detectNetwork.call(this)),
          n ||
            cde.throwError("no network detected", Se.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (Je(this, "_network", n), this.emit("network", n, null))),
        n
      );
    });
  }
}
const Z_ = new Se(ky);
let dde = 1;
function IO(t, e) {
  const n = "Web3LegacyFetcher";
  return function (r, i) {
    const s = { method: r, params: i, id: dde++, jsonrpc: "2.0" };
    return new Promise((a, o) => {
      this.emit("debug", {
        action: "request",
        fetcher: n,
        request: Zc(s),
        provider: this,
      }),
        e(s, (l, u) => {
          if (l)
            return (
              this.emit("debug", {
                action: "response",
                fetcher: n,
                error: l,
                request: s,
                provider: this,
              }),
              o(l)
            );
          if (
            (this.emit("debug", {
              action: "response",
              fetcher: n,
              request: s,
              response: u,
              provider: this,
            }),
            u.error)
          ) {
            const f = new Error(u.error.message);
            return (f.code = u.error.code), (f.data = u.error.data), o(f);
          }
          a(u.result);
        });
    });
  };
}
function hde(t) {
  return function (e, n) {
    n == null && (n = []);
    const r = { method: e, params: n };
    return (
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: Zc(r),
        provider: this,
      }),
      t.request(r).then(
        (i) => (
          this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: r,
            response: i,
            provider: this,
          }),
          i
        ),
        (i) => {
          throw (
            (this.emit("debug", {
              action: "response",
              fetcher: "Eip1193Fetcher",
              request: r,
              error: i,
              provider: this,
            }),
            i)
          );
        }
      )
    );
  };
}
class X7 extends SH {
  constructor(e, n) {
    Z_.checkNew(new.target, X7),
      e == null && Z_.throwArgumentError("missing provider", "provider", e);
    let r = null,
      i = null,
      s = null;
    typeof e == "function"
      ? ((r = "unknown:"), (i = e))
      : ((r = e.host || e.path || ""),
        !r && e.isMetaMask && (r = "metamask"),
        (s = e),
        e.request
          ? (r === "" && (r = "eip-1193:"), (i = hde(e)))
          : e.sendAsync
          ? (i = IO(e, e.sendAsync.bind(e)))
          : e.send
          ? (i = IO(e, e.send.bind(e)))
          : Z_.throwArgumentError("unsupported provider", "provider", e),
        r || (r = "unknown:")),
      super(r, n),
      Je(this, "jsonRpcFetchFunc", i),
      Je(this, "provider", s);
  }
  send(e, n) {
    return this.jsonRpcFetchFunc(e, n);
  }
}
var g5 = { exports: {} };
g5.exports;
(function (t, e) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 800,
    s = 16,
    a = 9007199254740991,
    o = "[object Arguments]",
    l = "[object Array]",
    u = "[object AsyncFunction]",
    f = "[object Boolean]",
    c = "[object Date]",
    d = "[object Error]",
    p = "[object Function]",
    m = "[object GeneratorFunction]",
    g = "[object Map]",
    w = "[object Number]",
    y = "[object Null]",
    v = "[object Object]",
    E = "[object Proxy]",
    S = "[object RegExp]",
    D = "[object Set]",
    P = "[object String]",
    x = "[object Undefined]",
    _ = "[object WeakMap]",
    A = "[object ArrayBuffer]",
    N = "[object DataView]",
    M = "[object Float32Array]",
    T = "[object Float64Array]",
    O = "[object Int8Array]",
    I = "[object Int16Array]",
    k = "[object Int32Array]",
    L = "[object Uint8Array]",
    U = "[object Uint8ClampedArray]",
    $ = "[object Uint16Array]",
    B = "[object Uint32Array]",
    R = /[\\^$.*+?()[\]{}|]/g,
    V = /^\[object .+?Constructor\]$/,
    oe = /^(?:0|[1-9]\d*)$/,
    le = {};
  (le[M] = le[T] = le[O] = le[I] = le[k] = le[L] = le[U] = le[$] = le[B] = !0),
    (le[o] =
      le[l] =
      le[A] =
      le[f] =
      le[N] =
      le[c] =
      le[d] =
      le[p] =
      le[g] =
      le[w] =
      le[v] =
      le[S] =
      le[D] =
      le[P] =
      le[_] =
        !1);
  var fe = typeof Ur == "object" && Ur && Ur.Object === Object && Ur,
    z = typeof self == "object" && self && self.Object === Object && self,
    se = fe || z || Function("return this")(),
    Y = e && !e.nodeType && e,
    Q = Y && !0 && t && !t.nodeType && t,
    ee = Q && Q.exports === Y,
    F = ee && fe.process,
    te = (function () {
      try {
        var q = Q && Q.require && Q.require("util").types;
        return q || (F && F.binding && F.binding("util"));
      } catch {}
    })(),
    he = te && te.isTypedArray;
  function Te(q, ie, ve) {
    switch (ve.length) {
      case 0:
        return q.call(ie);
      case 1:
        return q.call(ie, ve[0]);
      case 2:
        return q.call(ie, ve[0], ve[1]);
      case 3:
        return q.call(ie, ve[0], ve[1], ve[2]);
    }
    return q.apply(ie, ve);
  }
  function Ce(q, ie) {
    for (var ve = -1, Me = Array(q); ++ve < q; ) Me[ve] = ie(ve);
    return Me;
  }
  function ke(q) {
    return function (ie) {
      return q(ie);
    };
  }
  function at(q, ie) {
    return q?.[ie];
  }
  function Rt(q, ie) {
    return function (ve) {
      return q(ie(ve));
    };
  }
  var Ft = Array.prototype,
    Nt = Function.prototype,
    Ot = Object.prototype,
    et = se["__core-js_shared__"],
    st = Nt.toString,
    vt = Ot.hasOwnProperty,
    Re = (function () {
      var q = /[^.]+$/.exec((et && et.keys && et.keys.IE_PROTO) || "");
      return q ? "Symbol(src)_1." + q : "";
    })(),
    me = Ot.toString,
    $e = st.call(Object),
    De = RegExp(
      "^" +
        st
          .call(vt)
          .replace(R, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    je = ee ? se.Buffer : void 0,
    lt = se.Symbol,
    Ke = se.Uint8Array,
    tt = je ? je.allocUnsafe : void 0,
    jt = Rt(Object.getPrototypeOf, Object),
    ct = Object.create,
    rt = Ot.propertyIsEnumerable,
    Dt = Ft.splice,
    Ht = lt ? lt.toStringTag : void 0,
    Yt = (function () {
      try {
        var q = jo(Object, "defineProperty");
        return q({}, "", {}), q;
      } catch {}
    })(),
    sr = je ? je.isBuffer : void 0,
    Bt = Math.max,
    en = Date.now,
    Tr = jo(se, "Map"),
    on = jo(Object, "create"),
    Pt = (function () {
      function q() {}
      return function (ie) {
        if (!ps(ie)) return {};
        if (ct) return ct(ie);
        q.prototype = ie;
        var ve = new q();
        return (q.prototype = void 0), ve;
      };
    })();
  function fn(q) {
    var ie = -1,
      ve = q == null ? 0 : q.length;
    for (this.clear(); ++ie < ve; ) {
      var Me = q[ie];
      this.set(Me[0], Me[1]);
    }
  }
  function Wt() {
    (this.__data__ = on ? on(null) : {}), (this.size = 0);
  }
  function qt(q) {
    var ie = this.has(q) && delete this.__data__[q];
    return (this.size -= ie ? 1 : 0), ie;
  }
  function Ye(q) {
    var ie = this.__data__;
    if (on) {
      var ve = ie[q];
      return ve === r ? void 0 : ve;
    }
    return vt.call(ie, q) ? ie[q] : void 0;
  }
  function xe(q) {
    var ie = this.__data__;
    return on ? ie[q] !== void 0 : vt.call(ie, q);
  }
  function nt(q, ie) {
    var ve = this.__data__;
    return (
      (this.size += this.has(q) ? 0 : 1),
      (ve[q] = on && ie === void 0 ? r : ie),
      this
    );
  }
  (fn.prototype.clear = Wt),
    (fn.prototype.delete = qt),
    (fn.prototype.get = Ye),
    (fn.prototype.has = xe),
    (fn.prototype.set = nt);
  function gt(q) {
    var ie = -1,
      ve = q == null ? 0 : q.length;
    for (this.clear(); ++ie < ve; ) {
      var Me = q[ie];
      this.set(Me[0], Me[1]);
    }
  }
  function ht() {
    (this.__data__ = []), (this.size = 0);
  }
  function wt(q) {
    var ie = this.__data__,
      ve = zi(ie, q);
    if (ve < 0) return !1;
    var Me = ie.length - 1;
    return ve == Me ? ie.pop() : Dt.call(ie, ve, 1), --this.size, !0;
  }
  function rn(q) {
    var ie = this.__data__,
      ve = zi(ie, q);
    return ve < 0 ? void 0 : ie[ve][1];
  }
  function ot(q) {
    return zi(this.__data__, q) > -1;
  }
  function pt(q, ie) {
    var ve = this.__data__,
      Me = zi(ve, q);
    return Me < 0 ? (++this.size, ve.push([q, ie])) : (ve[Me][1] = ie), this;
  }
  (gt.prototype.clear = ht),
    (gt.prototype.delete = wt),
    (gt.prototype.get = rn),
    (gt.prototype.has = ot),
    (gt.prototype.set = pt);
  function zt(q) {
    var ie = -1,
      ve = q == null ? 0 : q.length;
    for (this.clear(); ++ie < ve; ) {
      var Me = q[ie];
      this.set(Me[0], Me[1]);
    }
  }
  function Zt() {
    (this.size = 0),
      (this.__data__ = {
        hash: new fn(),
        map: new (Tr || gt)(),
        string: new fn(),
      });
  }
  function $t(q) {
    var ie = po(this, q).delete(q);
    return (this.size -= ie ? 1 : 0), ie;
  }
  function Vr(q) {
    return po(this, q).get(q);
  }
  function $n(q) {
    return po(this, q).has(q);
  }
  function En(q, ie) {
    var ve = po(this, q),
      Me = ve.size;
    return ve.set(q, ie), (this.size += ve.size == Me ? 0 : 1), this;
  }
  (zt.prototype.clear = Zt),
    (zt.prototype.delete = $t),
    (zt.prototype.get = Vr),
    (zt.prototype.has = $n),
    (zt.prototype.set = En);
  function In(q) {
    var ie = (this.__data__ = new gt(q));
    this.size = ie.size;
  }
  function as() {
    (this.__data__ = new gt()), (this.size = 0);
  }
  function os(q) {
    var ie = this.__data__,
      ve = ie.delete(q);
    return (this.size = ie.size), ve;
  }
  function ls(q) {
    return this.__data__.get(q);
  }
  function us(q) {
    return this.__data__.has(q);
  }
  function Or(q, ie) {
    var ve = this.__data__;
    if (ve instanceof gt) {
      var Me = ve.__data__;
      if (!Tr || Me.length < n - 1)
        return Me.push([q, ie]), (this.size = ++ve.size), this;
      ve = this.__data__ = new zt(Me);
    }
    return ve.set(q, ie), (this.size = ve.size), this;
  }
  (In.prototype.clear = as),
    (In.prototype.delete = os),
    (In.prototype.get = ls),
    (In.prototype.has = us),
    (In.prototype.set = Or);
  function ar(q, ie) {
    var ve = Wo(q),
      Me = !ve && Vi(q),
      St = !ve && !Me && gu(q),
      kt = !ve && !Me && !St && Fa(q),
      _t = ve || Me || St || kt,
      Et = _t ? Ce(q.length, String) : [],
      tn = Et.length;
    for (var Kn in q)
      (ie || vt.call(q, Kn)) &&
        !(
          _t &&
          (Kn == "length" ||
            (St && (Kn == "offset" || Kn == "parent")) ||
            (kt &&
              (Kn == "buffer" || Kn == "byteLength" || Kn == "byteOffset")) ||
            fu(Kn, tn))
        ) &&
        Et.push(Kn);
    return Et;
  }
  function cs(q, ie, ve) {
    ((ve !== void 0 && !Go(q[ie], ve)) || (ve === void 0 && !(ie in q))) &&
      la(q, ie, ve);
  }
  function lo(q, ie, ve) {
    var Me = q[ie];
    (!(vt.call(q, ie) && Go(Me, ve)) || (ve === void 0 && !(ie in q))) &&
      la(q, ie, ve);
  }
  function zi(q, ie) {
    for (var ve = q.length; ve--; ) if (Go(q[ve][0], ie)) return ve;
    return -1;
  }
  function la(q, ie, ve) {
    ie == "__proto__" && Yt
      ? Yt(q, ie, { configurable: !0, enumerable: !0, value: ve, writable: !0 })
      : (q[ie] = ve);
  }
  var xi = Ma();
  function ci(q) {
    return q == null
      ? q === void 0
        ? x
        : y
      : Ht && Ht in Object(q)
      ? Ho(q)
      : pu(q);
  }
  function ua(q) {
    return js(q) && ci(q) == o;
  }
  function Ra(q) {
    if (!ps(q) || Ba(q)) return !1;
    var ie = Qr(q) ? De : V;
    return ie.test(Il(q));
  }
  function pr(q) {
    return js(q) && Gr(q.length) && !!le[ci(q)];
  }
  function uo(q) {
    if (!ps(q)) return hu(q);
    var ie = Mi(q),
      ve = [];
    for (var Me in q)
      (Me == "constructor" && (ie || !vt.call(q, Me))) || ve.push(Me);
    return ve;
  }
  function fs(q, ie, ve, Me, St) {
    q !== ie &&
      xi(
        ie,
        function (kt, _t) {
          if ((St || (St = new In()), ps(kt))) co(q, ie, _t, ve, fs, Me, St);
          else {
            var Et = Me ? Me(Vo(q, _t), kt, _t + "", q, ie, St) : void 0;
            Et === void 0 && (Et = kt), cs(q, _t, Et);
          }
        },
        vu
      );
  }
  function co(q, ie, ve, Me, St, kt, _t) {
    var Et = Vo(q, ve),
      tn = Vo(ie, ve),
      Kn = _t.get(tn);
    if (Kn) {
      cs(q, ve, Kn);
      return;
    }
    var pn = kt ? kt(Et, tn, ve + "", q, ie, _t) : void 0,
      xn = pn === void 0;
    if (xn) {
      var Sr = Wo(tn),
        Gi = !Sr && gu(tn),
        Wi = !Sr && !Gi && Fa(tn);
      (pn = tn),
        Sr || Gi || Wi
          ? Wo(Et)
            ? (pn = Et)
            : hs(Et)
            ? (pn = fo(Et))
            : Gi
            ? ((xn = !1), (pn = cu(tn, !0)))
            : Wi
            ? ((xn = !1), (pn = Al(tn, !0)))
            : (pn = [])
          : Hs(tn) || Vi(tn)
          ? ((pn = Et),
            Vi(Et) ? (pn = yu(Et)) : (!ps(Et) || Qr(Et)) && (pn = La(tn)))
          : (xn = !1);
    }
    xn && (_t.set(tn, pn), St(pn, tn, Me, kt, _t), _t.delete(tn)),
      cs(q, ve, pn);
  }
  function lc(q, ie) {
    return kl(Us(q, ie, re), q + "");
  }
  var ds = Yt
    ? function (q, ie) {
        return Yt(q, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Un(ie),
          writable: !0,
        });
      }
    : re;
  function cu(q, ie) {
    if (ie) return q.slice();
    var ve = q.length,
      Me = tt ? tt(ve) : new q.constructor(ve);
    return q.copy(Me), Me;
  }
  function $s(q) {
    var ie = new q.constructor(q.byteLength);
    return new Ke(ie).set(new Ke(q)), ie;
  }
  function Al(q, ie) {
    var ve = ie ? $s(q.buffer) : q.buffer;
    return new q.constructor(ve, q.byteOffset, q.length);
  }
  function fo(q, ie) {
    var ve = -1,
      Me = q.length;
    for (ie || (ie = Array(Me)); ++ve < Me; ) ie[ve] = q[ve];
    return ie;
  }
  function Cl(q, ie, ve, Me) {
    var St = !ve;
    ve || (ve = {});
    for (var kt = -1, _t = ie.length; ++kt < _t; ) {
      var Et = ie[kt],
        tn = Me ? Me(ve[Et], q[Et], Et, ve, q) : void 0;
      tn === void 0 && (tn = q[Et]), St ? la(ve, Et, tn) : lo(ve, Et, tn);
    }
    return ve;
  }
  function ho(q) {
    return lc(function (ie, ve) {
      var Me = -1,
        St = ve.length,
        kt = St > 1 ? ve[St - 1] : void 0,
        _t = St > 2 ? ve[2] : void 0;
      for (
        kt = q.length > 3 && typeof kt == "function" ? (St--, kt) : void 0,
          _t && du(ve[0], ve[1], _t) && ((kt = St < 3 ? void 0 : kt), (St = 1)),
          ie = Object(ie);
        ++Me < St;

      ) {
        var Et = ve[Me];
        Et && q(ie, Et, Me, kt);
      }
      return ie;
    });
  }
  function Ma(q) {
    return function (ie, ve, Me) {
      for (var St = -1, kt = Object(ie), _t = Me(ie), Et = _t.length; Et--; ) {
        var tn = _t[q ? Et : ++St];
        if (ve(kt[tn], tn, kt) === !1) break;
      }
      return ie;
    };
  }
  function po(q, ie) {
    var ve = q.__data__;
    return zo(ie) ? ve[typeof ie == "string" ? "string" : "hash"] : ve.map;
  }
  function jo(q, ie) {
    var ve = at(q, ie);
    return Ra(ve) ? ve : void 0;
  }
  function Ho(q) {
    var ie = vt.call(q, Ht),
      ve = q[Ht];
    try {
      q[Ht] = void 0;
      var Me = !0;
    } catch {}
    var St = me.call(q);
    return Me && (ie ? (q[Ht] = ve) : delete q[Ht]), St;
  }
  function La(q) {
    return typeof q.constructor == "function" && !Mi(q) ? Pt(jt(q)) : {};
  }
  function fu(q, ie) {
    var ve = typeof q;
    return (
      (ie = ie ?? a),
      !!ie &&
        (ve == "number" || (ve != "symbol" && oe.test(q))) &&
        q > -1 &&
        q % 1 == 0 &&
        q < ie
    );
  }
  function du(q, ie, ve) {
    if (!ps(ve)) return !1;
    var Me = typeof ie;
    return (
      Me == "number" ? qo(ve) && fu(ie, ve.length) : Me == "string" && ie in ve
    )
      ? Go(ve[ie], q)
      : !1;
  }
  function zo(q) {
    var ie = typeof q;
    return ie == "string" || ie == "number" || ie == "symbol" || ie == "boolean"
      ? q !== "__proto__"
      : q === null;
  }
  function Ba(q) {
    return !!Re && Re in q;
  }
  function Mi(q) {
    var ie = q && q.constructor,
      ve = (typeof ie == "function" && ie.prototype) || Ot;
    return q === ve;
  }
  function hu(q) {
    var ie = [];
    if (q != null) for (var ve in Object(q)) ie.push(ve);
    return ie;
  }
  function pu(q) {
    return me.call(q);
  }
  function Us(q, ie, ve) {
    return (
      (ie = Bt(ie === void 0 ? q.length - 1 : ie, 0)),
      function () {
        for (
          var Me = arguments,
            St = -1,
            kt = Bt(Me.length - ie, 0),
            _t = Array(kt);
          ++St < kt;

        )
          _t[St] = Me[ie + St];
        St = -1;
        for (var Et = Array(ie + 1); ++St < ie; ) Et[St] = Me[St];
        return (Et[ie] = ve(_t)), Te(q, this, Et);
      }
    );
  }
  function Vo(q, ie) {
    if (
      !(ie === "constructor" && typeof q[ie] == "function") &&
      ie != "__proto__"
    )
      return q[ie];
  }
  var kl = mu(ds);
  function mu(q) {
    var ie = 0,
      ve = 0;
    return function () {
      var Me = en(),
        St = s - (Me - ve);
      if (((ve = Me), St > 0)) {
        if (++ie >= i) return arguments[0];
      } else ie = 0;
      return q.apply(void 0, arguments);
    };
  }
  function Il(q) {
    if (q != null) {
      try {
        return st.call(q);
      } catch {}
      try {
        return q + "";
      } catch {}
    }
    return "";
  }
  function Go(q, ie) {
    return q === ie || (q !== q && ie !== ie);
  }
  var Vi = ua(
      (function () {
        return arguments;
      })()
    )
      ? ua
      : function (q) {
          return js(q) && vt.call(q, "callee") && !rt.call(q, "callee");
        },
    Wo = Array.isArray;
  function qo(q) {
    return q != null && Gr(q.length) && !Qr(q);
  }
  function hs(q) {
    return js(q) && qo(q);
  }
  var gu = sr || pe;
  function Qr(q) {
    if (!ps(q)) return !1;
    var ie = ci(q);
    return ie == p || ie == m || ie == u || ie == E;
  }
  function Gr(q) {
    return typeof q == "number" && q > -1 && q % 1 == 0 && q <= a;
  }
  function ps(q) {
    var ie = typeof q;
    return q != null && (ie == "object" || ie == "function");
  }
  function js(q) {
    return q != null && typeof q == "object";
  }
  function Hs(q) {
    if (!js(q) || ci(q) != v) return !1;
    var ie = jt(q);
    if (ie === null) return !0;
    var ve = vt.call(ie, "constructor") && ie.constructor;
    return typeof ve == "function" && ve instanceof ve && st.call(ve) == $e;
  }
  var Fa = he ? ke(he) : pr;
  function yu(q) {
    return Cl(q, vu(q));
  }
  function vu(q) {
    return qo(q) ? ar(q, !0) : uo(q);
  }
  var qn = ho(function (q, ie, ve) {
    fs(q, ie, ve);
  });
  function Un(q) {
    return function () {
      return q;
    };
  }
  function re(q) {
    return q;
  }
  function pe() {
    return !1;
  }
  t.exports = qn;
})(g5, g5.exports);
var pde = g5.exports;
const mde = oa(pde);
var CH = { exports: {} };
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(l, u, f) {
    (this.fn = l), (this.context = u), (this.once = f || !1);
  }
  function s(l, u, f, c, d) {
    if (typeof f != "function")
      throw new TypeError("The listener must be a function");
    var p = new i(f, c || l, d),
      m = n ? n + u : u;
    return (
      l._events[m]
        ? l._events[m].fn
          ? (l._events[m] = [l._events[m], p])
          : l._events[m].push(p)
        : ((l._events[m] = p), l._eventsCount++),
      l
    );
  }
  function a(l, u) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[u];
  }
  function o() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var u = [],
      f,
      c;
    if (this._eventsCount === 0) return u;
    for (c in (f = this._events)) e.call(f, c) && u.push(n ? c.slice(1) : c);
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(f))
      : u;
  }),
    (o.prototype.listeners = function (u) {
      var f = n ? n + u : u,
        c = this._events[f];
      if (!c) return [];
      if (c.fn) return [c.fn];
      for (var d = 0, p = c.length, m = new Array(p); d < p; d++)
        m[d] = c[d].fn;
      return m;
    }),
    (o.prototype.listenerCount = function (u) {
      var f = n ? n + u : u,
        c = this._events[f];
      return c ? (c.fn ? 1 : c.length) : 0;
    }),
    (o.prototype.emit = function (u, f, c, d, p, m) {
      var g = n ? n + u : u;
      if (!this._events[g]) return !1;
      var w = this._events[g],
        y = arguments.length,
        v,
        E;
      if (w.fn) {
        switch ((w.once && this.removeListener(u, w.fn, void 0, !0), y)) {
          case 1:
            return w.fn.call(w.context), !0;
          case 2:
            return w.fn.call(w.context, f), !0;
          case 3:
            return w.fn.call(w.context, f, c), !0;
          case 4:
            return w.fn.call(w.context, f, c, d), !0;
          case 5:
            return w.fn.call(w.context, f, c, d, p), !0;
          case 6:
            return w.fn.call(w.context, f, c, d, p, m), !0;
        }
        for (E = 1, v = new Array(y - 1); E < y; E++) v[E - 1] = arguments[E];
        w.fn.apply(w.context, v);
      } else {
        var S = w.length,
          D;
        for (E = 0; E < S; E++)
          switch (
            (w[E].once && this.removeListener(u, w[E].fn, void 0, !0), y)
          ) {
            case 1:
              w[E].fn.call(w[E].context);
              break;
            case 2:
              w[E].fn.call(w[E].context, f);
              break;
            case 3:
              w[E].fn.call(w[E].context, f, c);
              break;
            case 4:
              w[E].fn.call(w[E].context, f, c, d);
              break;
            default:
              if (!v)
                for (D = 1, v = new Array(y - 1); D < y; D++)
                  v[D - 1] = arguments[D];
              w[E].fn.apply(w[E].context, v);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (u, f, c) {
      return s(this, u, f, c, !1);
    }),
    (o.prototype.once = function (u, f, c) {
      return s(this, u, f, c, !0);
    }),
    (o.prototype.removeListener = function (u, f, c, d) {
      var p = n ? n + u : u;
      if (!this._events[p]) return this;
      if (!f) return a(this, p), this;
      var m = this._events[p];
      if (m.fn)
        m.fn === f && (!d || m.once) && (!c || m.context === c) && a(this, p);
      else {
        for (var g = 0, w = [], y = m.length; g < y; g++)
          (m[g].fn !== f || (d && !m[g].once) || (c && m[g].context !== c)) &&
            w.push(m[g]);
        w.length ? (this._events[p] = w.length === 1 ? w[0] : w) : a(this, p);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (u) {
      var f;
      return (
        u
          ? ((f = n ? n + u : u), this._events[f] && a(this, f))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = n),
    (o.EventEmitter = o),
    (t.exports = o);
})(CH);
var gde = CH.exports;
const yde = oa(gde);
var kH = `<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="56" height="56" rx="8" fill="#262A3D"/>
<g clip-path="url(#clip0_15747_103507)">
<path d="M20.6176 35.9801L16.0142 27.9949H25.2218L29.826 35.9801H20.6176Z" fill="#262A3D"/>
<path d="M20.6176 35.9801L16.0142 27.9949H25.2218L29.826 35.9801H20.6176Z" fill="white"/>
<path d="M25.2218 27.9947H16.0142L20.6176 20.0095H29.826L25.2218 27.9947Z" fill="url(#paint0_linear_15747_103507)"/>
<path d="M34.4302 27.9948L29.826 20.0096H20.6176L16.0142 12.0244H34.4302L43.6379 27.9948H34.4302Z" fill="#262A3D"/>
<path d="M34.4302 27.9948L29.826 20.0096H20.6176L16.0142 12.0244H34.4302L43.6379 27.9948H34.4302Z" fill="white"/>
<path d="M34.4302 43.9652H16.0142L20.6176 35.9801H29.826L34.4302 27.9949H43.6379L34.4302 43.9652Z" fill="url(#paint1_linear_15747_103507)"/>
</g>
<defs>
<linearGradient id="paint0_linear_15747_103507" x1="16.0142" y1="24.0021" x2="29.826" y2="24.0021" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<linearGradient id="paint1_linear_15747_103507" x1="76.5102" y1="5214.05" x2="10391.8" y2="5214.05" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<clipPath id="clip0_15747_103507">
<rect width="27.6667" height="32" fill="white" transform="translate(16 12)"/>
</clipPath>
</defs>
</svg>
`,
  vde = `
<svg width="152" height="16" viewBox="0 0 152 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.03641 6.252C3.23241 6.252 2.41641 6.636 2.04441 7.272V6.396H1.00041V14.724H2.04441V11.124C2.41641 11.784 3.20841 12.144 4.04841 12.144C5.58441 12.144 6.84441 10.98 6.84441 9.204C6.84441 7.44 5.57241 6.252 4.03641 6.252ZM3.94041 11.16C3.02841 11.16 2.04441 10.428 2.04441 9.216C2.04441 8.016 2.94441 7.236 3.94041 7.236C4.97241 7.236 5.78841 8.1 5.78841 9.216C5.78841 10.344 4.97241 11.16 3.94041 11.16ZM10.8452 12.144C12.4412 12.144 13.7852 10.968 13.7852 9.192C13.7852 7.416 12.4412 6.252 10.8452 6.252C9.24919 6.252 7.91719 7.416 7.91719 9.192C7.91719 10.968 9.24919 12.144 10.8452 12.144ZM10.8452 11.16C9.82519 11.16 8.97319 10.356 8.97319 9.192C8.97319 8.04 9.82519 7.236 10.8452 7.236C11.8772 7.236 12.7412 8.04 12.7412 9.192C12.7412 10.356 11.8772 11.16 10.8452 11.16ZM22.2729 6.396L20.8449 10.38L19.4049 6.396H18.3849L16.9569 10.38L15.5289 6.396H14.4009L16.5369 12H17.4009L18.8889 7.836L20.4369 12H21.3129L23.4009 6.396H22.2729ZM29.6948 9.18C29.6948 7.404 28.5068 6.252 26.9108 6.252C25.3148 6.252 24.0308 7.404 24.0308 9.18C24.0308 10.956 25.3148 12.144 26.9108 12.144C27.9908 12.144 28.9988 11.616 29.4788 10.644L28.5788 10.284C28.2548 10.848 27.6308 11.16 26.9468 11.16C25.9868 11.16 25.2668 10.644 25.1108 9.648H29.6708C29.6828 9.492 29.6948 9.336 29.6948 9.18ZM25.1228 8.748C25.2908 7.74 25.9628 7.236 26.9108 7.236C27.8348 7.236 28.5188 7.788 28.6508 8.748H25.1228ZM33.7456 6.252C33.0016 6.252 32.4616 6.684 32.1736 7.668V6.396H31.1176V12H32.1736V9.948C32.1736 8.472 32.6176 7.26 33.7336 7.26C33.9496 7.26 34.2496 7.308 34.5496 7.452L34.7176 6.468C34.5496 6.36 34.1416 6.252 33.7456 6.252ZM40.8627 9.18C40.8627 7.404 39.6747 6.252 38.0787 6.252C36.4827 6.252 35.1987 7.404 35.1987 9.18C35.1987 10.956 36.4827 12.144 38.0787 12.144C39.1587 12.144 40.1667 11.616 40.6467 10.644L39.7467 10.284C39.4227 10.848 38.7987 11.16 38.1147 11.16C37.1547 11.16 36.4347 10.644 36.2787 9.648H40.8387C40.8507 9.492 40.8627 9.336 40.8627 9.18ZM36.2907 8.748C36.4587 7.74 37.1307 7.236 38.0787 7.236C39.0027 7.236 39.6867 7.788 39.8187 8.748H36.2907ZM46.7136 3.348V7.272C46.3416 6.612 45.5496 6.252 44.7096 6.252C43.1736 6.252 41.9136 7.416 41.9136 9.192C41.9136 10.956 43.1856 12.144 44.7216 12.144C45.5256 12.144 46.3416 11.76 46.7136 11.124V12H47.7576V3.348H46.7136ZM44.8056 11.16C43.7856 11.16 42.9696 10.296 42.9696 9.18C42.9696 8.052 43.7856 7.236 44.8056 7.236C45.7296 7.236 46.7136 7.968 46.7136 9.18C46.7136 10.38 45.8136 11.16 44.8056 11.16ZM55.6695 6.252C54.8295 6.252 54.0375 6.612 53.6655 7.272V3.348H52.6215V12H53.6655V11.124C54.0375 11.76 54.8535 12.144 55.6575 12.144C57.1935 12.144 58.4655 10.956 58.4655 9.192C58.4655 7.416 57.2055 6.252 55.6695 6.252ZM55.5615 11.16C54.5655 11.16 53.6655 10.38 53.6655 9.18C53.6655 7.968 54.6495 7.236 55.5615 7.236C56.5935 7.236 57.4095 8.052 57.4095 9.18C57.4095 10.296 56.5935 11.16 55.5615 11.16ZM63.6097 6.396L61.8937 10.524L60.2017 6.396H59.0737L61.3297 11.832L60.1537 14.724H61.2577L64.7377 6.396H63.6097Z" fill="var(--w3o-text-color, #707481)"/>
<g clip-path="url(#clip0_13558_103869)">
<path d="M143.502 11.0888L141.863 8.24889H145.142L146.782 11.0888H143.502Z" fill="currentColor"/>
<path d="M145.142 8.24887H141.863L143.502 5.40895H146.782L145.142 8.24887Z" fill="url(#paint0_linear_13558_103869)"/>
<path d="M148.421 8.24888L146.782 5.40896H143.502L141.863 2.56903H148.421L151.701 8.24888H148.421Z" fill="currentColor"/>
<path d="M148.421 13.9287H141.863L143.502 11.0888H146.782L148.421 8.24889H151.701L148.421 13.9287Z" fill="url(#paint1_linear_13558_103869)"/>
<path d="M76.4774 8.89232C76.4774 10.9327 74.9716 12.5077 73.1366 12.5077C72.1369 12.5077 71.4106 12.1378 70.9181 11.508V12.316H69.1513V2.71994L70.9181 2.17606V6.27771C71.4106 5.64894 72.1369 5.27797 73.1366 5.27797C74.9716 5.27797 76.4774 6.85198 76.4774 8.89232ZM74.7106 8.89232C74.7106 7.73959 73.9037 6.96201 72.8076 6.96201C71.7114 6.96201 70.9213 7.74273 70.9213 8.89232C70.9213 10.0419 71.7292 10.8237 72.8076 10.8237C73.8859 10.8237 74.7106 10.043 74.7106 8.89232Z" fill="currentColor"/>
<path d="M77.2718 2.71994L79.0376 2.17606V12.316H77.2718V2.71994Z" fill="currentColor"/>
<path d="M79.8183 8.89232C79.8171 8.17544 80.0286 7.47431 80.4261 6.87774C80.8236 6.28117 81.3893 5.816 82.0514 5.54113C82.7135 5.26627 83.4422 5.19408 84.1454 5.33371C84.8485 5.47333 85.4944 5.8185 86.0013 6.32549C86.5081 6.83247 86.8531 7.47847 86.9925 8.18166C87.1319 8.88486 87.0595 9.61361 86.7845 10.2756C86.5094 10.9376 86.0441 11.5031 85.4474 11.9005C84.8507 12.2978 84.1495 12.5092 83.4326 12.5077C82.9565 12.5128 82.4842 12.4227 82.0433 12.2428C81.6024 12.0629 81.2019 11.7967 80.8653 11.46C80.5286 11.1232 80.2626 10.7227 80.0828 10.2817C79.903 9.84083 79.8131 9.36845 79.8183 8.89232ZM85.2948 8.89232C85.2948 7.78359 84.4869 7.00602 83.4326 7.00602C82.3784 7.00602 81.5841 7.78674 81.5841 8.89232C81.5841 9.9979 82.392 10.7786 83.4326 10.7786C84.4733 10.7786 85.2948 10.0021 85.2948 8.89232Z" fill="currentColor"/>
<path d="M87.7313 8.89233C87.7313 6.85198 89.2645 5.27797 91.3457 5.27797C92.6881 5.27797 93.8513 5.98952 94.413 7.04375L92.8935 7.93451C92.6189 7.37281 92.03 7.01651 91.3321 7.01651C90.2778 7.01651 89.4971 7.79723 89.4971 8.89233C89.4971 9.98743 90.2778 10.7545 91.3321 10.7545C92.0447 10.7545 92.6326 10.4129 92.904 9.8512L94.4371 10.7273C94.1281 11.2741 93.6779 11.7279 93.1335 12.0413C92.5891 12.3547 91.9706 12.5161 91.3425 12.5088C89.2645 12.5077 87.7313 10.9327 87.7313 8.89233Z" fill="currentColor"/>
<path d="M99.5123 12.316L97.0203 9.20776V12.316H95.2534V2.71994L97.0203 2.17606V8.48153L99.374 5.46974H101.482L98.7316 8.85145L101.566 12.316H99.5123Z" fill="currentColor"/>
<path d="M108.623 8.11161V12.316H106.856V8.33377C106.856 7.40215 106.296 6.92324 105.501 6.92324C104.639 6.92324 103.994 7.4294 103.994 8.62091V12.316H102.229V5.46974H103.994V6.23579C104.405 5.6196 105.118 5.27797 106.035 5.27797C107.486 5.27797 108.623 6.29657 108.623 8.11161Z" fill="currentColor"/>
<path d="M116.74 5.46974V12.316H114.975V11.508C114.481 12.1242 113.742 12.5077 112.743 12.5077C110.921 12.5077 109.415 10.9358 109.415 8.89233C109.415 6.84884 110.921 5.27797 112.743 5.27797C113.742 5.27797 114.481 5.66152 114.975 6.27771V5.46974H116.74ZM114.975 8.89233C114.975 7.73959 114.167 6.96201 113.071 6.96201C111.974 6.96201 111.184 7.74273 111.184 8.89233C111.184 10.0419 111.992 10.8237 113.071 10.8237C114.149 10.8237 114.975 10.043 114.975 8.89233Z" fill="currentColor"/>
<path d="M121.344 7.16742V5.46975H119.796V3.45665L118.027 4.00053V10.0157C118.027 11.8643 118.866 12.5895 121.342 12.3212V10.7137C120.329 10.7692 119.794 10.7545 119.794 10.0157V7.16742H121.344Z" fill="currentColor"/>
<path d="M122.582 5.46974H124.347V12.316H122.582V5.46974Z" fill="currentColor"/>
<path d="M132.293 5.46974L129.691 12.316H127.678L125.077 5.46974H127.021L128.678 10.262L130.348 5.46974H132.293Z" fill="currentColor"/>
<path d="M136.073 10.9075C136.757 10.9075 137.305 10.6204 137.607 10.2232L139.03 11.0448C138.387 11.9754 137.36 12.5119 136.046 12.5119C133.74 12.5119 132.294 10.94 132.294 8.89652C132.294 6.85303 133.761 5.28217 135.908 5.28217C137.935 5.28217 139.373 6.88447 139.373 8.89652C139.37 9.13886 139.346 9.38049 139.301 9.61856H134.143C134.389 10.5219 135.142 10.9075 136.073 10.9075ZM137.607 8.25099C137.387 7.26487 136.648 6.8677 135.908 6.8677C134.965 6.8677 134.321 7.37491 134.114 8.25099H137.607Z" fill="currentColor"/>
</g>
<defs>
<linearGradient id="paint0_linear_13558_103869" x1="141.863" y1="6.82891" x2="146.782" y2="6.82891" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<linearGradient id="paint1_linear_13558_103869" x1="6973.93" y1="500.862" x2="7897.53" y2="500.862" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<clipPath id="clip0_13558_103869">
<rect width="82.8232" height="12" fill="white" transform="translate(69.0884 2)"/>
</clipPath>
</defs>
</svg>
`,
  fp = `
  <svg height="100%" viewBox="0 0 10 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.99902 0.12619V5.20805L9.58065 7.12736L4.99902 0.12619Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 0.12619L0.416992 7.12736L4.99923 5.20805V0.12619Z" fill="white"/>
    <path d="M4.99902 10.4207V13.8737L9.58371 7.92728L4.99902 10.4207Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 13.8737V10.4201L0.416992 7.92728L4.99923 13.8737Z" fill="white"/>
    <path d="M4.99902 9.62134L9.58065 7.12739L4.99902 5.20923V9.62134Z" fill="white" fill-opacity="0.2"/>
    <path d="M0.416992 7.12739L4.99923 9.62134V5.20923L0.416992 7.12739Z" fill="white" fill-opacity="0.602"/>
  </svg>
`,
  OO = `
  <svg width="100%" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M10.5091 4.05856C10.2585 3.91901 9.9362 3.91901 9.64974 4.05856L7.64453 5.20986L6.28385 5.94251L4.31445 7.09382C4.0638 7.23337 3.74154 7.23337 3.45508 7.09382L1.91536 6.18673C1.66471 6.04718 1.48568 5.76807 1.48568 5.45408V3.70968C1.48568 3.43057 1.62891 3.15147 1.91536 2.97703L3.45508 2.10483C3.70573 1.96527 4.02799 1.96527 4.31445 2.10483L5.85417 3.01192C6.10482 3.15147 6.28385 3.43057 6.28385 3.74457V4.89587L7.64453 4.12833V2.94214C7.64453 2.66304 7.5013 2.38393 7.21484 2.20949L4.35026 0.569752C4.09961 0.4302 3.77734 0.4302 3.49089 0.569752L0.554687 2.24438C0.268229 2.38393 0.125 2.66304 0.125 2.94214V6.22162C0.125 6.50072 0.268229 6.77983 0.554687 6.95427L3.45508 8.59401C3.70573 8.73356 4.02799 8.73356 4.31445 8.59401L6.28385 7.47759L7.64453 6.71005L9.61393 5.59363C9.86458 5.45408 10.1868 5.45408 10.4733 5.59363L12.013 6.46583C12.2637 6.60539 12.4427 6.88449 12.4427 7.19848V8.94289C12.4427 9.22199 12.2995 9.50109 12.013 9.67553L10.5091 10.5477C10.2585 10.6873 9.9362 10.6873 9.64974 10.5477L8.11002 9.67553C7.85937 9.53598 7.68034 9.25688 7.68034 8.94289V7.82647L6.31966 8.59401V9.74531C6.31966 10.0244 6.46289 10.3035 6.74935 10.478L9.64974 12.1177C9.90039 12.2572 10.2227 12.2572 10.5091 12.1177L13.4095 10.478C13.6602 10.3384 13.8392 10.0593 13.8392 9.74531V6.43095C13.8392 6.15184 13.696 5.87274 13.4095 5.6983L10.5091 4.05856Z" fill="white"/>
  </svg>
`,
  bde = `
  <svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.32975 5.90275L7 3.2325L9.67163 5.90413L11.2254 4.35038L7 0.125L2.776 4.349L4.32975 5.90275ZM0.125 7L1.67875 5.44625L3.2325 7L1.67875 8.55375L0.125 7ZM4.32975 8.09725L7 10.7675L9.67163 8.09587L11.2254 9.64894L7 13.875L2.776 9.651L2.77394 9.64894L4.32975 8.09725ZM10.7675 7L12.3212 5.44625L13.875 7L12.3212 8.55375L10.7675 7ZM8.57575 6.99863H8.57713V7L7 8.57713L5.42494 7.00275L5.42219 7L5.42494 6.99794L5.70062 6.72156L5.83469 6.5875L7 5.42288L8.57644 6.99931L8.57575 6.99863Z" fill="white"/>
  </svg>
`,
  wde = `
  <svg height="100%" viewBox="0 0 12 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M5.26613 0.133876C5.46683 0.0457135 5.68592 0 5.90775 0C6.12958 0 6.34867 0.0457135 6.54938 0.133876L10.2679 1.9598C10.3617 1.99893 10.4437 2.05898 10.5068 2.13465C10.5699 2.21033 10.6121 2.29932 10.6298 2.3938H10.6335V11.5637C10.6245 11.6667 10.5857 11.7654 10.5213 11.8495C10.457 11.9336 10.3694 11.9998 10.2679 12.0411L6.54938 13.8656C6.34867 13.9538 6.12958 13.9995 5.90775 13.9995C5.68592 13.9995 5.46683 13.9538 5.26613 13.8656L1.54762 12.0397C1.44724 11.9979 1.36095 11.9313 1.29799 11.8472C1.23504 11.7631 1.19779 11.6646 1.19025 11.5623C1.19025 11.5465 1.19025 11.5332 1.19025 11.522V2.39205C1.20579 2.29767 1.24673 2.20852 1.30923 2.13292C1.37173 2.05733 1.45375 1.99776 1.54762 1.9598L5.26613 0.133876ZM10.0478 7.50898L6.54938 9.22396C6.34872 9.31229 6.12961 9.35809 5.90775 9.35809C5.68589 9.35809 5.46678 9.31229 5.26613 9.22396L1.77525 7.51283V11.5455L5.26613 13.2493C5.43937 13.3471 5.62982 13.4154 5.82863 13.4512L5.9085 13.4558C6.12668 13.4357 6.3373 13.3704 6.525 13.2647L10.05 11.5301V7.50898H10.0478ZM0.585375 11.3642C0.568078 11.6186 0.612957 11.8734 0.716625 12.1093C0.805331 12.2602 0.936232 12.3857 1.09538 12.4726L1.10662 12.4796C1.1505 12.5069 1.1985 12.5356 1.25663 12.5692L1.32563 12.6081L1.53675 12.7267L1.23375 13.1922L0.9975 13.0592L0.95775 13.0365C0.889125 12.9973 0.8325 12.9637 0.779625 12.9315C0.214875 12.5769 0.004125 12.1912 0 11.3887V11.3642H0.585H0.585375ZM5.61412 5.05096C5.58845 5.05933 5.5634 5.06926 5.53912 5.08071L1.82137 6.90524L1.81013 6.91119H1.80675L1.81275 6.91469L1.82137 6.91889L5.53988 8.74341C5.56405 8.75505 5.58912 8.76499 5.61487 8.77316L5.61412 5.05096ZM6.201 5.05096V8.77456C6.22675 8.76639 6.25182 8.75645 6.276 8.74481L9.9945 6.92029L10.0057 6.91434H10.0091L10.0031 6.91154L9.9945 6.90699L6.276 5.08246C6.25182 5.07083 6.22675 5.06088 6.201 5.05271V5.05096ZM10.0478 3.04479L6.71025 4.68137L10.0478 6.31795V3.04304V3.04479ZM1.77525 3.04864V6.3141L5.103 4.68137L1.77525 3.04864ZM6.27525 0.61617C6.15894 0.569406 6.03364 0.545286 5.907 0.545286C5.78036 0.545286 5.65506 0.569406 5.53875 0.61617L1.821 2.4393L1.80975 2.4449L1.80638 2.44665L1.81238 2.4498L1.821 2.45365L5.5395 4.27817C5.65571 4.32526 5.78106 4.34956 5.90775 4.34956C6.03444 4.34956 6.15979 4.32526 6.276 4.27817L9.9945 2.45365L10.0057 2.4498L10.0091 2.44805L10.0031 2.4449L9.9945 2.4407L6.27525 0.61617ZM10.5968 0.816717L10.833 0.949365L10.875 0.970015C10.9432 1.00921 10.9999 1.04316 11.0528 1.07501C11.6179 1.42851 11.8282 1.81455 11.8328 2.61709V2.64159H11.2459C11.2632 2.38703 11.2183 2.13212 11.1146 1.8961C11.0258 1.74528 10.8948 1.61983 10.7355 1.53316L10.7242 1.52616C10.6807 1.49851 10.6327 1.47016 10.5743 1.43656L10.5056 1.39981L10.2945 1.28151L10.5975 0.816017L10.5968 0.816717Z" fill="white"/>
  </svg>
`,
  PO = `
  <svg width="100%" viewBox="0 0 17 10" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.33611 9.25254C2.38341 9.25254 1.60287 9.02834 0.99442 8.58002C0.393974 8.1237 0.09375 7.47526 0.09375 6.63462C0.09375 6.45849 0.113782 6.2423 0.153782 5.9861C0.257909 5.40972 0.406006 4.71718 0.598133 3.9086C1.14252 1.707 2.54757 0.606201 4.81323 0.606201C5.42967 0.606201 5.98206 0.710266 6.47044 0.918394C6.95882 1.11852 7.34308 1.42278 7.62327 1.8311C7.90346 2.23135 8.04362 2.71174 8.04362 3.27212C8.04362 3.44025 8.02359 3.65241 7.98352 3.9086C7.86346 4.62111 7.71933 5.31366 7.55121 5.9861C7.27101 7.08294 6.78666 7.90354 6.09815 8.44793C5.40964 8.98431 4.489 9.25254 3.33611 9.25254ZM3.50424 7.52326C3.95262 7.52326 4.33284 7.39116 4.6451 7.12697C4.96535 6.86278 5.19351 6.45849 5.32958 5.9141C5.51371 5.16153 5.65387 4.50502 5.74993 3.94463C5.78193 3.7765 5.79793 3.60441 5.79793 3.42822C5.79793 2.6997 5.41764 2.33542 4.65713 2.33542C4.20875 2.33542 3.82449 2.46751 3.50424 2.7317C3.19205 2.99596 2.96786 3.40025 2.83179 3.94463C2.68766 4.48102 2.54354 5.13753 2.39947 5.9141C2.36741 6.07417 2.35141 6.2423 2.35141 6.41842C2.35141 7.155 2.73573 7.52326 3.50424 7.52326Z" fill="white"/>
    <path d="M8.59569 9.13247C8.50762 9.13247 8.43953 9.10443 8.39153 9.04837C8.35146 8.98431 8.33949 8.9123 8.35549 8.83224L10.0127 1.02648C10.0287 0.938417 10.0727 0.866353 10.1448 0.810289C10.2169 0.754289 10.2929 0.726257 10.373 0.726257H13.5673C14.456 0.726257 15.1685 0.910385 15.7049 1.27864C16.2493 1.64696 16.5215 2.17931 16.5215 2.87582C16.5215 3.07595 16.4975 3.28415 16.4495 3.50027C16.2493 4.42098 15.845 5.10149 15.2366 5.54181C14.6361 5.98213 13.8115 6.20229 12.7627 6.20229H11.1415L10.5892 8.83224C10.5731 8.92031 10.5291 8.99231 10.4571 9.04837C10.385 9.10443 10.3089 9.13247 10.2289 9.13247H8.59569ZM12.8468 4.54507C13.183 4.54507 13.4752 4.45298 13.7234 4.26885C13.9796 4.08472 14.1478 3.82053 14.2278 3.47627C14.2518 3.34015 14.2639 3.22008 14.2639 3.11602C14.2639 2.88383 14.1958 2.7077 14.0597 2.58763C13.9236 2.45951 13.6914 2.3955 13.3632 2.3955H11.9221L11.4658 4.54507H12.8468Z" fill="white"/>
  </svg>
`,
  _de = `
  <svg width="100%" viewBox="0 0 20 19" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.8682 0.489349H0.110352V18.4468H19.8682V0.489349Z" fill="white"/>
  </svg>
`,
  Ede = `
  <svg width="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.1511 8.08001C19.1511 4.11201 15.9191 0.880005 11.9511 0.880005C8.94313 0.880005 6.38313 2.70401 5.29513 5.32801C2.73513 6.41601 0.911133 8.976 0.911133 11.952C0.911133 15.92 4.14313 19.152 8.11113 19.152C11.1191 19.152 13.6791 17.328 14.7671 14.704C17.2951 13.616 19.1511 11.056 19.1511 8.08001ZM8.11113 17.36C5.13513 17.36 2.70313 14.928 2.70313 11.952C2.70313 10.256 3.50313 8.72001 4.75113 7.72801C4.75113 7.85601 4.75113 7.98401 4.75113 8.08001C4.75113 12.048 7.98313 15.28 11.9511 15.28C12.1111 15.28 12.2391 15.28 12.3991 15.28C11.3751 16.56 9.83913 17.36 8.11113 17.36ZM13.3591 13.296C12.9111 13.424 12.4311 13.488 11.9511 13.488C8.97513 13.488 6.54313 11.056 6.54313 8.08001C6.54313 7.60001 6.60713 7.15201 6.73513 6.736C7.18313 6.60801 7.66313 6.54401 8.14313 6.54401C11.1191 6.54401 13.5511 8.976 13.5511 11.952C13.5191 12.432 13.4551 12.88 13.3591 13.296ZM15.3111 12.304C15.3111 12.176 15.3111 12.048 15.3111 11.952C15.3111 7.984 12.0791 4.752 8.11113 4.752C7.95113 4.752 7.82313 4.752 7.66313 4.752C8.65513 3.472 10.1911 2.67201 11.9191 2.67201C14.8951 2.67201 17.3271 5.10401 17.3271 8.08001C17.3271 9.80801 16.5271 11.312 15.3111 12.304Z" fill="white"/>
  </svg>
`,
  xde = `
  <svg width="100%" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32C24.8366 32 32 24.8366 32 16Z" fill="#04795B"/>
    <path d="M11.6529 17.4492C12.2831 17.4492 12.8648 17.2392 13.3334 16.8758L9.4877 13.0316C9.12413 13.4919 8.9141 14.0734 8.9141 14.7114C8.906 16.2216 10.134 17.4492 11.6529 17.4492Z" fill="#EFEFEF"/>
    <path d="M23.0931 14.7033C23.0931 14.0734 22.8831 13.4919 22.5195 13.0234L18.6738 16.8677C19.1343 17.2311 19.716 17.4411 20.3543 17.4411C21.8651 17.4492 23.0931 16.2216 23.0931 14.7033Z" fill="#EFEFEF"/>
    <path d="M25.0322 10.528L23.3275 12.2321C23.8931 12.9105 24.2324 13.7666 24.2324 14.7195C24.2324 16.8597 22.4954 18.5961 20.3544 18.5961C19.4092 18.5961 18.5447 18.2569 17.866 17.6915L15.9998 19.5571L14.1335 17.6915C13.4549 18.2569 12.5985 18.5961 11.6451 18.5961C9.50416 18.5961 7.7672 16.8597 7.7672 14.7195C7.7672 13.7746 8.10651 12.9105 8.67206 12.2321L7.79947 11.3599L6.96736 10.528C5.99787 12.1271 5.44043 13.9927 5.44043 15.9956C5.44043 21.8265 10.1667 26.543 15.9917 26.543C21.8167 26.543 26.543 21.8185 26.543 15.9956C26.5591 13.9846 26.0017 12.119 25.0322 10.528Z" fill="#EFEFEF"/>
    <path d="M23.6338 8.71084C21.7191 6.6999 19.0045 5.44 15.9991 5.44C12.9937 5.44 10.2872 6.6999 8.36435 8.71084C8.10584 8.98545 7.85539 9.27617 7.62109 9.575L15.991 17.9419L24.361 9.56695C24.1509 9.27617 23.9005 8.97734 23.6338 8.71084ZM15.9991 6.81297C18.4713 6.81297 20.7658 7.76593 22.4866 9.50231L15.9991 15.9874L9.5116 9.50231C11.2405 7.76593 13.5269 6.81297 15.9991 6.81297Z" fill="#EFEFEF"/>
  </svg>
`,
  Tde = `
  <svg width="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.5484 1.04102e-06C11.6346 -0.000708404 10.7578 0.361217 10.1105 1.00633C9.46322 1.65145 9.09835 2.52703 9.096 3.44089V7.256C8.74045 7.28 8.37689 7.29511 8 7.29511C7.62311 7.29511 7.26133 7.31022 6.904 7.33156V3.44089C6.88946 2.53496 6.51938 1.67105 5.87358 1.03553C5.22779 0.400017 4.35805 0.0438409 3.452 0.0438409C2.54595 0.0438409 1.67621 0.400017 1.03042 1.03553C0.384623 1.67105 0.0145378 2.53496 0 3.44089V12.5591C0.0145378 13.465 0.384623 14.329 1.03042 14.9645C1.67621 15.6 2.54595 15.9562 3.452 15.9562C4.35805 15.9562 5.22779 15.6 5.87358 14.9645C6.51938 14.329 6.88946 13.465 6.904 12.5591V8.744C7.25956 8.72 7.62311 8.70489 8 8.70489C8.37689 8.70489 8.73867 8.68978 9.096 8.66845V12.5591C9.11054 13.465 9.48062 14.329 10.1264 14.9645C10.7722 15.6 11.6419 15.9562 12.548 15.9562C13.4541 15.9562 14.3238 15.6 14.9696 14.9645C15.6154 14.329 15.9855 13.465 16 12.5591V3.44089C15.9976 2.52719 15.6329 1.65173 14.9858 1.00665C14.3387 0.361557 13.4622 -0.000472854 12.5484 1.04102e-06ZM3.45156 1.40978C3.99089 1.40954 4.50828 1.62326 4.89023 2.00404C5.27218 2.38482 5.48748 2.90156 5.48889 3.44089V7.48089C4.47892 7.62724 3.49264 7.90609 2.55556 8.31023C2.14954 8.48842 1.76733 8.71655 1.41778 8.98934V3.44089C1.41919 2.90218 1.634 2.38597 2.01518 2.00529C2.39636 1.62462 2.91284 1.41048 3.45156 1.40978ZM5.48889 12.5591C5.48889 13.0994 5.27424 13.6177 4.89217 13.9997C4.51009 14.3818 3.99189 14.5964 3.45156 14.5964C2.91122 14.5964 2.39302 14.3818 2.01094 13.9997C1.62887 13.6177 1.41422 13.0994 1.41422 12.5591V11.6444C1.41422 10.8364 2.05422 10.0711 3.12711 9.59467C3.88309 9.26852 4.6763 9.03656 5.48889 8.904V12.5591ZM12.5484 14.5902C12.0091 14.5905 11.4917 14.3767 11.1098 13.996C10.7278 13.6152 10.5125 13.0984 10.5111 12.5591V8.51911C11.5211 8.37276 12.5074 8.09392 13.4444 7.68978C13.8505 7.51159 14.2327 7.28345 14.5822 7.01067V12.5591C14.5808 13.0978 14.366 13.614 13.9848 13.9947C13.6036 14.3754 13.0872 14.5895 12.5484 14.5902ZM12.8729 6.4C12.1169 6.72615 11.3237 6.95811 10.5111 7.09067V3.44089C10.5111 2.90056 10.7258 2.38235 11.1078 2.00028C11.4899 1.6182 12.0081 1.40356 12.5484 1.40356C13.0888 1.40356 13.607 1.6182 13.9891 2.00028C14.3711 2.38235 14.5858 2.90056 14.5858 3.44089V4.35556C14.5858 5.16 13.9458 5.92534 12.8729 6.4Z" fill="url(#paint0_linear_10254_2422)"/>
    <defs>
      <linearGradient id="paint0_linear_10254_2422" x1="1.01333" y1="14.7674" x2="14.8954" y2="0.847434" gradientUnits="userSpaceOnUse">
        <stop stop-color="#00AEE9"/>
        <stop offset="1" stop-color="#69FABD"/>
      </linearGradient>
    </defs>
  </svg>
`,
  NO = `
  <svg height="100%" viewBox="0 0 22 25" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M13.7827 11.3172L15.5966 8.23933L20.4858 15.8545L20.4881 17.3159L20.4722 7.25942C20.4606 7.0136 20.3301 6.7887 20.1218 6.6561L11.3194 1.5928C11.1135 1.49162 10.8523 1.49269 10.6468 1.59594C10.6191 1.60989 10.593 1.62499 10.568 1.64147L10.5374 1.66079L1.99318 6.6121L1.95999 6.62712C1.91737 6.64674 1.8743 6.67165 1.83382 6.70063C1.67186 6.81683 1.56424 6.98861 1.52944 7.18131C1.52423 7.21052 1.52039 7.24026 1.51855 7.27023L1.53197 15.4653L6.08607 8.40666C6.65942 7.47067 7.90869 7.1692 9.06835 7.1856L10.4295 7.22155L2.40986 20.0827L3.3552 20.627L11.4709 7.23458L15.0581 7.22155L6.96327 20.9519L10.3366 22.8921L10.7396 23.1239C10.9101 23.1932 11.111 23.1967 11.283 23.1347L20.2091 17.9618L18.5026 18.9507L13.7827 11.3172ZM14.4747 21.2849L11.0677 15.9375L13.1474 12.4083L17.622 19.461L14.4747 21.2849Z" fill="#2D374B"/>
    <path d="M11.0684 15.9375L14.4754 21.2849L17.6228 19.4609L13.1482 12.4083L11.0684 15.9375Z" fill="#28A0F0"/>
    <path d="M20.4887 17.3159L20.4864 15.8545L15.5972 8.23932L13.7832 11.3172L18.5031 18.9507L20.2097 17.9618C20.3771 17.8259 20.4783 17.6264 20.489 17.4111L20.4887 17.3159Z" fill="#28A0F0"/>
    <path d="M7.71943e-05 18.694L2.41 20.0826L10.4296 7.22152L9.0685 7.18557C7.90883 7.16916 6.65964 7.47063 6.08621 8.40662L1.53211 15.4652L0 17.8193V18.694H7.71943e-05Z" fill="white"/>
    <path d="M15.0582 7.22156L11.4712 7.23459L3.35547 20.627L6.19211 22.2603L6.96354 20.9519L15.0582 7.22156Z" fill="white"/>
    <path d="M21.9999 7.20306C21.97 6.45287 21.5638 5.76608 20.9275 5.36626L12.0097 0.237888C11.3803 -0.079066 10.594 -0.0794494 9.96363 0.237658C9.88913 0.275218 1.2912 5.26171 1.2912 5.26171C1.17223 5.31874 1.05764 5.38673 0.949789 5.46384C0.381801 5.87094 0.0355663 6.50346 0 7.19846V17.8194L1.53211 15.4653L1.5187 7.27029C1.52054 7.24032 1.52429 7.21088 1.52958 7.18175C1.56415 6.9889 1.67185 6.81689 1.83397 6.70069C1.87444 6.67171 10.6192 1.60995 10.647 1.596C10.8526 1.49275 11.1137 1.49168 11.3195 1.59286L20.122 6.65616C20.3302 6.78876 20.4608 7.01366 20.4723 7.25948V17.4111C20.4617 17.6265 20.3766 17.8259 20.2092 17.9619L18.5026 18.9508L17.6221 19.461L14.4748 21.285L11.283 23.1347C11.1111 23.1968 10.9101 23.1933 10.7397 23.124L6.96334 20.952L6.19191 22.2603L9.58559 24.2142C9.6978 24.278 9.79784 24.3345 9.87985 24.3807C10.0069 24.452 10.0935 24.4996 10.1241 24.5144C10.3653 24.6315 10.7123 24.6997 11.025 24.6997C11.3118 24.6997 11.5913 24.647 11.8559 24.5434L21.1266 19.1745C21.6587 18.7623 21.9717 18.1406 21.9999 17.467V7.20306Z" fill="#96BEDC"/>
  </svg>
`,
  DO = `
<svg height="100%" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_1607_202)">
<mask id="mask0_1607_202" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="0" y="0" width="32" height="32">
<path d="M32 0H0V32H32V0Z" fill="white"/>
</mask>
<g mask="url(#mask0_1607_202)">
<path d="M16 32C19.1645 32 22.258 31.0616 24.8892 29.3036C27.5204 27.5454 29.571 25.0466 30.782 22.123C31.993 19.1993 32.31 15.9823 31.6926 12.8786C31.0752 9.77486 29.5514 6.92394 27.3138 4.6863C25.076 2.44866 22.2252 0.924806 19.1214 0.307442C16.0177 -0.30992 12.8007 0.0069325 9.87706 1.21793C6.95344 2.42894 4.45458 4.4797 2.69648 7.11088C0.938384 9.74206 0 12.8355 0 16C0 20.2434 1.68571 24.3132 4.6863 27.3138C7.68688 30.3142 11.7565 32 16 32Z" fill="#0052FF"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.9624 27.2676C22.1852 27.2676 27.23 22.223 27.23 16C27.23 9.7771 22.1852 4.73242 15.9624 4.73242C10.0588 4.73242 5.21566 9.2726 4.7341 15.0518H21.4546V16.928H4.73242C5.20432 22.7168 10.0519 27.2676 15.9624 27.2676Z" fill="white"/>
</g>
</g>
<defs>
<clipPath id="clip0_1607_202">
<rect width="32" height="32" fill="white"/>
</clipPath>
</defs>
</svg>
`,
  Sde = `
<svg width="100%" height="100%" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0L0.0100002 6L4 10L0.0100002 14.01L0 20H12V14L8 10L12 6.01V0H0ZM10 14.5V18H2V14.5L6 10.5L10 14.5Z" fill="#929BED"/>
</svg>
`,
  Gg = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.07 12.85C11.84 11.46 13.32 10.64 14.18 9.41C15.09 8.12 14.58 5.71 12 5.71C10.31 5.71 9.48 6.99 9.13 8.05L6.54 6.96C7.25 4.83 9.18 3 11.99 3C14.34 3 15.95 4.07 16.77 5.41C17.47 6.56 17.88 8.71 16.8 10.31C15.6 12.08 14.45 12.62 13.83 13.76C13.58 14.22 13.48 14.52 13.48 16H10.59C10.58 15.22 10.46 13.95 11.07 12.85ZM14 20C14 21.1 13.1 22 12 22C10.9 22 10 21.1 10 20C10 18.9 10.9 18 12 18C13.1 18 14 18.9 14 20Z" fill="currentColor"/>
  </svg>
`,
  Ade = `
<svg width="14" height="11" viewBox="0 0 14 11" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M4.48076 8.10881L1.33076 4.95881L0.280762 6.00881L4.48076 10.2088L13.4808 1.20881L12.4308 0.158813L4.48076 8.10881Z" fill="#A4F4C6"/>
</svg>
`,
  Cde = `<svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.666992 13.0002H15.3337L8.00033 0.333496L0.666992 13.0002ZM8.66699 11.0002H7.33366V9.66683H8.66699V11.0002ZM8.66699 8.3335H7.33366V5.66683H8.66699V8.3335Z" fill="#FFB3B3"/>
</svg>
`,
  Uw = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM13 17H11V11H13V17ZM13 9H11V7H13V9Z" fill="currentColor"/>
  </svg>
`,
  IH = `
  <svg width="100%" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M6.74999 12.15L3.59999 9L2.54999 10.05L6.74999 14.25L15.75 5.25L14.7 4.2L6.74999 12.15Z" fill="currentColor"/>
  </svg>
`,
  kde = `
  <svg width="100%" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M6 2L6.01 8L10 12L6.01 16.01L6 22H18V16L14 12L18 8.01V2H6ZM16 16.5V20H8V16.5L12 12.5L16 16.5Z" fill="currenColor"/>
  </svg>
`;
function Ide() {
  if (typeof window < "u") {
    const t = tae.getParser(window.navigator.userAgent),
      e = t.getOS(),
      n = t.getBrowser(),
      { type: r } = t.getPlatform();
    return { type: r, os: e, browser: n };
  } else return { type: null, os: null, browser: null };
}
const Ode = (t) => t != null;
function ag(t) {
  switch (t) {
    case "0x1":
    case "0x89":
    case "0xa":
    case "0xa4b1":
    case "0xa4ba":
    case "0x144":
      return "0x1";
    case "0x5":
      return t;
    case "0xaa36a7":
      return t;
    default:
      return null;
  }
}
function Z7(t) {
  return t.includes("<svg");
}
function sDe(t) {
  return `${t.slice(0, 6)}…${t.slice(-4)}`;
}
function aDe(t) {
  return t.length > 11 ? `${t.slice(0, 4)}…${t.slice(-6)}` : t;
}
async function oDe(t) {
  try {
    return await navigator.clipboard.writeText(t);
  } catch (e) {
    console.error("Failed to copy: ", e);
  }
}
const OH = (t) => (typeof t == "number" ? `0x${t.toString(16)}` : t);
function Pde(t) {
  return t.map(({ id: e, ...n }) => ({ id: OH(e), ...n }));
}
function lDe(t) {
  return `0x${(t * 1e9).toString(16)}`;
}
const uDe = {
    "0x1": "Ethereum",
    "0x3": "Ropsten",
    "0x4": "Rinkeby",
    "0x5": "Goerli",
    "0xaa36a7": "Sepolia",
    "0x2a": "Kovan",
    "0x38": "Binance",
    "0x89": "Polygon",
    "0xfa": "Fantom",
    "0xa": "Optimism",
    "0x45": "Optimism Kovan",
    "0xa86a": "Avalanche",
    "0xa4ec": "Celo",
    "0x2105": "Base",
    "0x14a33": "Base Goerli",
    "0x64": "Gnosis",
    "0x63564C40": "Harmony One",
    "0xa4b1": "Arbitrum One",
    "0xa4ba": "Arbitrum Nova",
  },
  RO = {
    main: "0x1",
    ropsten: "0x3",
    rinkeby: "0x4",
    goerli: "0x5",
    kovan: "0x2a",
    xdai: "0x64",
    "bsc-main": "0x38",
    "matic-main": "0x89",
    "fantom-main": "0xfa",
    "matic-mumbai": "0x80001",
  },
  Nde = {
    "0x1": { icon: fp, color: "#627EEA" },
    "0x3": { icon: fp, color: "#627EEA" },
    "0x4": { icon: fp, color: "#627EEA" },
    "0x5": { icon: fp, color: "#627EEA" },
    "0x2a": { icon: fp, color: "#627EEA" },
    "0xaa36a7": { icon: fp, color: "#627EEA" },
    "0x38": { icon: bde, color: "#F3BA2F" },
    "0x89": { icon: OO, color: "#8247E5" },
    "0xfa": { icon: wde, color: "#1969FF" },
    "0xa": { icon: PO, color: "#FF0420" },
    "0x45": { icon: PO, color: "#FF0420" },
    "0xa86a": { icon: _de, color: "#E84142" },
    "0xa4ec": { icon: Ede, color: "#FBCC5C" },
    "0x64": { icon: xde, color: "#04795B" },
    "0x63564C40": { icon: Tde, color: "#ffffff" },
    "0xa4b1": { icon: NO, color: "#33394B" },
    "0xa4ba": { icon: NO, color: "#33394B" },
    "0x2105": { icon: DO, color: "#0259F9" },
    "0x14a33": { icon: DO, color: "#0259F9" },
    "0x80001": { icon: OO, color: "#8247E5" },
  },
  cDe = { icon: Gg, color: "#33394B" };
function fDe(t) {
  return t ? Nde[t.toLowerCase()] : void 0;
}
function dDe(t, e) {
  return !!e.find(({ id: n, namespace: r }) => n === t.id && r === t.namespace);
}
const hDe = {
    pending: {
      backgroundColor: "var(--onboard-primary-700, var(--primary-700))",
      borderColor: "#6370E5",
      eventIcon: Sde,
    },
    success: {
      backgroundColor: "#052E17",
      borderColor: "var(--onboard-success-300, var(--success-300))",
      eventIcon: Ade,
    },
    error: {
      backgroundColor: "#FDB1B11A",
      borderColor: "var(--onboard-danger-300, var(--danger-300))",
      eventIcon: Cde,
    },
    hint: {
      backgroundColor: "var(--onboard-gray-500, var(--gray-500))",
      borderColor: "var(--onboard-gray-500, var(--gray-500))",
      iconColor: "var(--onboard-gray-100, var(--gray-100))",
      eventIcon: Uw,
    },
  },
  Dde = (t) => new Promise((e) => setTimeout(e, t));
function jw(t) {
  try {
    return localStorage.getItem(t);
  } catch {
    return null;
  }
}
function Hw(t, e) {
  try {
    localStorage.setItem(t, e);
  } catch {
    return;
  }
}
function PH(t) {
  try {
    localStorage.removeItem(t);
  } catch {
    return;
  }
}
let so = {
  svelteInstance: null,
  apiKey: null,
  device: Ide(),
  initialWalletInit: [],
  gas: null,
  containerElements: { accountCenter: null, connectModal: null },
  transactionPreview: null,
  unstoppableResolution: null,
};
function MO(t) {
  so = { ...so, ...t };
}
const Nf = {
    wallets: [],
    walletModules: [],
    chains: [],
    accountCenter: {
      enabled: !0,
      position: "bottomRight",
      expanded: !1,
      minimal: !0,
    },
    notify: {
      enabled: !0,
      transactionHandler: () => {},
      position: "topRight",
      replacement: { gasPriceProbability: { speedup: 80, cancel: 95 } },
    },
    notifications: [],
    locale: "",
    connect: { showSidebar: !0, disableClose: !1 },
    appMetadata: null,
  },
  Ku = {
    TERMS_AGREEMENT: "onboard.js:agreement",
    LAST_CONNECTED_WALLET: "onboard.js:last_connected_wallet",
  },
  $i = 768,
  pDe = "https://rpc.blocknative.com/boost",
  mDe =
    "https://docs.blocknative.com/blocknative-mev-protection/transaction-boost",
  NH = "add_chains",
  DH = "update_chains",
  RH = "reset_store",
  MH = "add_wallet",
  LH = "update_wallet",
  BH = "remove_wallet",
  FH = "update_account",
  $H = "update_account_center",
  UH = "update_connect_modal",
  jH = "set_wallet_modules",
  HH = "set_locale",
  zH = "update_notify",
  Y7 = "add_notification",
  VH = "remove_notification",
  GH = "update_balance",
  WH = "update_app_metadata";
function Rde(t, e) {
  const { type: n, payload: r } = e;
  switch (n) {
    case NH:
      return { ...t, chains: [...t.chains, ...r] };
    case DH: {
      const i = r,
        s = t.chains,
        a = s.findIndex((o) => o.id === i.id);
      return (s[a] = i), { ...t, chains: s };
    }
    case MH: {
      const i = r,
        s = t.wallets.find(({ label: a }) => a === i.label);
      return {
        ...t,
        wallets: [s || r, ...t.wallets.filter(({ label: a }) => a !== i.label)],
      };
    }
    case LH: {
      const i = r,
        { id: s, ...a } = i,
        o = t.wallets.map((l) => (l.label === s ? { ...l, ...a } : l));
      return { ...t, wallets: o };
    }
    case BH: {
      const i = r;
      return { ...t, wallets: t.wallets.filter(({ label: s }) => s !== i.id) };
    }
    case FH: {
      const i = r,
        { id: s, address: a, ...o } = i,
        l = t.wallets.map(
          (u) => (
            u.label === s &&
              (u.accounts = u.accounts.map((f) =>
                f.address === a ? { ...f, ...o } : f
              )),
            u
          )
        );
      return { ...t, wallets: l };
    }
    case GH:
      return { ...t, wallets: r };
    case UH: {
      const i = r;
      return { ...t, connect: { ...t.connect, ...i } };
    }
    case $H: {
      const i = r;
      return { ...t, accountCenter: { ...t.accountCenter, ...i } };
    }
    case zH: {
      const i = r;
      return { ...t, notify: { ...t.notify, ...i } };
    }
    case Y7: {
      const i = r,
        s = [...t.notifications],
        a = s.findIndex(({ id: o }) => o === i.id);
      return a !== -1 ? (s[a] = i) : s.unshift(i), { ...t, notifications: s };
    }
    case VH: {
      const i = r;
      return { ...t, notifications: t.notifications.filter((s) => s.id !== i) };
    }
    case jH:
      return { ...t, walletModules: r };
    case HH:
      return Lh.set(r), { ...t, locale: r };
    case WH: {
      const i = r;
      return { ...t, appMetadata: { ...t.appMetadata, ...i } };
    }
    case RH:
      return Nf;
    default:
      throw new Error(`Unknown type: ${n} in appStore reducer`);
  }
}
const zw = new by(Nf),
  y5 = new sf();
y5.subscribe(zw);
function Ls(t) {
  const e = zw.getValue();
  y5.next(Rde(e, t));
}
function Mde(t) {
  if (!t) return y5.asObservable();
  if (!Object.keys(zw.getValue()).includes(String(t)))
    throw new Error(`key: ${t} does not exist on this store`);
  return y5.asObservable().pipe(Xse(t), O7(t), D0(Ode));
}
function Lde() {
  return zw.getValue();
}
const Jt = { select: Mde, get: Lde };
function We() {}
const Iy = (t) => t;
function Bde(t, e) {
  for (const n in e) t[n] = e[n];
  return t;
}
function Fde(t) {
  return (
    !!t &&
    (typeof t == "object" || typeof t == "function") &&
    typeof t.then == "function"
  );
}
function qH(t) {
  return t();
}
function LO() {
  return Object.create(null);
}
function ac(t) {
  t.forEach(qH);
}
function _d(t) {
  return typeof t == "function";
}
function ns(t, e) {
  return t != t
    ? e == e
    : t !== e || (t && typeof t == "object") || typeof t == "function";
}
let uv;
function z0(t, e) {
  return uv || (uv = document.createElement("a")), (uv.href = e), t === uv.href;
}
function $de(t) {
  return Object.keys(t).length === 0;
}
function Ude(t, ...e) {
  if (t == null) return We;
  const n = t.subscribe(...e);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function Xr(t, e, n) {
  t.$$.on_destroy.push(Ude(e, n));
}
function Q7(t, e, n, r) {
  if (t) {
    const i = KH(t, e, n, r);
    return t[0](i);
  }
}
function KH(t, e, n, r) {
  return t[1] && r ? Bde(n.ctx.slice(), t[1](r(e))) : n.ctx;
}
function J7(t, e, n, r) {
  if (t[2] && r) {
    const i = t[2](r(n));
    if (e.dirty === void 0) return i;
    if (typeof i == "object") {
      const s = [],
        a = Math.max(e.dirty.length, i.length);
      for (let o = 0; o < a; o += 1) s[o] = e.dirty[o] | i[o];
      return s;
    }
    return e.dirty | i;
  }
  return e.dirty;
}
function eT(t, e, n, r, i, s) {
  if (i) {
    const a = KH(e, n, r, s);
    t.p(a, i);
  }
}
function tT(t) {
  if (t.ctx.length > 32) {
    const e = [],
      n = t.ctx.length / 32;
    for (let r = 0; r < n; r++) e[r] = -1;
    return e;
  }
  return -1;
}
function BO(t) {
  return t ?? "";
}
function FO(t) {
  const e = typeof t == "string" && t.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return e ? [parseFloat(e[1]), e[2] || "px"] : [t, "px"];
}
const XH = typeof window < "u";
let Vw = XH ? () => window.performance.now() : () => Date.now(),
  nT = XH ? (t) => requestAnimationFrame(t) : We;
const f0 = new Set();
function ZH(t) {
  f0.forEach((e) => {
    e.c(t) || (f0.delete(e), e.f());
  }),
    f0.size !== 0 && nT(ZH);
}
function Gw(t) {
  let e;
  return (
    f0.size === 0 && nT(ZH),
    {
      promise: new Promise((n) => {
        f0.add((e = { c: t, f: n }));
      }),
      abort() {
        f0.delete(e);
      },
    }
  );
}
function _e(t, e) {
  t.appendChild(e);
}
function rs(t, e, n) {
  const r = rT(t);
  if (!r.getElementById(e)) {
    const i = Oe("style");
    (i.id = e), (i.textContent = n), YH(r, i);
  }
}
function rT(t) {
  if (!t) return document;
  const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
  return e && e.host ? e : t.ownerDocument;
}
function jde(t) {
  const e = Oe("style");
  return YH(rT(t), e), e.sheet;
}
function YH(t, e) {
  return _e(t.head || t, e), e.sheet;
}
function Ge(t, e, n) {
  t.insertBefore(e, n || null);
}
function ze(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function QH(t, e) {
  for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e);
}
function Oe(t) {
  return document.createElement(t);
}
function Hde(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
function Ln(t) {
  return document.createTextNode(t);
}
function mt() {
  return Ln(" ");
}
function xr() {
  return Ln("");
}
function ao(t, e, n, r) {
  return t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r);
}
function zde(t) {
  return function (e) {
    return e.stopPropagation(), t.call(this, e);
  };
}
function be(t, e, n) {
  n == null
    ? t.removeAttribute(e)
    : t.getAttribute(e) !== n && t.setAttribute(e, n);
}
function Vde(t) {
  return Array.from(t.childNodes);
}
function ir(t, e) {
  (e = "" + e), t.data !== e && (t.data = e);
}
function Mu(t, e, n, r) {
  n == null
    ? t.style.removeProperty(e)
    : t.style.setProperty(e, n, r ? "important" : "");
}
function gDe(t, e, n) {
  for (let r = 0; r < t.options.length; r += 1) {
    const i = t.options[r];
    if (i.__value === e) {
      i.selected = !0;
      return;
    }
  }
  (!n || e !== void 0) && (t.selectedIndex = -1);
}
function bt(t, e, n) {
  t.classList[n ? "add" : "remove"](e);
}
function Gde(t, e, { bubbles: n = !1, cancelable: r = !1 } = {}) {
  const i = document.createEvent("CustomEvent");
  return i.initCustomEvent(t, n, r, e), i;
}
class w1 {
  constructor(e = !1) {
    (this.is_svg = !1), (this.is_svg = e), (this.e = this.n = null);
  }
  c(e) {
    this.h(e);
  }
  m(e, n, r = null) {
    this.e ||
      (this.is_svg
        ? (this.e = Hde(n.nodeName))
        : (this.e = Oe(n.nodeType === 11 ? "TEMPLATE" : n.nodeName)),
      (this.t = n.tagName !== "TEMPLATE" ? n : n.content),
      this.c(e)),
      this.i(r);
  }
  h(e) {
    (this.e.innerHTML = e),
      (this.n = Array.from(
        this.e.nodeName === "TEMPLATE"
          ? this.e.content.childNodes
          : this.e.childNodes
      ));
  }
  i(e) {
    for (let n = 0; n < this.n.length; n += 1) Ge(this.t, this.n[n], e);
  }
  p(e) {
    this.d(), this.h(e), this.i(this.a);
  }
  d() {
    this.n.forEach(ze);
  }
}
function Ju(t, e) {
  return new t(e);
}
const v5 = new Map();
let b5 = 0;
function Wde(t) {
  let e = 5381,
    n = t.length;
  for (; n--; ) e = ((e << 5) - e) ^ t.charCodeAt(n);
  return e >>> 0;
}
function qde(t, e) {
  const n = { stylesheet: jde(e), rules: {} };
  return v5.set(t, n), n;
}
function Wg(t, e, n, r, i, s, a, o = 0) {
  const l = 16.666 / r;
  let u = `{
`;
  for (let w = 0; w <= 1; w += l) {
    const y = e + (n - e) * s(w);
    u +=
      w * 100 +
      `%{${a(y, 1 - y)}}
`;
  }
  const f =
      u +
      `100% {${a(n, 1 - n)}}
}`,
    c = `__svelte_${Wde(f)}_${o}`,
    d = rT(t),
    { stylesheet: p, rules: m } = v5.get(d) || qde(d, t);
  m[c] ||
    ((m[c] = !0), p.insertRule(`@keyframes ${c} ${f}`, p.cssRules.length));
  const g = t.style.animation || "";
  return (
    (t.style.animation = `${
      g ? `${g}, ` : ""
    }${c} ${r}ms linear ${i}ms 1 both`),
    (b5 += 1),
    c
  );
}
function qg(t, e) {
  const n = (t.style.animation || "").split(", "),
    r = n.filter(
      e ? (s) => s.indexOf(e) < 0 : (s) => s.indexOf("__svelte") === -1
    ),
    i = n.length - r.length;
  i && ((t.style.animation = r.join(", ")), (b5 -= i), b5 || Kde());
}
function Kde() {
  nT(() => {
    b5 ||
      (v5.forEach((t) => {
        const { ownerNode: e } = t.stylesheet;
        e && ze(e);
      }),
      v5.clear());
  });
}
function yDe(t, e, n, r) {
  if (!e) return We;
  const i = t.getBoundingClientRect();
  if (
    e.left === i.left &&
    e.right === i.right &&
    e.top === i.top &&
    e.bottom === i.bottom
  )
    return We;
  const {
    delay: s = 0,
    duration: a = 300,
    easing: o = Iy,
    start: l = Vw() + s,
    end: u = l + a,
    tick: f = We,
    css: c,
  } = n(t, { from: e, to: i }, r);
  let d = !0,
    p = !1,
    m;
  function g() {
    c && (m = Wg(t, 0, 1, a, s, o, c)), s || (p = !0);
  }
  function w() {
    c && qg(t, m), (d = !1);
  }
  return (
    Gw((y) => {
      if ((!p && y >= l && (p = !0), p && y >= u && (f(1, 0), w()), !d))
        return !1;
      if (p) {
        const v = y - l,
          E = 0 + 1 * o(v / a);
        f(E, 1 - E);
      }
      return !0;
    }),
    g(),
    f(0, 1),
    w
  );
}
function vDe(t) {
  const e = getComputedStyle(t);
  if (e.position !== "absolute" && e.position !== "fixed") {
    const { width: n, height: r } = e,
      i = t.getBoundingClientRect();
    (t.style.position = "absolute"),
      (t.style.width = n),
      (t.style.height = r),
      Xde(t, i);
  }
}
function Xde(t, e) {
  const n = t.getBoundingClientRect();
  if (e.left !== n.left || e.top !== n.top) {
    const r = getComputedStyle(t),
      i = r.transform === "none" ? "" : r.transform;
    t.style.transform = `${i} translate(${e.left - n.left}px, ${
      e.top - n.top
    }px)`;
  }
}
let Kg;
function Bc(t) {
  Kg = t;
}
function iT() {
  if (!Kg) throw new Error("Function called outside component initialization");
  return Kg;
}
function Zde(t) {
  iT().$$.on_mount.push(t);
}
function JH(t) {
  iT().$$.on_destroy.push(t);
}
function Yde(t, e) {
  const n = t.$$.callbacks[e.type];
  n && n.slice().forEach((r) => r.call(this, e));
}
const Cp = [],
  w5 = [];
let d0 = [];
const NE = [],
  Qde = Promise.resolve();
let DE = !1;
function Jde() {
  DE || ((DE = !0), Qde.then(sT));
}
function Ia(t) {
  d0.push(t);
}
function ehe(t) {
  NE.push(t);
}
const Y_ = new Set();
let dp = 0;
function sT() {
  if (dp !== 0) return;
  const t = Kg;
  do {
    try {
      for (; dp < Cp.length; ) {
        const e = Cp[dp];
        dp++, Bc(e), the(e.$$);
      }
    } catch (e) {
      throw ((Cp.length = 0), (dp = 0), e);
    }
    for (Bc(null), Cp.length = 0, dp = 0; w5.length; ) w5.pop()();
    for (let e = 0; e < d0.length; e += 1) {
      const n = d0[e];
      Y_.has(n) || (Y_.add(n), n());
    }
    d0.length = 0;
  } while (Cp.length);
  for (; NE.length; ) NE.pop()();
  (DE = !1), Y_.clear(), Bc(t);
}
function the(t) {
  if (t.fragment !== null) {
    t.update(), ac(t.before_update);
    const e = t.dirty;
    (t.dirty = [-1]),
      t.fragment && t.fragment.p(t.ctx, e),
      t.after_update.forEach(Ia);
  }
}
function nhe(t) {
  const e = [],
    n = [];
  d0.forEach((r) => (t.indexOf(r) === -1 ? e.push(r) : n.push(r))),
    n.forEach((r) => r()),
    (d0 = e);
}
let hm;
function aT() {
  return (
    hm ||
      ((hm = Promise.resolve()),
      hm.then(() => {
        hm = null;
      })),
    hm
  );
}
function oh(t, e, n) {
  t.dispatchEvent(Gde(`${e ? "intro" : "outro"}${n}`));
}
const ab = new Set();
let Uu;
function jr() {
  Uu = { r: 0, c: [], p: Uu };
}
function Hr() {
  Uu.r || ac(Uu.c), (Uu = Uu.p);
}
function Fe(t, e) {
  t && t.i && (ab.delete(t), t.i(e));
}
function Ze(t, e, n, r) {
  if (t && t.o) {
    if (ab.has(t)) return;
    ab.add(t),
      Uu.c.push(() => {
        ab.delete(t), r && (n && t.d(1), r());
      }),
      t.o(e);
  } else r && r();
}
const oT = { duration: 0 };
function lT(t, e, n) {
  const r = { direction: "in" };
  let i = e(t, n, r),
    s = !1,
    a,
    o,
    l = 0;
  function u() {
    a && qg(t, a);
  }
  function f() {
    const {
      delay: d = 0,
      duration: p = 300,
      easing: m = Iy,
      tick: g = We,
      css: w,
    } = i || oT;
    w && (a = Wg(t, 0, 1, p, d, m, w, l++)), g(0, 1);
    const y = Vw() + d,
      v = y + p;
    o && o.abort(),
      (s = !0),
      Ia(() => oh(t, !0, "start")),
      (o = Gw((E) => {
        if (s) {
          if (E >= v) return g(1, 0), oh(t, !0, "end"), u(), (s = !1);
          if (E >= y) {
            const S = m((E - y) / p);
            g(S, 1 - S);
          }
        }
        return s;
      }));
  }
  let c = !1;
  return {
    start() {
      c || ((c = !0), qg(t), _d(i) ? ((i = i(r)), aT().then(f)) : f());
    },
    invalidate() {
      c = !1;
    },
    end() {
      s && (u(), (s = !1));
    },
  };
}
function bDe(t, e, n) {
  const r = { direction: "out" };
  let i = e(t, n, r),
    s = !0,
    a;
  const o = Uu;
  o.r += 1;
  function l() {
    const {
      delay: u = 0,
      duration: f = 300,
      easing: c = Iy,
      tick: d = We,
      css: p,
    } = i || oT;
    p && (a = Wg(t, 1, 0, f, u, c, p));
    const m = Vw() + u,
      g = m + f;
    Ia(() => oh(t, !1, "start")),
      Gw((w) => {
        if (s) {
          if (w >= g) return d(0, 1), oh(t, !1, "end"), --o.r || ac(o.c), !1;
          if (w >= m) {
            const y = c((w - m) / f);
            d(1 - y, y);
          }
        }
        return s;
      });
  }
  return (
    _d(i)
      ? aT().then(() => {
          (i = i(r)), l();
        })
      : l(),
    {
      end(u) {
        u && i.tick && i.tick(1, 0), s && (a && qg(t, a), (s = !1));
      },
    }
  );
}
function $O(t, e, n, r) {
  const i = { direction: "both" };
  let s = e(t, n, i),
    a = r ? 0 : 1,
    o = null,
    l = null,
    u = null;
  function f() {
    u && qg(t, u);
  }
  function c(p, m) {
    const g = p.b - a;
    return (
      (m *= Math.abs(g)),
      {
        a,
        b: p.b,
        d: g,
        duration: m,
        start: p.start,
        end: p.start + m,
        group: p.group,
      }
    );
  }
  function d(p) {
    const {
        delay: m = 0,
        duration: g = 300,
        easing: w = Iy,
        tick: y = We,
        css: v,
      } = s || oT,
      E = { start: Vw() + m, b: p };
    p || ((E.group = Uu), (Uu.r += 1)),
      o || l
        ? (l = E)
        : (v && (f(), (u = Wg(t, a, p, g, m, w, v))),
          p && y(0, 1),
          (o = c(E, g)),
          Ia(() => oh(t, p, "start")),
          Gw((S) => {
            if (
              (l &&
                S > l.start &&
                ((o = c(l, g)),
                (l = null),
                oh(t, o.b, "start"),
                v && (f(), (u = Wg(t, a, o.b, o.duration, 0, w, s.css)))),
              o)
            ) {
              if (S >= o.end)
                y((a = o.b), 1 - a),
                  oh(t, o.b, "end"),
                  l || (o.b ? f() : --o.group.r || ac(o.group.c)),
                  (o = null);
              else if (S >= o.start) {
                const D = S - o.start;
                (a = o.a + o.d * w(D / o.duration)), y(a, 1 - a);
              }
            }
            return !!(o || l);
          }));
  }
  return {
    run(p) {
      _d(s)
        ? aT().then(() => {
            (s = s(i)), d(p);
          })
        : d(p);
    },
    end() {
      f(), (o = l = null);
    },
  };
}
function wh(t, e) {
  const n = (e.token = {});
  function r(i, s, a, o) {
    if (e.token !== n) return;
    e.resolved = o;
    let l = e.ctx;
    a !== void 0 && ((l = l.slice()), (l[a] = o));
    const u = i && (e.current = i)(l);
    let f = !1;
    e.block &&
      (e.blocks
        ? e.blocks.forEach((c, d) => {
            d !== s &&
              c &&
              (jr(),
              Ze(c, 1, 1, () => {
                e.blocks[d] === c && (e.blocks[d] = null);
              }),
              Hr());
          })
        : e.block.d(1),
      u.c(),
      Fe(u, 1),
      u.m(e.mount(), e.anchor),
      (f = !0)),
      (e.block = u),
      e.blocks && (e.blocks[s] = u),
      f && sT();
  }
  if (Fde(t)) {
    const i = iT();
    if (
      (t.then(
        (s) => {
          Bc(i), r(e.then, 1, e.value, s), Bc(null);
        },
        (s) => {
          if ((Bc(i), r(e.catch, 2, e.error, s), Bc(null), !e.hasCatch))
            throw s;
        }
      ),
      e.current !== e.pending)
    )
      return r(e.pending, 0), !0;
  } else {
    if (e.current !== e.then) return r(e.then, 1, e.value, t), !0;
    e.resolved = t;
  }
}
function _1(t, e, n) {
  const r = e.slice(),
    { resolved: i } = t;
  t.current === t.then && (r[t.value] = i),
    t.current === t.catch && (r[t.error] = i),
    t.block.p(r, n);
}
function wDe(t, e) {
  t.d(1), e.delete(t.key);
}
function rhe(t, e) {
  Ze(t, 1, 1, () => {
    e.delete(t.key);
  });
}
function _De(t, e) {
  t.f(), rhe(t, e);
}
function EDe(t, e, n, r, i, s, a, o, l, u, f, c) {
  let d = t.length,
    p = s.length,
    m = d;
  const g = {};
  for (; m--; ) g[t[m].key] = m;
  const w = [],
    y = new Map(),
    v = new Map(),
    E = [];
  for (m = p; m--; ) {
    const x = c(i, s, m),
      _ = n(x);
    let A = a.get(_);
    A ? r && E.push(() => A.p(x, e)) : ((A = u(_, x)), A.c()),
      y.set(_, (w[m] = A)),
      _ in g && v.set(_, Math.abs(m - g[_]));
  }
  const S = new Set(),
    D = new Set();
  function P(x) {
    Fe(x, 1), x.m(o, f), a.set(x.key, x), (f = x.first), p--;
  }
  for (; d && p; ) {
    const x = w[p - 1],
      _ = t[d - 1],
      A = x.key,
      N = _.key;
    x === _
      ? ((f = x.first), d--, p--)
      : y.has(N)
      ? !a.has(A) || S.has(A)
        ? P(x)
        : D.has(N)
        ? d--
        : v.get(A) > v.get(N)
        ? (D.add(A), P(x))
        : (S.add(N), d--)
      : (l(_, a), d--);
  }
  for (; d--; ) {
    const x = t[d];
    y.has(x.key) || l(x, a);
  }
  for (; p; ) P(w[p - 1]);
  return ac(E), w;
}
function ihe(t, e, n) {
  const r = t.$$.props[e];
  r !== void 0 && ((t.$$.bound[r] = n), n(t.$$.ctx[r]));
}
function Bn(t) {
  t && t.c();
}
function Dn(t, e, n, r) {
  const { fragment: i, after_update: s } = t.$$;
  i && i.m(e, n),
    r ||
      Ia(() => {
        const a = t.$$.on_mount.map(qH).filter(_d);
        t.$$.on_destroy ? t.$$.on_destroy.push(...a) : ac(a),
          (t.$$.on_mount = []);
      }),
    s.forEach(Ia);
}
function Rn(t, e) {
  const n = t.$$;
  n.fragment !== null &&
    (nhe(n.after_update),
    ac(n.on_destroy),
    n.fragment && n.fragment.d(e),
    (n.on_destroy = n.fragment = null),
    (n.ctx = []));
}
function she(t, e) {
  t.$$.dirty[0] === -1 && (Cp.push(t), Jde(), t.$$.dirty.fill(0)),
    (t.$$.dirty[(e / 31) | 0] |= 1 << e % 31);
}
function is(t, e, n, r, i, s, a, o = [-1]) {
  const l = Kg;
  Bc(t);
  const u = (t.$$ = {
    fragment: null,
    ctx: [],
    props: s,
    update: We,
    not_equal: i,
    bound: LO(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (l ? l.$$.context : [])),
    callbacks: LO(),
    dirty: o,
    skip_bound: !1,
    root: e.target || l.$$.root,
  });
  a && a(u.root);
  let f = !1;
  if (
    ((u.ctx = n
      ? n(t, e.props || {}, (c, d, ...p) => {
          const m = p.length ? p[0] : d;
          return (
            u.ctx &&
              i(u.ctx[c], (u.ctx[c] = m)) &&
              (!u.skip_bound && u.bound[c] && u.bound[c](m), f && she(t, c)),
            d
          );
        })
      : []),
    u.update(),
    (f = !0),
    ac(u.before_update),
    (u.fragment = r ? r(u.ctx) : !1),
    e.target)
  ) {
    if (e.hydrate) {
      const c = Vde(e.target);
      u.fragment && u.fragment.l(c), c.forEach(ze);
    } else u.fragment && u.fragment.c();
    e.intro && Fe(t.$$.fragment),
      Dn(t, e.target, e.anchor, e.customElement),
      sT();
  }
  Bc(l);
}
class ss {
  $destroy() {
    Rn(this, 1), (this.$destroy = We);
  }
  $on(e, n) {
    if (!_d(n)) return We;
    const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return (
      r.push(n),
      () => {
        const i = r.indexOf(n);
        i !== -1 && r.splice(i, 1);
      }
    );
  }
  $set(e) {
    this.$$set &&
      !$de(e) &&
      ((this.$$.skip_bound = !0), this.$$set(e), (this.$$.skip_bound = !1));
  }
}
const uT = new sf(),
  cT = new sf(),
  Wl = new by({ inProgress: !1, actionRequired: "" }),
  V0 = new by(null),
  Ww = Jt.select("wallets").pipe(Xc(1));
uT.pipe(BU(Ww), O7("1")).subscribe((t) => {
  t.forEach(({ label: e }) => {
    cT.next(e);
  }),
    npe();
});
const og = new by([]);
function ahe(t) {
  const e = og.getValue(),
    n = e.findIndex(({ hash: r }) => r === t.hash);
  if (n !== -1) {
    const r = e.map((i, s) => (s === n ? t : i));
    og.next(r);
  } else og.next([...e, t]);
}
function xDe(t) {
  const e = og.getValue();
  og.next(e.filter((n) => n.hash !== t));
}
const UO = jse(() => {
    const t = new sf();
    return (
      JH(() => {
        t.next();
      }),
      t.asObservable().pipe(I7(1))
    );
  }),
  Kp = {
    default: {
      "--w3o-background-color": "unset",
      "--w3o-foreground-color": "unset",
      "--w3o-text-color": "unset",
      "--w3o-border-color": "unset",
      "--w3o-action-color": "unset",
      "--w3o-border-radius": "unset",
      "--w3o-font-family": "inherit",
    },
    light: {
      "--w3o-background-color": "#ffffff",
      "--w3o-foreground-color": "#EFF1FC",
      "--w3o-text-color": "#1a1d26",
      "--w3o-border-color": "#d0d4f7",
      "--w3o-action-color": "#6370E5",
      "--w3o-border-radius": "16px",
      "--w3o-font-family": "inherit",
    },
    dark: {
      "--w3o-background-color": "#1A1D26",
      "--w3o-foreground-color": "#242835",
      "--w3o-text-color": "#EFF1FC",
      "--w3o-border-color": "#33394B",
      "--w3o-action-color": "#929bed",
      "--w3o-border-radius": "16px",
      "--w3o-font-family": "inherit",
    },
  },
  ohe = (t) => (typeof t == "string" && t === "system" ? uhe() : lhe(t)),
  lhe = (t) => {
    if (typeof t == "string" && t in Kp) return Kp[t];
    if (typeof t == "object") return t;
  },
  $m = (t) => {
    Object.keys(t).forEach((e) => {
      document.documentElement.style.setProperty(e, t[e]);
    });
  },
  uhe = () => {
    const t = window.matchMedia("(prefers-color-scheme: dark)");
    t.matches ? $m(Kp.dark) : $m(Kp.light),
      uE(t, "change")
        .pipe(Lg(uT))
        .subscribe((e) => {
          e.matches ? $m(Kp.dark) : $m(Kp.light);
        });
  },
  jO = ae.object().unknown(),
  che = ae.object({ namespace: L7.required(), id: M7.required() }),
  fhe = ae.any().allow(
    ae.object({
      name: ae.string().required(),
      avatar: ae.string(),
      contentHash: ae.any().allow(ae.string(), null),
      getText: ae.function().arity(1).required(),
    }),
    null
  ),
  dhe = ae.any().allow(ae.object({ name: ae.string().required() }), null),
  hhe = ae.any().allow(ae.object({ eth: ae.number() }).unknown(), null),
  phe = ae
    .any()
    .allow(
      ae.object({ balance: ae.string().required(), icon: ae.string() }),
      null
    ),
  mhe = ae.object({
    address: ae.string().required(),
    ens: fhe,
    uns: dhe,
    balance: hhe,
    secondaryTokens: phe,
  }),
  ghe = ae
    .array()
    .items(ele)
    .unique((t, e) => t.id === e.id)
    .error((t) =>
      t[0].code === "array.unique"
        ? new Error(
            `There is a duplicate Chain ID in your Onboard Chains array: ${t}`
          )
        : new Error(`${t}`)
    ),
  yhe = ae.array().items(mhe),
  ez = ae
    .object({
      label: ae.string(),
      icon: ae.string(),
      provider: jO,
      instance: jO,
      accounts: yhe,
      chains: ae.array().items(che),
    })
    .required()
    .error(new Error("wallet must be defined")),
  vhe = ae.array().items(ez),
  tz = ae.object({
    name: ae.string().required(),
    url: ae.string().uri().required(),
  }),
  nz = ae.object({
    version: ae.string().required(),
    termsUrl: ae.string().uri(),
    privacyUrl: ae.string().uri(),
  }),
  bhe = ae.object({
    name: ae.string().required(),
    description: ae.string().required(),
    icon: ae.string(),
    logo: ae.string(),
    gettingStartedGuide: ae.string(),
    email: ae.string(),
    appUrl: ae.string(),
    explore: ae.string(),
    recommendedInjectedWallets: ae.array().items(tz),
    agreement: nz,
  }),
  whe = ae.object({
    name: ae.string(),
    description: ae.string(),
    icon: ae.string(),
    logo: ae.string(),
    gettingStartedGuide: ae.string(),
    email: ae.string(),
    appUrl: ae.string(),
    explore: ae.string(),
    recommendedInjectedWallets: ae.array().items(tz),
    agreement: nz,
  });
ae.object({
  label: ae.string().required(),
  getInfo: ae.function().arity(1).required(),
  getInterface: ae.function().arity(1).required(),
});
const rz = ae.array().items(ae.function()).required(),
  _he = ae.string(),
  fT = ae.string().valid("topRight", "bottomRight", "bottomLeft", "topLeft"),
  HO = [70, 80, 90, 95, 99],
  _5 = ae.object({
    transactionHandler: ae.function(),
    enabled: ae.boolean(),
    position: fT,
    replacement: ae.object({
      gasPriceProbability: ae.object({
        speedup: ae.number().valid(...HO),
        cancel: ae.number().valid(...HO),
      }),
    }),
  }),
  iz = ae.object({ desktop: _5, mobile: _5 }),
  zO = ae.object({
    enabled: ae.boolean(),
    position: fT,
    minimal: ae.boolean(),
    containerElement: ae.string(),
    hideTransactionProtectionBtn: ae.boolean(),
    transactionProtectionInfoLink: ae.string(),
  }),
  Ehe = ae.object({
    enabled: ae.boolean(),
    position: fT,
    expanded: ae.boolean(),
    minimal: ae.boolean(),
    hideTransactionProtectionBtn: ae.boolean(),
    transactionProtectionInfoLink: ae.string(),
    containerElement: ae.string(),
  }),
  sz = ae.object({
    showSidebar: ae.boolean(),
    disableClose: ae.boolean(),
    autoConnectLastWallet: ae.boolean(),
    autoConnectAllPreviousWallet: ae.boolean(),
    iDontHaveAWalletLink: ae.string(),
    wheresMyWalletLink: ae.string(),
    removeWhereIsMyWalletWarning: ae.boolean(),
    removeIDontHaveAWalletInfoLink: ae.boolean(),
    disableUDResolution: ae.boolean(),
  }),
  xhe = ae.object({ accountCenter: ae.string(), connectModal: ae.string() }),
  The = ae.object({
    "--w3o-background-color": ae.string(),
    "--w3o-font-family": ae.string(),
    "--w3o-foreground-color": ae.string(),
    "--w3o-text-color": ae.string(),
    "--w3o-border-color": ae.string(),
    "--w3o-action-color": ae.string(),
    "--w3o-border-radius": ae.string(),
  }),
  She = ae.string().valid("default", "dark", "light", "system"),
  az = ae.alternatives().try(The, She),
  Ahe = ae.object({
    wallets: rz,
    chains: ghe.required(),
    appMetadata: bhe,
    i18n: ae.object().unknown(),
    apiKey: ae.string(),
    accountCenter: ae.object({
      desktop: zO,
      mobile: zO,
      hideTransactionProtectionBtn: ae.boolean(),
      transactionProtectionInfoLink: ae.string(),
    }),
    notify: [iz, _5],
    gas: ae.object({
      get: ae.function().required(),
      stream: ae.function().required(),
    }),
    connect: sz,
    containerElements: xhe,
    transactionPreview: ae.object({
      patchProvider: ae.function().required(),
      init: ae.function().required(),
      previewTransaction: ae.function(),
    }),
    theme: az,
    disableFontDownload: ae.boolean(),
    unstoppableResolution: ae.function(),
  }),
  Che = ae.object({
    autoSelect: ae.alternatives().try(
      ae.object({
        label: ae.string().required(),
        disableModals: ae.boolean(),
      }),
      ae.string()
    ),
  }),
  khe = ae.object({ label: ae.string().required() }).required(),
  Ihe = ae.object({
    address: ae.string().required(),
    icon: ae.string().optional(),
  }),
  Ohe = ae.object({
    chainId: M7.required(),
    chainNamespace: L7,
    wallet: ae.string(),
    rpcUrl: ae.string(),
    label: ae.string(),
    token: ae.string(),
    protectedRpcUrl: ae.string(),
    secondaryTokens: ae.array().max(5).items(Ihe).optional(),
  }),
  oz = ae.object({
    key: ae.string().required(),
    type: ae.string().allow("pending", "error", "success", "hint"),
    eventCode: ae.string(),
    message: ae.string().required(),
    id: ae.string().required(),
    autoDismiss: ae.number(),
    onClick: ae.function(),
    link: ae.string(),
  }),
  Phe = ae.object({
    sendTransaction: ae.function(),
    estimateGas: ae.function(),
    gasPrice: ae.function(),
    balance: ae.alternatives(ae.string(), ae.number()),
    txDetails: ae.object({
      value: ae.alternatives(ae.string(), ae.number()),
      to: ae.string(),
      from: ae.string(),
    }),
    txApproveReminderTimeout: ae.number(),
  }),
  Nhe = ae.object({
    key: ae.string(),
    type: ae.string().allow("pending", "error", "success", "hint"),
    eventCode: ae.string(),
    message: ae.string(),
    id: ae.string(),
    autoDismiss: ae.number(),
    onClick: ae.function(),
    link: ae.string(),
  }),
  Dhe = ae.object({
    id: ae.string().required(),
    key: ae.string().required(),
    type: ae.string().allow("pending", "error", "success", "hint").required(),
    eventCode: ae.string().required(),
    message: ae.string().required(),
    autoDismiss: ae.number().required(),
    network: ae.string().required(),
    startTime: ae.number(),
    onClick: ae.function(),
    link: ae.string(),
  }),
  Rhe = ae.any().allow(oz, ae.boolean().allow(!1));
function dT(t) {
  return Ri(ez, t);
}
function Mhe(t) {
  return Ri(Ahe, t);
}
function Lhe(t) {
  return Ri(Che, t);
}
function Bhe(t) {
  return Ri(khe, t);
}
function lz(t, e) {
  return Ri(
    ae
      .string()
      .required()
      .label(e || "value"),
    t
  );
}
function uz(t) {
  return Ri(Ohe, t);
}
function Fhe(t) {
  return Ri(Ehe, t);
}
function $he(t) {
  return Ri(sz, t);
}
function Uhe(t) {
  return Ri(rz, t);
}
function jhe(t) {
  return Ri(_he, t);
}
function cz(t) {
  return Ri(_5, t);
}
function Hhe(t) {
  return Ri(iz, t);
}
function zhe(t) {
  return Ri(Rhe, t);
}
function Vhe(t) {
  return Ri(Dhe, t);
}
function Ghe(t) {
  return Ri(Phe, t);
}
function Whe(t) {
  return Ri(oz, t);
}
function VO(t) {
  return Ri(Nhe, t);
}
function qhe(t) {
  return Ri(vhe, t);
}
function Khe(t) {
  return Ri(az, t);
}
function Xhe(t) {
  return Ri(whe, t);
}
function Zhe(t) {
  const e = {
    type: NH,
    payload: t.map(({ namespace: n = "evm", id: r, rpcUrl: i, ...s }) => ({
      ...s,
      namespace: n,
      id: r.toLowerCase(),
      rpcUrl: i ? i.trim() : null,
    })),
  };
  Ls(e);
}
function Yhe(t) {
  const { label: e, token: n, rpcUrl: r, id: i, namespace: s } = t,
    a = uz({ label: e, token: n, rpcUrl: r, chainId: i, chainNamespace: s });
  if (a) throw a;
  Ls({ type: DH, payload: t });
}
function RE(t) {
  const e = dT(t);
  if (e) throw (console.error(e), e);
  Ls({ type: MH, payload: t });
}
function ob(t, e) {
  const n = dT(e);
  if (n) throw (console.error(n), n);
  const r = { type: LH, payload: { id: t, ...e } };
  Ls(r);
}
function Qhe(t) {
  const e = lz(t, "wallet id");
  if (e) throw e;
  Ls({ type: BH, payload: { id: t } });
}
function Jhe(t, e) {
  const n = dT(t) || (e && lz(e, "address"));
  if (n) throw n;
  if (e) {
    const r = t.accounts.find((i) => i.address === e);
    r &&
      (t.accounts = [
        r,
        ...t.accounts.filter(({ address: i }) => i !== r.address),
      ]);
  }
  RE(t);
}
function Um(t, e, n) {
  const r = { type: FH, payload: { id: t, address: e, ...n } };
  Ls(r);
}
function fz(t) {
  const e = Fhe(t);
  if (e) throw e;
  Ls({ type: $H, payload: t });
}
function epe(t) {
  const e = $he(t);
  if (e) throw e;
  Ls({ type: UH, payload: t });
}
function lb(t) {
  const e = cz(t);
  if (e) throw e;
  Ls({ type: zH, payload: t });
}
function kp(t) {
  const e = Vhe(t);
  if (e) throw e;
  Ls({ type: Y7, payload: t });
}
function Q_(t) {
  const e = Whe(t);
  if (e) throw e;
  Ls({ type: Y7, payload: t });
}
function tpe(t) {
  const e = VO(t);
  if (e) throw e;
  const n = `customNotification-${cj()}`,
    r = { ...t, id: n, key: n };
  Q_(r);
  const i = () => dz(r.id),
    s = (a) => {
      const o = VO(t);
      if (o) throw o;
      const l = { ...a, id: r.id, key: r.key };
      return Q_(l), { dismiss: i, update: s };
    };
  return Q_(r), { dismiss: i, update: s };
}
function dz(t) {
  if (typeof t != "string")
    throw new Error("Notification id must be of type string");
  Ls({ type: VH, payload: t });
}
function npe() {
  Ls({ type: RH });
}
function hz(t) {
  const e = Uhe(t);
  if (e) throw e;
  const n = spe(t),
    r = ape(n);
  Ls({ type: jH, payload: r });
}
function rpe(t) {
  const e = jhe(t);
  if (e) throw e;
  Ls({ type: HH, payload: t });
}
function ipe(t) {
  const e = qhe(t);
  if (e) throw e;
  Ls({ type: GH, payload: t });
}
function spe(t) {
  const { device: e } = so;
  return t.reduce((n, r) => {
    const i = r({ device: e });
    return i && n.push(...(Array.isArray(i) ? i : [i])), n;
  }, []);
}
function ape(t) {
  return t.filter(
    (e, n) => e && t.findIndex((r) => r && r.label === e.label) === n
  );
}
function pz(t) {
  const e = Khe(t);
  if (e) throw e;
  const n = ohe(t);
  n && $m(n);
}
function mz(t) {
  const e = Xhe(t);
  if (e) throw e;
  Ls({ type: WH, payload: t });
}
async function ope(t) {
  if (t) {
    const i = Lhe(t);
    if (i) throw i;
  }
  const { chains: e } = Jt.get();
  if (!e.length)
    throw new Error(
      "At least one chain must be set before attempting to connect a wallet"
    );
  const { autoSelect: n } = t || {
    autoSelect: { label: "", disableModals: !1 },
  };
  n && (typeof n == "string" || n.label) && (await Dde(50)),
    Jt.get().walletModules.length || hz(so.initialWalletInit),
    Wl.next({
      autoSelect: typeof n == "string" ? { label: n, disableModals: !1 } : n,
      inProgress: !0,
    });
  const r = Wl.pipe(
    D0(({ inProgress: i, actionRequired: s }) => i === !1 && !s),
    BU(Ww),
    O7(1)
  );
  return Aw(r);
}
var lpe = {
    selectingWallet: {
      header: "Available Wallets",
      sidebar: {
        heading: "",
        subheading: "Connect your wallet",
        paragraph:
          "Connecting your wallet is like “logging in” to Web3. Select your wallet from the options to get started.",
        IDontHaveAWallet: "I don't have a wallet",
      },
      recommendedWalletsPart1: "{app} only supports",
      recommendedWalletsPart2:
        "on this platform. Please use or install one of the supported wallets to continue",
      installWallet:
        "You do not have any wallets installed that {app} supports, please use a supported wallet",
      agreement: {
        agree: "I agree to the",
        terms: "Terms & Conditions",
        and: "and",
        privacy: "Privacy Policy",
      },
      whyDontISeeMyWallet: "Why don't I see my wallet?",
      learnMore: "Click here to learn more",
    },
    connectingWallet: {
      header:
        "{connectionRejected, select, false {Connecting to {wallet}...} other {Connection Rejected}}",
      sidebar: {
        subheading: "Approve Connection",
        paragraph:
          "Please approve the connection in your wallet and authorize access to continue.",
      },
      mainText: "Connecting...",
      paragraph:
        "Make sure to select all accounts that you want to grant access to.",
      previousConnection:
        "{wallet} already has a pending connection request, please open the {wallet} app to login and connect.",
      rejectedText: "Connection Rejected!",
      rejectedCTA: "Click here to try again",
      primaryButton: "Back to wallets",
    },
    connectedWallet: {
      header: "Connection Successful",
      sidebar: {
        subheading: "Connection Successful!",
        paragraph: "Your wallet is now connected to {app}",
      },
      mainText: "Connected",
    },
  },
  upe = {
    actionRequired: {
      heading: "Action required in {wallet}",
      paragraph: "Please switch the active account in your wallet.",
      linkText: "Learn more.",
      buttonText: "Okay",
    },
    switchChain: {
      heading: "Switch Chain",
      paragraph1:
        "{app} requires that you switch your wallet to the {nextNetworkName} network to continue.",
      paragraph2:
        "*Some wallets may not support changing networks. If you can not change networks in your wallet you may consider switching to a different wallet.",
    },
    confirmDisconnectAll: {
      heading: "Disconnect all Wallets",
      description:
        "Are you sure that you would like to disconnect all your wallets?",
      confirm: "Confirm",
      cancel: "Cancel",
    },
    confirmTransactionProtection: {
      heading: "Enable Transaction Protection",
      description:
        "Protect RPC endpoints hide your transaction from front-running and sandwich bots.",
      link: "Learn more",
      enable: "Enable",
      dismiss: "Dismiss",
    },
  },
  cpe = {
    connectAnotherWallet: "Connect another Wallet",
    disconnectAllWallets: "Disconnect all Wallets",
    currentNetwork: "Current Network",
    enableTransactionProtection: "Enable Transaction Protection",
    appInfo: "App Info",
    learnMore: "Learn More",
    gettingStartedGuide: "Getting Started Guide",
    smartContracts: "Smart Contract(s)",
    explore: "Explore",
    poweredBy: "powered by",
    addAccount: "Add Account",
    setPrimaryAccount: "Set Primary Account",
    disconnectWallet: "Disconnect Wallet",
    copyAddress: "Copy Wallet address",
  },
  fpe = {
    transaction: {
      txRequest: "Your transaction is waiting for you to confirm",
      nsfFail: "You have insufficient funds for this transaction",
      txUnderpriced:
        "The gas price for your transaction is too low, try a higher gas price",
      txRepeat: "This could be a repeat transaction",
      txAwaitingApproval:
        "You have a previous transaction waiting for you to confirm",
      txConfirmReminder: "Please confirm your transaction to continue",
      txSendFail: "You rejected the transaction",
      txSent: "Your transaction has been sent to the network",
      txStallPending:
        "Your transaction has stalled before it was sent, please try again",
      txStuck: "Your transaction is stuck due to a nonce gap",
      txPool: "Your transaction has started",
      txStallConfirmed:
        "Your transaction has stalled and hasn't been confirmed",
      txSpeedUp: "Your transaction has been sped up",
      txCancel: "Your transaction is being canceled",
      txFailed: "Your transaction has failed",
      txConfirmed: "Your transaction has succeeded",
      txError: "Oops something went wrong, please try again",
      txReplaceError:
        "There was an error replacing your transaction, please try again",
    },
    watched: {
      txPool:
        "Your account is {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txSpeedUp:
        "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been sped up",
      txCancel:
        "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been canceled",
      txConfirmed:
        "Your account successfully {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txFailed:
        "Your account failed to {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txStuck: "Your transaction is stuck due to a nonce gap",
    },
    time: { minutes: "min", seconds: "sec" },
  },
  Cn = { connect: lpe, modals: upe, accountCenter: cpe, notify: fpe };
const J_ = {};
function dpe(t) {
  return t
    ? (J_[t.rpcUrl] ||
        (J_[t.rpcUrl] = new fde(
          t.providerConnectionInfo && t.providerConnectionInfo.url
            ? t.providerConnectionInfo
            : t.rpcUrl
        )),
      J_[t.rpcUrl])
    : null;
}
function hpe(t) {
  const e = { method: "eth_requestAccounts" };
  return t.request(e);
}
function TDe(t) {
  const e = { method: "eth_selectAccounts" };
  return t.request(e);
}
function ppe(t) {
  return t.request({ method: "eth_chainId" });
}
function gz(t) {
  const { provider: e, disconnected$: n } = t;
  return k7(
    (s) => {
      e.on("accountsChanged", s);
    },
    (s) => {
      e.removeListener("accountsChanged", s);
    }
  ).pipe(Lg(n));
}
function mpe(t) {
  const { provider: e, disconnected$: n } = t;
  return k7(
    (s) => {
      e.on("chainChanged", s);
    },
    (s) => {
      e.removeListener("chainChanged", s);
    }
  ).pipe(Lg(n));
}
function gpe(t, e) {
  const n = cT.pipe(
      D0((s) => s === e),
      I7(1)
    ),
    r = gz({ provider: t, disconnected$: n }).pipe(cE());
  r.subscribe(async ([s]) => {
    try {
      await bpe(e);
    } catch (f) {
      console.warn(
        "Web3Onboard: Error whilst trying to sync connected accounts:",
        f
      );
    }
    if (!s) {
      wz({ label: e });
      return;
    }
    const { wallets: a } = Jt.get(),
      { accounts: o } = a.find((f) => f.label === e),
      [[l], u] = nle(o, (f) => f.address === s);
    if (
      (ob(e, {
        accounts: [
          l || { address: s, ens: null, uns: null, balance: null },
          ...u,
        ],
      }),
      Jt.get().notify.enabled && !l)
    ) {
      const f = await T5();
      if (f) {
        const c = Jt.get().wallets.find((d) => d.label === e);
        try {
          f.subscribe({ id: s, chainId: c.chains[0].id, type: "account" });
        } catch {}
      }
    }
  }),
    r
      .pipe(
        yI(async ([s]) => {
          if (!s) return;
          const { wallets: a, chains: o } = Jt.get(),
            l = a.find((E) => E.label === e),
            { chains: u, accounts: f } = l,
            [c] = u,
            d = o.find(({ namespace: E, id: S }) => E === "evm" && S === c.id),
            p = E5(s, d),
            m = x5(l, s, d),
            g = f.find((E) => E.address === s),
            w = o.find(({ id: E }) => E === ag(c.id)),
            y =
              g && g.ens
                ? Promise.resolve(g.ens)
                : w
                ? ME(s, w)
                : Promise.resolve(null),
            v = g && g.uns ? Promise.resolve(g.uns) : LE(s, d);
          return Promise.all([Promise.resolve(s), p, y, v, m]);
        })
      )
      .subscribe((s) => {
        if (!s) return;
        const [a, o, l, u, f] = s;
        Um(e, a, { balance: o, ens: l, uns: u, secondaryTokens: f });
      });
  const i = mpe({ provider: t, disconnected$: n }).pipe(cE());
  i.subscribe(async (s) => {
    const { wallets: a } = Jt.get(),
      { chains: o, accounts: l } = a.find((c) => c.label === e),
      [u] = o;
    if (s === u.id) return;
    if (Jt.get().notify.enabled) {
      const c = await T5();
      if (c) {
        const d = Jt.get().wallets.find((p) => p.label === e);
        d.accounts.forEach(({ address: p }) => {
          c.unsubscribe({ id: p, chainId: d.chains[0].id, timeout: 6e4 });
        }),
          d.accounts.forEach(({ address: p }) => {
            try {
              c.subscribe({ id: p, chainId: s, type: "account" });
            } catch {}
          });
      }
    }
    const f = l.map(({ address: c }) => ({
      address: c,
      ens: null,
      uns: null,
      balance: null,
    }));
    ob(e, { chains: [{ namespace: "evm", id: s }], accounts: f });
  }),
    i
      .pipe(
        yI(async (s) => {
          const { wallets: a, chains: o } = Jt.get(),
            l = a.find((c) => c.label === e),
            { accounts: u } = l,
            f = o.find(({ namespace: c, id: d }) => c === "evm" && d === s);
          return Promise.all(
            u.map(async ({ address: c }) => {
              const d = E5(c, f),
                p = x5(l, c, f),
                m = o.find(({ id: D }) => D === ag(s)),
                g = m ? ME(c, m) : Promise.resolve(null),
                w = ag(s) ? LE(c, m) : Promise.resolve(null),
                [y, v, E, S] = await Promise.all([d, g, w, p]);
              return {
                address: c,
                balance: y,
                ens: v,
                uns: E,
                secondaryTokens: S,
              };
            })
          );
        })
      )
      .subscribe((s) => {
        s && ob(e, { accounts: s });
      }),
    n.subscribe(() => {
      t.disconnect && t.disconnect();
    });
}
async function ME(t, e) {
  if (!e) return null;
  const n = dpe(e);
  try {
    const r = await n.lookupAddress(t);
    let i = null;
    if (r) {
      const s = await n.getResolver(r);
      if (s) {
        const [a, o] = await Promise.all([s.getContentHash(), s.getAvatar()]),
          l = s.getText.bind(s);
        i = { name: r, avatar: o, contentHash: a, getText: l };
      }
    }
    return i;
  } catch (r) {
    return console.error(r), null;
  }
}
async function LE(t, e) {
  const { unstoppableResolution: n } = so;
  if (!n || !Nle(t) || !e) return null;
  try {
    return await n(t);
  } catch (r) {
    return console.error(r), null;
  }
}
async function E5(t, e) {
  if (!e) return null;
  const { wallets: n } = Jt.get();
  try {
    const s = await n
      .find((a) => !!a.provider)
      .provider.request({ method: "eth_getBalance", params: [t, "latest"] });
    return s ? { [e.token || "eth"]: hj(s) } : null;
  } catch (r) {
    return console.error(r), null;
  }
}
function yz(t, e) {
  return t.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: e }],
  });
}
function ype(t, e) {
  return t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: e.id,
        chainName: e.label,
        nativeCurrency: { name: e.label, symbol: e.token, decimals: 18 },
        rpcUrls: [e.publicRpcUrl || e.rpcUrl],
        blockExplorerUrls: e.blockExplorerUrl ? [e.blockExplorerUrl] : void 0,
      },
    ],
  });
}
function SDe(t, e, n) {
  return t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: e.id,
        chainName: e.label,
        nativeCurrency: { name: e.label, symbol: e.token, decimals: 18 },
        rpcUrls: [n],
        blockExplorerUrls: e.blockExplorerUrl ? [e.blockExplorerUrl] : void 0,
      },
    ],
  });
}
async function vpe(t) {
  try {
    const e = await t.request({ method: "wallet_getPermissions" });
    return Array.isArray(e) ? e : [];
  } catch {
    return [];
  }
}
async function bpe(t) {
  const e = Jt.get().wallets.find((i) => i.label === t),
    r = (await vpe(e.provider)).find(
      ({ parentCapability: i }) => i === "eth_accounts"
    );
  if (r) {
    const { value: i } = r.caveats.find(
      ({ type: s }) => s === "restrictReturnedAccounts"
    ) || { value: null };
    if (i) {
      const s = e.accounts.filter(({ address: a }) => i.includes(a));
      ob(e.label, { ...e, accounts: s });
    }
  }
}
async function vz(t) {
  const { wallets: e, chains: n } = Jt.get(),
    r = await Promise.all(
      e.map(async (i) => {
        const s = n.find(({ id: o }) => o === i.chains[0].id),
          a = await Promise.all(
            i.accounts.map(async (o) => {
              const l = await x5(i, o.address, s);
              if (
                !t ||
                t.some((u) => u.toLowerCase() === o.address.toLowerCase())
              ) {
                const u = await E5(o.address, s);
                return { ...o, balance: u, secondaryTokens: l };
              }
              return { ...o, secondaryTokens: l };
            })
          );
        return { ...i, accounts: a };
      })
    );
  ipe(r);
}
const x5 = async (t, e, n) => {
  if (!n) return;
  const r = n.rpcUrl;
  if (!n.secondaryTokens || !n.secondaryTokens.length || !r) return;
  const s = new X7(t.provider, "any").getSigner(),
    a = [
      {
        inputs: [{ name: "owner", type: "address" }],
        name: "balanceOf",
        outputs: [{ name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [{ name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
      },
    ];
  return await Promise.all(
    n.secondaryTokens.map(async (l) => {
      try {
        const u = new pH(l.address, a, s),
          f = await u.balanceOf(e);
        return {
          name: await u.symbol(),
          balance: hj(f.toHexString()),
          icon: l.icon,
        };
      } catch (u) {
        console.error(`There was an error fetching balance and/or symbol 
          for token contract: ${l.address} - ${u}`);
      }
    })
  );
};
function wpe(t) {
  const e = Jt.get().notify.transactionHandler(t),
    n = zhe(e);
  if (n) throw n;
  t.eventCode === "txConfirmed" && vz([t.watchedAddress, t.counterparty]);
  const r = _pe(t, e);
  kp(r), ahe(t);
}
function _pe(t, e) {
  const {
      id: n,
      hash: r,
      startTime: i,
      eventCode: s,
      direction: a,
      counterparty: o,
      value: l,
      asset: u,
      network: f,
    } = t,
    c = bz(s),
    d = `${n || r}-${(typeof e == "object" && e.eventCode) || s}`,
    p = o && o.substring(0, 4) + "..." + o.substring(o.length - 4),
    m = new gh(l || 0).div(new gh("1000000000000000000")).toString(10),
    g =
      o && l
        ? {
            messageId: `notify.watched['${s}']`,
            values: {
              verb:
                s === "txConfirmed"
                  ? a === "incoming"
                    ? "received"
                    : "sent"
                  : a === "incoming"
                  ? "receiving"
                  : "sending",
              formattedValue: m,
              preposition: a === "incoming" ? "from" : "to",
              counterpartyShortened: p,
              asset: u,
            },
          }
        : {
            messageId: `notify.transaction['${s}']`,
            values: { formattedValue: m, asset: u },
          },
    w = aae(ic),
    S = Cn.notify[o ? "watched" : "transaction"][s],
    D = w(g.messageId, { values: g.values, default: S });
  let P = {
    id: n || r,
    type: c,
    key: d,
    network: f,
    startTime: i || Date.now(),
    eventCode: s,
    message: D,
    autoDismiss: Epe((typeof e == "object" && e.type) || c),
  };
  return typeof e == "object" && (P = { ...P, ...e }), P;
}
function bz(t) {
  switch (t) {
    case "txSent":
    case "txPool":
      return "pending";
    case "txSpeedUp":
    case "txCancel":
    case "txRequest":
    case "txRepeat":
    case "txAwaitingApproval":
    case "txConfirmReminder":
    case "txStuck":
      return "hint";
    case "txError":
    case "txSendFail":
    case "txFailed":
    case "txDropped":
    case "nsfFail":
    case "txUnderpriced":
      return "error";
    case "txConfirmed":
      return "success";
    default:
      return "hint";
  }
}
function Epe(t) {
  switch (t) {
    case "success":
    case "hint":
      return 4e3;
    default:
      return 0;
  }
}
let cv, fv;
async function T5() {
  const { apiKey: t } = so;
  if (!t) return null;
  if (!cv) {
    const { default: e } = await qe(() => import("./index-ff479422.js"), []);
    (cv = e.multichain({ apiKey: so.apiKey })), cv.transactions$.subscribe(wpe);
  }
  return cv;
}
async function xpe() {
  const { apiKey: t } = so;
  if (!t) return null;
  if (!fv) {
    const { default: e } = await qe(() => import("./index-ff479422.js"), []);
    return (fv = new e({ dappId: so.apiKey, networkId: 1 })), fv;
  }
  return fv;
}
async function wz(t) {
  const e = Bhe(t);
  if (e) throw e;
  const { label: n } = t;
  if (Jt.get().notify.enabled) {
    const i = await T5();
    if (i) {
      const s = Jt.get().wallets.find((a) => a.label === n);
      s.accounts.forEach(({ address: a }) => {
        i.unsubscribe({ id: a, chainId: s.chains[0].id, timeout: 6e4 });
      });
    }
  }
  cT.next(n), Qhe(n);
  const r = JSON.parse(jw(Ku.LAST_CONNECTED_WALLET));
  return (
    Array.isArray(r) &&
      r.indexOf(n) >= 0 &&
      Hw(Ku.LAST_CONNECTED_WALLET, JSON.stringify(r.filter((i) => i !== n))),
    typeof r == "string" && r === n && PH(Ku.LAST_CONNECTED_WALLET),
    Jt.get().wallets
  );
}
async function Tpe(t) {
  const e = uz(t);
  if (e) throw e;
  const { wallets: n, chains: r } = Jt.get(),
    {
      chainId: i,
      chainNamespace: s = "evm",
      wallet: a,
      rpcUrl: o,
      label: l,
      token: u,
    } = t,
    f = OH(i),
    c = r.find(
      ({ namespace: m, id: g }) =>
        m === s && g.toLowerCase() === f.toLowerCase()
    );
  if (!c)
    throw new Error(
      `Chain with chainId: ${i} and chainNamespace: ${s} has not been set and must be added when Onboard is initialized.`
    );
  const d = a ? n.find(({ label: m }) => m === a) : n[0];
  if (!d)
    throw new Error(
      a
        ? `Wallet with label ${a} is not connected`
        : "A wallet must be connected before a chain can be set"
    );
  const [p] = d.chains;
  if (p.namespace === s && p.id === f) return !0;
  try {
    return await yz(d.provider, f), !0;
  } catch (m) {
    const { code: g } = m,
      w = V0.pipe(
        D0((y) => y === null),
        wy(() => !1)
      );
    if (g === td.CHAIN_NOT_ADDED || g === td.UNRECOGNIZED_CHAIN_ID)
      return (
        (o || l || u) &&
          (o && (c.rpcUrl = o), l && (c.label = l), u && (c.token = u), Yhe(c)),
        Spe(d, c, w, f)
      );
    if (g === td.UNSUPPORTED_METHOD) return V0.next({ chain: c }), Aw(w);
  }
  return !1;
}
const Spe = async (t, e, n, r) => {
  try {
    return await ype(t.provider, e), await yz(t.provider, r), !0;
  } catch (i) {
    const { code: s } = i;
    return s === td.ACCOUNT_ACCESS_REJECTED
      ? !1
      : (V0.next({ chain: e }), Aw(n));
  }
};
function Ape(t) {
  if (t) {
    const { en: e } = t,
      n = mde(Cn, e || {});
    Jv("en", n),
      Object.keys(t)
        .filter((i) => i !== "en")
        .forEach((i) => {
          const s = t[i];
          s && Jv(i, s);
        });
  } else Jv("en", Cn);
  Aoe({ fallbackLocale: "en", initialLocale: Moe() });
}
var Cpe = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z" fill="currentColor"/>
  </svg>
`;
function kpe(t) {
  rs(
    t,
    "svelte-1ubf722",
    ".close-button.svelte-1ubf722.svelte-1ubf722{position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center;height:2rem;width:2rem;border-radius:2rem;cursor:pointer;color:var(--onboard-close-button-color, inherit)}.close-button.svelte-1ubf722.svelte-1ubf722:hover::before{opacity:0.2}.close-button.svelte-1ubf722:hover .svg-box.svelte-1ubf722{opacity:1}.close-button.svelte-1ubf722.svelte-1ubf722::before{content:'';position:absolute;height:inherit;width:inherit;opacity:0.1;background:currentColor;transition:300ms ease-in-out opacity}.svg-box.svelte-1ubf722.svelte-1ubf722{position:absolute;height:1.5rem;width:1.5rem;opacity:0.6;transition:300ms ease-in-out opacity}"
  );
}
function Ipe(t) {
  let e, n;
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        be(n, "class", "svg-box svelte-1ubf722"),
        be(e, "class", "close-button svelte-1ubf722");
    },
    m(r, i) {
      Ge(r, e, i), _e(e, n), (n.innerHTML = Cpe);
    },
    p: We,
    i: We,
    o: We,
    d(r) {
      r && ze(e);
    },
  };
}
class _z extends ss {
  constructor(e) {
    super(), is(this, e, null, Ipe, ns, {}, kpe);
  }
}
function Ez(t) {
  const e = t - 1;
  return e * e * e + 1;
}
function ADe(t) {
  return Math.pow(t - 1, 3) * (1 - t) + 1;
}
function S5(t, { delay: e = 0, duration: n = 400, easing: r = Iy } = {}) {
  const i = +getComputedStyle(t).opacity;
  return { delay: e, duration: n, easing: r, css: (s) => `opacity: ${s * i}` };
}
function CDe(
  t,
  {
    delay: e = 0,
    duration: n = 400,
    easing: r = Ez,
    x: i = 0,
    y: s = 0,
    opacity: a = 0,
  } = {}
) {
  const o = getComputedStyle(t),
    l = +o.opacity,
    u = o.transform === "none" ? "" : o.transform,
    f = l * (1 - a),
    [c, d] = FO(i),
    [p, m] = FO(s);
  return {
    delay: e,
    duration: n,
    easing: r,
    css: (g, w) => `
			transform: ${u} translate(${(1 - g) * c}${d}, ${(1 - g) * p}${m});
			opacity: ${l - f * w}`,
  };
}
function Ope(
  t,
  { delay: e = 0, duration: n = 400, easing: r = Ez, axis: i = "y" } = {}
) {
  const s = getComputedStyle(t),
    a = +s.opacity,
    o = i === "y" ? "height" : "width",
    l = parseFloat(s[o]),
    u = i === "y" ? ["top", "bottom"] : ["left", "right"],
    f = u.map((y) => `${y[0].toUpperCase()}${y.slice(1)}`),
    c = parseFloat(s[`padding${f[0]}`]),
    d = parseFloat(s[`padding${f[1]}`]),
    p = parseFloat(s[`margin${f[0]}`]),
    m = parseFloat(s[`margin${f[1]}`]),
    g = parseFloat(s[`border${f[0]}Width`]),
    w = parseFloat(s[`border${f[1]}Width`]);
  return {
    delay: e,
    duration: n,
    easing: r,
    css: (y) =>
      `overflow: hidden;opacity: ${Math.min(y * 20, 1) * a};${o}: ${
        y * l
      }px;padding-${u[0]}: ${y * c}px;padding-${u[1]}: ${y * d}px;margin-${
        u[0]
      }: ${y * p}px;margin-${u[1]}: ${y * m}px;border-${u[0]}-width: ${
        y * g
      }px;border-${u[1]}-width: ${y * w}px;`,
  };
}
function Ppe(t) {
  rs(
    t,
    "svelte-baitaa",
    `section.svelte-baitaa{top:0;left:0;pointer-events:none;z-index:var(--onboard-modal-z-index, var(--modal-z-index))}.background.svelte-baitaa{background:var(--onboard-modal-backdrop, var(--modal-backdrop));pointer-events:all}.full-screen-background.svelte-baitaa{width:100vw;height:100vh}.max-height.svelte-baitaa{max-height:calc(100vh - 2rem)}.modal-position.svelte-baitaa{top:var(--onboard-modal-top, var(--modal-top));bottom:var(--onboard-modal-bottom, var(--modal-bottom));left:var(--onboard-modal-left, var(--modal-left));right:var(--onboard-modal-right, var(--modal-right))}.modal-overflow.svelte-baitaa{overflow:hidden}.modal-styling.svelte-baitaa{--border-radius:var(
      --onboard-modal-border-radius,
      var(--w3o-border-radius, 1rem)
    );border-radius:var(--border-radius) var(--border-radius) 0 0;box-shadow:var(--onboard-modal-box-shadow, var(--box-shadow-0));max-width:100vw}.modal.svelte-baitaa{overflow-y:auto;background:var(--onboard-modal-background, white);color:var(--onboard-modal-color, initial)}.width-100.svelte-baitaa{width:100%}.modal-container-mobile.svelte-baitaa{bottom:0}@media all and (min-width: 768px){.modal-styling.svelte-baitaa{border-radius:var(--border-radius)}.modal-container-mobile.svelte-baitaa{bottom:unset;margin:1rem}.width-100.svelte-baitaa{width:unset}}`
  );
}
function Npe(t) {
  let e, n, r, i, s, a, o, l, u, f;
  const c = t[3].default,
    d = Q7(c, t, t[2], null);
  return {
    c() {
      (e = Oe("section")),
        (n = Oe("div")),
        (r = Oe("div")),
        (i = Oe("div")),
        (s = Oe("div")),
        (a = Oe("div")),
        d && d.c(),
        be(a, "class", "modal relative svelte-baitaa"),
        be(
          s,
          "class",
          "modal-overflow modal-styling relative flex justify-center svelte-baitaa"
        ),
        be(s, "style", `${t[1] ? "max-width: 100%;" : ""}`),
        be(i, "class", "flex relative max-height svelte-baitaa"),
        bt(i, "width-100", t[1]),
        be(
          r,
          "class",
          "modal-container-mobile modal-position flex svelte-baitaa"
        ),
        bt(r, "absolute", !t[1]),
        bt(r, "width-100", t[1]),
        be(
          n,
          "class",
          "background flex items-center justify-center relative svelte-baitaa"
        ),
        bt(n, "full-screen-background", !t[1]),
        be(e, "class", "svelte-baitaa"),
        bt(e, "fixed", !t[1]);
    },
    m(p, m) {
      Ge(p, e, m),
        _e(e, n),
        _e(n, r),
        _e(r, i),
        _e(i, s),
        _e(s, a),
        d && d.m(a, null),
        (l = !0),
        u ||
          ((f = [
            ao(i, "click", zde(t[4])),
            ao(n, "click", function () {
              _d(t[0]) && t[0].apply(this, arguments);
            }),
          ]),
          (u = !0));
    },
    p(p, [m]) {
      (t = p),
        d &&
          d.p &&
          (!l || m & 4) &&
          eT(d, c, t, t[2], l ? J7(c, t[2], m, null) : tT(t[2]), null);
    },
    i(p) {
      l ||
        (Fe(d, p),
        Ia(() => {
          l && (o || (o = $O(e, S5, {}, !0)), o.run(1));
        }),
        (l = !0));
    },
    o(p) {
      Ze(d, p), o || (o = $O(e, S5, {}, !1)), o.run(0), (l = !1);
    },
    d(p) {
      p && ze(e), d && d.d(p), p && o && o.end(), (u = !1), ac(f);
    },
  };
}
function Dpe(t, e, n) {
  let { $$slots: r = {}, $$scope: i } = e;
  const s = !!so.containerElements.connectModal,
    a = document.documentElement;
  Zde(() => {
    s || ((a.style.position = "sticky"), (a.style.overflow = "hidden"));
  }),
    JH(() => {
      s || ((a.style.position = ""), a.style.removeProperty("overflow"));
    });
  let { close: o } = e;
  function l(u) {
    Yde.call(this, t, u);
  }
  return (
    (t.$$set = (u) => {
      "close" in u && n(0, (o = u.close)),
        "$$scope" in u && n(2, (i = u.$$scope));
    }),
    [o, s, i, r, l]
  );
}
class hT extends ss {
  constructor(e) {
    super(), is(this, e, Dpe, Npe, ns, { close: 0 }, Ppe);
  }
}
function Rpe(t) {
  rs(
    t,
    "svelte-tz7ru1",
    ".container.svelte-tz7ru1{padding:var(--onboard-spacing-4, var(--spacing-4));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:24px}input.svelte-tz7ru1{height:1rem;width:1rem;margin-right:0.5rem}"
  );
}
function Mpe(t) {
  let e,
    n,
    r,
    i,
    s,
    a = t[1]("connect.selectingWallet.agreement.agree") + "",
    o,
    l,
    u = " ",
    f,
    c,
    d,
    p,
    m,
    g = t[3] && Lpe(t),
    w = t[4] && Bpe(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("label")),
        (r = Oe("input")),
        (i = mt()),
        (s = Oe("span")),
        (o = Ln(a)),
        (l = mt()),
        (f = Ln(u)),
        (c = mt()),
        g && g.c(),
        (d = mt()),
        w && w.c(),
        be(r, "class", " svelte-tz7ru1"),
        be(r, "type", "checkbox"),
        be(n, "class", "flex"),
        be(e, "class", "container flex items-center svelte-tz7ru1");
    },
    m(y, v) {
      Ge(y, e, v),
        _e(e, n),
        _e(n, r),
        (r.checked = t[0]),
        _e(n, i),
        _e(n, s),
        _e(s, o),
        _e(s, l),
        _e(s, f),
        _e(s, c),
        g && g.m(s, null),
        _e(s, d),
        w && w.m(s, null),
        p || ((m = ao(r, "change", t[6])), (p = !0));
    },
    p(y, v) {
      v & 1 && (r.checked = y[0]),
        v & 2 &&
          a !== (a = y[1]("connect.selectingWallet.agreement.agree") + "") &&
          ir(o, a),
        y[3] && g.p(y, v),
        y[4] && w.p(y, v);
    },
    d(y) {
      y && ze(e), g && g.d(), w && w.d(), (p = !1), m();
    },
  };
}
function Lpe(t) {
  let e,
    n = t[1]("connect.selectingWallet.agreement.terms") + "",
    r,
    i = t[4] ? " " + t[1]("connect.selectingWallet.agreement.and") + " " : ".",
    s;
  return {
    c() {
      (e = Oe("a")),
        (r = Ln(n)),
        (s = Ln(i)),
        be(e, "href", t[3]),
        be(e, "target", "_blank");
    },
    m(a, o) {
      Ge(a, e, o), _e(e, r), Ge(a, s, o);
    },
    p(a, o) {
      o & 2 &&
        n !== (n = a[1]("connect.selectingWallet.agreement.terms") + "") &&
        ir(r, n),
        o & 2 &&
          i !==
            (i = a[4]
              ? " " + a[1]("connect.selectingWallet.agreement.and") + " "
              : ".") &&
          ir(s, i);
    },
    d(a) {
      a && ze(e), a && ze(s);
    },
  };
}
function Bpe(t) {
  let e,
    n = t[1]("connect.selectingWallet.agreement.privacy") + "",
    r,
    i;
  return {
    c() {
      (e = Oe("a")),
        (r = Ln(n)),
        (i = Ln(".")),
        be(e, "href", t[4]),
        be(e, "target", "_blank");
    },
    m(s, a) {
      Ge(s, e, a), _e(e, r), Ge(s, i, a);
    },
    p(s, a) {
      a & 2 &&
        n !== (n = s[1]("connect.selectingWallet.agreement.privacy") + "") &&
        ir(r, n);
    },
    d(s) {
      s && ze(e), s && ze(i);
    },
  };
}
function Fpe(t) {
  let e,
    n = t[5] && Mpe(t);
  return {
    c() {
      n && n.c(), (e = xr());
    },
    m(r, i) {
      n && n.m(r, i), Ge(r, e, i);
    },
    p(r, [i]) {
      r[5] && n.p(r, i);
    },
    i: We,
    o: We,
    d(r) {
      n && n.d(r), r && ze(e);
    },
  };
}
function $pe(t, e, n) {
  let r, i;
  Xr(t, ic, (w) => n(1, (i = w)));
  let { agreed: s } = e;
  const {
      terms: a,
      privacy: o,
      version: l,
    } = JSON.parse(jw(Ku.TERMS_AGREEMENT) || "{}"),
    u = { termsUrl: "", privacyUrl: "", version: "" },
    f = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  Xr(t, f, (w) => n(7, (r = w)));
  const { termsUrl: c, privacyUrl: d, version: p } = (r && r.agreement) || u,
    m = !!((c && !a) || (d && !o) || (p && p !== l));
  s = !m;
  function g() {
    (s = this.checked), n(0, s);
  }
  return (
    (t.$$set = (w) => {
      "agreed" in w && n(0, (s = w.agreed));
    }),
    (t.$$.update = () => {
      t.$$.dirty & 1 &&
        (s
          ? Hw(
              Ku.TERMS_AGREEMENT,
              JSON.stringify({ version: p, terms: !!c, privacy: !!d })
            )
          : s === !1 && PH(Ku.TERMS_AGREEMENT));
    }),
    [s, i, f, c, d, m, g]
  );
}
class Upe extends ss {
  constructor(e) {
    super(), is(this, e, $pe, Fpe, ns, { agreed: 0 }, Rpe);
  }
}
function jpe(t) {
  rs(
    t,
    "svelte-2btye1",
    ".icon.svelte-2btye1{color:var(--onboard-white, var(--white));border-radius:50px;bottom:-0.25rem;right:-0.25rem}.yellow.svelte-2btye1{background:var(--onboard-warning-500, var(--warning-500))}"
  );
}
function Hpe(t) {
  let e, n, r;
  return {
    c() {
      (e = Oe("div")),
        be(
          e,
          "class",
          (n = BO(`${t[2]} icon flex absolute`) + " svelte-2btye1")
        ),
        be(
          e,
          "style",
          (r = `width: ${t[0]}px; height: ${t[0]}px; padding: ${t[0] / 6}px;`)
        ),
        bt(e, "yellow", t[1] === "yellow");
    },
    m(i, s) {
      Ge(i, e, s), (e.innerHTML = kde);
    },
    p(i, [s]) {
      s & 4 &&
        n !== (n = BO(`${i[2]} icon flex absolute`) + " svelte-2btye1") &&
        be(e, "class", n),
        s & 1 &&
          r !==
            (r = `width: ${i[0]}px; height: ${i[0]}px; padding: ${
              i[0] / 6
            }px;`) &&
          be(e, "style", r),
        s & 6 && bt(e, "yellow", i[1] === "yellow");
    },
    i: We,
    o: We,
    d(i) {
      i && ze(e);
    },
  };
}
function zpe(t, e, n) {
  let { size: r } = e,
    { color: i = "yellow" } = e,
    { class: s = "test" } = e;
  return (
    (t.$$set = (a) => {
      "size" in a && n(0, (r = a.size)),
        "color" in a && n(1, (i = a.color)),
        "class" in a && n(2, (s = a.class));
    }),
    [r, i, s]
  );
}
class Vpe extends ss {
  constructor(e) {
    super(), is(this, e, zpe, Hpe, ns, { size: 0, color: 1, class: 2 }, jpe);
  }
}
function Gpe(t) {
  rs(
    t,
    "svelte-1bikw7k",
    ".icon.svelte-1bikw7k{color:var(--onboard-white, var(--white));border-radius:50px}.green.svelte-1bikw7k{background:var(--onboard-success-600, var(--success-600))}.blue.svelte-1bikw7k{background:var(--onboard-primary-1, var(--primary-1))}"
  );
}
function Wpe(t) {
  let e, n;
  return {
    c() {
      (e = Oe("div")),
        be(e, "class", "icon flex svelte-1bikw7k"),
        be(
          e,
          "style",
          (n = `width: ${t[0]}px; height: ${t[0]}px; padding: ${t[0] / 5}px;`)
        ),
        bt(e, "green", t[1] === "green"),
        bt(e, "blue", t[1] === "blue");
    },
    m(r, i) {
      Ge(r, e, i), (e.innerHTML = IH);
    },
    p(r, [i]) {
      i & 1 &&
        n !==
          (n = `width: ${r[0]}px; height: ${r[0]}px; padding: ${
            r[0] / 5
          }px;`) &&
        be(e, "style", n),
        i & 2 && bt(e, "green", r[1] === "green"),
        i & 2 && bt(e, "blue", r[1] === "blue");
    },
    i: We,
    o: We,
    d(r) {
      r && ze(e);
    },
  };
}
function qpe(t, e, n) {
  let { size: r } = e,
    { color: i = "green" } = e;
  return (
    (t.$$set = (s) => {
      "size" in s && n(0, (r = s.size)), "color" in s && n(1, (i = s.color));
    }),
    [r, i]
  );
}
class xz extends ss {
  constructor(e) {
    super(), is(this, e, qpe, Wpe, ns, { size: 0, color: 1 }, Gpe);
  }
}
function Kpe(t) {
  rs(
    t,
    "svelte-1le5672",
    ".loading-container.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:inherit;color:inherit}span.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-1le5672.svelte-1le5672{display:inline-block}.loading.svelte-1le5672 div.svelte-1le5672{font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-1le5672-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-1le5672 .loading-first.svelte-1le5672{animation-delay:-0.45s}.loading.svelte-1le5672 .loading-second.svelte-1le5672{animation-delay:-0.3s}.loading.svelte-1le5672 .loading-third.svelte-1le5672{animation-delay:-0.15s}@keyframes svelte-1le5672-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}"
  );
}
function GO(t) {
  let e, n;
  return {
    c() {
      (e = Oe("span")), (n = Ln(t[0])), be(e, "class", "svelte-1le5672");
    },
    m(r, i) {
      Ge(r, e, i), _e(e, n);
    },
    p(r, i) {
      i & 1 && ir(n, r[0]);
    },
    d(r) {
      r && ze(e);
    },
  };
}
function Xpe(t) {
  let e,
    n,
    r,
    i,
    s,
    a,
    o,
    l,
    u,
    f,
    c,
    d,
    p = t[0] && GO(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        (r = Oe("div")),
        (s = mt()),
        (a = Oe("div")),
        (l = mt()),
        (u = Oe("div")),
        (d = mt()),
        p && p.c(),
        be(r, "class", "loading-first svelte-1le5672"),
        be(r, "style", (i = `height: ${t[1]}; width: ${t[1]};`)),
        be(a, "class", "loading-second svelte-1le5672"),
        be(a, "style", (o = `height: ${t[1]}; width: ${t[1]};`)),
        be(u, "class", "loading-third svelte-1le5672"),
        be(u, "style", (f = `height: ${t[1]}; width: ${t[1]};`)),
        be(n, "class", "loading relative svelte-1le5672"),
        be(n, "style", (c = `height: ${t[1]}; width: ${t[1]};`)),
        be(
          e,
          "class",
          "loading-container flex flex-column justify-center items-center absolute svelte-1le5672"
        );
    },
    m(m, g) {
      Ge(m, e, g),
        _e(e, n),
        _e(n, r),
        _e(n, s),
        _e(n, a),
        _e(n, l),
        _e(n, u),
        _e(e, d),
        p && p.m(e, null);
    },
    p(m, [g]) {
      g & 2 &&
        i !== (i = `height: ${m[1]}; width: ${m[1]};`) &&
        be(r, "style", i),
        g & 2 &&
          o !== (o = `height: ${m[1]}; width: ${m[1]};`) &&
          be(a, "style", o),
        g & 2 &&
          f !== (f = `height: ${m[1]}; width: ${m[1]};`) &&
          be(u, "style", f),
        g & 2 &&
          c !== (c = `height: ${m[1]}; width: ${m[1]};`) &&
          be(n, "style", c),
        m[0]
          ? p
            ? p.p(m, g)
            : ((p = GO(m)), p.c(), p.m(e, null))
          : p && (p.d(1), (p = null));
    },
    i: We,
    o: We,
    d(m) {
      m && ze(e), p && p.d();
    },
  };
}
function Zpe(t, e, n) {
  let { description: r = "" } = e,
    { size: i = "2rem" } = e;
  return (
    (t.$$set = (s) => {
      "description" in s && n(0, (r = s.description)),
        "size" in s && n(1, (i = s.size));
    }),
    [r, i]
  );
}
class Ype extends ss {
  constructor(e) {
    super(), is(this, e, Zpe, Xpe, ns, { description: 0, size: 1 }, Kpe);
  }
}
function Qpe(t) {
  rs(
    t,
    "svelte-i129jl",
    `.icon.svelte-i129jl{height:100%}.border-custom.svelte-i129jl{border:1px solid var(--border-color)}.border-yellow.svelte-i129jl{border:1px solid var(--onboard-warning-500, var(--warning-500))}.border-gray.svelte-i129jl{border:1px solid var(--onboard-gray-400, var(--gray-400))}.border-green.svelte-i129jl{border:1px solid var(--onboard-success-500, var(--success-500))}.border-dark-green.svelte-i129jl{border:1px solid var(--onboard-success-700, var(--success-700))}.border-blue.svelte-i129jl{border:1px solid
      var(
        --onboard-wallet-app-icon-border-color,
        var(--onboard-primary-300, var(--primary-300))
      )}.border-dark-blue.svelte-i129jl{border:1px solid
      var(
        --onboard-wallet-app-icon-border-color,
        var(--onboard-primary-600, var(--primary-600))
      )}.border-transparent.svelte-i129jl{border:1px solid transparent}.border-black.svelte-i129jl{border:1px solid var(--onboard-gray-600, var(--gray-600))}.background-gray.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-gray,
      var(--onboard-gray-500, var(--gray-500))
    )}.background-light-gray.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-light-gray,
      var(--onboard-gray-100, var(--gray-100))
    )}.background-light-blue.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-light-blue,
      var(--onboard-primary-100, var(--primary-100))
    )}.background-green.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-green,
      var(--onboard-success-100, var(--success-100))
    )}.background-white.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-white,
      var(--onboard-white, var(--white))
    )}.background-transparent.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-transparent,
      transparent
    )}@keyframes svelte-i129jl-pulse{from{opacity:0}to{opacity:1}}.placeholder-icon.svelte-i129jl{width:100%;height:100%;background:var(--onboard-gray-100, var(--gray-100));border-radius:32px;animation:svelte-i129jl-pulse infinite 750ms alternate ease-in-out}.spinner-container.svelte-i129jl{color:var(--onboard-primary-300, var(--primary-300))}img.svelte-i129jl{max-width:100%;height:auto}.pending-status-icon{z-index:1;fill:white;box-shadow:0px 2px 12px 0px rgba(0, 0, 0, 0.1)}.status-icon-container.svelte-i129jl{right:-0.25rem;bottom:-0.25rem;position:absolute}`
  );
}
const Jpe = (t) => ({}),
  WO = (t) => ({});
function e0e(t) {
  let e,
    n,
    r,
    i = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: a0e,
      then: r0e,
      catch: n0e,
      value: 13,
      blocks: [, , ,],
    };
  return (
    wh((n = t[1]), i),
    {
      c() {
        (e = xr()), i.block.c();
      },
      m(s, a) {
        Ge(s, e, a),
          i.block.m(s, (i.anchor = a)),
          (i.mount = () => e.parentNode),
          (i.anchor = e),
          (r = !0);
      },
      p(s, a) {
        (t = s),
          (i.ctx = t),
          (a & 2 && n !== (n = t[1]) && wh(n, i)) || _1(i, t, a);
      },
      i(s) {
        r || (Fe(i.block), (r = !0));
      },
      o(s) {
        for (let a = 0; a < 3; a += 1) {
          const o = i.blocks[a];
          Ze(o);
        }
        r = !1;
      },
      d(s) {
        s && ze(e), i.block.d(s), (i.token = null), (i = null);
      },
    }
  );
}
function t0e(t) {
  let e, n, r;
  return (
    (n = new Ype({ props: { size: "2rem" } })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "spinner-container svelte-i129jl");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      p: We,
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function n0e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function r0e(t) {
  let e, n, r, i, s, a;
  function o(c, d) {
    return d & 2 && (n = null), n == null && (n = !!Z7(c[13])), n ? s0e : i0e;
  }
  let l = o(t, -1),
    u = l(t),
    f = t[2] && t[9] <= $i && qO();
  return {
    c() {
      (e = Oe("div")),
        u.c(),
        (i = mt()),
        f && f.c(),
        (s = xr()),
        be(e, "class", "icon flex justify-center items-center svelte-i129jl");
    },
    m(c, d) {
      Ge(c, e, d),
        u.m(e, null),
        Ge(c, i, d),
        f && f.m(c, d),
        Ge(c, s, d),
        (a = !0);
    },
    p(c, d) {
      l === (l = o(c, d)) && u
        ? u.p(c, d)
        : (u.d(1), (u = l(c)), u && (u.c(), u.m(e, null))),
        c[2] && c[9] <= $i
          ? f
            ? d & 516 && Fe(f, 1)
            : ((f = qO()), f.c(), Fe(f, 1), f.m(s.parentNode, s))
          : f &&
            (jr(),
            Ze(f, 1, 1, () => {
              f = null;
            }),
            Hr());
    },
    i(c) {
      a ||
        (c &&
          (r ||
            Ia(() => {
              (r = lT(e, S5, {})), r.start();
            })),
        Fe(f),
        (a = !0));
    },
    o(c) {
      Ze(f), (a = !1);
    },
    d(c) {
      c && ze(e), u.d(), c && ze(i), f && f.d(c), c && ze(s);
    },
  };
}
function i0e(t) {
  let e, n;
  return {
    c() {
      (e = Oe("img")),
        z0(e.src, (n = t[13])) || be(e, "src", n),
        be(e, "alt", "logo"),
        be(e, "class", "svelte-i129jl");
    },
    m(r, i) {
      Ge(r, e, i);
    },
    p(r, i) {
      i & 2 && !z0(e.src, (n = r[13])) && be(e, "src", n);
    },
    d(r) {
      r && ze(e);
    },
  };
}
function s0e(t) {
  let e,
    n = t[13] + "",
    r;
  return {
    c() {
      (e = new w1(!1)), (r = xr()), (e.a = r);
    },
    m(i, s) {
      e.m(n, i, s), Ge(i, r, s);
    },
    p(i, s) {
      s & 2 && n !== (n = i[13] + "") && e.p(n);
    },
    d(i) {
      i && ze(r), i && e.d();
    },
  };
}
function qO(t) {
  let e, n, r;
  return (
    (n = new Vpe({ props: { class: "pending-status-icon", size: 20 } })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "status-icon-container svelte-i129jl");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function a0e(t) {
  let e;
  return {
    c() {
      (e = Oe("div")), be(e, "class", "placeholder-icon svelte-i129jl");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    p: We,
    i: We,
    o: We,
    d(n) {
      n && ze(e);
    },
  };
}
function o0e(t) {
  let e, n, r, i, s, a, o, l;
  Ia(t[12]);
  const u = [t0e, e0e],
    f = [];
  function c(m, g) {
    return m[2] && m[9] >= $i ? 0 : 1;
  }
  (n = c(t)), (r = f[n] = u[n](t));
  const d = t[11].status,
    p = Q7(d, t, t[10], WO);
  return {
    c() {
      (e = Oe("div")),
        r.c(),
        (i = mt()),
        p && p.c(),
        be(e, "class", "relative svelte-i129jl"),
        be(
          e,
          "style",
          (s = `${
            t[6] === "custom" ? `background-color: ${t[7]}` : ""
          }; padding: ${t[3] - 1}px; width: ${t[0]}px; height: ${
            t[0]
          }px; border-radius: ${t[8]}px; color: ${t[4]};`)
        ),
        bt(e, "border-custom", t[5] === "custom"),
        bt(e, "border-yellow", t[5] === "yellow"),
        bt(e, "border-gray", t[5] === "gray"),
        bt(e, "border-green", t[5] === "green"),
        bt(e, "border-dark-green", t[5] === "darkGreen"),
        bt(e, "border-blue", t[5] === "blue"),
        bt(e, "border-dark-blue", t[5] === "darkBlue"),
        bt(e, "border-transparent", t[5] === "transparent"),
        bt(e, "border-black", t[5] === "black"),
        bt(e, "background-gray", t[6] === "gray"),
        bt(e, "background-light-gray", t[6] === "lightGray"),
        bt(e, "background-light-blue", t[6] === "lightBlue"),
        bt(e, "background-green", t[6] === "green"),
        bt(e, "background-white", t[6] === "white"),
        bt(e, "background-transparent", t[6] === "transparent");
    },
    m(m, g) {
      Ge(m, e, g),
        f[n].m(e, null),
        _e(e, i),
        p && p.m(e, null),
        (a = !0),
        o || ((l = ao(window, "resize", t[12])), (o = !0));
    },
    p(m, [g]) {
      let w = n;
      (n = c(m)),
        n === w
          ? f[n].p(m, g)
          : (jr(),
            Ze(f[w], 1, 1, () => {
              f[w] = null;
            }),
            Hr(),
            (r = f[n]),
            r ? r.p(m, g) : ((r = f[n] = u[n](m)), r.c()),
            Fe(r, 1),
            r.m(e, i)),
        p &&
          p.p &&
          (!a || g & 1024) &&
          eT(p, d, m, m[10], a ? J7(d, m[10], g, Jpe) : tT(m[10]), WO),
        (!a ||
          (g & 473 &&
            s !==
              (s = `${
                m[6] === "custom" ? `background-color: ${m[7]}` : ""
              }; padding: ${m[3] - 1}px; width: ${m[0]}px; height: ${
                m[0]
              }px; border-radius: ${m[8]}px; color: ${m[4]};`))) &&
          be(e, "style", s),
        (!a || g & 32) && bt(e, "border-custom", m[5] === "custom"),
        (!a || g & 32) && bt(e, "border-yellow", m[5] === "yellow"),
        (!a || g & 32) && bt(e, "border-gray", m[5] === "gray"),
        (!a || g & 32) && bt(e, "border-green", m[5] === "green"),
        (!a || g & 32) && bt(e, "border-dark-green", m[5] === "darkGreen"),
        (!a || g & 32) && bt(e, "border-blue", m[5] === "blue"),
        (!a || g & 32) && bt(e, "border-dark-blue", m[5] === "darkBlue"),
        (!a || g & 32) && bt(e, "border-transparent", m[5] === "transparent"),
        (!a || g & 32) && bt(e, "border-black", m[5] === "black"),
        (!a || g & 64) && bt(e, "background-gray", m[6] === "gray"),
        (!a || g & 64) && bt(e, "background-light-gray", m[6] === "lightGray"),
        (!a || g & 64) && bt(e, "background-light-blue", m[6] === "lightBlue"),
        (!a || g & 64) && bt(e, "background-green", m[6] === "green"),
        (!a || g & 64) && bt(e, "background-white", m[6] === "white"),
        (!a || g & 64) &&
          bt(e, "background-transparent", m[6] === "transparent");
    },
    i(m) {
      a || (Fe(r), Fe(p, m), (a = !0));
    },
    o(m) {
      Ze(r), Ze(p, m), (a = !1);
    },
    d(m) {
      m && ze(e), f[n].d(), p && p.d(m), (o = !1), l();
    },
  };
}
function l0e(t, e, n) {
  let { $$slots: r = {}, $$scope: i } = e,
    { size: s } = e,
    { icon: a } = e,
    { loading: o = !1 } = e,
    { padding: l = s / 6 } = e,
    { color: u = "black" } = e,
    { border: f = "transparent" } = e,
    { background: c = "transparent" } = e,
    { customBackgroundColor: d = "" } = e,
    { radius: p = 12 } = e,
    m;
  function g() {
    n(9, (m = window.innerWidth));
  }
  return (
    (t.$$set = (w) => {
      "size" in w && n(0, (s = w.size)),
        "icon" in w && n(1, (a = w.icon)),
        "loading" in w && n(2, (o = w.loading)),
        "padding" in w && n(3, (l = w.padding)),
        "color" in w && n(4, (u = w.color)),
        "border" in w && n(5, (f = w.border)),
        "background" in w && n(6, (c = w.background)),
        "customBackgroundColor" in w && n(7, (d = w.customBackgroundColor)),
        "radius" in w && n(8, (p = w.radius)),
        "$$scope" in w && n(10, (i = w.$$scope));
    }),
    [s, a, o, l, u, f, c, d, p, m, i, r, g]
  );
}
class Xg extends ss {
  constructor(e) {
    super(),
      is(
        this,
        e,
        l0e,
        o0e,
        ns,
        {
          size: 0,
          icon: 1,
          loading: 2,
          padding: 3,
          color: 4,
          border: 5,
          background: 6,
          customBackgroundColor: 7,
          radius: 8,
        },
        Qpe
      );
  }
}
function u0e(t) {
  rs(
    t,
    "svelte-q2gson",
    ".container.svelte-q2gson{gap:1rem;padding:0.75rem;color:var(--onboard-warning-700, var(--warning-700));font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;border:1px solid var(--onboard-warning-400, var(--warning-400));background:var(--onboard-warning-100, var(--warning-100));border-radius:12px}.icon.svelte-q2gson{color:var(--onboard-warning-700, var(--warning-700));width:1rem;height:1rem;flex:0 0 auto}"
  );
}
function c0e(t) {
  let e, n, r, i, s, a;
  const o = t[1].default,
    l = Q7(o, t, t[0], null);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        l && l.c(),
        (r = mt()),
        (i = Oe("div")),
        be(i, "class", "icon svelte-q2gson"),
        be(e, "class", "container flex justify-between svelte-q2gson");
    },
    m(u, f) {
      Ge(u, e, f),
        _e(e, n),
        l && l.m(n, null),
        _e(e, r),
        _e(e, i),
        (i.innerHTML = Uw),
        (a = !0);
    },
    p(u, [f]) {
      l &&
        l.p &&
        (!a || f & 1) &&
        eT(l, o, u, u[0], a ? J7(o, u[0], f, null) : tT(u[0]), null);
    },
    i(u) {
      a ||
        (Fe(l, u),
        u &&
          (s ||
            Ia(() => {
              (s = lT(e, Ope, { delay: 50, duration: 500 })), s.start();
            })),
        (a = !0));
    },
    o(u) {
      Ze(l, u), (a = !1);
    },
    d(u) {
      u && ze(e), l && l.d(u);
    },
  };
}
function f0e(t, e, n) {
  let { $$slots: r = {}, $$scope: i } = e;
  return (
    (t.$$set = (s) => {
      "$$scope" in s && n(0, (i = s.$$scope));
    }),
    [i, r]
  );
}
class pT extends ss {
  constructor(e) {
    super(), is(this, e, f0e, c0e, ns, {}, u0e);
  }
}
function d0e(t) {
  rs(
    t,
    "svelte-1kfgpsl",
    `.container.svelte-1kfgpsl{padding:var(--onboard-spacing-4, var(--spacing-4));color:var(
      --onboard-connect-accent-text-color,
      var(--onboard-gray-700, var(--gray-700))
    )}.connecting-container.svelte-1kfgpsl{padding:var(--onboard-spacing-4, var(--spacing-4));border-radius:var(--onboard-border-radius-1, var(--border-radius-1));background:var(--onboard-success-100, var(--success-100));border:1px solid var(--onboard-success-600, var(--success-600));width:100%}.text.svelte-1kfgpsl{right:var(--onboard-spacing-5, var(--spacing-5))}.tick.svelte-1kfgpsl{color:var(--onboard-success-700, var(--success-700))}`
  );
}
function h0e(t) {
  let e,
    n,
    r,
    i,
    s,
    a,
    o,
    l,
    u,
    f,
    c,
    d,
    p,
    m =
      t[2]("connect.connectedWallet.mainText", {
        default: Cn.connect.connectedWallet.mainText,
        values: { wallet: t[0].label },
      }) + "",
    g,
    w,
    y,
    v;
  return (
    (s = new Xg({
      props: {
        size: 40,
        padding: 8,
        background: t[1] && t[1].icon ? "lightBlue" : "lightGray",
        border: "darkGreen",
        icon: (t[1] && t[1].icon) || Gg,
      },
    })),
    (l = new xz({ props: { size: 17 } })),
    (c = new Xg({
      props: {
        size: 40,
        padding: 8,
        border: "darkGreen",
        background: "white",
        icon: t[0].icon,
      },
    })),
    {
      c() {
        (e = Oe("div")),
          (n = Oe("div")),
          (r = Oe("div")),
          (i = Oe("div")),
          Bn(s.$$.fragment),
          (a = mt()),
          (o = Oe("div")),
          Bn(l.$$.fragment),
          (u = mt()),
          (f = Oe("div")),
          Bn(c.$$.fragment),
          (d = mt()),
          (p = Oe("div")),
          (g = Ln(m)),
          (w = mt()),
          (y = Oe("div")),
          be(o, "class", "relative"),
          Mu(o, "right", "1rem"),
          Mu(o, "top", "4px"),
          Mu(o, "z-index", "1"),
          be(f, "class", "relative"),
          Mu(f, "right", "1.75rem"),
          be(i, "class", "flex justify-center items-end relative"),
          be(p, "class", "text relative svelte-1kfgpsl"),
          be(r, "class", "flex items-center"),
          be(y, "class", "tick flex items-center svelte-1kfgpsl"),
          Mu(y, "width", "24px"),
          be(
            n,
            "class",
            "connecting-container flex justify-between items-center svelte-1kfgpsl"
          ),
          be(e, "class", "container svelte-1kfgpsl");
      },
      m(E, S) {
        Ge(E, e, S),
          _e(e, n),
          _e(n, r),
          _e(r, i),
          Dn(s, i, null),
          _e(i, a),
          _e(i, o),
          Dn(l, o, null),
          _e(i, u),
          _e(i, f),
          Dn(c, f, null),
          _e(r, d),
          _e(r, p),
          _e(p, g),
          _e(n, w),
          _e(n, y),
          (y.innerHTML = IH),
          (v = !0);
      },
      p(E, [S]) {
        const D = {};
        S & 2 && (D.background = E[1] && E[1].icon ? "lightBlue" : "lightGray"),
          S & 2 && (D.icon = (E[1] && E[1].icon) || Gg),
          s.$set(D);
        const P = {};
        S & 1 && (P.icon = E[0].icon),
          c.$set(P),
          (!v || S & 5) &&
            m !==
              (m =
                E[2]("connect.connectedWallet.mainText", {
                  default: Cn.connect.connectedWallet.mainText,
                  values: { wallet: E[0].label },
                }) + "") &&
            ir(g, m);
      },
      i(E) {
        v ||
          (Fe(s.$$.fragment, E),
          Fe(l.$$.fragment, E),
          Fe(c.$$.fragment, E),
          (v = !0));
      },
      o(E) {
        Ze(s.$$.fragment, E),
          Ze(l.$$.fragment, E),
          Ze(c.$$.fragment, E),
          (v = !1);
      },
      d(E) {
        E && ze(e), Rn(s), Rn(l), Rn(c);
      },
    }
  );
}
function p0e(t, e, n) {
  let r, i;
  Xr(t, ic, (o) => n(2, (i = o)));
  let { selectedWallet: s } = e;
  const a = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  return (
    Xr(t, a, (o) => n(1, (r = o))),
    (t.$$set = (o) => {
      "selectedWallet" in o && n(0, (s = o.selectedWallet));
    }),
    [s, r, i, a]
  );
}
class m0e extends ss {
  constructor(e) {
    super(), is(this, e, p0e, h0e, ns, { selectedWallet: 0 }, d0e);
  }
}
function g0e(t) {
  rs(
    t,
    "svelte-j1ywa3",
    `.container.svelte-j1ywa3{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-j1ywa3{width:100%;padding:var(--onboard-spacing-4, var(--spacing-4));transition:background-color 100ms ease-in-out,
      border-color 100ms ease-in-out;border-radius:24px;background:var(--onboard-primary-100, var(--primary-100));border:1px solid;border-color:var(--onboard-primary-300, var(--primary-300));color:var(--onboard-gray-600, var(--gray-600))}.connecting-container.warning.svelte-j1ywa3{background:var(--onboard-warning-100, var(--warning-100));border-color:var(--onboard-warning-400, var(--warning-400))}.text.svelte-j1ywa3{line-height:16px;margin-bottom:var(--onboard-spacing-5, var(--spacing-5))}.text.text-rejected.svelte-j1ywa3{line-height:24px;margin-bottom:0}.subtext.svelte-j1ywa3{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px}.rejected-cta.svelte-j1ywa3{color:var(--onboard-primary-500, var(--primary-500))}.onboard-button-primary.svelte-j1ywa3{bottom:var(--onboard-spacing-3, var(--spacing-3))}.ml.svelte-j1ywa3{margin-left:var(--onboard-spacing-4, var(--spacing-4))}@media all and (max-width: 520px){.connecting-container.svelte-j1ywa3{border-radius:var(--onboard-border-radius-4, var(--border-radius-4))}.container.svelte-j1ywa3{padding-bottom:0}.wallet-badges.svelte-j1ywa3{display:none}.connecting-wallet-info.svelte-j1ywa3{margin:0}.onboard-button-primary.svelte-j1ywa3{display:none}}`
  );
}
function y0e(t) {
  let e,
    n =
      t[7](
        `connect.connectingWallet.${t[5] ? "previousConnection" : "paragraph"}`,
        {
          default: Cn.connect.connectingWallet.paragraph,
          values: { wallet: t[1].label },
        }
      ) + "",
    r;
  return {
    c() {
      (e = Oe("div")), (r = Ln(n)), be(e, "class", "subtext svelte-j1ywa3");
    },
    m(i, s) {
      Ge(i, e, s), _e(e, r);
    },
    p(i, s) {
      s & 162 &&
        n !==
          (n =
            i[7](
              `connect.connectingWallet.${
                i[5] ? "previousConnection" : "paragraph"
              }`,
              {
                default: Cn.connect.connectingWallet.paragraph,
                values: { wallet: i[1].label },
              }
            ) + "") &&
        ir(r, n);
    },
    d(i) {
      i && ze(e);
    },
  };
}
function v0e(t) {
  let e,
    n =
      t[7]("connect.connectingWallet.rejectedCTA", {
        default: Cn.connect.connectingWallet.rejectedCTA,
        values: { wallet: t[1].label },
      }) + "",
    r,
    i,
    s;
  return {
    c() {
      (e = Oe("div")),
        (r = Ln(n)),
        be(e, "class", "rejected-cta pointer subtext svelte-j1ywa3");
    },
    m(a, o) {
      Ge(a, e, o),
        _e(e, r),
        i ||
          ((s = ao(e, "click", function () {
            _d(t[0]) && t[0].apply(this, arguments);
          })),
          (i = !0));
    },
    p(a, o) {
      (t = a),
        o & 130 &&
          n !==
            (n =
              t[7]("connect.connectingWallet.rejectedCTA", {
                default: Cn.connect.connectingWallet.rejectedCTA,
                values: { wallet: t[1].label },
              }) + "") &&
          ir(r, n);
    },
    d(a) {
      a && ze(e), (i = !1), s();
    },
  };
}
function b0e(t) {
  let e,
    n,
    r,
    i,
    s,
    a,
    o,
    l,
    u,
    f,
    c,
    d =
      t[7](`connect.connectingWallet.${t[4] ? "rejectedText" : "mainText"}`, {
        default: t[4]
          ? Cn.connect.connectingWallet.rejectedText
          : Cn.connect.connectingWallet.mainText,
        values: { wallet: t[1].label },
      }) + "",
    p,
    m,
    g,
    w,
    y =
      t[7]("connect.connectingWallet.primaryButton", {
        default: Cn.connect.connectingWallet.primaryButton,
      }) + "",
    v,
    E,
    S,
    D;
  (s = new Xg({
    props: {
      size: 40,
      padding: 8,
      icon: (t[6] && t[6].icon) || Gg,
      border: t[4] || t[5] ? "yellow" : "blue",
      background: "lightGray",
    },
  })),
    (l = new Xg({
      props: {
        size: 40,
        padding: 8,
        border: t[4] || t[5] ? "yellow" : "blue",
        background: "white",
        icon: t[1].icon,
      },
    }));
  function P(A, N) {
    return A[4] ? v0e : y0e;
  }
  let x = P(t),
    _ = x(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        (r = Oe("div")),
        (i = Oe("div")),
        Bn(s.$$.fragment),
        (a = mt()),
        (o = Oe("div")),
        Bn(l.$$.fragment),
        (u = mt()),
        (f = Oe("div")),
        (c = Oe("div")),
        (p = Ln(d)),
        (m = mt()),
        _.c(),
        (g = mt()),
        (w = Oe("button")),
        (v = Ln(y)),
        be(o, "class", "relative"),
        Mu(o, "right", "0.5rem"),
        be(
          i,
          "class",
          "flex justify-center relative wallet-badges svelte-j1ywa3"
        ),
        be(c, "class", "text svelte-j1ywa3"),
        bt(c, "text-rejected", t[4]),
        be(
          f,
          "class",
          "flex flex-column justify-center ml connecting-wallet-info svelte-j1ywa3"
        ),
        be(r, "class", "flex"),
        be(
          n,
          "class",
          "connecting-container flex justify-between items-center svelte-j1ywa3"
        ),
        bt(n, "warning", t[4] || t[5]),
        be(w, "class", "onboard-button-primary absolute svelte-j1ywa3"),
        be(e, "class", "container flex flex-column items-center svelte-j1ywa3");
    },
    m(A, N) {
      Ge(A, e, N),
        _e(e, n),
        _e(n, r),
        _e(r, i),
        Dn(s, i, null),
        _e(i, a),
        _e(i, o),
        Dn(l, o, null),
        _e(r, u),
        _e(r, f),
        _e(f, c),
        _e(c, p),
        _e(f, m),
        _.m(f, null),
        _e(e, g),
        _e(e, w),
        _e(w, v),
        (E = !0),
        S || ((D = ao(w, "click", t[9])), (S = !0));
    },
    p(A, [N]) {
      const M = {};
      N & 64 && (M.icon = (A[6] && A[6].icon) || Gg),
        N & 48 && (M.border = A[4] || A[5] ? "yellow" : "blue"),
        s.$set(M);
      const T = {};
      N & 48 && (T.border = A[4] || A[5] ? "yellow" : "blue"),
        N & 2 && (T.icon = A[1].icon),
        l.$set(T),
        (!E || N & 146) &&
          d !==
            (d =
              A[7](
                `connect.connectingWallet.${
                  A[4] ? "rejectedText" : "mainText"
                }`,
                {
                  default: A[4]
                    ? Cn.connect.connectingWallet.rejectedText
                    : Cn.connect.connectingWallet.mainText,
                  values: { wallet: A[1].label },
                }
              ) + "") &&
          ir(p, d),
        (!E || N & 16) && bt(c, "text-rejected", A[4]),
        x === (x = P(A)) && _
          ? _.p(A, N)
          : (_.d(1), (_ = x(A)), _ && (_.c(), _.m(f, null))),
        (!E || N & 48) && bt(n, "warning", A[4] || A[5]),
        (!E || N & 128) &&
          y !==
            (y =
              A[7]("connect.connectingWallet.primaryButton", {
                default: Cn.connect.connectingWallet.primaryButton,
              }) + "") &&
          ir(v, y);
    },
    i(A) {
      E || (Fe(s.$$.fragment, A), Fe(l.$$.fragment, A), (E = !0));
    },
    o(A) {
      Ze(s.$$.fragment, A), Ze(l.$$.fragment, A), (E = !1);
    },
    d(A) {
      A && ze(e), Rn(s), Rn(l), _.d(), (S = !1), D();
    },
  };
}
function w0e(t, e, n) {
  let r, i;
  Xr(t, ic, (p) => n(7, (i = p)));
  let { connectWallet: s } = e,
    { selectedWallet: a } = e,
    { deselectWallet: o } = e,
    { setStep: l } = e,
    { connectionRejected: u } = e,
    { previousConnectionRequest: f } = e;
  const c = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  Xr(t, c, (p) => n(6, (r = p)));
  const d = () => {
    o(a.label), l("selectingWallet");
  };
  return (
    (t.$$set = (p) => {
      "connectWallet" in p && n(0, (s = p.connectWallet)),
        "selectedWallet" in p && n(1, (a = p.selectedWallet)),
        "deselectWallet" in p && n(2, (o = p.deselectWallet)),
        "setStep" in p && n(3, (l = p.setStep)),
        "connectionRejected" in p && n(4, (u = p.connectionRejected)),
        "previousConnectionRequest" in p &&
          n(5, (f = p.previousConnectionRequest));
    }),
    [s, a, o, l, u, f, r, i, c, d]
  );
}
class _0e extends ss {
  constructor(e) {
    super(),
      is(
        this,
        e,
        w0e,
        b0e,
        ns,
        {
          connectWallet: 0,
          selectedWallet: 1,
          deselectWallet: 2,
          setStep: 3,
          connectionRejected: 4,
          previousConnectionRequest: 5,
        },
        g0e
      );
  }
}
function E0e(t) {
  rs(
    t,
    "svelte-1uy2ffh",
    ".outer-container.svelte-1uy2ffh{padding:var(--onboard-spacing-4, var(--spacing-4))}.link.svelte-1uy2ffh{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;color:var(--onboard-primary-500, var(--primary-500));text-decoration:none}"
  );
}
function KO(t, e, n) {
  const r = t.slice();
  return (r[3] = e[n].name), (r[4] = e[n].url), (r[6] = n), r;
}
function x0e(t) {
  let e =
      t[1]("connect.selectingWallet.installWallet", {
        default: Cn.connect.selectingWallet.installWallet,
        values: { app: t[0].name || "this app" },
      }) + "",
    n;
  return {
    c() {
      n = Ln(e);
    },
    m(r, i) {
      Ge(r, n, i);
    },
    p(r, i) {
      i & 3 &&
        e !==
          (e =
            r[1]("connect.selectingWallet.installWallet", {
              default: Cn.connect.selectingWallet.installWallet,
              values: { app: r[0].name || "this app" },
            }) + "") &&
        ir(n, e);
    },
    d(r) {
      r && ze(n);
    },
  };
}
function T0e(t) {
  let e =
      t[1]("connect.selectingWallet.recommendedWalletsPart1", {
        default: Cn.connect.selectingWallet.recommendedWalletsPart1,
        values: { app: t[0].name || "This app" },
      }) + "",
    n,
    r,
    i,
    s =
      t[1]("connect.selectingWallet.recommendedWalletsPart2", {
        default: Cn.connect.selectingWallet.recommendedWalletsPart2,
      }) + "",
    a,
    o = t[0].recommendedInjectedWallets,
    l = [];
  for (let u = 0; u < o.length; u += 1) l[u] = XO(KO(t, o, u));
  return {
    c() {
      (n = Ln(e)), (r = mt());
      for (let u = 0; u < l.length; u += 1) l[u].c();
      (i = mt()), (a = Ln(s));
    },
    m(u, f) {
      Ge(u, n, f), Ge(u, r, f);
      for (let c = 0; c < l.length; c += 1) l[c] && l[c].m(u, f);
      Ge(u, i, f), Ge(u, a, f);
    },
    p(u, f) {
      if (
        (f & 3 &&
          e !==
            (e =
              u[1]("connect.selectingWallet.recommendedWalletsPart1", {
                default: Cn.connect.selectingWallet.recommendedWalletsPart1,
                values: { app: u[0].name || "This app" },
              }) + "") &&
          ir(n, e),
        f & 1)
      ) {
        o = u[0].recommendedInjectedWallets;
        let c;
        for (c = 0; c < o.length; c += 1) {
          const d = KO(u, o, c);
          l[c]
            ? l[c].p(d, f)
            : ((l[c] = XO(d)), l[c].c(), l[c].m(i.parentNode, i));
        }
        for (; c < l.length; c += 1) l[c].d(1);
        l.length = o.length;
      }
      f & 2 &&
        s !==
          (s =
            u[1]("connect.selectingWallet.recommendedWalletsPart2", {
              default: Cn.connect.selectingWallet.recommendedWalletsPart2,
            }) + "") &&
        ir(a, s);
    },
    d(u) {
      u && ze(n), u && ze(r), QH(l, u), u && ze(i), u && ze(a);
    },
  };
}
function XO(t) {
  let e,
    n = t[3] + "",
    r,
    i = t[6] < t[0].recommendedInjectedWallets.length - 1 ? ", " : "",
    s,
    a;
  return {
    c() {
      (e = Oe("a")),
        (r = Ln(n)),
        (s = Ln(i)),
        be(e, "class", "link pointer svelte-1uy2ffh"),
        be(e, "href", (a = t[4])),
        be(e, "target", "_blank"),
        be(e, "rel", "noreferrer noopener");
    },
    m(o, l) {
      Ge(o, e, l), _e(e, r), _e(e, s);
    },
    p(o, l) {
      l & 1 && n !== (n = o[3] + "") && ir(r, n),
        l & 1 &&
          i !==
            (i =
              o[6] < o[0].recommendedInjectedWallets.length - 1 ? ", " : "") &&
          ir(s, i),
        l & 1 && a !== (a = o[4]) && be(e, "href", a);
    },
    d(o) {
      o && ze(e);
    },
  };
}
function S0e(t) {
  let e;
  function n(s, a) {
    return s[0].recommendedInjectedWallets ? T0e : x0e;
  }
  let r = n(t),
    i = r(t);
  return {
    c() {
      i.c(), (e = xr());
    },
    m(s, a) {
      i.m(s, a), Ge(s, e, a);
    },
    p(s, a) {
      r === (r = n(s)) && i
        ? i.p(s, a)
        : (i.d(1), (i = r(s)), i && (i.c(), i.m(e.parentNode, e)));
    },
    d(s) {
      i.d(s), s && ze(e);
    },
  };
}
function A0e(t) {
  let e, n, r;
  return (
    (n = new pT({
      props: { $$slots: { default: [S0e] }, $$scope: { ctx: t } },
    })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "outer-container svelte-1uy2ffh");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      p(i, [s]) {
        const a = {};
        s & 131 && (a.$$scope = { dirty: s, ctx: i }), n.$set(a);
      },
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function C0e(t, e, n) {
  let r, i;
  Xr(t, ic, (a) => n(1, (i = a)));
  const s = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  return Xr(t, s, (a) => n(0, (r = a))), [r, i, s];
}
class k0e extends ss {
  constructor(e) {
    super(), is(this, e, C0e, A0e, ns, {}, E0e);
  }
}
function I0e(t) {
  rs(
    t,
    "svelte-1vlog3j",
    "button.svelte-1vlog3j:disabled{opacity:0.5}button.wallet-button-styling.svelte-1vlog3j{position:relative;align-items:flex-start;flex:1;padding:0;background:none;color:var(--onboard-wallet-button-color, inherit)}.wallet-button-container.svelte-1vlog3j{display:flex}.wallet-button-container-inner.svelte-1vlog3j{position:relative;display:flex;flex-flow:column;align-items:center;gap:0.5rem;padding:0.75rem;width:5rem}.name.svelte-1vlog3j{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:1rem;text-overflow:ellipsis;max-width:5rem;max-height:2rem;overflow:hidden}.status-icon.svelte-1vlog3j{position:absolute;top:3.5rem;left:3.5rem}@media screen and (min-width: 768px){button.wallet-button-styling.svelte-1vlog3j{transition:background-color 250ms ease-in-out;background:var(--onboard-wallet-button-background, none);border:1px solid transparent;border-color:var(--onboard-wallet-button-border-color, var(--border-color));border-radius:var(--onboard-wallet-button-border-radius, var(--border-radius-1))}button.wallet-button-styling.svelte-1vlog3j:hover{background:var(--onboard-wallet-button-background-hover, var(--foreground-color));color:var(--onboard-wallet-button-color-hover)}.wallet-button-container-inner.svelte-1vlog3j{flex:1;flex-flow:row nowrap;gap:1rem;padding:1rem}button.connected.svelte-1vlog3j{border-color:var(--onboard-success-500, var(--success-500))}.name.svelte-1vlog3j{font-size:1rem;line-height:1.25rem;text-align:initial;max-width:inherit;max-height:3rem}.status-icon.svelte-1vlog3j{top:0;bottom:0;left:auto;right:1rem;margin:auto;height:20px}}"
  );
}
function ZO(t) {
  let e, n, r;
  return (
    (n = new xz({ props: { size: 20 } })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "status-icon svelte-1vlog3j");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function O0e(t) {
  let e, n, r, i, s, a, o, l, u, f, c, d;
  Ia(t[7]),
    (i = new Xg({
      props: {
        size: t[6] >= $i ? 48 : 56,
        icon: t[0],
        loading: t[4],
        border: t[3] ? "green" : "custom",
        background: "transparent",
      },
    }));
  let p = t[3] && ZO();
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("button")),
        (r = Oe("div")),
        Bn(i.$$.fragment),
        (s = mt()),
        (a = Oe("div")),
        (o = Ln(t[1])),
        (l = mt()),
        p && p.c(),
        be(a, "class", "name svelte-1vlog3j"),
        be(r, "class", "wallet-button-container-inner svelte-1vlog3j"),
        be(n, "class", "wallet-button-styling svelte-1vlog3j"),
        (n.disabled = t[5]),
        bt(n, "connected", t[3]),
        be(e, "class", "wallet-button-container svelte-1vlog3j");
    },
    m(m, g) {
      Ge(m, e, g),
        _e(e, n),
        _e(n, r),
        Dn(i, r, null),
        _e(r, s),
        _e(r, a),
        _e(a, o),
        _e(r, l),
        p && p.m(r, null),
        (f = !0),
        c ||
          ((d = [
            ao(window, "resize", t[7]),
            ao(n, "click", function () {
              _d(t[2]) && t[2].apply(this, arguments);
            }),
          ]),
          (c = !0));
    },
    p(m, [g]) {
      t = m;
      const w = {};
      g & 64 && (w.size = t[6] >= $i ? 48 : 56),
        g & 1 && (w.icon = t[0]),
        g & 16 && (w.loading = t[4]),
        g & 8 && (w.border = t[3] ? "green" : "custom"),
        i.$set(w),
        (!f || g & 2) && ir(o, t[1]),
        t[3]
          ? p
            ? g & 8 && Fe(p, 1)
            : ((p = ZO()), p.c(), Fe(p, 1), p.m(r, null))
          : p &&
            (jr(),
            Ze(p, 1, 1, () => {
              p = null;
            }),
            Hr()),
        (!f || g & 32) && (n.disabled = t[5]),
        (!f || g & 8) && bt(n, "connected", t[3]);
    },
    i(m) {
      f ||
        (Fe(i.$$.fragment, m),
        Fe(p),
        m &&
          (u ||
            Ia(() => {
              (u = lT(n, S5, {})), u.start();
            })),
        (f = !0));
    },
    o(m) {
      Ze(i.$$.fragment, m), Ze(p), (f = !1);
    },
    d(m) {
      m && ze(e), Rn(i), p && p.d(), (c = !1), ac(d);
    },
  };
}
function P0e(t, e, n) {
  let { icon: r } = e,
    { label: i } = e,
    { onClick: s } = e,
    { connected: a } = e,
    { connecting: o } = e,
    { disabled: l } = e,
    u;
  function f() {
    n(6, (u = window.innerWidth));
  }
  return (
    (t.$$set = (c) => {
      "icon" in c && n(0, (r = c.icon)),
        "label" in c && n(1, (i = c.label)),
        "onClick" in c && n(2, (s = c.onClick)),
        "connected" in c && n(3, (a = c.connected)),
        "connecting" in c && n(4, (o = c.connecting)),
        "disabled" in c && n(5, (l = c.disabled));
    }),
    [r, i, s, a, o, l, u, f]
  );
}
class N0e extends ss {
  constructor(e) {
    super(),
      is(
        this,
        e,
        P0e,
        O0e,
        ns,
        {
          icon: 0,
          label: 1,
          onClick: 2,
          connected: 3,
          connecting: 4,
          disabled: 5,
        },
        I0e
      );
  }
}
function D0e(t) {
  rs(
    t,
    "svelte-kpc6js",
    ".wallets-container.svelte-kpc6js{display:flex;gap:0.5rem;overflow-x:scroll;overflow-y:hidden;padding:0.75rem 0.5rem;border-bottom:1px solid var(--border-color);-ms-overflow-style:none;scrollbar-width:none}.wallets-container.svelte-kpc6js::-webkit-scrollbar{display:none}.warning-container.svelte-kpc6js{margin:1rem 1rem 0}.notice-container.svelte-kpc6js{flex:0 0 100%;margin-top:0.75rem}@media all and (min-width: 768px){.wallets-container.svelte-kpc6js{display:grid;grid-template-columns:repeat(var(--onboard-wallet-columns, 2), 1fr);padding:1rem;border:none}.notice-container.svelte-kpc6js{grid-column:span 2;margin:0}}"
  );
}
function YO(t, e, n) {
  const r = t.slice();
  return (r[10] = e[n]), r;
}
function QO(t) {
  let e, n, r;
  return (
    (n = new pT({
      props: { $$slots: { default: [R0e] }, $$scope: { ctx: t } },
    })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "warning-container svelte-kpc6js");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      p(i, s) {
        const a = {};
        s & 8200 && (a.$$scope = { dirty: s, ctx: i }), n.$set(a);
      },
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function R0e(t) {
  let e, n;
  return {
    c() {
      (e = new w1(!1)), (n = xr()), (e.a = n);
    },
    m(r, i) {
      e.m(t[3], r, i), Ge(r, n, i);
    },
    p(r, i) {
      i & 8 && e.p(r[3]);
    },
    d(r) {
      r && ze(n), r && e.d();
    },
  };
}
function JO(t) {
  let e, n;
  function r() {
    return t[9](t[10]);
  }
  return (
    (e = new N0e({
      props: {
        connected: t[7](t[10].label),
        connecting: t[2] === t[10].label,
        label: t[10].label,
        icon: t[10].icon,
        onClick: r,
        disabled: t[4] <= $i && t[2] && t[2] !== t[10].label,
      },
    })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(i, s) {
        Dn(e, i, s), (n = !0);
      },
      p(i, s) {
        t = i;
        const a = {};
        s & 1 && (a.connected = t[7](t[10].label)),
          s & 5 && (a.connecting = t[2] === t[10].label),
          s & 1 && (a.label = t[10].label),
          s & 1 && (a.icon = t[10].icon),
          s & 3 && (a.onClick = r),
          s & 21 && (a.disabled = t[4] <= $i && t[2] && t[2] !== t[10].label),
          e.$set(a);
      },
      i(i) {
        n || (Fe(e.$$.fragment, i), (n = !0));
      },
      o(i) {
        Ze(e.$$.fragment, i), (n = !1);
      },
      d(i) {
        Rn(e, i);
      },
    }
  );
}
function M0e(t) {
  let e, n, r;
  return (
    (n = new pT({
      props: { $$slots: { default: [L0e] }, $$scope: { ctx: t } },
    })),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "notice-container svelte-kpc6js");
      },
      m(i, s) {
        Ge(i, e, s), Dn(n, e, null), (r = !0);
      },
      p(i, s) {
        const a = {};
        s & 8224 && (a.$$scope = { dirty: s, ctx: i }), n.$set(a);
      },
      i(i) {
        r || (Fe(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        Ze(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && ze(e), Rn(n);
      },
    }
  );
}
function L0e(t) {
  let e,
    n =
      t[5]("connect.selectingWallet.whyDontISeeMyWallet", {
        default: Cn.connect.selectingWallet.whyDontISeeMyWallet,
      }) + "",
    r,
    i,
    s,
    a =
      t[5]("connect.selectingWallet.learnMore", {
        default: Cn.connect.selectingWallet.learnMore,
      }) + "",
    o;
  return {
    c() {
      (e = Oe("div")),
        (r = Ln(n)),
        (i = mt()),
        (s = Oe("a")),
        (o = Ln(a)),
        be(s, "class", "link pointer"),
        be(s, "href", t[6].wheresMyWalletLink || F0e),
        be(s, "target", "_blank"),
        be(s, "rel", "noreferrer noopener");
    },
    m(l, u) {
      Ge(l, e, u), _e(e, r), Ge(l, i, u), Ge(l, s, u), _e(s, o);
    },
    p(l, u) {
      u & 32 &&
        n !==
          (n =
            l[5]("connect.selectingWallet.whyDontISeeMyWallet", {
              default: Cn.connect.selectingWallet.whyDontISeeMyWallet,
            }) + "") &&
        ir(r, n),
        u & 32 &&
          a !==
            (a =
              l[5]("connect.selectingWallet.learnMore", {
                default: Cn.connect.selectingWallet.learnMore,
              }) + "") &&
          ir(o, a);
    },
    d(l) {
      l && ze(e), l && ze(i), l && ze(s);
    },
  };
}
function B0e(t) {
  let e, n, r, i, s, a, o;
  Ia(t[8]);
  let l = t[3] && QO(t),
    u = t[0],
    f = [];
  for (let p = 0; p < u.length; p += 1) f[p] = JO(YO(t, u, p));
  const c = (p) =>
    Ze(f[p], 1, 1, () => {
      f[p] = null;
    });
  let d = !t[6].removeWhereIsMyWalletWarning && M0e(t);
  return {
    c() {
      (e = Oe("div")), l && l.c(), (n = mt()), (r = Oe("div"));
      for (let p = 0; p < f.length; p += 1) f[p].c();
      (i = mt()),
        d && d.c(),
        be(r, "class", "wallets-container svelte-kpc6js"),
        be(e, "class", "outer-container");
    },
    m(p, m) {
      Ge(p, e, m), l && l.m(e, null), _e(e, n), _e(e, r);
      for (let g = 0; g < f.length; g += 1) f[g] && f[g].m(r, null);
      _e(r, i),
        d && d.m(r, null),
        (s = !0),
        a || ((o = ao(window, "resize", t[8])), (a = !0));
    },
    p(p, [m]) {
      if (
        (p[3]
          ? l
            ? (l.p(p, m), m & 8 && Fe(l, 1))
            : ((l = QO(p)), l.c(), Fe(l, 1), l.m(e, n))
          : l &&
            (jr(),
            Ze(l, 1, 1, () => {
              l = null;
            }),
            Hr()),
        m & 151)
      ) {
        u = p[0];
        let g;
        for (g = 0; g < u.length; g += 1) {
          const w = YO(p, u, g);
          f[g]
            ? (f[g].p(w, m), Fe(f[g], 1))
            : ((f[g] = JO(w)), f[g].c(), Fe(f[g], 1), f[g].m(r, i));
        }
        for (jr(), g = u.length; g < f.length; g += 1) c(g);
        Hr();
      }
      p[6].removeWhereIsMyWalletWarning || d.p(p, m);
    },
    i(p) {
      if (!s) {
        Fe(l);
        for (let m = 0; m < u.length; m += 1) Fe(f[m]);
        Fe(d), (s = !0);
      }
    },
    o(p) {
      Ze(l), (f = f.filter(Boolean));
      for (let m = 0; m < f.length; m += 1) Ze(f[m]);
      Ze(d), (s = !1);
    },
    d(p) {
      p && ze(e), l && l.d(), QH(f, p), d && d.d(), (a = !1), o();
    },
  };
}
const F0e =
  "https://www.blocknative.com/blog/metamask-wont-connect-web3-wallet-troubleshooting";
function $0e(t, e, n) {
  let r;
  Xr(t, ic, (p) => n(5, (r = p)));
  let { wallets: i } = e,
    { selectWallet: s } = e,
    { connectingWalletLabel: a } = e,
    { connectingErrorMessage: o } = e,
    l;
  const { connect: u } = Jt.get();
  function f(p) {
    const { wallets: m } = Jt.get();
    return !!m.find((g) => g.label === p);
  }
  function c() {
    n(4, (l = window.innerWidth));
  }
  const d = (p) => s(p);
  return (
    (t.$$set = (p) => {
      "wallets" in p && n(0, (i = p.wallets)),
        "selectWallet" in p && n(1, (s = p.selectWallet)),
        "connectingWalletLabel" in p && n(2, (a = p.connectingWalletLabel)),
        "connectingErrorMessage" in p && n(3, (o = p.connectingErrorMessage));
    }),
    [i, s, a, o, l, r, u, f, c, d]
  );
}
class U0e extends ss {
  constructor(e) {
    super(),
      is(
        this,
        e,
        $0e,
        B0e,
        ns,
        {
          wallets: 0,
          selectWallet: 1,
          connectingWalletLabel: 2,
          connectingErrorMessage: 3,
        },
        D0e
      );
  }
}
function j0e(t) {
  rs(
    t,
    "svelte-obaru3",
    `.sidebar.svelte-obaru3{--background-color:var(
      --onboard-connect-sidebar-background,
      var(--w3o-foreground-color, none)
    );--text-color:var(--onboard-connect-sidebar-color, inherit);--border-color:var(--onboard-connect-sidebar-border-color, inherit);display:flex;flex-flow:column;gap:1rem;padding:1rem;align-items:center}.inner-container.svelte-obaru3{display:flex;flex-flow:column;align-items:center;align-self:stretch;gap:0.5rem;padding:1.5rem;text-align:center;border:1px solid transparent;border-radius:12px;border-color:var(--border-color);background:var(--background-color);color:var(--text-color)}.icon-container.svelte-obaru3{display:flex;height:3.5rem;width:auto;min-width:3.5rem;max-width:100%}.heading.svelte-obaru3{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.subheading.svelte-obaru3{line-height:1rem}.description.svelte-obaru3{line-height:1.25rem;font-size:var(--onboard-font-size-6, var(--font-size-6))}img.svelte-obaru3{max-width:100%;height:auto}.indicators.svelte-obaru3{margin-top:auto}.indicator.svelte-obaru3{box-sizing:content-box;width:8px;height:8px;border-radius:8px;background:var(
      --onboard-connect-sidebar-progress-background,
      var(--onboard-gray-700, var(--gray-700))
    );transition:background 250ms ease-in-out}.indicator.on.svelte-obaru3{background:var(
      --onboard-connect-sidebar-progress-color,
      var(--action-color)
    );border:2px solid
      var(
        --onboard-connect-sidebar-progress-background,
        var(--onboard-gray-700, var(--gray-700))
      )}.join.svelte-obaru3{box-sizing:content-box;z-index:1;right:4px;height:2px;background:var(
      --onboard-connect-sidebar-progress-background,
      var(--onboard-gray-700, var(--gray-700))
    );transition:background 250ms ease-in-out}.join.active.svelte-obaru3{background:var(
      --onboard-connect-sidebar-progress-color,
      var(--action-color)
    )}.no-link.svelte-obaru3{display:flex;flex-direction:row;align-items:center;padding:0.25rem 0.5rem 0.25rem 0.75rem;gap:0.25rem;font-size:var(--onboard-font-size-6, var(--font-size-6))}.info-icon.svelte-obaru3{width:1.25rem;display:flex;align-items:center}@media all and (min-width: 768px){.sidebar.svelte-obaru3{max-width:280px;border-right:1px solid;border-color:var(--border-color);background:var(--background-color)}.inner-container.svelte-obaru3{border:none;text-align:initial;flex:1;align-items:flex-start;gap:1rem}.indicators.svelte-obaru3{margin-bottom:0.25rem}}`
  );
}
function eP(t) {
  let e,
    n,
    r = t[3](`connect.${t[0]}.sidebar.header`, { default: "" }),
    i;
  function s(u, f) {
    return u[2] && (u[2].logo || u[2].icon) ? z0e : H0e;
  }
  let a = s(t),
    o = a(t),
    l = r && tP(t);
  return {
    c() {
      (e = Oe("div")),
        o.c(),
        (n = mt()),
        l && l.c(),
        (i = xr()),
        be(e, "class", "icon-container svelte-obaru3");
    },
    m(u, f) {
      Ge(u, e, f), o.m(e, null), Ge(u, n, f), l && l.m(u, f), Ge(u, i, f);
    },
    p(u, f) {
      a === (a = s(u)) && o
        ? o.p(u, f)
        : (o.d(1), (o = a(u)), o && (o.c(), o.m(e, null))),
        f & 9 && (r = u[3](`connect.${u[0]}.sidebar.header`, { default: "" })),
        r
          ? l
            ? l.p(u, f)
            : ((l = tP(u)), l.c(), l.m(i.parentNode, i))
          : l && (l.d(1), (l = null));
    },
    d(u) {
      u && ze(e), o.d(), u && ze(n), l && l.d(u), u && ze(i);
    },
  };
}
function H0e(t) {
  let e, n;
  return {
    c() {
      (e = new w1(!1)), (n = xr()), (e.a = n);
    },
    m(r, i) {
      e.m(kH, r, i), Ge(r, n, i);
    },
    p: We,
    d(r) {
      r && ze(n), r && e.d();
    },
  };
}
function z0e(t) {
  let e, n;
  function r(a, o) {
    return (
      o & 4 && (e = null),
      e == null && (e = !!Z7(a[2].logo || a[2].icon)),
      e ? G0e : V0e
    );
  }
  let i = r(t, -1),
    s = i(t);
  return {
    c() {
      s.c(), (n = xr());
    },
    m(a, o) {
      s.m(a, o), Ge(a, n, o);
    },
    p(a, o) {
      i === (i = r(a, o)) && s
        ? s.p(a, o)
        : (s.d(1), (s = i(a)), s && (s.c(), s.m(n.parentNode, n)));
    },
    d(a) {
      s.d(a), a && ze(n);
    },
  };
}
function V0e(t) {
  let e, n;
  return {
    c() {
      (e = Oe("img")),
        z0(e.src, (n = t[2].logo || t[2].icon)) || be(e, "src", n),
        be(e, "alt", "logo"),
        be(e, "class", "svelte-obaru3");
    },
    m(r, i) {
      Ge(r, e, i);
    },
    p(r, i) {
      i & 4 && !z0(e.src, (n = r[2].logo || r[2].icon)) && be(e, "src", n);
    },
    d(r) {
      r && ze(e);
    },
  };
}
function G0e(t) {
  let e,
    n = (t[2].logo || t[2].icon) + "",
    r;
  return {
    c() {
      (e = new w1(!1)), (r = Ln("​")), (e.a = r);
    },
    m(i, s) {
      e.m(n, i, s), Ge(i, r, s);
    },
    p(i, s) {
      s & 4 && n !== (n = (i[2].logo || i[2].icon) + "") && e.p(n);
    },
    d(i) {
      i && e.d(), i && ze(r);
    },
  };
}
function tP(t) {
  let e,
    n = t[3](`connect.${t[0]}.sidebar.header`, { default: t[7] }) + "",
    r;
  return {
    c() {
      (e = Oe("div")), (r = Ln(n)), be(e, "class", "heading svelte-obaru3");
    },
    m(i, s) {
      Ge(i, e, s), _e(e, r);
    },
    p(i, s) {
      s & 9 &&
        n !==
          (n =
            i[3](`connect.${i[0]}.sidebar.header`, { default: i[7] }) + "") &&
        ir(r, n);
    },
    d(i) {
      i && ze(e);
    },
  };
}
function W0e(t) {
  let e,
    n =
      t[3]("connect.selectingWallet.sidebar.IDontHaveAWallet", {
        default: Cn.connect.selectingWallet.sidebar.IDontHaveAWallet,
      }) + "",
    r,
    i,
    s;
  return {
    c() {
      (e = Oe("a")),
        (r = Ln(n)),
        (i = mt()),
        (s = Oe("div")),
        be(s, "class", "info-icon svelte-obaru3"),
        be(
          e,
          "href",
          t[4].iDontHaveAWalletLink ||
            "https://ethereum.org/en/wallets/find-wallet/#main-content"
        ),
        be(e, "target", "_blank"),
        be(e, "rel", "noreferrer noopener"),
        be(e, "class", "no-link svelte-obaru3");
    },
    m(a, o) {
      Ge(a, e, o), _e(e, r), _e(e, i), _e(e, s), (s.innerHTML = Uw);
    },
    p(a, o) {
      o & 8 &&
        n !==
          (n =
            a[3]("connect.selectingWallet.sidebar.IDontHaveAWallet", {
              default: Cn.connect.selectingWallet.sidebar.IDontHaveAWallet,
            }) + "") &&
        ir(r, n);
    },
    d(a) {
      a && ze(e);
    },
  };
}
function nP(t) {
  let e, n, r, i, s, a, o, l, u, f, c, d;
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        (r = mt()),
        (i = Oe("div")),
        (a = mt()),
        (o = Oe("div")),
        (l = mt()),
        (u = Oe("div")),
        (c = mt()),
        (d = Oe("div")),
        be(n, "class", "indicator relative svelte-obaru3"),
        bt(n, "on", !0),
        be(i, "class", "join relative svelte-obaru3"),
        be(
          i,
          "style",
          (s = `${
            t[0] !== "selectingWallet"
              ? "right: 4px; width: 52px;"
              : "right: 2px; width: 54px;"
          }`)
        ),
        bt(i, "active", t[0] !== "selectingWallet"),
        be(o, "class", "indicator relative svelte-obaru3"),
        be(o, "style", "right: 8px;"),
        bt(o, "on", t[0] !== "selectingWallet"),
        be(u, "class", "join relative svelte-obaru3"),
        be(
          u,
          "style",
          (f = `${
            t[0] === "connectedWallet"
              ? "right: 12px; width: 52px;"
              : "right: 10px; width: 54px;"
          }`)
        ),
        bt(u, "active", t[0] === "connectedWallet"),
        be(d, "style", "right: 16px;"),
        be(d, "class", "indicator relative svelte-obaru3"),
        bt(d, "on", t[0] === "connectedWallet"),
        be(e, "class", "indicators flex items-center svelte-obaru3");
    },
    m(p, m) {
      Ge(p, e, m),
        _e(e, n),
        _e(e, r),
        _e(e, i),
        _e(e, a),
        _e(e, o),
        _e(e, l),
        _e(e, u),
        _e(e, c),
        _e(e, d);
    },
    p(p, m) {
      m & 1 &&
        s !==
          (s = `${
            p[0] !== "selectingWallet"
              ? "right: 4px; width: 52px;"
              : "right: 2px; width: 54px;"
          }`) &&
        be(i, "style", s),
        m & 1 && bt(i, "active", p[0] !== "selectingWallet"),
        m & 1 && bt(o, "on", p[0] !== "selectingWallet"),
        m & 1 &&
          f !==
            (f = `${
              p[0] === "connectedWallet"
                ? "right: 12px; width: 52px;"
                : "right: 10px; width: 54px;"
            }`) &&
          be(u, "style", f),
        m & 1 && bt(u, "active", p[0] === "connectedWallet"),
        m & 1 && bt(d, "on", p[0] === "connectedWallet");
    },
    d(p) {
      p && ze(e);
    },
  };
}
function rP(t) {
  let e, n, r, i, s, a, o, l, u, f, c, d;
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        (r = mt()),
        (i = Oe("div")),
        (a = mt()),
        (o = Oe("div")),
        (l = mt()),
        (u = Oe("div")),
        (c = mt()),
        (d = Oe("div")),
        be(n, "class", "indicator relative svelte-obaru3"),
        bt(n, "on", !0),
        be(i, "class", "join relative svelte-obaru3"),
        be(
          i,
          "style",
          (s = `right: 2px; ${
            t[0] !== "selectingWallet" ? "width: 78px;" : "width: 82px;"
          }`)
        ),
        bt(i, "active", t[0] !== "selectingWallet"),
        be(o, "class", "indicator relative svelte-obaru3"),
        be(o, "style", "right: 4px;"),
        bt(o, "on", t[0] !== "selectingWallet"),
        be(u, "class", "join relative svelte-obaru3"),
        be(
          u,
          "style",
          (f = `right: 6px; ${
            t[0] === "connectedWallet" ? "width: 74px;" : "width: 81px;"
          }`)
        ),
        bt(u, "active", t[0] === "connectedWallet"),
        be(d, "style", "right: 8px;"),
        be(d, "class", "indicator relative svelte-obaru3"),
        bt(d, "on", t[0] === "connectedWallet"),
        be(e, "class", "indicators flex items-center svelte-obaru3");
    },
    m(p, m) {
      Ge(p, e, m),
        _e(e, n),
        _e(e, r),
        _e(e, i),
        _e(e, a),
        _e(e, o),
        _e(e, l),
        _e(e, u),
        _e(e, c),
        _e(e, d);
    },
    p(p, m) {
      m & 1 &&
        s !==
          (s = `right: 2px; ${
            p[0] !== "selectingWallet" ? "width: 78px;" : "width: 82px;"
          }`) &&
        be(i, "style", s),
        m & 1 && bt(i, "active", p[0] !== "selectingWallet"),
        m & 1 && bt(o, "on", p[0] !== "selectingWallet"),
        m & 1 &&
          f !==
            (f = `right: 6px; ${
              p[0] === "connectedWallet" ? "width: 74px;" : "width: 81px;"
            }`) &&
          be(u, "style", f),
        m & 1 && bt(u, "active", p[0] === "connectedWallet"),
        m & 1 && bt(d, "on", p[0] === "connectedWallet");
    },
    d(p) {
      p && ze(e);
    },
  };
}
function q0e(t) {
  let e,
    n,
    r,
    i,
    s = t[3](`connect.${t[0]}.sidebar.subheading`, { default: t[5] }) + "",
    a,
    o,
    l,
    u =
      t[3](`connect.${t[0]}.sidebar.paragraph`, {
        values: { app: (t[2] && t[2].name) || "This App" },
        default: t[6],
      }) + "",
    f,
    c,
    d,
    p,
    m,
    g,
    w,
    y;
  Ia(t[9]);
  let v = t[1] >= $i && eP(t),
    E = !t[4].removeIDontHaveAWalletInfoLink && W0e(t),
    S = t[1] < $i && nP(t),
    D = t[1] >= $i && rP(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        v && v.c(),
        (r = mt()),
        (i = Oe("div")),
        (a = Ln(s)),
        (o = mt()),
        (l = Oe("div")),
        (f = Ln(u)),
        (c = mt()),
        E && E.c(),
        (d = mt()),
        S && S.c(),
        (p = mt()),
        D && D.c(),
        (m = mt()),
        (g = Oe("div")),
        be(i, "class", "subheading svelte-obaru3"),
        be(l, "class", "description svelte-obaru3"),
        be(n, "class", "inner-container svelte-obaru3"),
        be(e, "class", "sidebar svelte-obaru3");
    },
    m(P, x) {
      Ge(P, e, x),
        _e(e, n),
        v && v.m(n, null),
        _e(n, r),
        _e(n, i),
        _e(i, a),
        _e(n, o),
        _e(n, l),
        _e(l, f),
        _e(n, c),
        E && E.m(n, null),
        _e(n, d),
        S && S.m(n, null),
        _e(e, p),
        D && D.m(e, null),
        _e(e, m),
        _e(e, g),
        (g.innerHTML = vde),
        w || ((y = ao(window, "resize", t[9])), (w = !0));
    },
    p(P, [x]) {
      P[1] >= $i
        ? v
          ? v.p(P, x)
          : ((v = eP(P)), v.c(), v.m(n, r))
        : v && (v.d(1), (v = null)),
        x & 9 &&
          s !==
            (s =
              P[3](`connect.${P[0]}.sidebar.subheading`, { default: P[5] }) +
              "") &&
          ir(a, s),
        x & 13 &&
          u !==
            (u =
              P[3](`connect.${P[0]}.sidebar.paragraph`, {
                values: { app: (P[2] && P[2].name) || "This App" },
                default: P[6],
              }) + "") &&
          ir(f, u),
        P[4].removeIDontHaveAWalletInfoLink || E.p(P, x),
        P[1] < $i
          ? S
            ? S.p(P, x)
            : ((S = nP(P)), S.c(), S.m(n, null))
          : S && (S.d(1), (S = null)),
        P[1] >= $i
          ? D
            ? D.p(P, x)
            : ((D = rP(P)), D.c(), D.m(e, m))
          : D && (D.d(1), (D = null));
    },
    i: We,
    o: We,
    d(P) {
      P && ze(e), v && v.d(), E && E.d(), S && S.d(), D && D.d(), (w = !1), y();
    },
  };
}
function K0e(t, e, n) {
  let r, i;
  Xr(t, ic, (m) => n(3, (i = m)));
  let { step: s } = e;
  const { connect: a } = Jt.get(),
    o = Cn.connect[s].sidebar,
    { subheading: l, paragraph: u } = o,
    { heading: f } = o;
  let c;
  const d = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  Xr(t, d, (m) => n(2, (r = m)));
  function p() {
    n(1, (c = window.innerWidth));
  }
  return (
    (t.$$set = (m) => {
      "step" in m && n(0, (s = m.step));
    }),
    [s, c, r, i, a, l, u, f, d, p]
  );
}
class X0e extends ss {
  constructor(e) {
    super(), is(this, e, K0e, q0e, ns, { step: 0 }, j0e);
  }
}
function Z0e(t) {
  rs(
    t,
    "svelte-b3j15j",
    `.container.svelte-b3j15j{--background-color:var(
      --onboard-main-scroll-container-background,
      var(--w3o-background-color)
    );--foreground-color:var(--w3o-foreground-color);--text-color:var(--onboard-connect-text-color, var(--w3o-text-color));--border-color:var(--w3o-border-color, var(--gray-200));--action-color:var(--w3o-action-color, var(--primary-500));font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, 1rem);background:var(--background-color);color:var(--text-color);border-color:var(--border-color);line-height:24px;overflow:hidden;position:relative;display:flex;height:min-content;flex-flow:column-reverse}.content.svelte-b3j15j{width:var(--onboard-connect-content-width, 100%)}.header.svelte-b3j15j{display:flex;padding:1rem;border-bottom:1px solid transparent;background:var(--onboard-connect-header-background);color:var(--onboard-connect-header-color);border-color:var(--border-color)}.header-heading.svelte-b3j15j{line-height:1rem}.button-container.svelte-b3j15j{right:0.5rem;top:0.5rem}.mobile-header.svelte-b3j15j{display:flex;gap:0.5rem;height:4.5rem;padding:1rem;border-bottom:1px solid;border-color:var(--border-color)}.mobile-subheader.svelte-b3j15j{opacity:0.6;font-size:0.875rem;font-weight:400;line-height:1rem;margin-top:0.25rem}.icon-container.svelte-b3j15j{display:flex;flex:0 0 auto;height:2.5rem;width:2.5rem;min-width:2.5rem;justify-content:center;align-items:center}.disabled.svelte-b3j15j{opacity:0.2;pointer-events:none;overflow:hidden}.icon-container svg{display:block;height:100%;width:auto}.w-full.svelte-b3j15j{width:100%}.scroll-container.svelte-b3j15j{overflow-y:auto;transition:opacity 250ms ease-in-out;scrollbar-width:none}.scroll-container.svelte-b3j15j::-webkit-scrollbar{display:none}.mobile-safari.svelte-b3j15j{padding-bottom:80px}@media all and (min-width: 768px){.container.svelte-b3j15j{margin:0;flex-flow:row;height:var(--onboard-connect-content-height, 440px)}.content.svelte-b3j15j{width:var(--onboard-connect-content-width, 488px)}.mobile-subheader.svelte-b3j15j{display:none}.icon-container.svelte-b3j15j{display:none}}`
  );
}
function iP(t) {
  let e, n;
  return (
    (e = new hT({
      props: {
        close: !t[16].disableClose && t[20],
        $$slots: { default: [o1e] },
        $$scope: { ctx: t },
      },
    })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        (i[0] & 32766) | (i[1] & 64) && (s.$$scope = { dirty: i, ctx: r }),
          e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function Y0e(t) {
  let e, n;
  return (
    (e = new X0e({ props: { step: t[5] } })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 32 && (s.step = r[5]), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function Q0e(t) {
  let e,
    n,
    r =
      t[14](`connect.${t[5]}.header`, {
        default: Cn.connect[t[5]].header,
        values: { connectionRejected: t[1], wallet: t[3] && t[3].label },
      }) + "",
    i,
    s,
    a = t[5] === "selectingWallet" ? `(${t[12]})` : "",
    o;
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        (i = Ln(r)),
        (s = mt()),
        (o = Ln(a)),
        be(n, "class", "header-heading svelte-b3j15j"),
        be(e, "class", "header relative flex items-center svelte-b3j15j");
    },
    m(l, u) {
      Ge(l, e, u), _e(e, n), _e(n, i), _e(n, s), _e(n, o);
    },
    p(l, u) {
      u[0] & 16426 &&
        r !==
          (r =
            l[14](`connect.${l[5]}.header`, {
              default: Cn.connect[l[5]].header,
              values: { connectionRejected: l[1], wallet: l[3] && l[3].label },
            }) + "") &&
        ir(i, r),
        u[0] & 4128 &&
          a !== (a = l[5] === "selectingWallet" ? `(${l[12]})` : "") &&
          ir(o, a);
    },
    d(l) {
      l && ze(e);
    },
  };
}
function J0e(t) {
  let e,
    n,
    r,
    i,
    s,
    a =
      t[14](
        t[5] === "connectingWallet" && t[3]
          ? `connect.${t[5]}.header`
          : `connect.${t[5]}.sidebar.subheading`,
        {
          default:
            t[5] === "connectingWallet" && t[3]
              ? Cn.connect[t[5]].header
              : Cn.connect[t[5]].sidebar.subheading,
          values: { connectionRejected: t[1], wallet: t[3] && t[3].label },
        }
      ) + "",
    o,
    l,
    u,
    f =
      t[5] === "selectingWallet"
        ? `${t[12]} available wallets`
        : "1 account selected",
    c;
  function d(g, w) {
    return g[13] && g[13].icon ? t1e : e1e;
  }
  let p = d(t),
    m = p(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        m.c(),
        (r = mt()),
        (i = Oe("div")),
        (s = Oe("div")),
        (o = Ln(a)),
        (l = mt()),
        (u = Oe("div")),
        (c = Ln(f)),
        be(n, "class", "icon-container svelte-b3j15j"),
        be(s, "class", "header-heading svelte-b3j15j"),
        be(u, "class", "mobile-subheader svelte-b3j15j"),
        be(i, "class", "flex flex-column justify-center w-full svelte-b3j15j"),
        be(e, "class", "mobile-header svelte-b3j15j");
    },
    m(g, w) {
      Ge(g, e, w),
        _e(e, n),
        m.m(n, null),
        _e(e, r),
        _e(e, i),
        _e(i, s),
        _e(s, o),
        _e(i, l),
        _e(i, u),
        _e(u, c);
    },
    p(g, w) {
      p === (p = d(g)) && m
        ? m.p(g, w)
        : (m.d(1), (m = p(g)), m && (m.c(), m.m(n, null))),
        w[0] & 16426 &&
          a !==
            (a =
              g[14](
                g[5] === "connectingWallet" && g[3]
                  ? `connect.${g[5]}.header`
                  : `connect.${g[5]}.sidebar.subheading`,
                {
                  default:
                    g[5] === "connectingWallet" && g[3]
                      ? Cn.connect[g[5]].header
                      : Cn.connect[g[5]].sidebar.subheading,
                  values: {
                    connectionRejected: g[1],
                    wallet: g[3] && g[3].label,
                  },
                }
              ) + "") &&
          ir(o, a),
        w[0] & 4128 &&
          f !==
            (f =
              g[5] === "selectingWallet"
                ? `${g[12]} available wallets`
                : "1 account selected") &&
          ir(c, f);
    },
    d(g) {
      g && ze(e), m.d();
    },
  };
}
function e1e(t) {
  let e, n;
  return {
    c() {
      (e = new w1(!1)), (n = xr()), (e.a = n);
    },
    m(r, i) {
      e.m(kH, r, i), Ge(r, n, i);
    },
    p: We,
    d(r) {
      r && ze(n), r && e.d();
    },
  };
}
function t1e(t) {
  let e, n;
  function r(a, o) {
    return (
      o[0] & 8192 && (e = null),
      e == null && (e = !!Z7(a[13].icon)),
      e ? r1e : n1e
    );
  }
  let i = r(t, [-1, -1]),
    s = i(t);
  return {
    c() {
      s.c(), (n = xr());
    },
    m(a, o) {
      s.m(a, o), Ge(a, n, o);
    },
    p(a, o) {
      i === (i = r(a, o)) && s
        ? s.p(a, o)
        : (s.d(1), (s = i(a)), s && (s.c(), s.m(n.parentNode, n)));
    },
    d(a) {
      s.d(a), a && ze(n);
    },
  };
}
function n1e(t) {
  let e, n;
  return {
    c() {
      (e = Oe("img")),
        z0(e.src, (n = t[13].icon)) || be(e, "src", n),
        be(e, "alt", "logo");
    },
    m(r, i) {
      Ge(r, e, i);
    },
    p(r, i) {
      i[0] & 8192 && !z0(e.src, (n = r[13].icon)) && be(e, "src", n);
    },
    d(r) {
      r && ze(e);
    },
  };
}
function r1e(t) {
  let e,
    n = t[13].icon + "",
    r;
  return {
    c() {
      (e = new w1(!1)), (r = xr()), (e.a = r);
    },
    m(i, s) {
      e.m(n, i, s), Ge(i, r, s);
    },
    p(i, s) {
      s[0] & 8192 && n !== (n = i[13].icon + "") && e.p(n);
    },
    d(i) {
      i && ze(r), i && e.d();
    },
  };
}
function i1e(t) {
  let e, n, r, i, s;
  return (
    (n = new _z({})),
    {
      c() {
        (e = Oe("div")),
          Bn(n.$$.fragment),
          be(e, "class", "button-container absolute svelte-b3j15j");
      },
      m(a, o) {
        Ge(a, e, o),
          Dn(n, e, null),
          (r = !0),
          i || ((s = ao(e, "click", t[20])), (i = !0));
      },
      p: We,
      i(a) {
        r || (Fe(n.$$.fragment, a), (r = !0));
      },
      o(a) {
        Ze(n.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(e), Rn(n), (i = !1), s();
      },
    }
  );
}
function sP(t) {
  let e, n, r, i;
  const s = [a1e, s1e],
    a = [];
  function o(l, u) {
    return l[2].length ? 0 : 1;
  }
  return (
    (e = o(t)),
    (n = a[e] = s[e](t)),
    {
      c() {
        n.c(), (r = xr());
      },
      m(l, u) {
        a[e].m(l, u), Ge(l, r, u), (i = !0);
      },
      p(l, u) {
        let f = e;
        (e = o(l)),
          e === f
            ? a[e].p(l, u)
            : (jr(),
              Ze(a[f], 1, 1, () => {
                a[f] = null;
              }),
              Hr(),
              (n = a[e]),
              n ? n.p(l, u) : ((n = a[e] = s[e](l)), n.c()),
              Fe(n, 1),
              n.m(r.parentNode, r));
      },
      i(l) {
        i || (Fe(n), (i = !0));
      },
      o(l) {
        Ze(n), (i = !1);
      },
      d(l) {
        a[e].d(l), l && ze(r);
      },
    }
  );
}
function s1e(t) {
  let e, n;
  return (
    (e = new k0e({})),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p: We,
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function a1e(t) {
  let e, n, r, i, s, a;
  function o(u) {
    t[25](u);
  }
  let l = {};
  return (
    t[7] !== void 0 && (l.agreed = t[7]),
    (e = new Upe({ props: l })),
    w5.push(() => ihe(e, "agreed", o)),
    (s = new U0e({
      props: {
        selectWallet: t[18],
        wallets: t[2],
        connectingWalletLabel: t[8],
        connectingErrorMessage: t[9],
      },
    })),
    {
      c() {
        Bn(e.$$.fragment),
          (r = mt()),
          (i = Oe("div")),
          Bn(s.$$.fragment),
          be(i, "class", "svelte-b3j15j"),
          bt(i, "disabled", !t[7]);
      },
      m(u, f) {
        Dn(e, u, f), Ge(u, r, f), Ge(u, i, f), Dn(s, i, null), (a = !0);
      },
      p(u, f) {
        const c = {};
        !n && f[0] & 128 && ((n = !0), (c.agreed = u[7]), ehe(() => (n = !1))),
          e.$set(c);
        const d = {};
        f[0] & 4 && (d.wallets = u[2]),
          f[0] & 256 && (d.connectingWalletLabel = u[8]),
          f[0] & 512 && (d.connectingErrorMessage = u[9]),
          s.$set(d),
          (!a || f[0] & 128) && bt(i, "disabled", !u[7]);
      },
      i(u) {
        a || (Fe(e.$$.fragment, u), Fe(s.$$.fragment, u), (a = !0));
      },
      o(u) {
        Ze(e.$$.fragment, u), Ze(s.$$.fragment, u), (a = !1);
      },
      d(u) {
        Rn(e, u), u && ze(r), u && ze(i), Rn(s);
      },
    }
  );
}
function aP(t) {
  let e, n;
  return (
    (e = new _0e({
      props: {
        connectWallet: t[21],
        connectionRejected: t[1],
        previousConnectionRequest: t[6],
        setStep: t[22],
        deselectWallet: t[19],
        selectedWallet: t[3],
      },
    })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 2 && (s.connectionRejected = r[1]),
          i[0] & 64 && (s.previousConnectionRequest = r[6]),
          i[0] & 8 && (s.selectedWallet = r[3]),
          e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function oP(t) {
  let e, n;
  return (
    (e = new m0e({ props: { selectedWallet: t[3] } })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 8 && (s.selectedWallet = r[3]), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function o1e(t) {
  let e,
    n,
    r,
    i,
    s,
    a,
    o,
    l,
    u,
    f = t[16].showSidebar && Y0e(t);
  function c(v, E) {
    return v[4] <= $i ? J0e : Q0e;
  }
  let d = c(t),
    p = d(t),
    m = !t[16].disableClose && i1e(t),
    g = (t[5] === "selectingWallet" || t[4] <= $i) && sP(t),
    w = t[11] && aP(t),
    y = t[5] === "connectedWallet" && t[3] && t[4] >= $i && oP(t);
  return {
    c() {
      (e = Oe("div")),
        f && f.c(),
        (n = mt()),
        (r = Oe("div")),
        p.c(),
        (i = mt()),
        m && m.c(),
        (s = mt()),
        (a = Oe("div")),
        g && g.c(),
        (o = mt()),
        w && w.c(),
        (l = mt()),
        y && y.c(),
        be(a, "class", "scroll-container svelte-b3j15j"),
        be(r, "class", "content flex flex-column svelte-b3j15j"),
        be(e, "class", "container svelte-b3j15j"),
        bt(e, "mobile-safari", t[23]);
    },
    m(v, E) {
      Ge(v, e, E),
        f && f.m(e, null),
        _e(e, n),
        _e(e, r),
        p.m(r, null),
        _e(r, i),
        m && m.m(r, null),
        _e(r, s),
        _e(r, a),
        g && g.m(a, null),
        _e(a, o),
        w && w.m(a, null),
        _e(a, l),
        y && y.m(a, null),
        t[26](a),
        (u = !0);
    },
    p(v, E) {
      v[16].showSidebar && f.p(v, E),
        d === (d = c(v)) && p
          ? p.p(v, E)
          : (p.d(1), (p = d(v)), p && (p.c(), p.m(r, i))),
        v[16].disableClose || m.p(v, E),
        v[5] === "selectingWallet" || v[4] <= $i
          ? g
            ? (g.p(v, E), E[0] & 48 && Fe(g, 1))
            : ((g = sP(v)), g.c(), Fe(g, 1), g.m(a, o))
          : g &&
            (jr(),
            Ze(g, 1, 1, () => {
              g = null;
            }),
            Hr()),
        v[11]
          ? w
            ? (w.p(v, E), E[0] & 2048 && Fe(w, 1))
            : ((w = aP(v)), w.c(), Fe(w, 1), w.m(a, l))
          : w &&
            (jr(),
            Ze(w, 1, 1, () => {
              w = null;
            }),
            Hr()),
        v[5] === "connectedWallet" && v[3] && v[4] >= $i
          ? y
            ? (y.p(v, E), E[0] & 56 && Fe(y, 1))
            : ((y = oP(v)), y.c(), Fe(y, 1), y.m(a, null))
          : y &&
            (jr(),
            Ze(y, 1, 1, () => {
              y = null;
            }),
            Hr());
    },
    i(v) {
      u || (Fe(f), Fe(m), Fe(g), Fe(w), Fe(y), (u = !0));
    },
    o(v) {
      Ze(f), Ze(m), Ze(g), Ze(w), Ze(y), (u = !1);
    },
    d(v) {
      v && ze(e),
        f && f.d(),
        p.d(),
        m && m.d(),
        g && g.d(),
        w && w.d(),
        y && y.d(),
        t[26](null);
    },
  };
}
function l1e(t) {
  let e, n, r, i;
  Ia(t[24]);
  let s = !t[0].disableModals && iP(t);
  return {
    c() {
      s && s.c(), (e = xr());
    },
    m(a, o) {
      s && s.m(a, o),
        Ge(a, e, o),
        (n = !0),
        r || ((i = ao(window, "resize", t[24])), (r = !0));
    },
    p(a, o) {
      a[0].disableModals
        ? s &&
          (jr(),
          Ze(s, 1, 1, () => {
            s = null;
          }),
          Hr())
        : s
        ? (s.p(a, o), o[0] & 1 && Fe(s, 1))
        : ((s = iP(a)), s.c(), Fe(s, 1), s.m(e.parentNode, e));
    },
    i(a) {
      n || (Fe(s), (n = !0));
    },
    o(a) {
      Ze(s), (n = !1);
    },
    d(a) {
      s && s.d(a), a && ze(e), (r = !1), i();
    },
  };
}
function u1e(t, e, n) {
  let r, i, s, a, o;
  Xr(t, ic, (fe) => n(14, (o = fe)));
  let { autoSelect: l } = e;
  const u = Jt.select("appMetadata").pipe(Uc(Jt.get().appMetadata), Xc(1));
  Xr(t, u, (fe) => n(13, (s = fe)));
  const { unstoppableResolution: f, device: c } = so,
    { walletModules: d, connect: p, chains: m } = Jt.get(),
    g = new sf();
  let w = !1,
    y = !1,
    v = [],
    E,
    S,
    D,
    P,
    x,
    _;
  const A = new by("selectingWallet");
  Xr(t, A, (fe) => n(5, (a = fe))),
    Wl.pipe(
      LU(
        (fe, z) =>
          fe.autoSelect &&
          z.autoSelect &&
          fe.autoSelect.disableModals === z.autoSelect.disableModals
      ),
      D0(({ autoSelect: fe }) => fe && fe.disableModals === !1),
      Lg(UO)
    ).subscribe(() => {
      E && L();
    });
  async function N({ label: fe, icon: z, getInterface: se }) {
    n(8, (D = fe));
    try {
      const Y = Jt.get().wallets.find((he) => he.label === fe);
      if (Y) {
        RE(Y), setTimeout(() => $("connectedWallet"), 1), n(3, (E = Y));
        return;
      }
      const { chains: Q } = Jt.get(),
        { provider: ee, instance: F } = await se({
          chains: Q,
          BigNumber: dt,
          EventEmitter: yde,
          appMetadata: s,
        }),
        te = await z;
      n(
        3,
        (E = {
          label: fe,
          icon: te,
          provider: ee,
          instance: F,
          accounts: [],
          chains: [{ namespace: "evm", id: "0x1" }],
        })
      ),
        n(9, (P = "")),
        B(),
        setTimeout(() => $("connectingWallet"), 1);
    } catch (Y) {
      const { message: Q } = Y;
      n(9, (P = Q)), n(8, (D = "")), B();
    }
  }
  function M() {
    n(3, (E = null));
  }
  function T(fe) {
    n(3, (E = { ...E, ...fe }));
  }
  async function O(fe) {
    const { getIcon: z, getInterface: se, label: Y } = fe,
      Q = z();
    N({ label: Y, icon: Q, getInterface: se });
  }
  async function I() {
    n(
      2,
      (v = d.map(({ getIcon: fe, getInterface: z, label: se }) => ({
        label: se,
        icon: fe(),
        getInterface: z,
      })))
    );
  }
  function k() {
    Wl.next({ inProgress: !1 });
  }
  async function L() {
    n(1, (w = !1));
    const { provider: fe, label: z } = E;
    g.next();
    try {
      const [se] = await Promise.race([hpe(fe), Aw(g.pipe(gI([])))]);
      if (!se) return;
      if (
        Jt.get().connect.autoConnectLastWallet ||
        Jt.get().connect.autoConnectAllPreviousWallet
      ) {
        let ee = jw(Ku.LAST_CONNECTED_WALLET);
        try {
          let F = JSON.parse(ee);
          if (F && Array.isArray(F)) {
            const te = F;
            ee = [...new Set([z, ...te])];
          }
        } catch (F) {
          if (F instanceof SyntaxError && ee && typeof ee == "string")
            ee = [ee];
          else throw new Error(F);
        }
        ee || (ee = [z]), Hw(Ku.LAST_CONNECTED_WALLET, JSON.stringify(ee));
      }
      const Y = await ppe(fe);
      if (Jt.get().notify.enabled) {
        const ee = await T5();
        if (ee)
          try {
            ee.subscribe({ id: se, chainId: Y, type: "account" });
          } catch {}
      }
      const Q = {
        accounts: [{ address: se, ens: null, uns: null, balance: null }],
        chains: [{ namespace: "evm", id: Y }],
      };
      RE({ ...E, ...Q }), gpe(fe, z), T(Q), $("connectedWallet"), B();
    } catch (se) {
      const { code: Y } = se;
      if ((B(), Y === td.ACCOUNT_ACCESS_REJECTED)) {
        n(1, (w = !0)),
          l.disableModals
            ? Wl.next({ inProgress: !1 })
            : l.label && n(0, (l.label = ""), l);
        return;
      }
      if (Y === td.ACCOUNT_ACCESS_ALREADY_REQUESTED) {
        if ((n(6, (y = !0)), l.disableModals)) {
          Wl.next({ inProgress: !1 });
          return;
        }
        gz({
          provider: E.provider,
          disconnected$: Wl.pipe(
            D0(({ inProgress: Q }) => !Q),
            gI("")
          ),
        })
          .pipe(I7(1))
          .subscribe(([Q]) => {
            Q && L();
          });
        return;
      }
    }
  }
  async function U() {
    const { accounts: fe, chains: z } = E,
      se = Jt.get().chains,
      [Y] = z,
      Q = se.find(
        ({ namespace: Ce, id: ke }) => Ce === Y.namespace && ke === Y.id
      ),
      { address: ee } = fe[0];
    let { balance: F, ens: te, uns: he, secondaryTokens: Te } = fe[0];
    if (
      (F === null &&
        E5(ee, Q).then((Ce) => {
          Um(E.label, ee, { balance: Ce });
        }),
      Q &&
        !Te &&
        Array.isArray(Q.secondaryTokens) &&
        Q.secondaryTokens.length &&
        x5(E, ee, Q).then((Ce) => {
          Um(E.label, ee, { secondaryTokens: Ce });
        }),
      te === null && ag(Y.id))
    ) {
      const Ce = m.find(({ id: ke }) => ke === ag(Y.id));
      ME(ee, Ce).then((ke) => {
        Um(E.label, ee, { ens: ke });
      });
    }
    he === null &&
      f &&
      LE(ee, Q).then((Ce) => {
        Um(E.label, ee, { uns: Ce });
      }),
      setTimeout(() => Wl.next({ inProgress: !1 }), 1500);
  }
  A.pipe(Lg(UO)).subscribe((fe) => {
    switch (fe) {
      case "selectingWallet": {
        if (l.label) {
          const z = d.find(
            ({ label: se }) => se.toLowerCase() === l.label.toLowerCase()
          );
          z ? O(z) : l.disableModals && Wl.next({ inProgress: !1 });
        } else n(8, (D = "")), I();
        break;
      }
      case "connectingWallet": {
        L();
        break;
      }
      case "connectedWallet": {
        n(8, (D = "")), U();
        break;
      }
    }
  });
  function $(fe) {
    g.next(), A.next(fe);
  }
  function B() {
    _ && _.scrollTo(0, 0);
  }
  const R =
    c.type === "mobile" && c.browser.name && c.browser.name === "Safari";
  function V() {
    n(4, (x = window.innerWidth));
  }
  function oe(fe) {
    (S = fe), n(7, S);
  }
  function le(fe) {
    w5[fe ? "unshift" : "push"](() => {
      (_ = fe), n(10, _);
    });
  }
  return (
    (t.$$set = (fe) => {
      "autoSelect" in fe && n(0, (l = fe.autoSelect));
    }),
    (t.$$.update = () => {
      t.$$.dirty[0] & 4 && n(12, (r = v.length - Jt.get().wallets.length)),
        t.$$.dirty[0] & 58 &&
          n(
            11,
            (i =
              (a === "connectingWallet" && E && x >= $i) ||
              (x <= $i && w && a === "connectingWallet" && E))
          );
    }),
    [
      l,
      w,
      v,
      E,
      x,
      a,
      y,
      S,
      D,
      P,
      _,
      i,
      r,
      s,
      o,
      u,
      p,
      A,
      N,
      M,
      k,
      L,
      $,
      R,
      V,
      oe,
      le,
    ]
  );
}
class c1e extends ss {
  constructor(e) {
    super(), is(this, e, u1e, l1e, ns, { autoSelect: 0 }, Z0e, [-1, -1]);
  }
}
function f1e(t) {
  rs(
    t,
    "svelte-12yam41",
    ".container.svelte-12yam41{padding:var(--onboard-spacing-4, var(--spacing-4));font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:16px;font-size:var(--onboard-font-size-5, var(--font-size-5))}.close.svelte-12yam41{top:var(--onboard-spacing-5, var(--spacing-5));right:var(--onboard-spacing-5, var(--spacing-5));padding:0.5rem}h4.svelte-12yam41{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:var(--onboard-spacing-4, var(--spacing-4)) 0}p.svelte-12yam41{margin:0 0 var(--onboard-spacing-4, var(--spacing-4)) 0;max-width:488px}"
  );
}
function d1e(t) {
  let e,
    n,
    r =
      t[0]("modals.switchChain.heading", {
        default: Cn.modals.switchChain.heading,
      }) + "",
    i,
    s,
    a,
    o =
      t[0]("modals.switchChain.paragraph1", {
        default: Cn.modals.switchChain.paragraph1,
        values: {
          app: (t[1] && t[1].name) || "This app",
          nextNetworkName: t[2],
        },
      }) + "",
    l,
    u,
    f,
    c =
      t[0]("modals.switchChain.paragraph2", {
        default: Cn.modals.switchChain.paragraph2,
      }) + "",
    d,
    p,
    m,
    g,
    w,
    y,
    v;
  return (
    (g = new _z({})),
    {
      c() {
        (e = Oe("div")),
          (n = Oe("h4")),
          (i = Ln(r)),
          (s = mt()),
          (a = Oe("p")),
          (l = Ln(o)),
          (u = mt()),
          (f = Oe("p")),
          (d = Ln(c)),
          (p = mt()),
          (m = Oe("div")),
          Bn(g.$$.fragment),
          be(n, "class", "svelte-12yam41"),
          be(a, "class", "svelte-12yam41"),
          be(f, "class", "svelte-12yam41"),
          be(m, "class", "close absolute svelte-12yam41"),
          be(e, "class", "container relative svelte-12yam41");
      },
      m(E, S) {
        Ge(E, e, S),
          _e(e, n),
          _e(n, i),
          _e(e, s),
          _e(e, a),
          _e(a, l),
          _e(e, u),
          _e(e, f),
          _e(f, d),
          _e(e, p),
          _e(e, m),
          Dn(g, m, null),
          (w = !0),
          y || ((v = ao(m, "click", t[3])), (y = !0));
      },
      p(E, S) {
        (!w || S & 1) &&
          r !==
            (r =
              E[0]("modals.switchChain.heading", {
                default: Cn.modals.switchChain.heading,
              }) + "") &&
          ir(i, r),
          (!w || S & 3) &&
            o !==
              (o =
                E[0]("modals.switchChain.paragraph1", {
                  default: Cn.modals.switchChain.paragraph1,
                  values: {
                    app: (E[1] && E[1].name) || "This app",
                    nextNetworkName: E[2],
                  },
                }) + "") &&
            ir(l, o),
          (!w || S & 1) &&
            c !==
              (c =
                E[0]("modals.switchChain.paragraph2", {
                  default: Cn.modals.switchChain.paragraph2,
                }) + "") &&
            ir(d, c);
      },
      i(E) {
        w || (Fe(g.$$.fragment, E), (w = !0));
      },
      o(E) {
        Ze(g.$$.fragment, E), (w = !1);
      },
      d(E) {
        E && ze(e), Rn(g), (y = !1), v();
      },
    }
  );
}
function h1e(t) {
  let e, n;
  return (
    (e = new hT({
      props: { close: t[3], $$slots: { default: [d1e] }, $$scope: { ctx: t } },
    })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, [i]) {
        const s = {};
        i & 67 && (s.$$scope = { dirty: i, ctx: r }), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function p1e(t, e, n) {
  let r, i, s;
  Xr(t, V0, (u) => n(5, (r = u))), Xr(t, ic, (u) => n(0, (i = u)));
  const a = r.chain.label;
  function o() {
    V0.next(null);
  }
  const l = state
    .select("appMetadata")
    .pipe(startWith(state.get().appMetadata), shareReplay(1));
  return Xr(t, l, (u) => n(1, (s = u))), [i, s, a, o, l];
}
class m1e extends ss {
  constructor(e) {
    super(), is(this, e, p1e, h1e, ns, {}, f1e);
  }
}
function g1e(t) {
  rs(
    t,
    "svelte-z54y2j",
    ".icon.svelte-z54y2j{border-radius:50px;color:var(--onboard-primary-500, var(--primary-500))}"
  );
}
function y1e(t) {
  let e, n;
  return {
    c() {
      (e = Oe("div")),
        be(e, "class", "icon flex svelte-z54y2j"),
        be(e, "style", (n = `width: ${t[0]}px; height: ${t[0]}px;`));
    },
    m(r, i) {
      Ge(r, e, i), (e.innerHTML = Uw);
    },
    p(r, [i]) {
      i & 1 &&
        n !== (n = `width: ${r[0]}px; height: ${r[0]}px;`) &&
        be(e, "style", n);
    },
    i: We,
    o: We,
    d(r) {
      r && ze(e);
    },
  };
}
function v1e(t, e, n) {
  let { size: r = 20 } = e;
  return (
    (t.$$set = (i) => {
      "size" in i && n(0, (r = i.size));
    }),
    [r]
  );
}
class b1e extends ss {
  constructor(e) {
    super(), is(this, e, v1e, y1e, ns, { size: 0 }, g1e);
  }
}
function w1e(t) {
  rs(
    t,
    "svelte-20hjq1",
    `.content.svelte-20hjq1{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px;background:var(
      --onboard-action-required-modal-background,
      var(--onboard-white, var(--white))
    )}.icon-container.svelte-20hjq1{width:3rem;height:3rem;background:var(--onboard-primary-100, var(--primary-100));border-radius:24px}h4.svelte-20hjq1{margin:1.5rem 0 0.5rem 0;font-weight:600}.action-required-heading.svelte-20hjq1,.action-required-info.svelte-20hjq1{color:var(
      --onboard-action-required-text-color,
      var(--onboard-black, inherit)
    )}.action-required-btn.svelte-20hjq1{color:var(
      --onboard-action-required-btn-text-color,
      var(--onboard-black, inherit)
    )}p.svelte-20hjq1{margin:0;font-weight:400}a.svelte-20hjq1{font-weight:600}button.svelte-20hjq1{margin-top:1.5rem;font-weight:600}`
  );
}
function lP(t) {
  let e,
    n =
      t[1]("modals.actionRequired.linkText", { values: { wallet: t[0] } }) + "",
    r;
  return {
    c() {
      (e = Oe("a")),
        (r = Ln(n)),
        be(
          e,
          "href",
          "https://metamask.zendesk.com/hc/en-us/articles/360061346311-Switching-accounts-in-MetaMask"
        ),
        be(e, "target", "_blank"),
        be(e, "rel", "noreferrer noopener"),
        be(e, "class", "svelte-20hjq1");
    },
    m(i, s) {
      Ge(i, e, s), _e(e, r);
    },
    p(i, s) {
      s & 3 &&
        n !==
          (n =
            i[1]("modals.actionRequired.linkText", {
              values: { wallet: i[0] },
            }) + "") &&
        ir(r, n);
    },
    d(i) {
      i && ze(e);
    },
  };
}
function _1e(t) {
  let e,
    n,
    r,
    i,
    s,
    a =
      t[1]("modals.actionRequired.heading", { values: { wallet: t[0] } }) + "",
    o,
    l,
    u,
    f =
      t[1]("modals.actionRequired.paragraph", { values: { wallet: t[0] } }) +
      "",
    c,
    d,
    p,
    m,
    g = t[1]("modals.actionRequired.buttonText") + "",
    w,
    y,
    v,
    E;
  r = new b1e({});
  let S = t[0] === "MetaMask" && lP(t);
  return {
    c() {
      (e = Oe("div")),
        (n = Oe("div")),
        Bn(r.$$.fragment),
        (i = mt()),
        (s = Oe("h4")),
        (o = Ln(a)),
        (l = mt()),
        (u = Oe("p")),
        (c = Ln(f)),
        (d = mt()),
        S && S.c(),
        (p = mt()),
        (m = Oe("button")),
        (w = Ln(g)),
        be(
          n,
          "class",
          "icon-container flex justify-center items-center svelte-20hjq1"
        ),
        be(s, "class", "action-required-heading svelte-20hjq1"),
        be(u, "class", "action-required-info svelte-20hjq1"),
        be(
          m,
          "class",
          "button-neutral-solid rounded action-required-btn svelte-20hjq1"
        ),
        be(e, "class", "content svelte-20hjq1");
    },
    m(D, P) {
      Ge(D, e, P),
        _e(e, n),
        Dn(r, n, null),
        _e(e, i),
        _e(e, s),
        _e(s, o),
        _e(e, l),
        _e(e, u),
        _e(u, c),
        _e(u, d),
        S && S.m(u, null),
        _e(e, p),
        _e(e, m),
        _e(m, w),
        (y = !0),
        v || ((E = ao(m, "click", t[2])), (v = !0));
    },
    p(D, P) {
      (!y || P & 3) &&
        a !==
          (a =
            D[1]("modals.actionRequired.heading", {
              values: { wallet: D[0] },
            }) + "") &&
        ir(o, a),
        (!y || P & 3) &&
          f !==
            (f =
              D[1]("modals.actionRequired.paragraph", {
                values: { wallet: D[0] },
              }) + "") &&
          ir(c, f),
        D[0] === "MetaMask"
          ? S
            ? S.p(D, P)
            : ((S = lP(D)), S.c(), S.m(u, null))
          : S && (S.d(1), (S = null)),
        (!y || P & 2) &&
          g !== (g = D[1]("modals.actionRequired.buttonText") + "") &&
          ir(w, g);
    },
    i(D) {
      y || (Fe(r.$$.fragment, D), (y = !0));
    },
    o(D) {
      Ze(r.$$.fragment, D), (y = !1);
    },
    d(D) {
      D && ze(e), Rn(r), S && S.d(), (v = !1), E();
    },
  };
}
function E1e(t) {
  let e, n;
  return (
    (e = new hT({
      props: { close: t[2], $$slots: { default: [_1e] }, $$scope: { ctx: t } },
    })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, [i]) {
        const s = {};
        i & 11 && (s.$$scope = { dirty: i, ctx: r }), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function x1e(t, e, n) {
  let r;
  Xr(t, ic, (a) => n(1, (r = a)));
  let { wallet: i } = e;
  function s() {
    Wl.next({ inProgress: !1, actionRequired: "" });
  }
  return (
    (t.$$set = (a) => {
      "wallet" in a && n(0, (i = a.wallet));
    }),
    [i, r, s]
  );
}
class T1e extends ss {
  constructor(e) {
    super(), is(this, e, x1e, E1e, ns, { wallet: 0 }, w1e);
  }
}
function S1e(t) {
  rs(
    t,
    "svelte-g9s19b",
    `.flex{display:flex}.inline-flex{display:inline-flex}.flex-column{flex-direction:column}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.justify-between{justify-content:space-between}.justify-end{justify-content:flex-end}.justify-around{justify-content:space-around}.relative{position:relative}.absolute{position:absolute}.fixed{position:fixed}.pointer{cursor:pointer}.shadow-1{box-shadow:var(--onboard-shadow-1, var(--shadow-1))}.w-100{width:100%}*{box-sizing:border-box}input{background:var(--onboard-white, var(--white))}input{width:100%;padding:0.5rem 1rem;outline:2px solid var(--onboard-gray-200, var(--gray-200));border:none;border-radius:8px;font-size:1rem;line-height:1.5;color:var(--onboard-gray-600, var(--gray-600));transition:all 200ms ease-in-out}input[type='checkbox']{-webkit-appearance:none;width:auto;background:var(--onboard-white, var(--white));outline:1px solid var(--onboard-gray-300, var(--gray-300));border:none;padding:0.5em;border-radius:3px;display:flex;justify-content:center;align-items:center;position:relative;cursor:pointer}input[type='checkbox']:hover{border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    )}input[type='checkbox']:checked{background:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input[type='checkbox']:checked:after{content:url("data:image/svg+xml,%3Csvg width='0.885em' height='0.6em' viewBox='0 0 14 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 6L5 11L14 2L12.59 0.58L5 8.17L1.41 4.59L0 6Z' fill='white'/%3E%3C/svg%3E");font-size:12px;position:absolute;color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input:hover{border-color:var(
      --onboard-checkbox-color,
      var(--onboard-white, var(--white))
    )}input:focus{border-color:var(--onboard-primary-500, var(--primary-500));box-shadow:0 0 1px 1px
      var(
        --onboard-checkbox-background,
        var(--onboard-primary-500, var(--primary-500))
      );box-shadow:0 0 0 1px -moz-mac-focusring}input:disabled, textarea:disabled, select:disabled{background:var(--gray-100)}input::-moz-focus-inner{outline:0;padding:0;margin-top:-2px;margin-bottom:-2px}a{color:var(
      --onboard-link-color,
      var(--onboard-primary-500, var(--primary-500))
    );text-decoration:none}a:hover{text-decoration:underline}button{display:flex;align-items:center;justify-content:center;padding:calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);border-radius:24px;cursor:pointer;font:inherit;border:none;transition:background-color 150ms ease-in-out, color 150ms ease-in-out}.onboard-button-primary{background:var(--onboard-white, var(--white));padding:calc(var(--onboard-spacing-5, var(--spacing-5)) - 1px)
      calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);color:var(--onboard-gray-500, var(--gray-500));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));border:1px solid var(--onboard-gray-500, var(--gray-500));font-weight:600}.button-neutral-solid{width:100%;border-radius:8px;background:var(--onboard-gray-500, var(--gray-500));color:var(--onboard-white, var(--white));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}.button-neutral-solid-b{width:100%;background:var(--onboard-gray-100, var(--gray-100));color:var(--onboard-gray-500, var(--gray-500));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}button.rounded{border-radius:24px}.button-neutral-solid:hover{background:var(--onboard-gray-700, var(--gray-700))}.button-neutral-solid-b:hover{background:var(--onboard-gray-200, var(--gray-200))}.button-neutral-solid:active{color:var(--onboard-gray-300, var(--gray-300))}.button-neutral-solid-b:active{color:var(--onboard-gray-600, var(--gray-600));background:var(--onboard-gray-300, var(--gray-300))}.container.svelte-g9s19b{padding:16px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));pointer-events:none;touch-action:none;width:100%}.z-indexed.svelte-g9s19b{z-index:var(--account-center-z-index)}@media all and (min-width: 428px){.container.svelte-g9s19b{max-width:348px}}`
  );
}
function uP(t) {
  let e, n;
  return (
    (e = new c1e({ props: { autoSelect: t[8].autoSelect } })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i & 256 && (s.autoSelect = r[8].autoSelect), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function cP(t) {
  let e, n;
  return (
    (e = new T1e({ props: { wallet: t[8].actionRequired } })),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i & 256 && (s.wallet = r[8].actionRequired), e.$set(s);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function fP(t) {
  let e, n;
  return (
    (e = new m1e({})),
    {
      c() {
        Bn(e.$$.fragment);
      },
      m(r, i) {
        Dn(e, r, i), (n = !0);
      },
      i(r) {
        n || (Fe(e.$$.fragment, r), (n = !0));
      },
      o(r) {
        Ze(e.$$.fragment, r), (n = !1);
      },
      d(r) {
        Rn(e, r);
      },
    }
  );
}
function dP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")),
        be(
          e,
          "class",
          "container flex flex-column fixed z-indexed svelte-g9s19b"
        ),
        be(
          e,
          "style",
          "top: 0; right: 0; " +
            (t[11].type === "mobile" ? "padding-bottom: 0;" : "")
        ),
        be(e, "id", "w3o-transaction-preview-container");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    p: We,
    d(n) {
      n && ze(e);
    },
  };
}
function hP(t) {
  let e,
    n =
      t[3].position.includes("bottom") &&
      t[1].position.includes("bottom") &&
      t[7],
    r,
    i = t[1].position.includes("bottom"),
    s,
    a,
    o,
    l = t[1].position.includes("top"),
    u,
    f = t[3].position.includes("top") && t[1].position.includes("top") && t[7],
    c,
    d,
    p = n && pP(t),
    m = i && mP(),
    g = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: D1e,
      then: P1e,
      catch: O1e,
      value: 23,
      blocks: [, , ,],
    };
  wh(t[16], g);
  let w = l && gP(),
    y = f && yP(t);
  return {
    c() {
      (e = Oe("div")),
        p && p.c(),
        (r = mt()),
        m && m.c(),
        (s = mt()),
        (a = Oe("div")),
        g.block.c(),
        (o = mt()),
        w && w.c(),
        (u = mt()),
        y && y.c(),
        be(a, "id", "account-center-with-notify"),
        be(
          e,
          "class",
          "container flex flex-column fixed z-indexed svelte-g9s19b"
        ),
        be(
          e,
          "style",
          (c =
            t[15](A5)[t[1].position] +
            "; " +
            (t[11].type === "mobile" && t[1].position.includes("top")
              ? "padding-bottom: 0;"
              : t[11].type === "mobile" && t[1].position.includes("bottom")
              ? "padding-top:0;"
              : ""))
        );
    },
    m(v, E) {
      Ge(v, e, E),
        p && p.m(e, null),
        _e(e, r),
        m && m.m(e, null),
        _e(e, s),
        _e(e, a),
        g.block.m(a, (g.anchor = null)),
        (g.mount = () => a),
        (g.anchor = null),
        _e(e, o),
        w && w.m(e, null),
        _e(e, u),
        y && y.m(e, null),
        (d = !0);
    },
    p(v, E) {
      (t = v),
        E & 138 &&
          (n =
            t[3].position.includes("bottom") &&
            t[1].position.includes("bottom") &&
            t[7]),
        n
          ? p
            ? (p.p(t, E), E & 138 && Fe(p, 1))
            : ((p = pP(t)), p.c(), Fe(p, 1), p.m(e, r))
          : p &&
            (jr(),
            Ze(p, 1, 1, () => {
              p = null;
            }),
            Hr()),
        E & 2 && (i = t[1].position.includes("bottom")),
        i ? m || ((m = mP()), m.c(), m.m(e, s)) : m && (m.d(1), (m = null)),
        _1(g, t, E),
        E & 2 && (l = t[1].position.includes("top")),
        l ? w || ((w = gP()), w.c(), w.m(e, u)) : w && (w.d(1), (w = null)),
        E & 138 &&
          (f =
            t[3].position.includes("top") &&
            t[1].position.includes("top") &&
            t[7]),
        f
          ? y
            ? (y.p(t, E), E & 138 && Fe(y, 1))
            : ((y = yP(t)), y.c(), Fe(y, 1), y.m(e, null))
          : y &&
            (jr(),
            Ze(y, 1, 1, () => {
              y = null;
            }),
            Hr()),
        (!d ||
          (E & 2 &&
            c !==
              (c =
                t[15](A5)[t[1].position] +
                "; " +
                (t[11].type === "mobile" && t[1].position.includes("top")
                  ? "padding-bottom: 0;"
                  : t[11].type === "mobile" && t[1].position.includes("bottom")
                  ? "padding-top:0;"
                  : "")))) &&
          be(e, "style", c);
    },
    i(v) {
      d || (Fe(p), Fe(g.block), Fe(y), (d = !0));
    },
    o(v) {
      Ze(p);
      for (let E = 0; E < 3; E += 1) {
        const S = g.blocks[E];
        Ze(S);
      }
      Ze(y), (d = !1);
    },
    d(v) {
      v && ze(e),
        p && p.d(),
        m && m.d(),
        g.block.d(),
        (g.token = null),
        (g = null),
        w && w.d(),
        y && y.d();
    },
  };
}
function pP(t) {
  let e,
    n,
    r = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: I1e,
      then: C1e,
      catch: A1e,
      value: 22,
      blocks: [, , ,],
    };
  return (
    wh(t[17], r),
    {
      c() {
        (e = xr()), r.block.c();
      },
      m(i, s) {
        Ge(i, e, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => e.parentNode),
          (r.anchor = e),
          (n = !0);
      },
      p(i, s) {
        (t = i), _1(r, t, s);
      },
      i(i) {
        n || (Fe(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const a = r.blocks[s];
          Ze(a);
        }
        n = !1;
      },
      d(i) {
        i && ze(e), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function A1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function C1e(t) {
  let e,
    n,
    r = t[22] && k1e(t);
  return {
    c() {
      r && r.c(), (e = xr());
    },
    m(i, s) {
      r && r.m(i, s), Ge(i, e, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Fe(r), (n = !0));
    },
    o(i) {
      Ze(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && ze(e);
    },
  };
}
function k1e(t) {
  let e, n, r;
  var i = t[22];
  function s(a) {
    return {
      props: {
        notifications: a[10],
        position: a[3].position,
        sharedContainer: a[0],
      },
    };
  }
  return (
    i && (e = Ju(i, s(t))),
    {
      c() {
        e && Bn(e.$$.fragment), (n = xr());
      },
      m(a, o) {
        e && Dn(e, a, o), Ge(a, n, o), (r = !0);
      },
      p(a, o) {
        const l = {};
        if (
          (o & 1024 && (l.notifications = a[10]),
          o & 8 && (l.position = a[3].position),
          o & 1 && (l.sharedContainer = a[0]),
          i !== (i = a[22]))
        ) {
          if (e) {
            jr();
            const u = e;
            Ze(u.$$.fragment, 1, 0, () => {
              Rn(u, 1);
            }),
              Hr();
          }
          i
            ? ((e = Ju(i, s(a))),
              Bn(e.$$.fragment),
              Fe(e.$$.fragment, 1),
              Dn(e, n.parentNode, n))
            : (e = null);
        } else i && e.$set(l);
      },
      i(a) {
        r || (e && Fe(e.$$.fragment, a), (r = !0));
      },
      o(a) {
        e && Ze(e.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(n), e && Rn(e, a);
      },
    }
  );
}
function I1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function mP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")),
        be(e, "id", "w3o-transaction-preview-container"),
        Mu(e, "margin-bottom", "8px");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function O1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function P1e(t) {
  let e,
    n,
    r = t[23] && N1e(t);
  return {
    c() {
      r && r.c(), (e = xr());
    },
    m(i, s) {
      r && r.m(i, s), Ge(i, e, s), (n = !0);
    },
    p(i, s) {
      i[23] && r.p(i, s);
    },
    i(i) {
      n || (Fe(r), (n = !0));
    },
    o(i) {
      Ze(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && ze(e);
    },
  };
}
function N1e(t) {
  let e, n, r;
  var i = t[23];
  function s(a) {
    return {};
  }
  return (
    i && (e = Ju(i, s())),
    {
      c() {
        e && Bn(e.$$.fragment), (n = xr());
      },
      m(a, o) {
        e && Dn(e, a, o), Ge(a, n, o), (r = !0);
      },
      p(a, o) {
        if (i !== (i = a[23])) {
          if (e) {
            jr();
            const l = e;
            Ze(l.$$.fragment, 1, 0, () => {
              Rn(l, 1);
            }),
              Hr();
          }
          i
            ? ((e = Ju(i, s())),
              Bn(e.$$.fragment),
              Fe(e.$$.fragment, 1),
              Dn(e, n.parentNode, n))
            : (e = null);
        }
      },
      i(a) {
        r || (e && Fe(e.$$.fragment, a), (r = !0));
      },
      o(a) {
        e && Ze(e.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(n), e && Rn(e, a);
      },
    }
  );
}
function D1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function gP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")),
        be(e, "id", "w3o-transaction-preview-container"),
        Mu(e, "margin-top", "8px");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function yP(t) {
  let e,
    n,
    r = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: B1e,
      then: M1e,
      catch: R1e,
      value: 22,
      blocks: [, , ,],
    };
  return (
    wh(t[17], r),
    {
      c() {
        (e = xr()), r.block.c();
      },
      m(i, s) {
        Ge(i, e, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => e.parentNode),
          (r.anchor = e),
          (n = !0);
      },
      p(i, s) {
        (t = i), _1(r, t, s);
      },
      i(i) {
        n || (Fe(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const a = r.blocks[s];
          Ze(a);
        }
        n = !1;
      },
      d(i) {
        i && ze(e), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function R1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function M1e(t) {
  let e,
    n,
    r = t[22] && L1e(t);
  return {
    c() {
      r && r.c(), (e = xr());
    },
    m(i, s) {
      r && r.m(i, s), Ge(i, e, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Fe(r), (n = !0));
    },
    o(i) {
      Ze(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && ze(e);
    },
  };
}
function L1e(t) {
  let e, n, r;
  var i = t[22];
  function s(a) {
    return {
      props: {
        notifications: a[10],
        position: a[3].position,
        sharedContainer: a[0],
      },
    };
  }
  return (
    i && (e = Ju(i, s(t))),
    {
      c() {
        e && Bn(e.$$.fragment), (n = xr());
      },
      m(a, o) {
        e && Dn(e, a, o), Ge(a, n, o), (r = !0);
      },
      p(a, o) {
        const l = {};
        if (
          (o & 1024 && (l.notifications = a[10]),
          o & 8 && (l.position = a[3].position),
          o & 1 && (l.sharedContainer = a[0]),
          i !== (i = a[22]))
        ) {
          if (e) {
            jr();
            const u = e;
            Ze(u.$$.fragment, 1, 0, () => {
              Rn(u, 1);
            }),
              Hr();
          }
          i
            ? ((e = Ju(i, s(a))),
              Bn(e.$$.fragment),
              Fe(e.$$.fragment, 1),
              Dn(e, n.parentNode, n))
            : (e = null);
        } else i && e.$set(l);
      },
      i(a) {
        r || (e && Fe(e.$$.fragment, a), (r = !0));
      },
      o(a) {
        e && Ze(e.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(n), e && Rn(e, a);
      },
    }
  );
}
function B1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function vP(t) {
  let e,
    n = t[1].position.includes("bottom"),
    r,
    i,
    s,
    a = t[1].position.includes("top"),
    o,
    l,
    u = n && bP(),
    f = t[1].enabled && t[2].length && wP(t),
    c = a && _P();
  return {
    c() {
      (e = Oe("div")),
        u && u.c(),
        (r = mt()),
        (i = Oe("div")),
        f && f.c(),
        (s = mt()),
        c && c.c(),
        be(
          e,
          "class",
          "container flex flex-column fixed z-indexed svelte-g9s19b"
        ),
        be(
          e,
          "style",
          (o =
            t[15](A5)[t[1].position] +
            "; " +
            (t[11].type === "mobile" && t[1].position.includes("top")
              ? "padding-bottom: 0;"
              : t[11].type === "mobile" && t[1].position.includes("bottom")
              ? "padding-top:0;"
              : ""))
        );
    },
    m(d, p) {
      Ge(d, e, p),
        u && u.m(e, null),
        _e(e, r),
        _e(e, i),
        f && f.m(i, null),
        _e(e, s),
        c && c.m(e, null),
        (l = !0);
    },
    p(d, p) {
      p & 2 && (n = d[1].position.includes("bottom")),
        n ? u || ((u = bP()), u.c(), u.m(e, r)) : u && (u.d(1), (u = null)),
        d[1].enabled && d[2].length
          ? f
            ? (f.p(d, p), p & 6 && Fe(f, 1))
            : ((f = wP(d)), f.c(), Fe(f, 1), f.m(i, null))
          : f &&
            (jr(),
            Ze(f, 1, 1, () => {
              f = null;
            }),
            Hr()),
        p & 2 && (a = d[1].position.includes("top")),
        a ? c || ((c = _P()), c.c(), c.m(e, null)) : c && (c.d(1), (c = null)),
        (!l ||
          (p & 2 &&
            o !==
              (o =
                d[15](A5)[d[1].position] +
                "; " +
                (d[11].type === "mobile" && d[1].position.includes("top")
                  ? "padding-bottom: 0;"
                  : d[11].type === "mobile" && d[1].position.includes("bottom")
                  ? "padding-top:0;"
                  : "")))) &&
          be(e, "style", o);
    },
    i(d) {
      l || (Fe(f), (l = !0));
    },
    o(d) {
      Ze(f), (l = !1);
    },
    d(d) {
      d && ze(e), u && u.d(), f && f.d(), c && c.d();
    },
  };
}
function bP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")),
        be(e, "id", "w3o-transaction-preview-container"),
        Mu(e, "margin-bottom", "8px");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function wP(t) {
  let e,
    n,
    r = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: j1e,
      then: $1e,
      catch: F1e,
      value: 23,
      blocks: [, , ,],
    };
  return (
    wh(t[16], r),
    {
      c() {
        (e = xr()), r.block.c();
      },
      m(i, s) {
        Ge(i, e, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => e.parentNode),
          (r.anchor = e),
          (n = !0);
      },
      p(i, s) {
        (t = i), _1(r, t, s);
      },
      i(i) {
        n || (Fe(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const a = r.blocks[s];
          Ze(a);
        }
        n = !1;
      },
      d(i) {
        i && ze(e), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function F1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function $1e(t) {
  let e,
    n,
    r = t[23] && U1e(t);
  return {
    c() {
      r && r.c(), (e = xr());
    },
    m(i, s) {
      r && r.m(i, s), Ge(i, e, s), (n = !0);
    },
    p(i, s) {
      i[23] && r.p(i, s);
    },
    i(i) {
      n || (Fe(r), (n = !0));
    },
    o(i) {
      Ze(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && ze(e);
    },
  };
}
function U1e(t) {
  let e, n, r;
  var i = t[23];
  function s(a) {
    return {};
  }
  return (
    i && (e = Ju(i, s())),
    {
      c() {
        e && Bn(e.$$.fragment), (n = xr());
      },
      m(a, o) {
        e && Dn(e, a, o), Ge(a, n, o), (r = !0);
      },
      p(a, o) {
        if (i !== (i = a[23])) {
          if (e) {
            jr();
            const l = e;
            Ze(l.$$.fragment, 1, 0, () => {
              Rn(l, 1);
            }),
              Hr();
          }
          i
            ? ((e = Ju(i, s())),
              Bn(e.$$.fragment),
              Fe(e.$$.fragment, 1),
              Dn(e, n.parentNode, n))
            : (e = null);
        }
      },
      i(a) {
        r || (e && Fe(e.$$.fragment, a), (r = !0));
      },
      o(a) {
        e && Ze(e.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(n), e && Rn(e, a);
      },
    }
  );
}
function j1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function _P(t) {
  let e;
  return {
    c() {
      (e = Oe("div")),
        be(e, "id", "w3o-transaction-preview-container"),
        Mu(e, "margin-top", "8px");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function EP(t) {
  let e,
    n = t[3].position.includes("top"),
    r,
    i,
    s = t[3].position.includes("bottom"),
    a,
    o,
    l = n && xP(),
    u = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: G1e,
      then: z1e,
      catch: H1e,
      value: 22,
      blocks: [, , ,],
    };
  wh(t[17], u);
  let f = s && TP();
  return {
    c() {
      (e = Oe("div")),
        l && l.c(),
        (r = mt()),
        u.block.c(),
        (i = mt()),
        f && f.c(),
        be(
          e,
          "class",
          "container flex flex-column fixed z-indexed svelte-g9s19b"
        ),
        be(
          e,
          "style",
          (a =
            t[15](SP)[t[3].position] +
            "; " +
            (t[11].type === "mobile" && t[3].position.includes("top")
              ? "padding-bottom: 0;"
              : t[11].type === "mobile" && t[3].position.includes("bottom")
              ? "padding-top:0;"
              : ""))
        );
    },
    m(c, d) {
      Ge(c, e, d),
        l && l.m(e, null),
        _e(e, r),
        u.block.m(e, (u.anchor = null)),
        (u.mount = () => e),
        (u.anchor = i),
        _e(e, i),
        f && f.m(e, null),
        (o = !0);
    },
    p(c, d) {
      (t = c),
        d & 8 && (n = t[3].position.includes("top")),
        n ? l || ((l = xP()), l.c(), l.m(e, r)) : l && (l.d(1), (l = null)),
        _1(u, t, d),
        d & 8 && (s = t[3].position.includes("bottom")),
        s ? f || ((f = TP()), f.c(), f.m(e, null)) : f && (f.d(1), (f = null)),
        (!o ||
          (d & 8 &&
            a !==
              (a =
                t[15](SP)[t[3].position] +
                "; " +
                (t[11].type === "mobile" && t[3].position.includes("top")
                  ? "padding-bottom: 0;"
                  : t[11].type === "mobile" && t[3].position.includes("bottom")
                  ? "padding-top:0;"
                  : "")))) &&
          be(e, "style", a);
    },
    i(c) {
      o || (Fe(u.block), (o = !0));
    },
    o(c) {
      for (let d = 0; d < 3; d += 1) {
        const p = u.blocks[d];
        Ze(p);
      }
      o = !1;
    },
    d(c) {
      c && ze(e),
        l && l.d(),
        u.block.d(),
        (u.token = null),
        (u = null),
        f && f.d();
    },
  };
}
function xP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")), be(e, "id", "w3o-transaction-preview-container");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function H1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function z1e(t) {
  let e,
    n,
    r = t[22] && V1e(t);
  return {
    c() {
      r && r.c(), (e = xr());
    },
    m(i, s) {
      r && r.m(i, s), Ge(i, e, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Fe(r), (n = !0));
    },
    o(i) {
      Ze(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && ze(e);
    },
  };
}
function V1e(t) {
  let e, n, r;
  var i = t[22];
  function s(a) {
    return {
      props: {
        notifications: a[10],
        position: a[3].position,
        sharedContainer: a[0],
      },
    };
  }
  return (
    i && (e = Ju(i, s(t))),
    {
      c() {
        e && Bn(e.$$.fragment), (n = xr());
      },
      m(a, o) {
        e && Dn(e, a, o), Ge(a, n, o), (r = !0);
      },
      p(a, o) {
        const l = {};
        if (
          (o & 1024 && (l.notifications = a[10]),
          o & 8 && (l.position = a[3].position),
          o & 1 && (l.sharedContainer = a[0]),
          i !== (i = a[22]))
        ) {
          if (e) {
            jr();
            const u = e;
            Ze(u.$$.fragment, 1, 0, () => {
              Rn(u, 1);
            }),
              Hr();
          }
          i
            ? ((e = Ju(i, s(a))),
              Bn(e.$$.fragment),
              Fe(e.$$.fragment, 1),
              Dn(e, n.parentNode, n))
            : (e = null);
        } else i && e.$set(l);
      },
      i(a) {
        r || (e && Fe(e.$$.fragment, a), (r = !0));
      },
      o(a) {
        e && Ze(e.$$.fragment, a), (r = !1);
      },
      d(a) {
        a && ze(n), e && Rn(e, a);
      },
    }
  );
}
function G1e(t) {
  return { c: We, m: We, p: We, i: We, o: We, d: We };
}
function TP(t) {
  let e;
  return {
    c() {
      (e = Oe("div")), be(e, "id", "w3o-transaction-preview-container");
    },
    m(n, r) {
      Ge(n, e, r);
    },
    d(n) {
      n && ze(e);
    },
  };
}
function W1e(t) {
  let e,
    n,
    r,
    i,
    s,
    a,
    o,
    l,
    u = t[8].inProgress && uP(t),
    f = t[8].actionRequired && cP(t),
    c = t[9] && fP(),
    d = !t[1].enabled && !t[3].enabled && dP(t),
    p = t[4] && hP(t),
    m = t[5] && vP(t),
    g = t[6] && EP(t);
  return {
    c() {
      u && u.c(),
        (e = mt()),
        f && f.c(),
        (n = mt()),
        c && c.c(),
        (r = mt()),
        d && d.c(),
        (i = mt()),
        p && p.c(),
        (s = mt()),
        m && m.c(),
        (a = mt()),
        g && g.c(),
        (o = xr());
    },
    m(w, y) {
      u && u.m(w, y),
        Ge(w, e, y),
        f && f.m(w, y),
        Ge(w, n, y),
        c && c.m(w, y),
        Ge(w, r, y),
        d && d.m(w, y),
        Ge(w, i, y),
        p && p.m(w, y),
        Ge(w, s, y),
        m && m.m(w, y),
        Ge(w, a, y),
        g && g.m(w, y),
        Ge(w, o, y),
        (l = !0);
    },
    p(w, [y]) {
      w[8].inProgress
        ? u
          ? (u.p(w, y), y & 256 && Fe(u, 1))
          : ((u = uP(w)), u.c(), Fe(u, 1), u.m(e.parentNode, e))
        : u &&
          (jr(),
          Ze(u, 1, 1, () => {
            u = null;
          }),
          Hr()),
        w[8].actionRequired
          ? f
            ? (f.p(w, y), y & 256 && Fe(f, 1))
            : ((f = cP(w)), f.c(), Fe(f, 1), f.m(n.parentNode, n))
          : f &&
            (jr(),
            Ze(f, 1, 1, () => {
              f = null;
            }),
            Hr()),
        w[9]
          ? c
            ? y & 512 && Fe(c, 1)
            : ((c = fP()), c.c(), Fe(c, 1), c.m(r.parentNode, r))
          : c &&
            (jr(),
            Ze(c, 1, 1, () => {
              c = null;
            }),
            Hr()),
        !w[1].enabled && !w[3].enabled
          ? d
            ? d.p(w, y)
            : ((d = dP(w)), d.c(), d.m(i.parentNode, i))
          : d && (d.d(1), (d = null)),
        w[4]
          ? p
            ? (p.p(w, y), y & 16 && Fe(p, 1))
            : ((p = hP(w)), p.c(), Fe(p, 1), p.m(s.parentNode, s))
          : p &&
            (jr(),
            Ze(p, 1, 1, () => {
              p = null;
            }),
            Hr()),
        w[5]
          ? m
            ? (m.p(w, y), y & 32 && Fe(m, 1))
            : ((m = vP(w)), m.c(), Fe(m, 1), m.m(a.parentNode, a))
          : m &&
            (jr(),
            Ze(m, 1, 1, () => {
              m = null;
            }),
            Hr()),
        w[6]
          ? g
            ? (g.p(w, y), y & 64 && Fe(g, 1))
            : ((g = EP(w)), g.c(), Fe(g, 1), g.m(o.parentNode, o))
          : g &&
            (jr(),
            Ze(g, 1, 1, () => {
              g = null;
            }),
            Hr());
    },
    i(w) {
      l || (Fe(u), Fe(f), Fe(c), Fe(p), Fe(m), Fe(g), (l = !0));
    },
    o(w) {
      Ze(u), Ze(f), Ze(c), Ze(p), Ze(m), Ze(g), (l = !1);
    },
    d(w) {
      u && u.d(w),
        w && ze(e),
        f && f.d(w),
        w && ze(n),
        c && c.d(w),
        w && ze(r),
        d && d.d(w),
        w && ze(i),
        p && p.d(w),
        w && ze(s),
        m && m.d(w),
        w && ze(a),
        g && g.d(w),
        w && ze(o);
    },
  };
}
const A5 = "account-center",
  SP = "notify-onboard-container";
function q1e(t, e, n) {
  let r, i, s, a, o, l, u, f, c, d, p, m;
  Xr(t, Ww, (A) => n(2, (f = A))),
    Xr(t, Wl, (A) => n(8, (d = A))),
    Xr(t, V0, (A) => n(9, (p = A)));
  const { device: g, containerElements: w } = so,
    y = Jt.select("accountCenter").pipe(Uc(Jt.get().accountCenter), Xc(1));
  Xr(t, y, (A) => n(1, (u = A)));
  const v = Jt.select("notify").pipe(Uc(Jt.get().notify), Xc(1));
  Xr(t, v, (A) => n(3, (c = A)));
  const E = Jt.select("notifications").pipe(Uc(Jt.get().notifications));
  Xr(t, E, (A) => n(10, (m = A)));
  const S = (A) => ({
      topLeft: `
        top: var(--${A}-position-top, 0); 
        left: var(--${A}-position-left, 0);`,
      topRight: `
        top: var(--${A}-position-top, 0); 
        right: var(--${A}-position-right, 0);`,
      bottomRight: `
        bottom: var(--${A}-position-bottom, 0); 
        right: var(--${A}-position-right, 0);`,
      bottomLeft: `
        bottom: var(--${A}-position-bottom, 0); 
        left: var(--${A}-position-left, 0);`,
    }),
    D = u.enabled
      ? qe(
          () => import("./Index-a8f5e52f-33863709.js"),
          [
            "assets/Index-a8f5e52f-33863709.js",
            "assets/merge-f9009254.js",
            "assets/skip-5d19e776.js",
          ]
        ).then((A) => A.default)
      : Promise.resolve(null),
    P = c.enabled
      ? qe(() => import("./Index-66e3b3f1-7364faa0.js"), []).then(
          (A) => A.default
        )
      : Promise.resolve(null),
    x = u.enabled && w && w.accountCenter,
    _ = (A, N, M, T) => {
      const O = A.attachShadow({ mode: "open" });
      let k = document.querySelector("onboard-v2").shadowRoot.styleSheets;
      const L = new CSSStyleSheet();
      Object.values(k).forEach((B) => {
        Object.values(B.cssRules).forEach((V) => L.insertRule(V.cssText));
      }),
        (O.adoptedStyleSheets = [L]);
      const U = document.querySelector(N);
      if ((U.appendChild(A), !U))
        throw new Error(`Element with query ${N} does not exist.`);
      (async () => {
        let B = await M;
        B && new B({ target: O, props: { settings: T, mountInContainer: !0 } });
      })();
    };
  if (x) {
    const A = document.createElement("onboard-account-center");
    _(A, x, D, u);
  }
  return (
    (t.$$.update = () => {
      t.$$.dirty & 10 &&
        n(0, (r = !x && u.enabled && c.enabled && c.position === u.position)),
        t.$$.dirty & 10 &&
          n(7, (i = g.type === "mobile" || u.position === c.position)),
        t.$$.dirty & 10 &&
          n(
            18,
            (s =
              (c.position.includes("bottom") &&
                u.position.includes("bottom")) ||
              (c.position.includes("top") && u.position.includes("top")))
          ),
        t.$$.dirty & 262158 &&
          n(
            6,
            (a =
              c.enabled &&
              (!u.enabled ||
                x ||
                (c.position !== u.position && g.type !== "mobile") ||
                (g.type === "mobile" && !s) ||
                !f.length))
          ),
        t.$$.dirty & 262158 &&
          n(
            5,
            (o =
              u.enabled &&
              (!c.enabled ||
                (c.position !== u.position && g.type !== "mobile") ||
                (g.type === "mobile" && !s)) &&
              f.length)
          ),
        t.$$.dirty & 262159 &&
          n(
            4,
            (l =
              c.enabled &&
              u.enabled &&
              (r || (g.type === "mobile" && s)) &&
              f.length)
          );
    }),
    [r, u, f, c, l, o, a, i, d, p, m, g, y, v, E, S, D, P, s]
  );
}
class K1e extends ss {
  constructor(e) {
    super(), is(this, e, q1e, W1e, ns, {}, S1e);
  }
}
let BE;
Jt.select("notifications").subscribe((t) => {
  BE = t;
});
async function X1e(t) {
  const e = Ghe(t);
  if (e) throw e;
  const {
      sendTransaction: n,
      estimateGas: r,
      gasPrice: i,
      balance: s,
      txDetails: a,
      txApproveReminderTimeout: o,
    } = t,
    l = o && o > 3e3 ? o : 15e3,
    [u, f] = await eme(r, i),
    c = Y1e(cj()),
    d = new gh((a && a.value) || 0);
  s && u && f && u.times(f).plus(d).gt(new gh(s)) && kp(pm("nsfFail", c));
  const p = BE.find((w) => w.eventCode === "txRequest");
  if (p) {
    const y = pm("txAwaitingApproval", p.id);
    kp(y);
  }
  if (
    (setTimeout(() => {
      const w = BE.find((y) => y.id === c && y.eventCode === "txRequest");
      if (w) {
        const v = pm("txConfirmReminder", w.id);
        kp(v);
      }
    }, l),
    kp(pm("txRequest", c)),
    !n)
  )
    return c;
  let g;
  try {
    g = await n();
  } catch (w) {
    const { eventCode: y, errorMsg: v } = J1e(w);
    kp(pm(y, c)), console.error(v);
    return;
  }
  if ((dz(c), g)) return g;
}
const pm = (t, e) => ({
    eventCode: t,
    type: bz(t),
    id: e,
    key: Z1e(e, t),
    message: Q1e(t),
    startTime: Date.now(),
    network: Object.keys(RO).find((n) => RO[n] === Jt.get().chains[0].id),
    autoDismiss: 0,
  }),
  Z1e = (t, e) => `${t}-${e}`,
  Y1e = (t) => `${t}-preflight`,
  Q1e = (t) => {
    const e = Cn.notify;
    return e.transaction, e.transaction[t];
  };
function J1e(t) {
  if (!t.stack || !t.message)
    return { eventCode: "txError", errorMsg: "An unknown error occured" };
  const e = t.stack || t.message;
  return e.includes("User denied transaction signature")
    ? { eventCode: "txSendFail", errorMsg: "User denied transaction signature" }
    : e.includes("transaction underpriced")
    ? { eventCode: "txUnderpriced", errorMsg: "Transaction is under priced" }
    : { eventCode: "txError", errorMsg: e };
}
const eme = async (t, e) => {
    if (!t || !e) return Promise.resolve([]);
    const n = t();
    if (!n.then)
      throw new Error("The `estimateGas` function must return a Promise");
    const r = e();
    if (!r.then)
      throw new Error("The `gasPrice` function must return a Promise");
    return Promise.all([n, r])
      .then(([i, s]) => {
        if (typeof i != "string")
          throw new Error(
            `The Promise returned from calling 'estimateGas' must resolve with a value of type 'string'. Received a value of: ${i} with a type: ${typeof i}`
          );
        if (typeof s != "string")
          throw new Error(
            `The Promise returned from calling 'gasPrice' must resolve with a value of type 'string'. Received a value of: ${s} with a type: ${typeof s}`
          );
        return [new gh(i), new gh(s)];
      })
      .catch((i) => {
        throw new Error(`There was an error getting gas estimates: ${i}`);
      });
  },
  lg = {
    connectWallet: ope,
    disconnectWallet: wz,
    setChain: Tpe,
    state: {
      get: Jt.get,
      select: Jt.select,
      actions: {
        setWalletModules: hz,
        setLocale: rpe,
        updateNotify: lb,
        customNotification: tpe,
        preflightNotifications: X1e,
        updateBalances: vz,
        updateAccountCenter: fz,
        setPrimaryWallet: Jhe,
        updateTheme: pz,
        updateAppMetadata: mz,
      },
    },
  };
function tme(t) {
  if (typeof window > "u") return lg;
  if (t) {
    const v = Mhe(t);
    if (v) throw v;
  }
  const {
    wallets: e,
    chains: n,
    appMetadata: r,
    i18n: i,
    accountCenter: s,
    apiKey: a,
    notify: o,
    gas: l,
    connect: u,
    containerElements: f,
    transactionPreview: c,
    theme: d,
    disableFontDownload: p,
    unstoppableResolution: m,
  } = t;
  f && MO({ containerElements: f });
  const { device: g, svelteInstance: w } = so;
  if (
    (w &&
      (console.warn(
        "Re-initializing Onboard and resetting back to initial state"
      ),
      uT.next()),
    Ape(i),
    Zhe(Pde(n)),
    typeof u !== void 0 && epe(u),
    typeof s < "u")
  ) {
    let v;
    const {
      hideTransactionProtectionBtn: E,
      transactionProtectionInfoLink: S,
    } = s;
    g.type === "mobile"
      ? (v = {
          ...Nf.accountCenter,
          hideTransactionProtectionBtn: E,
          transactionProtectionInfoLink: S,
          ...(s.mobile ? s.mobile : {}),
        })
      : s.desktop &&
        (v = {
          ...Nf.accountCenter,
          hideTransactionProtectionBtn: E,
          transactionProtectionInfoLink: S,
          ...s.desktop,
        }),
      fz(v);
  }
  if (typeof o < "u")
    if ("desktop" in o || "mobile" in o) {
      const v = Hhe(o);
      if (v) throw v;
      (!o.desktop || (o.desktop && !o.desktop.position)) &&
        s &&
        s.desktop &&
        s.desktop.position &&
        (o.desktop.position = s.desktop.position),
        (!o.mobile || (o.mobile && !o.mobile.position)) &&
          s &&
          s.mobile &&
          s.mobile.position &&
          (o.mobile.position = s.mobile.position);
      let E;
      g.type === "mobile" && o.mobile
        ? (E = { ...Nf.notify, ...o.mobile })
        : o.desktop && (E = { ...Nf.notify, ...o.desktop }),
        lb(E);
    } else {
      const v = cz(o);
      if (v) throw v;
      const E = { ...Nf.notify, ...o };
      lb(E);
    }
  else {
    const v = Nf.notify;
    lb(v);
  }
  const y = w || sme(d, p);
  if (
    (MO({
      svelteInstance: y,
      apiKey: a,
      initialWalletInit: e,
      gas: l,
      transactionPreview: c,
      unstoppableResolution: m,
    }),
    r && mz(r),
    a &&
      c &&
      (async () => (
        c.init({
          containerElement: "#w3o-transaction-preview-container",
          sdk: await xpe(),
          apiKey: a,
        }),
        Ww.subscribe((E) => {
          E.forEach(({ provider: S }) => {
            c.patchProvider(S);
          });
        })
      ))(),
    d && pz(d),
    u && (u.autoConnectLastWallet || u.autoConnectAllPreviousWallet))
  ) {
    const v = jw(Ku.LAST_CONNECTED_WALLET);
    try {
      const E = JSON.parse(v);
      E && Array.isArray(E) && E.length && ime(E, u);
    } catch (E) {
      E instanceof SyntaxError &&
        v &&
        lg.connectWallet({ autoSelect: { label: v, disableModals: !0 } });
    }
  }
  return lg;
}
const nme = (t, e) =>
    e ||
    (document.body &&
      (getComputedStyle(document.body).getPropertyValue(
        "--onboard-font-family-normal"
      ) ||
        getComputedStyle(document.body).getPropertyValue("--w3o-font-family")))
      ? !0
      : t
      ? !!(typeof t == "object" && t["--w3o-font-family"])
      : !1,
  rme = async () => {
    const { InterVar: t } = await qe(() => import("./index-89223ecf.js"), []),
      e = document.createElement("style");
    (e.innerHTML = `
    ${t}
  `),
      document.body.appendChild(e);
  },
  ime = async (t, e) => {
    const n = [],
      r = t;
    if (!e.autoConnectAllPreviousWallet)
      lg.connectWallet({ autoSelect: { label: r[0], disableModals: !0 } }),
        n.push(r[0]);
    else
      for (let i = r.length; i--; )
        (
          await lg.connectWallet({
            autoSelect: { label: r[i], disableModals: !0 },
          })
        ).some((a) => a.label === r[i]) && n.unshift(r[i]);
    Hw(Ku.LAST_CONNECTED_WALLET, JSON.stringify(n));
  };
function sme(t, e) {
  class n extends HTMLElement {
    constructor() {
      super();
    }
  }
  customElements.get("onboard-v2") || customElements.define("onboard-v2", n),
    nme(t, e) || rme();
  const r = document.createElement("onboard-v2"),
    i = r.attachShadow({ mode: "open" });
  (r.style.all = "initial"),
    (i.innerHTML = `

  <style>
    :host {
          /* COLORS */
          --white: white;
          --black: black;
          --primary-1: #2F80ED;
          --primary-100: #eff1fc;
          --primary-200: #d0d4f7;
          --primary-300: #b1b8f2;
          --primary-400: #929bed;
          --primary-500: #6370e5;
          --primary-600: #454ea0;
          --primary-700: #323873;
          --gray-100: #ebebed;
          --gray-200: #c2c4c9;
          --gray-300: #999ca5;
          --gray-400: #707481;
          --gray-500: #33394b;
          --gray-600: #242835;
          --gray-700: #1a1d26;
          --success-100: #d1fae3;
          --success-200: #baf7d5;
          --success-300: #a4f4c6;
          --success-400: #8df2b8;
          --success-500: #5aec99;
          --success-600: #18ce66;
          --success-700: #129b4d;
          --danger-100: #ffe5e6;
          --danger-200: #ffcccc;
          --danger-300: #ffb3b3;
          --danger-400: #ff8080;
          --danger-500: #ff4f4f;
          --danger-600: #cc0000;
          --danger-700: #660000;
          --warning-100: #ffefcc;
          --warning-200: #ffe7b3;
          --warning-300: #ffd780;
          --warning-400: #ffc74c;
          --warning-500: #ffaf00;
          --warning-600: #cc8c00;
          --warning-700: #664600;

          /* FONTS */
          --font-family-normal: var(--w3o-font-family, Inter, sans-serif);

          --font-size-1: 3rem;
          --font-size-2: 2.25rem;
          --font-size-3: 1.5rem;
          --font-size-4: 1.25rem;
          --font-size-5: 1rem;
          --font-size-6: .875rem;
          --font-size-7: .75rem;

          --font-line-height-1: 24px;
          --font-line-height-2: 20px;
          --font-line-height-3: 16px;
          --font-line-height-4: 12px;

          /* SPACING */
          --spacing-1: 3rem;
          --spacing-2: 2rem;
          --spacing-3: 1.5rem;
          --spacing-4: 1rem;
          --spacing-5: 0.5rem;
          --spacing-6: 0.25rem;
          --spacing-7: 0.125rem;

          /* BORDER RADIUS */
          --border-radius-1: 24px;
          --border-radius-2: 20px;
          --border-radius-3: 16px;
          --border-radius-4: 12px;
          --border-radius-5: 8px;

          /* SHADOWS */
          --shadow-0: none;
          --shadow-1: 0px 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-2: inset 0px -1px 0px rgba(0, 0, 0, 0.1);
          --shadow-3: 0px 4px 16px rgba(0, 0, 0, 0.2);

          /* MODAL POSITIONING */
          --modal-z-index: 10;
          --modal-top: unset;
          --modal-right: unset;
          --modal-bottom: unset;
          --modal-left: unset;

          /* MODAL STYLES */
          --modal-backdrop: rgba(0, 0, 0, 0.6);

        }
      </style>
    `);
  const a =
      so.containerElements.connectModal ||
      Jt.get().accountCenter.containerElement ||
      "body",
    o = document.querySelector(a);
  if (!o) throw new Error(`Element with query ${a} does not exist.`);
  return o.appendChild(r), new K1e({ target: i });
}
const ame =
  "Must call the provided initialization method`init` method before using hooks.";
let C5,
  Tz = !1;
const ome = (t) => ((C5 = tme(t)), C5),
  Sz = Z.createContext(void 0);
function lme({ children: t, web3Onboard: e }) {
  return (
    (Tz = !0), (C5 = void 0), Z.createElement(Sz.Provider, { value: e }, t)
  );
}
function mT() {
  const t = Tz ? Z.useContext(Sz) : C5;
  if (!t) throw new Error(ame);
  return t;
}
var Az = { exports: {} },
  Cz = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var G0 = Z;
function ume(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var cme = typeof Object.is == "function" ? Object.is : ume,
  fme = G0.useState,
  dme = G0.useEffect,
  hme = G0.useLayoutEffect,
  pme = G0.useDebugValue;
function mme(t, e) {
  var n = e(),
    r = fme({ inst: { value: n, getSnapshot: e } }),
    i = r[0].inst,
    s = r[1];
  return (
    hme(
      function () {
        (i.value = n), (i.getSnapshot = e), e8(i) && s({ inst: i });
      },
      [t, n, e]
    ),
    dme(
      function () {
        return (
          e8(i) && s({ inst: i }),
          t(function () {
            e8(i) && s({ inst: i });
          })
        );
      },
      [t]
    ),
    pme(n),
    n
  );
}
function e8(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !cme(t, n);
  } catch {
    return !0;
  }
}
function gme(t, e) {
  return e();
}
var yme =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? gme
    : mme;
Cz.useSyncExternalStore =
  G0.useSyncExternalStore !== void 0 ? G0.useSyncExternalStore : yme;
Az.exports = Cz;
var vme = Az.exports;
const kz = (t = void 0) => {
    const e = mT(),
      { select: n, get: r } = e.state,
      i = Z.useCallback(
        (o) => {
          const { unsubscribe: l } = t ? n(t).subscribe(o) : n().subscribe(o);
          return () => l;
        },
        [t]
      ),
      s = Z.useCallback(() => {
        const o = r();
        return t ? o[t] : o;
      }, [t]),
      a = () => s();
    return vme.useSyncExternalStore(i, s, a);
  },
  Iz = () => {
    const t = mT(),
      { connectWallet: e, disconnectWallet: n } = t,
      i = kz("wallets")[0] || null,
      [s, a] = Z.useState(!1),
      o = Z.useCallback(async (d) => {
        a(!0);
        const p = await e(d);
        return a(!1), p;
      }, []),
      l = Z.useCallback(async ({ label: d }) => {
        a(!0);
        const p = await n({ label: d });
        return a(!1), p;
      }, []),
      u = t.state.actions.updateBalances,
      f = t.state.actions.setWalletModules,
      c = t.state.actions.setPrimaryWallet;
    return [{ wallet: i, connecting: s }, o, l, u, f, c];
  },
  bme = (t) => {
    const e = mT(),
      { setChain: n } = e,
      { wallets: r, chains: i } = kz(),
      a = (() => {
        const f = t ? r.find(({ label: c }) => c === t) : r[0];
        return f && f.chains ? f.chains[0] : null;
      })(),
      [o, l] = Z.useState(!1),
      u = Z.useCallback(async (f) => {
        l(!0);
        const c = await n({ ...f, wallet: t });
        return l(!1), c;
      }, []);
    return [{ chains: i, connectedChain: a, settingChain: o }, u];
  },
  wme = "6.11.1";
function _me(t, e, n) {
  const r = e.split("|").map((s) => s.trim());
  for (let s = 0; s < r.length; s++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof t === e) return;
    }
  const i = new Error(`invalid value for type ${e}`);
  throw (
    ((i.code = "INVALID_ARGUMENT"),
    (i.argument = `value.${n}`),
    (i.value = t),
    i)
  );
}
async function ya(t) {
  const e = Object.keys(t);
  return (await Promise.all(e.map((r) => Promise.resolve(t[r])))).reduce(
    (r, i, s) => ((r[e[s]] = i), r),
    {}
  );
}
function nn(t, e, n) {
  for (let r in e) {
    let i = e[r];
    const s = n ? n[r] : null;
    s && _me(i, s, r),
      Object.defineProperty(t, r, { enumerable: !0, value: i, writable: !1 });
  }
}
function Xp(t) {
  if (t == null) return "null";
  if (Array.isArray(t)) return "[ " + t.map(Xp).join(", ") + " ]";
  if (t instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let n = "0x";
    for (let r = 0; r < t.length; r++) (n += e[t[r] >> 4]), (n += e[t[r] & 15]);
    return n;
  }
  if (typeof t == "object" && typeof t.toJSON == "function")
    return Xp(t.toJSON());
  switch (typeof t) {
    case "boolean":
    case "symbol":
      return t.toString();
    case "bigint":
      return BigInt(t).toString();
    case "number":
      return t.toString();
    case "string":
      return JSON.stringify(t);
    case "object": {
      const e = Object.keys(t);
      return (
        e.sort(), "{ " + e.map((n) => `${Xp(n)}: ${Xp(t[n])}`).join(", ") + " }"
      );
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function ra(t, e) {
  return t && t.code === e;
}
function gT(t) {
  return ra(t, "CALL_EXCEPTION");
}
function mi(t, e, n) {
  let r = t;
  {
    const s = [];
    if (n) {
      if ("message" in n || "code" in n || "name" in n)
        throw new Error(`value will overwrite populated values: ${Xp(n)}`);
      for (const a in n) {
        if (a === "shortMessage") continue;
        const o = n[a];
        s.push(a + "=" + Xp(o));
      }
    }
    s.push(`code=${e}`),
      s.push(`version=${wme}`),
      s.length && (t += " (" + s.join(", ") + ")");
  }
  let i;
  switch (e) {
    case "INVALID_ARGUMENT":
      i = new TypeError(t);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(t);
      break;
    default:
      i = new Error(t);
  }
  return (
    nn(i, { code: e }),
    n && Object.assign(i, n),
    i.shortMessage == null && nn(i, { shortMessage: r }),
    i
  );
}
function Ue(t, e, n, r) {
  if (!t) throw mi(e, n, r);
}
function ge(t, e, n, r) {
  Ue(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
}
function Oz(t, e, n) {
  n == null && (n = ""),
    n && (n = ": " + n),
    Ue(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
      count: t,
      expectedCount: e,
    }),
    Ue(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
      count: t,
      expectedCount: e,
    });
}
const Eme = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
  try {
    if ("test".normalize(e) !== "test") throw new Error("bad");
    if (e === "NFD") {
      const n = String.fromCharCode(233).normalize("NFD"),
        r = String.fromCharCode(101, 769);
      if (n !== r) throw new Error("broken");
    }
    t.push(e);
  } catch {}
  return t;
}, []);
function xme(t) {
  Ue(
    Eme.indexOf(t) >= 0,
    "platform missing String.prototype.normalize",
    "UNSUPPORTED_OPERATION",
    { operation: "String.prototype.normalize", info: { form: t } }
  );
}
function Oy(t, e, n) {
  if ((n == null && (n = ""), t !== e)) {
    let r = n,
      i = "new";
    n && ((r += "."), (i += " " + n)),
      Ue(
        !1,
        `private constructor; use ${r}from* methods`,
        "UNSUPPORTED_OPERATION",
        { operation: i }
      );
  }
}
function Pz(t, e, n) {
  if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
  if (typeof t == "string" && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((t.length - 2) / 2);
    let i = 2;
    for (let s = 0; s < r.length; s++)
      (r[s] = parseInt(t.substring(i, i + 2), 16)), (i += 2);
    return r;
  }
  ge(!1, "invalid BytesLike value", e || "value", t);
}
function er(t, e) {
  return Pz(t, e, !1);
}
function va(t, e) {
  return Pz(t, e, !0);
}
function Mr(t, e) {
  return !(
    typeof t != "string" ||
    !t.match(/^0x[0-9A-Fa-f]*$/) ||
    (typeof e == "number" && t.length !== 2 + 2 * e) ||
    (e === !0 && t.length % 2 !== 0)
  );
}
function Tme(t) {
  return Mr(t, !0) || t instanceof Uint8Array;
}
const AP = "0123456789abcdef";
function Gt(t) {
  const e = er(t);
  let n = "0x";
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    n += AP[(i & 240) >> 4] + AP[i & 15];
  }
  return n;
}
function Di(t) {
  return "0x" + t.map((e) => Gt(e).substring(2)).join("");
}
function h0(t) {
  return Mr(t, !0) ? (t.length - 2) / 2 : er(t).length;
}
function vi(t, e, n) {
  const r = er(t);
  return (
    n != null &&
      n > r.length &&
      Ue(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: r,
        length: r.length,
        offset: n,
      }),
    Gt(r.slice(e ?? 0, n ?? r.length))
  );
}
function Nz(t, e, n) {
  const r = er(t);
  Ue(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: e,
    offset: e + 1,
  });
  const i = new Uint8Array(e);
  return i.fill(0), n ? i.set(r, e - r.length) : i.set(r, 0), Gt(i);
}
function _h(t, e) {
  return Nz(t, e, !0);
}
function Sme(t, e) {
  return Nz(t, e, !1);
}
const qw = BigInt(0),
  Zl = BigInt(1),
  Zp = 9007199254740991;
function k5(t, e) {
  const n = Kw(t, "value"),
    r = BigInt(kn(e, "width"));
  if (
    (Ue(n >> r === qw, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: t,
    }),
    n >> (r - Zl))
  ) {
    const i = (Zl << r) - Zl;
    return -((~n & i) + Zl);
  }
  return n;
}
function Dz(t, e) {
  let n = Lt(t, "value");
  const r = BigInt(kn(e, "width")),
    i = Zl << (r - Zl);
  if (n < qw) {
    (n = -n),
      Ue(n <= i, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t,
      });
    const s = (Zl << r) - Zl;
    return (~n & s) + Zl;
  } else
    Ue(n < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t,
    });
  return n;
}
function Yd(t, e) {
  const n = Kw(t, "value"),
    r = BigInt(kn(e, "bits"));
  return n & ((Zl << r) - Zl);
}
function Lt(t, e) {
  switch (typeof t) {
    case "bigint":
      return t;
    case "number":
      return (
        ge(Number.isInteger(t), "underflow", e || "value", t),
        ge(t >= -Zp && t <= Zp, "overflow", e || "value", t),
        BigInt(t)
      );
    case "string":
      try {
        if (t === "") throw new Error("empty string");
        return t[0] === "-" && t[1] !== "-"
          ? -BigInt(t.substring(1))
          : BigInt(t);
      } catch (n) {
        ge(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t);
      }
  }
  ge(!1, "invalid BigNumberish value", e || "value", t);
}
function Kw(t, e) {
  const n = Lt(t, e);
  return (
    Ue(n >= qw, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value: t,
    }),
    n
  );
}
const CP = "0123456789abcdef";
function Xw(t) {
  if (t instanceof Uint8Array) {
    let e = "0x0";
    for (const n of t) (e += CP[n >> 4]), (e += CP[n & 15]);
    return BigInt(e);
  }
  return Lt(t);
}
function kn(t, e) {
  switch (typeof t) {
    case "bigint":
      return ge(t >= -Zp && t <= Zp, "overflow", e || "value", t), Number(t);
    case "number":
      return (
        ge(Number.isInteger(t), "underflow", e || "value", t),
        ge(t >= -Zp && t <= Zp, "overflow", e || "value", t),
        t
      );
    case "string":
      try {
        if (t === "") throw new Error("empty string");
        return kn(BigInt(t), e);
      } catch (n) {
        ge(!1, `invalid numeric string: ${n.message}`, e || "value", t);
      }
  }
  ge(!1, "invalid numeric value", e || "value", t);
}
function Ame(t) {
  return kn(Xw(t));
}
function ud(t, e) {
  let r = Kw(t, "value").toString(16);
  if (e == null) r.length % 2 && (r = "0" + r);
  else {
    const i = kn(e, "width");
    for (
      Ue(
        i * 2 >= r.length,
        `value exceeds width (${i} bytes)`,
        "NUMERIC_FAULT",
        { operation: "toBeHex", fault: "overflow", value: t }
      );
      r.length < i * 2;

    )
      r = "0" + r;
  }
  return "0x" + r;
}
function _a(t) {
  const e = Kw(t, "value");
  if (e === qw) return new Uint8Array([]);
  let n = e.toString(16);
  n.length % 2 && (n = "0" + n);
  const r = new Uint8Array(n.length / 2);
  for (let i = 0; i < r.length; i++) {
    const s = i * 2;
    r[i] = parseInt(n.substring(s, s + 2), 16);
  }
  return r;
}
function Qd(t) {
  let e = Gt(Tme(t) ? t : _a(t)).substring(2);
  for (; e.startsWith("0"); ) e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const kP = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const IP = BigInt(58);
function Cme(t) {
  const e = er(t);
  let n = Xw(e),
    r = "";
  for (; n; ) (r = kP[Number(n % IP)] + r), (n /= IP);
  for (let i = 0; i < e.length && !e[i]; i++) r = kP[0] + r;
  return r;
}
function kme(t) {
  t = atob(t);
  const e = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
  return er(e);
}
function Ime(t) {
  const e = er(t);
  let n = "";
  for (let r = 0; r < e.length; r++) n += String.fromCharCode(e[r]);
  return btoa(n);
}
class Rz {
  filter;
  emitter;
  #e;
  constructor(e, n, r) {
    (this.#e = n), nn(this, { emitter: e, filter: r });
  }
  async removeListener() {
    this.#e != null && (await this.emitter.off(this.filter, this.#e));
  }
}
function Ome(t, e, n, r, i) {
  ge(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
}
function Mz(t, e, n, r, i) {
  if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
    let s = 0;
    for (let a = e + 1; a < n.length && n[a] >> 6 === 2; a++) s++;
    return s;
  }
  return t === "OVERRUN" ? n.length - e - 1 : 0;
}
function Pme(t, e, n, r, i) {
  return t === "OVERLONG"
    ? (ge(
        typeof i == "number",
        "invalid bad code point for replacement",
        "badCodepoint",
        i
      ),
      r.push(i),
      0)
    : (r.push(65533), Mz(t, e, n));
}
const Nme = Object.freeze({ error: Ome, ignore: Mz, replace: Pme });
function Dme(t, e) {
  e == null && (e = Nme.error);
  const n = er(t, "bytes"),
    r = [];
  let i = 0;
  for (; i < n.length; ) {
    const s = n[i++];
    if (!(s >> 7)) {
      r.push(s);
      continue;
    }
    let a = null,
      o = null;
    if ((s & 224) === 192) (a = 1), (o = 127);
    else if ((s & 240) === 224) (a = 2), (o = 2047);
    else if ((s & 248) === 240) (a = 3), (o = 65535);
    else {
      (s & 192) === 128
        ? (i += e("UNEXPECTED_CONTINUE", i - 1, n, r))
        : (i += e("BAD_PREFIX", i - 1, n, r));
      continue;
    }
    if (i - 1 + a >= n.length) {
      i += e("OVERRUN", i - 1, n, r);
      continue;
    }
    let l = s & ((1 << (8 - a - 1)) - 1);
    for (let u = 0; u < a; u++) {
      let f = n[i];
      if ((f & 192) != 128) {
        (i += e("MISSING_CONTINUE", i, n, r)), (l = null);
        break;
      }
      (l = (l << 6) | (f & 63)), i++;
    }
    if (l !== null) {
      if (l > 1114111) {
        i += e("OUT_OF_RANGE", i - 1 - a, n, r, l);
        continue;
      }
      if (l >= 55296 && l <= 57343) {
        i += e("UTF16_SURROGATE", i - 1 - a, n, r, l);
        continue;
      }
      if (l <= o) {
        i += e("OVERLONG", i - 1 - a, n, r, l);
        continue;
      }
      r.push(l);
    }
  }
  return r;
}
function Hc(t, e) {
  ge(typeof t == "string", "invalid string value", "str", t),
    e != null && (xme(e), (t = t.normalize(e)));
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const i = t.charCodeAt(r);
    if (i < 128) n.push(i);
    else if (i < 2048) n.push((i >> 6) | 192), n.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = t.charCodeAt(r);
      ge(
        r < t.length && (s & 64512) === 56320,
        "invalid surrogate pair",
        "str",
        t
      );
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      n.push((a >> 18) | 240),
        n.push(((a >> 12) & 63) | 128),
        n.push(((a >> 6) & 63) | 128),
        n.push((a & 63) | 128);
    } else
      n.push((i >> 12) | 224),
        n.push(((i >> 6) & 63) | 128),
        n.push((i & 63) | 128);
  }
  return new Uint8Array(n);
}
function Rme(t) {
  return t
    .map((e) =>
      e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536),
          String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))
    )
    .join("");
}
function I5(t, e) {
  return Rme(Dme(t, e));
}
function Lz(t) {
  async function e(n, r) {
    const i = n.url.split(":")[0].toLowerCase();
    Ue(
      i === "http" || i === "https",
      `unsupported protocol ${i}`,
      "UNSUPPORTED_OPERATION",
      { info: { protocol: i }, operation: "request" }
    ),
      Ue(
        i === "https" || !n.credentials || n.allowInsecureAuthentication,
        "insecure authorized connections unsupported",
        "UNSUPPORTED_OPERATION",
        { operation: "request" }
      );
    let s;
    if (r) {
      const c = new AbortController();
      (s = c.signal),
        r.addListener(() => {
          c.abort();
        });
    }
    const a = {
        method: n.method,
        headers: new Headers(Array.from(n)),
        body: n.body || void 0,
        signal: s,
      },
      o = await fetch(n.url, a),
      l = {};
    o.headers.forEach((c, d) => {
      l[d.toLowerCase()] = c;
    });
    const u = await o.arrayBuffer(),
      f = u == null ? null : new Uint8Array(u);
    return {
      statusCode: o.status,
      statusMessage: o.statusText,
      headers: l,
      body: f,
    };
  }
  return e;
}
const Mme = 12,
  Lme = 250;
let OP = Lz();
const Bme = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
  Fme = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let t8 = !1;
async function Bz(t, e) {
  try {
    const n = t.match(Bme);
    if (!n) throw new Error("invalid data");
    return new nd(
      200,
      "OK",
      { "content-type": n[1] || "text/plain" },
      n[2] ? kme(n[3]) : Ume(n[3])
    );
  } catch {
    return new nd(599, "BAD REQUEST (invalid data: URI)", {}, null, new ec(t));
  }
}
function Fz(t) {
  async function e(n, r) {
    try {
      const i = n.match(Fme);
      if (!i) throw new Error("invalid link");
      return new ec(`${t}${i[2]}`);
    } catch {
      return new nd(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new ec(n));
    }
  }
  return e;
}
const dv = { data: Bz, ipfs: Fz("https://gateway.ipfs.io/ipfs/") },
  $z = new WeakMap();
class $me {
  #e;
  #t;
  constructor(e) {
    (this.#e = []),
      (this.#t = !1),
      $z.set(e, () => {
        if (!this.#t) {
          this.#t = !0;
          for (const n of this.#e)
            setTimeout(() => {
              n();
            }, 0);
          this.#e = [];
        }
      });
  }
  addListener(e) {
    Ue(!this.#t, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener",
    }),
      this.#e.push(e);
  }
  get cancelled() {
    return this.#t;
  }
  checkSignal() {
    Ue(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
function hv(t) {
  if (t == null) throw new Error("missing signal; should not happen");
  return t.checkSignal(), t;
}
class ec {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  #s;
  #o;
  #c;
  #u;
  #d;
  #h;
  #l;
  #f;
  #m;
  get url() {
    return this.#a;
  }
  set url(e) {
    this.#a = String(e);
  }
  get body() {
    return this.#s == null ? null : new Uint8Array(this.#s);
  }
  set body(e) {
    if (e == null) (this.#s = void 0), (this.#o = void 0);
    else if (typeof e == "string") (this.#s = Hc(e)), (this.#o = "text/plain");
    else if (e instanceof Uint8Array)
      (this.#s = e), (this.#o = "application/octet-stream");
    else if (typeof e == "object")
      (this.#s = Hc(JSON.stringify(e))), (this.#o = "application/json");
    else throw new Error("invalid body");
  }
  hasBody() {
    return this.#s != null;
  }
  get method() {
    return this.#r ? this.#r : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), (this.#r = String(e).toUpperCase());
  }
  get headers() {
    const e = Object.assign({}, this.#n);
    return (
      this.#c && (e.authorization = `Basic ${Ime(Hc(this.#c))}`),
      this.allowGzip && (e["accept-encoding"] = "gzip"),
      e["content-type"] == null && this.#o && (e["content-type"] = this.#o),
      this.body && (e["content-length"] = String(this.body.length)),
      e
    );
  }
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  setHeader(e, n) {
    this.#n[String(e).toLowerCase()] = String(n);
  }
  clearHeaders() {
    this.#n = {};
  }
  [Symbol.iterator]() {
    const e = this.headers,
      n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const i = n[r++];
          return { value: [i, e[i]], done: !1 };
        }
        return { value: void 0, done: !0 };
      },
    };
  }
  get credentials() {
    return this.#c || null;
  }
  setCredentials(e, n) {
    ge(
      !e.match(/:/),
      "invalid basic authentication username",
      "username",
      "[REDACTED]"
    ),
      (this.#c = `${e}:${n}`);
  }
  get allowGzip() {
    return this.#t;
  }
  set allowGzip(e) {
    this.#t = !!e;
  }
  get allowInsecureAuthentication() {
    return !!this.#e;
  }
  set allowInsecureAuthentication(e) {
    this.#e = !!e;
  }
  get timeout() {
    return this.#i;
  }
  set timeout(e) {
    ge(e >= 0, "timeout must be non-zero", "timeout", e), (this.#i = e);
  }
  get preflightFunc() {
    return this.#u || null;
  }
  set preflightFunc(e) {
    this.#u = e;
  }
  get processFunc() {
    return this.#d || null;
  }
  set processFunc(e) {
    this.#d = e;
  }
  get retryFunc() {
    return this.#h || null;
  }
  set retryFunc(e) {
    this.#h = e;
  }
  get getUrlFunc() {
    return this.#m || OP;
  }
  set getUrlFunc(e) {
    this.#m = e;
  }
  constructor(e) {
    (this.#a = String(e)),
      (this.#e = !1),
      (this.#t = !0),
      (this.#n = {}),
      (this.#r = ""),
      (this.#i = 3e5),
      (this.#f = { slotInterval: Lme, maxAttempts: Mme }),
      (this.#m = null);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(
      this.method
    )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
      this.headers
    )} body=${this.#s ? Gt(this.#s) : "null"}>`;
  }
  setThrottleParams(e) {
    e.slotInterval != null && (this.#f.slotInterval = e.slotInterval),
      e.maxAttempts != null && (this.#f.maxAttempts = e.maxAttempts);
  }
  async #p(e, n, r, i, s) {
    if (e >= this.#f.maxAttempts)
      return s.makeServerError("exceeded maximum retry limit");
    Ue(PP() <= n, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: i,
    }),
      r > 0 && (await jme(r));
    let a = this.clone();
    const o = (a.url.split(":")[0] || "").toLowerCase();
    if (o in dv) {
      const f = await dv[o](a.url, hv(i.#l));
      if (f instanceof nd) {
        let c = f;
        if (this.processFunc) {
          hv(i.#l);
          try {
            c = await this.processFunc(a, c);
          } catch (d) {
            (d.throttle == null || typeof d.stall != "number") &&
              c
                .makeServerError("error in post-processing function", d)
                .assertOk();
          }
        }
        return c;
      }
      a = f;
    }
    this.preflightFunc && (a = await this.preflightFunc(a));
    const l = await this.getUrlFunc(a, hv(i.#l));
    let u = new nd(l.statusCode, l.statusMessage, l.headers, l.body, i);
    if (u.statusCode === 301 || u.statusCode === 302) {
      try {
        const f = u.headers.location || "";
        return a.redirect(f).#p(e + 1, n, 0, i, u);
      } catch {}
      return u;
    } else if (
      u.statusCode === 429 &&
      (this.retryFunc == null || (await this.retryFunc(a, u, e)))
    ) {
      const f = u.headers["retry-after"];
      let c = this.#f.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return (
        typeof f == "string" && f.match(/^[1-9][0-9]*$/) && (c = parseInt(f)),
        a.clone().#p(e + 1, n, c, i, u)
      );
    }
    if (this.processFunc) {
      hv(i.#l);
      try {
        u = await this.processFunc(a, u);
      } catch (f) {
        (f.throttle == null || typeof f.stall != "number") &&
          u.makeServerError("error in post-processing function", f).assertOk();
        let c =
          this.#f.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
        return f.stall >= 0 && (c = f.stall), a.clone().#p(e + 1, n, c, i, u);
      }
    }
    return u;
  }
  send() {
    return (
      Ue(this.#l == null, "request already sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.send",
      }),
      (this.#l = new $me(this)),
      this.#p(0, PP() + this.timeout, 0, this, new nd(0, "", {}, null, this))
    );
  }
  cancel() {
    Ue(this.#l != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
      operation: "fetchRequest.cancel",
    });
    const e = $z.get(this);
    if (!e) throw new Error("missing signal; should not happen");
    e();
  }
  redirect(e) {
    const n = this.url.split(":")[0].toLowerCase(),
      r = e.split(":")[0].toLowerCase();
    Ue(
      this.method === "GET" &&
        (n !== "https" || r !== "http") &&
        e.match(/^https?:/),
      "unsupported redirect",
      "UNSUPPORTED_OPERATION",
      {
        operation: `redirect(${this.method} ${JSON.stringify(
          this.url
        )} => ${JSON.stringify(e)})`,
      }
    );
    const i = new ec(e);
    return (
      (i.method = "GET"),
      (i.allowGzip = this.allowGzip),
      (i.timeout = this.timeout),
      (i.#n = Object.assign({}, this.#n)),
      this.#s && (i.#s = new Uint8Array(this.#s)),
      (i.#o = this.#o),
      i
    );
  }
  clone() {
    const e = new ec(this.url);
    return (
      (e.#r = this.#r),
      this.#s && (e.#s = this.#s),
      (e.#o = this.#o),
      (e.#n = Object.assign({}, this.#n)),
      (e.#c = this.#c),
      this.allowGzip && (e.allowGzip = !0),
      (e.timeout = this.timeout),
      this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0),
      (e.#u = this.#u),
      (e.#d = this.#d),
      (e.#h = this.#h),
      (e.#m = this.#m),
      e
    );
  }
  static lockConfig() {
    t8 = !0;
  }
  static getGateway(e) {
    return dv[e.toLowerCase()] || null;
  }
  static registerGateway(e, n) {
    if (((e = e.toLowerCase()), e === "http" || e === "https"))
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (t8) throw new Error("gateways locked");
    dv[e] = n;
  }
  static registerGetUrl(e) {
    if (t8) throw new Error("gateways locked");
    OP = e;
  }
  static createGetUrlFunc(e) {
    return Lz();
  }
  static createDataGateway() {
    return Bz;
  }
  static createIpfsGatewayFunc(e) {
    return Fz(e);
  }
}
class nd {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${
      this.#r ? Gt(this.#r) : "null"
    }>`;
  }
  get statusCode() {
    return this.#e;
  }
  get statusMessage() {
    return this.#t;
  }
  get headers() {
    return Object.assign({}, this.#n);
  }
  get body() {
    return this.#r == null ? null : new Uint8Array(this.#r);
  }
  get bodyText() {
    try {
      return this.#r == null ? "" : I5(this.#r);
    } catch {
      Ue(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this },
      });
    }
  }
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      Ue(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this },
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers,
      n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const i = n[r++];
          return { value: [i, e[i]], done: !1 };
        }
        return { value: void 0, done: !0 };
      },
    };
  }
  constructor(e, n, r, i, s) {
    (this.#e = e),
      (this.#t = n),
      (this.#n = Object.keys(r).reduce(
        (a, o) => ((a[o.toLowerCase()] = String(r[o])), a),
        {}
      )),
      (this.#r = i == null ? null : new Uint8Array(i)),
      (this.#i = s || null),
      (this.#a = { message: "" });
  }
  makeServerError(e, n) {
    let r;
    e
      ? (r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})`)
      : ((e = `${this.statusCode} ${this.statusMessage}`),
        (r = `CLIENT ESCALATED SERVER ERROR (${e})`));
    const i = new nd(599, r, this.headers, this.body, this.#i || void 0);
    return (i.#a = { message: e, error: n }), i;
  }
  throwThrottleError(e, n) {
    n == null
      ? (n = -1)
      : ge(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
    const r = new Error(e || "throttling requests");
    throw (nn(r, { stall: n, throttle: !0 }), r);
  }
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  hasBody() {
    return this.#r != null;
  }
  get request() {
    return this.#i;
  }
  ok() {
    return (
      this.#a.message === "" && this.statusCode >= 200 && this.statusCode < 300
    );
  }
  assertOk() {
    if (this.ok()) return;
    let { message: e, error: n } = this.#a;
    e === "" &&
      (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let i = null;
    try {
      this.#r && (i = I5(this.#r));
    } catch {}
    Ue(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: n,
      info: {
        requestUrl: r,
        responseBody: i,
        responseStatus: `${this.statusCode} ${this.statusMessage}`,
      },
    });
  }
}
function PP() {
  return new Date().getTime();
}
function Ume(t) {
  return Hc(
    t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) =>
      String.fromCharCode(parseInt(n, 16))
    )
  );
}
function jme(t) {
  return new Promise((e) => setTimeout(e, t));
}
const Hme = BigInt(-1),
  jl = BigInt(0),
  Yp = BigInt(1),
  zme = BigInt(5),
  hp = {};
let p0 = "0000";
for (; p0.length < 80; ) p0 += p0;
function Md(t) {
  let e = p0;
  for (; e.length < t; ) e += e;
  return BigInt("1" + e.substring(0, t));
}
function mm(t, e, n) {
  const r = BigInt(e.width);
  if (e.signed) {
    const i = Yp << (r - Yp);
    Ue(n == null || (t >= -i && t < i), "overflow", "NUMERIC_FAULT", {
      operation: n,
      fault: "overflow",
      value: t,
    }),
      t > jl ? (t = k5(Yd(t, r), r)) : (t = -k5(Yd(-t, r), r));
  } else {
    const i = Yp << r;
    Ue(n == null || (t >= 0 && t < i), "overflow", "NUMERIC_FAULT", {
      operation: n,
      fault: "overflow",
      value: t,
    }),
      (t = ((t % i) + i) % i & (i - Yp));
  }
  return t;
}
function n8(t) {
  typeof t == "number" && (t = `fixed128x${t}`);
  let e = !0,
    n = 128,
    r = 18;
  if (typeof t == "string") {
    if (t !== "fixed")
      if (t === "ufixed") e = !1;
      else {
        const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        ge(s, "invalid fixed format", "format", t),
          (e = s[1] !== "u"),
          (n = parseInt(s[2])),
          (r = parseInt(s[3]));
      }
  } else if (t) {
    const s = t,
      a = (o, l, u) =>
        s[o] == null
          ? u
          : (ge(
              typeof s[o] === l,
              "invalid fixed format (" + o + " not " + l + ")",
              "format." + o,
              s[o]
            ),
            s[o]);
    (e = a("signed", "boolean", e)),
      (n = a("width", "number", n)),
      (r = a("decimals", "number", r));
  }
  ge(
    n % 8 === 0,
    "invalid FixedNumber width (not byte aligned)",
    "format.width",
    n
  ),
    ge(
      r <= 80,
      "invalid FixedNumber decimals (too large)",
      "format.decimals",
      r
    );
  const i = (e ? "" : "u") + "fixed" + String(n) + "x" + String(r);
  return { signed: e, width: n, decimals: r, name: i };
}
function Vme(t, e) {
  let n = "";
  t < jl && ((n = "-"), (t *= Hme));
  let r = t.toString();
  if (e === 0) return n + r;
  for (; r.length <= e; ) r = p0 + r;
  const i = r.length - e;
  for (
    r = r.substring(0, i) + "." + r.substring(i);
    r[0] === "0" && r[1] !== ".";

  )
    r = r.substring(1);
  for (; r[r.length - 1] === "0" && r[r.length - 2] !== "."; )
    r = r.substring(0, r.length - 1);
  return n + r;
}
class Nc {
  format;
  #e;
  #t;
  #n;
  _value;
  constructor(e, n, r) {
    Oy(e, hp, "FixedNumber"), (this.#t = n), (this.#e = r);
    const i = Vme(n, r.decimals);
    nn(this, { format: r.name, _value: i }), (this.#n = Md(r.decimals));
  }
  get signed() {
    return this.#e.signed;
  }
  get width() {
    return this.#e.width;
  }
  get decimals() {
    return this.#e.decimals;
  }
  get value() {
    return this.#t;
  }
  #r(e) {
    ge(
      this.format === e.format,
      "incompatible format; use fixedNumber.toFormat",
      "other",
      e
    );
  }
  #i(e, n) {
    return (e = mm(e, this.#e, n)), new Nc(hp, e, this.#e);
  }
  #a(e, n) {
    return this.#r(e), this.#i(this.#t + e.#t, n);
  }
  addUnsafe(e) {
    return this.#a(e);
  }
  add(e) {
    return this.#a(e, "add");
  }
  #s(e, n) {
    return this.#r(e), this.#i(this.#t - e.#t, n);
  }
  subUnsafe(e) {
    return this.#s(e);
  }
  sub(e) {
    return this.#s(e, "sub");
  }
  #o(e, n) {
    return this.#r(e), this.#i((this.#t * e.#t) / this.#n, n);
  }
  mulUnsafe(e) {
    return this.#o(e);
  }
  mul(e) {
    return this.#o(e, "mul");
  }
  mulSignal(e) {
    this.#r(e);
    const n = this.#t * e.#t;
    return (
      Ue(
        n % this.#n === jl,
        "precision lost during signalling mul",
        "NUMERIC_FAULT",
        { operation: "mulSignal", fault: "underflow", value: this }
      ),
      this.#i(n / this.#n, "mulSignal")
    );
  }
  #c(e, n) {
    return (
      Ue(e.#t !== jl, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this,
      }),
      this.#r(e),
      this.#i((this.#t * this.#n) / e.#t, n)
    );
  }
  divUnsafe(e) {
    return this.#c(e);
  }
  div(e) {
    return this.#c(e, "div");
  }
  divSignal(e) {
    Ue(e.#t !== jl, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this,
    }),
      this.#r(e);
    const n = this.#t * this.#n;
    return (
      Ue(
        n % e.#t === jl,
        "precision lost during signalling div",
        "NUMERIC_FAULT",
        { operation: "divSignal", fault: "underflow", value: this }
      ),
      this.#i(n / e.#t, "divSignal")
    );
  }
  cmp(e) {
    let n = this.value,
      r = e.value;
    const i = this.decimals - e.decimals;
    return (
      i > 0 ? (r *= Md(i)) : i < 0 && (n *= Md(-i)), n < r ? -1 : n > r ? 1 : 0
    );
  }
  eq(e) {
    return this.cmp(e) === 0;
  }
  lt(e) {
    return this.cmp(e) < 0;
  }
  lte(e) {
    return this.cmp(e) <= 0;
  }
  gt(e) {
    return this.cmp(e) > 0;
  }
  gte(e) {
    return this.cmp(e) >= 0;
  }
  floor() {
    let e = this.#t;
    return (
      this.#t < jl && (e -= this.#n - Yp),
      (e = (this.#t / this.#n) * this.#n),
      this.#i(e, "floor")
    );
  }
  ceiling() {
    let e = this.#t;
    return (
      this.#t > jl && (e += this.#n - Yp),
      (e = (this.#t / this.#n) * this.#n),
      this.#i(e, "ceiling")
    );
  }
  round(e) {
    if ((e == null && (e = 0), e >= this.decimals)) return this;
    const n = this.decimals - e,
      r = zme * Md(n - 1);
    let i = this.value + r;
    const s = Md(n);
    return (i = (i / s) * s), mm(i, this.#e, "round"), new Nc(hp, i, this.#e);
  }
  isZero() {
    return this.#t === jl;
  }
  isNegative() {
    return this.#t < jl;
  }
  toString() {
    return this._value;
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return Nc.fromString(this.toString(), e);
  }
  static fromValue(e, n, r) {
    const i = n == null ? 0 : kn(n),
      s = n8(r);
    let a = Lt(e, "value");
    const o = i - s.decimals;
    if (o > 0) {
      const l = Md(o);
      Ue(a % l === jl, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e,
      }),
        (a /= l);
    } else o < 0 && (a *= Md(-o));
    return mm(a, s, "fromValue"), new Nc(hp, a, s);
  }
  static fromString(e, n) {
    const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    ge(
      r && r[2].length + r[3].length > 0,
      "invalid FixedNumber string value",
      "value",
      e
    );
    const i = n8(n);
    let s = r[2] || "0",
      a = r[3] || "";
    for (; a.length < i.decimals; ) a += p0;
    Ue(
      a.substring(i.decimals).match(/^0*$/),
      "too many decimals for format",
      "NUMERIC_FAULT",
      { operation: "fromString", fault: "underflow", value: e }
    ),
      (a = a.substring(0, i.decimals));
    const o = BigInt(r[1] + s + a);
    return mm(o, i, "fromString"), new Nc(hp, o, i);
  }
  static fromBytes(e, n) {
    let r = Xw(er(e, "value"));
    const i = n8(n);
    return (
      i.signed && (r = k5(r, i.width)), mm(r, i, "fromBytes"), new Nc(hp, r, i)
    );
  }
}
function Gme(t) {
  let e = t.toString(16);
  for (; e.length < 2; ) e = "0" + e;
  return "0x" + e;
}
function NP(t, e, n) {
  let r = 0;
  for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
  return r;
}
function DP(t, e, n, r) {
  const i = [];
  for (; n < e + 1 + r; ) {
    const s = Uz(t, n);
    i.push(s.result),
      (n += s.consumed),
      Ue(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: r,
        offset: e,
      });
  }
  return { consumed: 1 + r, result: i };
}
function Uz(t, e) {
  Ue(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: t,
    length: 0,
    offset: 1,
  });
  const n = (r) => {
    Ue(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: t.length,
      offset: r,
    });
  };
  if (t[e] >= 248) {
    const r = t[e] - 247;
    n(e + 1 + r);
    const i = NP(t, e + 1, r);
    return n(e + 1 + r + i), DP(t, e, e + 1 + r, r + i);
  } else if (t[e] >= 192) {
    const r = t[e] - 192;
    return n(e + 1 + r), DP(t, e, e + 1, r);
  } else if (t[e] >= 184) {
    const r = t[e] - 183;
    n(e + 1 + r);
    const i = NP(t, e + 1, r);
    n(e + 1 + r + i);
    const s = Gt(t.slice(e + 1 + r, e + 1 + r + i));
    return { consumed: 1 + r + i, result: s };
  } else if (t[e] >= 128) {
    const r = t[e] - 128;
    n(e + 1 + r);
    const i = Gt(t.slice(e + 1, e + 1 + r));
    return { consumed: 1 + r, result: i };
  }
  return { consumed: 1, result: Gme(t[e]) };
}
function Zw(t) {
  const e = er(t, "data"),
    n = Uz(e, 0);
  return (
    ge(n.consumed === e.length, "unexpected junk after rlp payload", "data", t),
    n.result
  );
}
function RP(t) {
  const e = [];
  for (; t; ) e.unshift(t & 255), (t >>= 8);
  return e;
}
function jz(t) {
  if (Array.isArray(t)) {
    let r = [];
    if (
      (t.forEach(function (s) {
        r = r.concat(jz(s));
      }),
      r.length <= 55)
    )
      return r.unshift(192 + r.length), r;
    const i = RP(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  const e = Array.prototype.slice.call(er(t, "object"));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  const n = RP(e.length);
  return n.unshift(183 + n.length), n.concat(e);
}
const MP = "0123456789abcdef";
function W0(t) {
  let e = "0x";
  for (const n of jz(t)) (e += MP[n >> 4]), (e += MP[n & 15]);
  return e;
}
const Hz = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function Eh(t, e) {
  let n = 18;
  if (typeof e == "string") {
    const r = Hz.indexOf(e);
    ge(r >= 0, "invalid unit", "unit", e), (n = 3 * r);
  } else e != null && (n = kn(e, "unit"));
  return Nc.fromValue(t, n, { decimals: n, width: 512 }).toString();
}
function zz(t, e) {
  ge(typeof t == "string", "value must be a string", "value", t);
  let n = 18;
  if (typeof e == "string") {
    const r = Hz.indexOf(e);
    ge(r >= 0, "invalid unit", "unit", e), (n = 3 * r);
  } else e != null && (n = kn(e, "unit"));
  return Nc.fromString(t, { decimals: n, width: 512 }).value;
}
function ri(t) {
  return Eh(t, 18);
}
function kDe(t) {
  return zz(t, 18);
}
const Ea = 32,
  FE = new Uint8Array(Ea),
  Wme = ["then"],
  pv = {};
function gm(t, e) {
  const n = new Error(
    `deferred error during ABI decoding triggered accessing ${t}`
  );
  throw ((n.error = e), n);
}
class m0 extends Array {
  #e;
  constructor(...e) {
    const n = e[0];
    let r = e[1],
      i = (e[2] || []).slice(),
      s = !0;
    n !== pv && ((r = e), (i = []), (s = !1)),
      super(r.length),
      r.forEach((o, l) => {
        this[l] = o;
      });
    const a = i.reduce(
      (o, l) => (typeof l == "string" && o.set(l, (o.get(l) || 0) + 1), o),
      new Map()
    );
    if (
      ((this.#e = Object.freeze(
        r.map((o, l) => {
          const u = i[l];
          return u != null && a.get(u) === 1 ? u : null;
        })
      )),
      !!s)
    )
      return (
        Object.freeze(this),
        new Proxy(this, {
          get: (o, l, u) => {
            if (typeof l == "string") {
              if (l.match(/^[0-9]+$/)) {
                const c = kn(l, "%index");
                if (c < 0 || c >= this.length)
                  throw new RangeError("out of result range");
                const d = o[c];
                return d instanceof Error && gm(`index ${c}`, d), d;
              }
              if (Wme.indexOf(l) >= 0) return Reflect.get(o, l, u);
              const f = o[l];
              if (f instanceof Function)
                return function (...c) {
                  return f.apply(this === u ? o : this, c);
                };
              if (!(l in o))
                return o.getValue.apply(this === u ? o : this, [l]);
            }
            return Reflect.get(o, l, u);
          },
        })
      );
  }
  toArray() {
    const e = [];
    return (
      this.forEach((n, r) => {
        n instanceof Error && gm(`index ${r}`, n), e.push(n);
      }),
      e
    );
  }
  toObject() {
    return this.#e.reduce(
      (e, n, r) => (
        Ue(
          n != null,
          "value at index ${ index } unnamed",
          "UNSUPPORTED_OPERATION",
          { operation: "toObject()" }
        ),
        n in e || (e[n] = this.getValue(n)),
        e
      ),
      {}
    );
  }
  slice(e, n) {
    e == null && (e = 0),
      e < 0 && ((e += this.length), e < 0 && (e = 0)),
      n == null && (n = this.length),
      n < 0 && ((n += this.length), n < 0 && (n = 0)),
      n > this.length && (n = this.length);
    const r = [],
      i = [];
    for (let s = e; s < n; s++) r.push(this[s]), i.push(this.#e[s]);
    return new m0(pv, r, i);
  }
  filter(e, n) {
    const r = [],
      i = [];
    for (let s = 0; s < this.length; s++) {
      const a = this[s];
      a instanceof Error && gm(`index ${s}`, a),
        e.call(n, a, s, this) && (r.push(a), i.push(this.#e[s]));
    }
    return new m0(pv, r, i);
  }
  map(e, n) {
    const r = [];
    for (let i = 0; i < this.length; i++) {
      const s = this[i];
      s instanceof Error && gm(`index ${i}`, s), r.push(e.call(n, s, i, this));
    }
    return r;
  }
  getValue(e) {
    const n = this.#e.indexOf(e);
    if (n === -1) return;
    const r = this[n];
    return (
      r instanceof Error && gm(`property ${JSON.stringify(e)}`, r.error), r
    );
  }
  static fromItems(e, n) {
    return new m0(pv, e, n);
  }
}
function LP(t) {
  let e = _a(t);
  return (
    Ue(e.length <= Ea, "value out-of-bounds", "BUFFER_OVERRUN", {
      buffer: e,
      length: Ea,
      offset: e.length,
    }),
    e.length !== Ea && (e = va(Di([FE.slice(e.length % Ea), e]))),
    e
  );
}
class lf {
  name;
  type;
  localName;
  dynamic;
  constructor(e, n, r, i) {
    nn(
      this,
      { name: e, type: n, localName: r, dynamic: i },
      {
        name: "string",
        type: "string",
        localName: "string",
        dynamic: "boolean",
      }
    );
  }
  _throwError(e, n) {
    ge(!1, e, this.localName, n);
  }
}
class $E {
  #e;
  #t;
  constructor() {
    (this.#e = []), (this.#t = 0);
  }
  get data() {
    return Di(this.#e);
  }
  get length() {
    return this.#t;
  }
  #n(e) {
    return this.#e.push(e), (this.#t += e.length), e.length;
  }
  appendWriter(e) {
    return this.#n(va(e.data));
  }
  writeBytes(e) {
    let n = va(e);
    const r = n.length % Ea;
    return r && (n = va(Di([n, FE.slice(r)]))), this.#n(n);
  }
  writeValue(e) {
    return this.#n(LP(e));
  }
  writeUpdatableValue() {
    const e = this.#e.length;
    return (
      this.#e.push(FE),
      (this.#t += Ea),
      (n) => {
        this.#e[e] = LP(n);
      }
    );
  }
}
class yT {
  allowLoose;
  #e;
  #t;
  #n;
  #r;
  #i;
  constructor(e, n, r) {
    nn(this, { allowLoose: !!n }),
      (this.#e = va(e)),
      (this.#n = 0),
      (this.#r = null),
      (this.#i = r ?? 1024),
      (this.#t = 0);
  }
  get data() {
    return Gt(this.#e);
  }
  get dataLength() {
    return this.#e.length;
  }
  get consumed() {
    return this.#t;
  }
  get bytes() {
    return new Uint8Array(this.#e);
  }
  #a(e) {
    if (this.#r) return this.#r.#a(e);
    (this.#n += e),
      Ue(
        this.#i < 1 || this.#n <= this.#i * this.dataLength,
        `compressed ABI data exceeds inflation ratio of ${
          this.#i
        } ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
        "BUFFER_OVERRUN",
        {
          buffer: va(this.#e),
          offset: this.#t,
          length: e,
          info: { bytesRead: this.#n, dataLength: this.dataLength },
        }
      );
  }
  #s(e, n, r) {
    let i = Math.ceil(n / Ea) * Ea;
    return (
      this.#t + i > this.#e.length &&
        (this.allowLoose && r && this.#t + n <= this.#e.length
          ? (i = n)
          : Ue(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
              buffer: va(this.#e),
              length: this.#e.length,
              offset: this.#t + i,
            })),
      this.#e.slice(this.#t, this.#t + i)
    );
  }
  subReader(e) {
    const n = new yT(this.#e.slice(this.#t + e), this.allowLoose, this.#i);
    return (n.#r = this), n;
  }
  readBytes(e, n) {
    let r = this.#s(0, e, !!n);
    return this.#a(e), (this.#t += r.length), r.slice(0, e);
  }
  readValue() {
    return Xw(this.readBytes(Ea));
  }
  readIndex() {
    return Ame(this.readBytes(Ea));
  }
}
function O5(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function vT(t, ...e) {
  if (!(t instanceof Uint8Array)) throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      `Expected Uint8Array of length ${e}, not of length=${t.length}`
    );
}
function qme(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  O5(t.outputLen), O5(t.blockLen);
}
function q0(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Vz(t, e) {
  vT(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      `digestInto() expects output buffer of length at least ${n}`
    );
}
const r8 =
  typeof globalThis == "object" && "crypto" in globalThis
    ? globalThis.crypto
    : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Gz =
    (t) => t instanceof Uint8Array,
  Kme = (t) =>
    new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
  i8 = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
  Tu = (t, e) => (t << (32 - e)) | (t >>> e),
  Xme = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Xme) throw new Error("Non little-endian hardware is not supported");
function Zme(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Py(t) {
  if ((typeof t == "string" && (t = Zme(t)), !Gz(t)))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
function Yme(...t) {
  const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return (
    t.forEach((r) => {
      if (!Gz(r)) throw new Error("Uint8Array expected");
      e.set(r, n), (n += r.length);
    }),
    e
  );
}
class bT {
  clone() {
    return this._cloneInto();
  }
}
function Wz(t) {
  const e = (r) => t().update(Py(r)).digest(),
    n = t();
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = () => t()),
    e
  );
}
function Qme(t) {
  const e = (r, i) => t(i).update(Py(r)).digest(),
    n = t({});
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = (r) => t(r)),
    e
  );
}
function qz(t = 32) {
  if (r8 && typeof r8.getRandomValues == "function")
    return r8.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
let Kz = class extends bT {
  constructor(e, n) {
    super(), (this.finished = !1), (this.destroyed = !1), qme(e);
    const r = Py(n);
    if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? e.create().update(r).digest() : r);
    for (let a = 0; a < s.length; a++) s[a] ^= 54;
    this.iHash.update(s), (this.oHash = e.create());
    for (let a = 0; a < s.length; a++) s[a] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(e) {
    return q0(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    q0(this),
      vT(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: i,
      destroyed: s,
      blockLen: a,
      outputLen: o,
    } = this;
    return (
      (e = e),
      (e.finished = i),
      (e.destroyed = s),
      (e.blockLen = a),
      (e.outputLen = o),
      (e.oHash = n._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const Xz = (t, e, n) => new Kz(t, e).update(n).digest();
Xz.create = (t, e) => new Kz(t, e);
function Jme(t, e, n, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    a = Number((n >> i) & s),
    o = Number(n & s),
    l = r ? 4 : 0,
    u = r ? 0 : 4;
  t.setUint32(e + l, a, r), t.setUint32(e + u, o, r);
}
class ege extends bT {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = i8(this.buffer));
  }
  update(e) {
    q0(this);
    const { view: n, buffer: r, blockLen: i } = this;
    e = Py(e);
    const s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      if (o === i) {
        const l = i8(e);
        for (; i <= s - a; a += i) this.process(l, a);
        continue;
      }
      r.set(e.subarray(a, a + o), this.pos),
        (this.pos += o),
        (a += o),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    q0(this), Vz(e, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: a } = this;
    (n[a++] = 128),
      this.buffer.subarray(a).fill(0),
      this.padOffset > i - a && (this.process(r, 0), (a = 0));
    for (let c = a; c < i; c++) n[c] = 0;
    Jme(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const o = i8(e),
      l = this.outputLen;
    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = l / 4,
      f = this.get();
    if (u > f.length) throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++) o.setUint32(4 * c, f[c], s);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: a,
      pos: o,
    } = this;
    return (
      (e.length = i),
      (e.pos = o),
      (e.finished = s),
      (e.destroyed = a),
      i % n && e.buffer.set(r),
      e
    );
  }
}
const tge = (t, e, n) => (t & e) ^ (~t & n),
  nge = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
  rge = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Tf = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  Sf = new Uint32Array(64);
class ige extends ege {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Tf[0] | 0),
      (this.B = Tf[1] | 0),
      (this.C = Tf[2] | 0),
      (this.D = Tf[3] | 0),
      (this.E = Tf[4] | 0),
      (this.F = Tf[5] | 0),
      (this.G = Tf[6] | 0),
      (this.H = Tf[7] | 0);
  }
  get() {
    const { A: e, B: n, C: r, D: i, E: s, F: a, G: o, H: l } = this;
    return [e, n, r, i, s, a, o, l];
  }
  set(e, n, r, i, s, a, o, l) {
    (this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = a | 0),
      (this.G = o | 0),
      (this.H = l | 0);
  }
  process(e, n) {
    for (let c = 0; c < 16; c++, n += 4) Sf[c] = e.getUint32(n, !1);
    for (let c = 16; c < 64; c++) {
      const d = Sf[c - 15],
        p = Sf[c - 2],
        m = Tu(d, 7) ^ Tu(d, 18) ^ (d >>> 3),
        g = Tu(p, 17) ^ Tu(p, 19) ^ (p >>> 10);
      Sf[c] = (g + Sf[c - 7] + m + Sf[c - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: a, E: o, F: l, G: u, H: f } = this;
    for (let c = 0; c < 64; c++) {
      const d = Tu(o, 6) ^ Tu(o, 11) ^ Tu(o, 25),
        p = (f + d + tge(o, l, u) + rge[c] + Sf[c]) | 0,
        g = ((Tu(r, 2) ^ Tu(r, 13) ^ Tu(r, 22)) + nge(r, i, s)) | 0;
      (f = u),
        (u = l),
        (l = o),
        (o = (a + p) | 0),
        (a = s),
        (s = i),
        (i = r),
        (r = (p + g) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (a = (a + this.D) | 0),
      (o = (o + this.E) | 0),
      (l = (l + this.F) | 0),
      (u = (u + this.G) | 0),
      (f = (f + this.H) | 0),
      this.set(r, i, s, a, o, l, u, f);
  }
  roundClean() {
    Sf.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const P5 = Wz(() => new ige()),
  mv = BigInt(2 ** 32 - 1),
  BP = BigInt(32);
function sge(t, e = !1) {
  return e
    ? { h: Number(t & mv), l: Number((t >> BP) & mv) }
    : { h: Number((t >> BP) & mv) | 0, l: Number(t & mv) | 0 };
}
function age(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: a } = sge(t[i], e);
    [n[i], r[i]] = [s, a];
  }
  return [n, r];
}
const oge = (t, e, n) => (t << n) | (e >>> (32 - n)),
  lge = (t, e, n) => (e << n) | (t >>> (32 - n)),
  uge = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  cge = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  [Zz, Yz, Qz] = [[], [], []],
  fge = BigInt(0),
  ym = BigInt(1),
  dge = BigInt(2),
  hge = BigInt(7),
  pge = BigInt(256),
  mge = BigInt(113);
for (let t = 0, e = ym, n = 1, r = 0; t < 24; t++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    Zz.push(2 * (5 * r + n)),
    Yz.push((((t + 1) * (t + 2)) / 2) % 64);
  let i = fge;
  for (let s = 0; s < 7; s++)
    (e = ((e << ym) ^ ((e >> hge) * mge)) % pge),
      e & dge && (i ^= ym << ((ym << BigInt(s)) - ym));
  Qz.push(i);
}
const [gge, yge] = age(Qz, !0),
  FP = (t, e, n) => (n > 32 ? uge(t, e, n) : oge(t, e, n)),
  $P = (t, e, n) => (n > 32 ? cge(t, e, n) : lge(t, e, n));
function Jz(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let a = 0; a < 10; a++)
      n[a] = t[a] ^ t[a + 10] ^ t[a + 20] ^ t[a + 30] ^ t[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const o = (a + 8) % 10,
        l = (a + 2) % 10,
        u = n[l],
        f = n[l + 1],
        c = FP(u, f, 1) ^ n[o],
        d = $P(u, f, 1) ^ n[o + 1];
      for (let p = 0; p < 50; p += 10) (t[a + p] ^= c), (t[a + p + 1] ^= d);
    }
    let i = t[2],
      s = t[3];
    for (let a = 0; a < 24; a++) {
      const o = Yz[a],
        l = FP(i, s, o),
        u = $P(i, s, o),
        f = Zz[a];
      (i = t[f]), (s = t[f + 1]), (t[f] = l), (t[f + 1] = u);
    }
    for (let a = 0; a < 50; a += 10) {
      for (let o = 0; o < 10; o++) n[o] = t[a + o];
      for (let o = 0; o < 10; o++)
        t[a + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    (t[0] ^= gge[r]), (t[1] ^= yge[r]);
  }
  n.fill(0);
}
class Ny extends bT {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      O5(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = Kme(this.state));
  }
  keccak() {
    Jz(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(e) {
    q0(this);
    const { blockLen: n, state: r } = this;
    e = Py(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(n - this.pos, i - s);
      for (let o = 0; o < a; o++) r[this.pos++] ^= e[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: i } = this;
    (e[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (e[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    q0(this, !1), vT(e), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, s - i);
      e.set(n.subarray(this.posOut, this.posOut + a), i),
        (this.posOut += a),
        (i += a);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return O5(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((Vz(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: a,
    } = this;
    return (
      e || (e = new Ny(n, r, i, a, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = a),
      (e.destroyed = this.destroyed),
      e
    );
  }
}
const Ed = (t, e, n) => Wz(() => new Ny(e, t, n)),
  vge = Ed(6, 144, 224 / 8),
  bge = Ed(6, 136, 256 / 8),
  wge = Ed(6, 104, 384 / 8),
  _ge = Ed(6, 72, 512 / 8),
  Ege = Ed(1, 144, 224 / 8),
  eV = Ed(1, 136, 256 / 8),
  xge = Ed(1, 104, 384 / 8),
  Tge = Ed(1, 72, 512 / 8),
  tV = (t, e, n) =>
    Qme((r = {}) => new Ny(e, t, r.dkLen === void 0 ? n : r.dkLen, !0)),
  Sge = tV(31, 168, 128 / 8),
  Age = tV(31, 136, 256 / 8),
  ODe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Keccak: Ny,
        keccakP: Jz,
        keccak_224: Ege,
        keccak_256: eV,
        keccak_384: xge,
        keccak_512: Tge,
        sha3_224: vge,
        sha3_256: bge,
        sha3_384: wge,
        sha3_512: _ge,
        shake128: Sge,
        shake256: Age,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
let nV = !1;
const rV = function (t) {
  return eV(t);
};
let iV = rV;
function Zr(t) {
  const e = er(t, "data");
  return Gt(iV(e));
}
Zr._ = rV;
Zr.lock = function () {
  nV = !0;
};
Zr.register = function (t) {
  if (nV) throw new TypeError("keccak256 is locked");
  iV = t;
};
Object.freeze(Zr);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sV =
    BigInt(0),
  Yw = BigInt(1),
  Cge = BigInt(2),
  Qw = (t) => t instanceof Uint8Array,
  kge = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function K0(t) {
  if (!Qw(t)) throw new Error("Uint8Array expected");
  let e = "";
  for (let n = 0; n < t.length; n++) e += kge[t[n]];
  return e;
}
function aV(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function wT(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function X0(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length;
  if (e % 2)
    throw new Error(
      "padded hex string expected, got unpadded hex of length " + e
    );
  const n = new Uint8Array(e / 2);
  for (let r = 0; r < n.length; r++) {
    const i = r * 2,
      s = t.slice(i, i + 2),
      a = Number.parseInt(s, 16);
    if (Number.isNaN(a) || a < 0) throw new Error("Invalid byte sequence");
    n[r] = a;
  }
  return n;
}
function Aa(t) {
  return wT(K0(t));
}
function _T(t) {
  if (!Qw(t)) throw new Error("Uint8Array expected");
  return wT(K0(Uint8Array.from(t).reverse()));
}
function cd(t, e) {
  return X0(t.toString(16).padStart(e * 2, "0"));
}
function ET(t, e) {
  return cd(t, e).reverse();
}
function Ige(t) {
  return X0(aV(t));
}
function Ys(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = X0(e);
    } catch (s) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`);
    }
  else if (Qw(e)) r = Uint8Array.from(e);
  else throw new Error(`${t} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${t} expected ${n} bytes, got ${i}`);
  return r;
}
function ko(...t) {
  const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return (
    t.forEach((r) => {
      if (!Qw(r)) throw new Error("Uint8Array expected");
      e.set(r, n), (n += r.length);
    }),
    e
  );
}
function Oge(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Jw(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Pge(t) {
  let e;
  for (e = 0; t > sV; t >>= Yw, e += 1);
  return e;
}
function Nge(t, e) {
  return (t >> BigInt(e)) & Yw;
}
const Dge = (t, e, n) => t | ((n ? Yw : sV) << BigInt(e)),
  xT = (t) => (Cge << BigInt(t - 1)) - Yw,
  s8 = (t) => new Uint8Array(t),
  UP = (t) => Uint8Array.from(t);
function oV(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = s8(t),
    i = s8(t),
    s = 0;
  const a = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    o = (...c) => n(i, r, ...c),
    l = (c = s8()) => {
      (i = o(UP([0]), c)),
        (r = o()),
        c.length !== 0 && ((i = o(UP([1]), c)), (r = o()));
    },
    u = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let c = 0;
      const d = [];
      for (; c < e; ) {
        r = o();
        const p = r.slice();
        d.push(p), (c += r.length);
      }
      return ko(...d);
    };
  return (c, d) => {
    a(), l(c);
    let p;
    for (; !(p = d(u())); ) l();
    return a(), p;
  };
}
const Rge = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  stringOrUint8Array: (t) => typeof t == "string" || t instanceof Uint8Array,
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
};
function E1(t, e, n = {}) {
  const r = (i, s, a) => {
    const o = Rge[s];
    if (typeof o != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const l = t[i];
    if (!(a && l === void 0) && !o(l, t))
      throw new Error(
        `Invalid param ${String(i)}=${l} (${typeof l}), expected ${s}`
      );
  };
  for (const [i, s] of Object.entries(e)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return t;
}
const Mge = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      bitGet: Nge,
      bitLen: Pge,
      bitMask: xT,
      bitSet: Dge,
      bytesToHex: K0,
      bytesToNumberBE: Aa,
      bytesToNumberLE: _T,
      concatBytes: ko,
      createHmacDrbg: oV,
      ensureBytes: Ys,
      equalBytes: Oge,
      hexToBytes: X0,
      hexToNumber: wT,
      numberToBytesBE: cd,
      numberToBytesLE: ET,
      numberToHexUnpadded: aV,
      numberToVarBytesBE: Ige,
      utf8ToBytes: Jw,
      validateObject: E1,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ts =
    BigInt(0),
  Oi = BigInt(1),
  Wd = BigInt(2),
  Lge = BigInt(3),
  UE = BigInt(4),
  jP = BigInt(5),
  HP = BigInt(8);
BigInt(9);
BigInt(16);
function ws(t, e) {
  const n = t % e;
  return n >= Ts ? n : e + n;
}
function Bge(t, e, n) {
  if (n <= Ts || e < Ts) throw new Error("Expected power/modulo > 0");
  if (n === Oi) return Ts;
  let r = Oi;
  for (; e > Ts; ) e & Oi && (r = (r * t) % n), (t = (t * t) % n), (e >>= Oi);
  return r;
}
function nl(t, e, n) {
  let r = t;
  for (; e-- > Ts; ) (r *= r), (r %= n);
  return r;
}
function jE(t, e) {
  if (t === Ts || e <= Ts)
    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
  let n = ws(t, e),
    r = e,
    i = Ts,
    s = Oi;
  for (; n !== Ts; ) {
    const o = r / n,
      l = r % n,
      u = i - s * o;
    (r = n), (n = l), (i = s), (s = u);
  }
  if (r !== Oi) throw new Error("invert: does not exist");
  return ws(i, e);
}
function Fge(t) {
  const e = (t - Oi) / Wd;
  let n, r, i;
  for (n = t - Oi, r = 0; n % Wd === Ts; n /= Wd, r++);
  for (i = Wd; i < t && Bge(i, e, t) !== t - Oi; i++);
  if (r === 1) {
    const a = (t + Oi) / UE;
    return function (l, u) {
      const f = l.pow(u, a);
      if (!l.eql(l.sqr(f), u)) throw new Error("Cannot find square root");
      return f;
    };
  }
  const s = (n + Oi) / Wd;
  return function (o, l) {
    if (o.pow(l, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let u = r,
      f = o.pow(o.mul(o.ONE, i), n),
      c = o.pow(l, s),
      d = o.pow(l, n);
    for (; !o.eql(d, o.ONE); ) {
      if (o.eql(d, o.ZERO)) return o.ZERO;
      let p = 1;
      for (let g = o.sqr(d); p < u && !o.eql(g, o.ONE); p++) g = o.sqr(g);
      const m = o.pow(f, Oi << BigInt(u - p - 1));
      (f = o.sqr(m)), (c = o.mul(c, m)), (d = o.mul(d, f)), (u = p);
    }
    return c;
  };
}
function $ge(t) {
  if (t % UE === Lge) {
    const e = (t + Oi) / UE;
    return function (r, i) {
      const s = r.pow(i, e);
      if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (t % HP === jP) {
    const e = (t - jP) / HP;
    return function (r, i) {
      const s = r.mul(i, Wd),
        a = r.pow(s, e),
        o = r.mul(i, a),
        l = r.mul(r.mul(o, Wd), a),
        u = r.mul(o, r.sub(l, r.ONE));
      if (!r.eql(r.sqr(u), i)) throw new Error("Cannot find square root");
      return u;
    };
  }
  return Fge(t);
}
const Uge = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function lV(t) {
  const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = Uge.reduce((r, i) => ((r[i] = "function"), r), e);
  return E1(t, n);
}
function jge(t, e, n) {
  if (n < Ts) throw new Error("Expected power > 0");
  if (n === Ts) return t.ONE;
  if (n === Oi) return e;
  let r = t.ONE,
    i = e;
  for (; n > Ts; ) n & Oi && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= Oi);
  return r;
}
function Hge(t, e) {
  const n = new Array(e.length),
    r = e.reduce(
      (s, a, o) => (t.is0(a) ? s : ((n[o] = s), t.mul(s, a))),
      t.ONE
    ),
    i = t.inv(r);
  return (
    e.reduceRight(
      (s, a, o) => (t.is0(a) ? s : ((n[o] = t.mul(s, n[o])), t.mul(s, a))),
      i
    ),
    n
  );
}
function uV(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function zge(t, e, n = !1, r = {}) {
  if (t <= Ts) throw new Error(`Expected Field ORDER > 0, got ${t}`);
  const { nBitLength: i, nByteLength: s } = uV(t, e);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = $ge(t),
    o = Object.freeze({
      ORDER: t,
      BITS: i,
      BYTES: s,
      MASK: xT(i),
      ZERO: Ts,
      ONE: Oi,
      create: (l) => ws(l, t),
      isValid: (l) => {
        if (typeof l != "bigint")
          throw new Error(
            `Invalid field element: expected bigint, got ${typeof l}`
          );
        return Ts <= l && l < t;
      },
      is0: (l) => l === Ts,
      isOdd: (l) => (l & Oi) === Oi,
      neg: (l) => ws(-l, t),
      eql: (l, u) => l === u,
      sqr: (l) => ws(l * l, t),
      add: (l, u) => ws(l + u, t),
      sub: (l, u) => ws(l - u, t),
      mul: (l, u) => ws(l * u, t),
      pow: (l, u) => jge(o, l, u),
      div: (l, u) => ws(l * jE(u, t), t),
      sqrN: (l) => l * l,
      addN: (l, u) => l + u,
      subN: (l, u) => l - u,
      mulN: (l, u) => l * u,
      inv: (l) => jE(l, t),
      sqrt: r.sqrt || ((l) => a(o, l)),
      invertBatch: (l) => Hge(o, l),
      cmov: (l, u, f) => (f ? u : l),
      toBytes: (l) => (n ? ET(l, s) : cd(l, s)),
      fromBytes: (l) => {
        if (l.length !== s)
          throw new Error(`Fp.fromBytes: expected ${s}, got ${l.length}`);
        return n ? _T(l) : Aa(l);
      },
    });
  return Object.freeze(o);
}
function cV(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function fV(t) {
  const e = cV(t);
  return e + Math.ceil(e / 2);
}
function Vge(t, e, n = !1) {
  const r = t.length,
    i = cV(e),
    s = fV(e);
  if (r < 16 || r < s || r > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const a = n ? Aa(t) : _T(t),
    o = ws(a, e - Oi) + Oi;
  return n ? ET(o, i) : cd(o, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Gge =
    BigInt(0),
  a8 = BigInt(1);
function Wge(t, e) {
  const n = (i, s) => {
      const a = s.negate();
      return i ? a : s;
    },
    r = (i) => {
      const s = Math.ceil(e / i) + 1,
        a = 2 ** (i - 1);
      return { windows: s, windowSize: a };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(i, s) {
      let a = t.ZERO,
        o = i;
      for (; s > Gge; ) s & a8 && (a = a.add(o)), (o = o.double()), (s >>= a8);
      return a;
    },
    precomputeWindow(i, s) {
      const { windows: a, windowSize: o } = r(s),
        l = [];
      let u = i,
        f = u;
      for (let c = 0; c < a; c++) {
        (f = u), l.push(f);
        for (let d = 1; d < o; d++) (f = f.add(u)), l.push(f);
        u = f.double();
      }
      return l;
    },
    wNAF(i, s, a) {
      const { windows: o, windowSize: l } = r(i);
      let u = t.ZERO,
        f = t.BASE;
      const c = BigInt(2 ** i - 1),
        d = 2 ** i,
        p = BigInt(i);
      for (let m = 0; m < o; m++) {
        const g = m * l;
        let w = Number(a & c);
        (a >>= p), w > l && ((w -= d), (a += a8));
        const y = g,
          v = g + Math.abs(w) - 1,
          E = m % 2 !== 0,
          S = w < 0;
        w === 0 ? (f = f.add(n(E, s[y]))) : (u = u.add(n(S, s[v])));
      }
      return { p: u, f };
    },
    wNAFCached(i, s, a, o) {
      const l = i._WINDOW_SIZE || 1;
      let u = s.get(i);
      return (
        u || ((u = this.precomputeWindow(i, l)), l !== 1 && s.set(i, o(u))),
        this.wNAF(l, u, a)
      );
    },
  };
}
function dV(t) {
  return (
    lV(t.Fp),
    E1(
      t,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze({ ...uV(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function qge(
  t
) {
  const e = dV(t);
  E1(
    e,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    }
  );
  const { endo: n, Fp: r, a: i } = e;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error(
        "Endomorphism can only be defined for Koblitz curves that have a=0"
      );
    if (
      typeof n != "object" ||
      typeof n.beta != "bigint" ||
      typeof n.splitScalar != "function"
    )
      throw new Error(
        "Expected endomorphism with beta: bigint and splitScalar: function"
      );
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: Kge, hexToBytes: Xge } = Mge,
  Jd = {
    Err: class extends Error {
      constructor(e = "") {
        super(e);
      }
    },
    _parseInt(t) {
      const { Err: e } = Jd;
      if (t.length < 2 || t[0] !== 2)
        throw new e("Invalid signature integer tag");
      const n = t[1],
        r = t.subarray(2, n + 2);
      if (!n || r.length !== n)
        throw new e("Invalid signature integer: wrong length");
      if (r[0] & 128) throw new e("Invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new e("Invalid signature integer: unnecessary leading zero");
      return { d: Kge(r), l: t.subarray(n + 2) };
    },
    toSig(t) {
      const { Err: e } = Jd,
        n = typeof t == "string" ? Xge(t) : t;
      if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
      let r = n.length;
      if (r < 2 || n[0] != 48) throw new e("Invalid signature tag");
      if (n[1] !== r - 2) throw new e("Invalid signature: incorrect length");
      const { d: i, l: s } = Jd._parseInt(n.subarray(2)),
        { d: a, l: o } = Jd._parseInt(s);
      if (o.length) throw new e("Invalid signature: left bytes after parsing");
      return { r: i, s: a };
    },
    hexFromSig(t) {
      const e = (u) => (Number.parseInt(u[0], 16) & 8 ? "00" + u : u),
        n = (u) => {
          const f = u.toString(16);
          return f.length & 1 ? `0${f}` : f;
        },
        r = e(n(t.s)),
        i = e(n(t.r)),
        s = r.length / 2,
        a = i.length / 2,
        o = n(s),
        l = n(a);
      return `30${n(a + s + 4)}02${l}${i}02${o}${r}`;
    },
  },
  Yl = BigInt(0),
  bi = BigInt(1),
  Af = BigInt(2),
  N5 = BigInt(3),
  zP = BigInt(4);
function Zge(t) {
  const e = qge(t),
    { Fp: n } = e,
    r =
      e.toBytes ||
      ((m, g, w) => {
        const y = g.toAffine();
        return ko(Uint8Array.from([4]), n.toBytes(y.x), n.toBytes(y.y));
      }),
    i =
      e.fromBytes ||
      ((m) => {
        const g = m.subarray(1),
          w = n.fromBytes(g.subarray(0, n.BYTES)),
          y = n.fromBytes(g.subarray(n.BYTES, 2 * n.BYTES));
        return { x: w, y };
      });
  function s(m) {
    const { a: g, b: w } = e,
      y = n.sqr(m),
      v = n.mul(y, m);
    return n.add(n.add(v, n.mul(m, g)), w);
  }
  if (!n.eql(n.sqr(e.Gy), s(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(m) {
    return typeof m == "bigint" && Yl < m && m < e.n;
  }
  function o(m) {
    if (!a(m)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function l(m) {
    const {
      allowedPrivateKeyLengths: g,
      nByteLength: w,
      wrapPrivateKey: y,
      n: v,
    } = e;
    if (g && typeof m != "bigint") {
      if (
        (m instanceof Uint8Array && (m = K0(m)),
        typeof m != "string" || !g.includes(m.length))
      )
        throw new Error("Invalid key");
      m = m.padStart(w * 2, "0");
    }
    let E;
    try {
      E = typeof m == "bigint" ? m : Aa(Ys("private key", m, w));
    } catch {
      throw new Error(
        `private key must be ${w} bytes, hex or bigint, not ${typeof m}`
      );
    }
    return y && (E = ws(E, v)), o(E), E;
  }
  const u = new Map();
  function f(m) {
    if (!(m instanceof c)) throw new Error("ProjectivePoint expected");
  }
  class c {
    constructor(g, w, y) {
      if (
        ((this.px = g),
        (this.py = w),
        (this.pz = y),
        g == null || !n.isValid(g))
      )
        throw new Error("x required");
      if (w == null || !n.isValid(w)) throw new Error("y required");
      if (y == null || !n.isValid(y)) throw new Error("z required");
    }
    static fromAffine(g) {
      const { x: w, y } = g || {};
      if (!g || !n.isValid(w) || !n.isValid(y))
        throw new Error("invalid affine point");
      if (g instanceof c) throw new Error("projective point not allowed");
      const v = (E) => n.eql(E, n.ZERO);
      return v(w) && v(y) ? c.ZERO : new c(w, y, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(g) {
      const w = n.invertBatch(g.map((y) => y.pz));
      return g.map((y, v) => y.toAffine(w[v])).map(c.fromAffine);
    }
    static fromHex(g) {
      const w = c.fromAffine(i(Ys("pointHex", g)));
      return w.assertValidity(), w;
    }
    static fromPrivateKey(g) {
      return c.BASE.multiply(l(g));
    }
    _setWindowSize(g) {
      (this._WINDOW_SIZE = g), u.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !n.is0(this.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: g, y: w } = this.toAffine();
      if (!n.isValid(g) || !n.isValid(w))
        throw new Error("bad point: x or y not FE");
      const y = n.sqr(w),
        v = s(g);
      if (!n.eql(y, v)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: g } = this.toAffine();
      if (n.isOdd) return !n.isOdd(g);
      throw new Error("Field doesn't support isOdd");
    }
    equals(g) {
      f(g);
      const { px: w, py: y, pz: v } = this,
        { px: E, py: S, pz: D } = g,
        P = n.eql(n.mul(w, D), n.mul(E, v)),
        x = n.eql(n.mul(y, D), n.mul(S, v));
      return P && x;
    }
    negate() {
      return new c(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: g, b: w } = e,
        y = n.mul(w, N5),
        { px: v, py: E, pz: S } = this;
      let D = n.ZERO,
        P = n.ZERO,
        x = n.ZERO,
        _ = n.mul(v, v),
        A = n.mul(E, E),
        N = n.mul(S, S),
        M = n.mul(v, E);
      return (
        (M = n.add(M, M)),
        (x = n.mul(v, S)),
        (x = n.add(x, x)),
        (D = n.mul(g, x)),
        (P = n.mul(y, N)),
        (P = n.add(D, P)),
        (D = n.sub(A, P)),
        (P = n.add(A, P)),
        (P = n.mul(D, P)),
        (D = n.mul(M, D)),
        (x = n.mul(y, x)),
        (N = n.mul(g, N)),
        (M = n.sub(_, N)),
        (M = n.mul(g, M)),
        (M = n.add(M, x)),
        (x = n.add(_, _)),
        (_ = n.add(x, _)),
        (_ = n.add(_, N)),
        (_ = n.mul(_, M)),
        (P = n.add(P, _)),
        (N = n.mul(E, S)),
        (N = n.add(N, N)),
        (_ = n.mul(N, M)),
        (D = n.sub(D, _)),
        (x = n.mul(N, A)),
        (x = n.add(x, x)),
        (x = n.add(x, x)),
        new c(D, P, x)
      );
    }
    add(g) {
      f(g);
      const { px: w, py: y, pz: v } = this,
        { px: E, py: S, pz: D } = g;
      let P = n.ZERO,
        x = n.ZERO,
        _ = n.ZERO;
      const A = e.a,
        N = n.mul(e.b, N5);
      let M = n.mul(w, E),
        T = n.mul(y, S),
        O = n.mul(v, D),
        I = n.add(w, y),
        k = n.add(E, S);
      (I = n.mul(I, k)),
        (k = n.add(M, T)),
        (I = n.sub(I, k)),
        (k = n.add(w, v));
      let L = n.add(E, D);
      return (
        (k = n.mul(k, L)),
        (L = n.add(M, O)),
        (k = n.sub(k, L)),
        (L = n.add(y, v)),
        (P = n.add(S, D)),
        (L = n.mul(L, P)),
        (P = n.add(T, O)),
        (L = n.sub(L, P)),
        (_ = n.mul(A, k)),
        (P = n.mul(N, O)),
        (_ = n.add(P, _)),
        (P = n.sub(T, _)),
        (_ = n.add(T, _)),
        (x = n.mul(P, _)),
        (T = n.add(M, M)),
        (T = n.add(T, M)),
        (O = n.mul(A, O)),
        (k = n.mul(N, k)),
        (T = n.add(T, O)),
        (O = n.sub(M, O)),
        (O = n.mul(A, O)),
        (k = n.add(k, O)),
        (M = n.mul(T, k)),
        (x = n.add(x, M)),
        (M = n.mul(L, k)),
        (P = n.mul(I, P)),
        (P = n.sub(P, M)),
        (M = n.mul(I, T)),
        (_ = n.mul(L, _)),
        (_ = n.add(_, M)),
        new c(P, x, _)
      );
    }
    subtract(g) {
      return this.add(g.negate());
    }
    is0() {
      return this.equals(c.ZERO);
    }
    wNAF(g) {
      return p.wNAFCached(this, u, g, (w) => {
        const y = n.invertBatch(w.map((v) => v.pz));
        return w.map((v, E) => v.toAffine(y[E])).map(c.fromAffine);
      });
    }
    multiplyUnsafe(g) {
      const w = c.ZERO;
      if (g === Yl) return w;
      if ((o(g), g === bi)) return this;
      const { endo: y } = e;
      if (!y) return p.unsafeLadder(this, g);
      let { k1neg: v, k1: E, k2neg: S, k2: D } = y.splitScalar(g),
        P = w,
        x = w,
        _ = this;
      for (; E > Yl || D > Yl; )
        E & bi && (P = P.add(_)),
          D & bi && (x = x.add(_)),
          (_ = _.double()),
          (E >>= bi),
          (D >>= bi);
      return (
        v && (P = P.negate()),
        S && (x = x.negate()),
        (x = new c(n.mul(x.px, y.beta), x.py, x.pz)),
        P.add(x)
      );
    }
    multiply(g) {
      o(g);
      let w = g,
        y,
        v;
      const { endo: E } = e;
      if (E) {
        const { k1neg: S, k1: D, k2neg: P, k2: x } = E.splitScalar(w);
        let { p: _, f: A } = this.wNAF(D),
          { p: N, f: M } = this.wNAF(x);
        (_ = p.constTimeNegate(S, _)),
          (N = p.constTimeNegate(P, N)),
          (N = new c(n.mul(N.px, E.beta), N.py, N.pz)),
          (y = _.add(N)),
          (v = A.add(M));
      } else {
        const { p: S, f: D } = this.wNAF(w);
        (y = S), (v = D);
      }
      return c.normalizeZ([y, v])[0];
    }
    multiplyAndAddUnsafe(g, w, y) {
      const v = c.BASE,
        E = (D, P) =>
          P === Yl || P === bi || !D.equals(v)
            ? D.multiplyUnsafe(P)
            : D.multiply(P),
        S = E(this, w).add(E(g, y));
      return S.is0() ? void 0 : S;
    }
    toAffine(g) {
      const { px: w, py: y, pz: v } = this,
        E = this.is0();
      g == null && (g = E ? n.ONE : n.inv(v));
      const S = n.mul(w, g),
        D = n.mul(y, g),
        P = n.mul(v, g);
      if (E) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(P, n.ONE)) throw new Error("invZ was invalid");
      return { x: S, y: D };
    }
    isTorsionFree() {
      const { h: g, isTorsionFree: w } = e;
      if (g === bi) return !0;
      if (w) return w(c, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve"
      );
    }
    clearCofactor() {
      const { h: g, clearCofactor: w } = e;
      return g === bi ? this : w ? w(c, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(g = !0) {
      return this.assertValidity(), r(c, this, g);
    }
    toHex(g = !0) {
      return K0(this.toRawBytes(g));
    }
  }
  (c.BASE = new c(e.Gx, e.Gy, n.ONE)), (c.ZERO = new c(n.ZERO, n.ONE, n.ZERO));
  const d = e.nBitLength,
    p = Wge(c, e.endo ? Math.ceil(d / 2) : d);
  return {
    CURVE: e,
    ProjectivePoint: c,
    normPrivateKeyToScalar: l,
    weierstrassEquation: s,
    isWithinCurveOrder: a,
  };
}
function Yge(t) {
  const e = dV(t);
  return (
    E1(
      e,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
    ),
    Object.freeze({ lowS: !0, ...e })
  );
}
function Qge(t) {
  const e = Yge(t),
    { Fp: n, n: r } = e,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;
  function a(k) {
    return Yl < k && k < n.ORDER;
  }
  function o(k) {
    return ws(k, r);
  }
  function l(k) {
    return jE(k, r);
  }
  const {
      ProjectivePoint: u,
      normPrivateKeyToScalar: f,
      weierstrassEquation: c,
      isWithinCurveOrder: d,
    } = Zge({
      ...e,
      toBytes(k, L, U) {
        const $ = L.toAffine(),
          B = n.toBytes($.x),
          R = ko;
        return U
          ? R(Uint8Array.from([L.hasEvenY() ? 2 : 3]), B)
          : R(Uint8Array.from([4]), B, n.toBytes($.y));
      },
      fromBytes(k) {
        const L = k.length,
          U = k[0],
          $ = k.subarray(1);
        if (L === i && (U === 2 || U === 3)) {
          const B = Aa($);
          if (!a(B)) throw new Error("Point is not on curve");
          const R = c(B);
          let V = n.sqrt(R);
          const oe = (V & bi) === bi;
          return ((U & 1) === 1) !== oe && (V = n.neg(V)), { x: B, y: V };
        } else if (L === s && U === 4) {
          const B = n.fromBytes($.subarray(0, n.BYTES)),
            R = n.fromBytes($.subarray(n.BYTES, 2 * n.BYTES));
          return { x: B, y: R };
        } else
          throw new Error(
            `Point of length ${L} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`
          );
      },
    }),
    p = (k) => K0(cd(k, e.nByteLength));
  function m(k) {
    const L = r >> bi;
    return k > L;
  }
  function g(k) {
    return m(k) ? o(-k) : k;
  }
  const w = (k, L, U) => Aa(k.slice(L, U));
  class y {
    constructor(L, U, $) {
      (this.r = L), (this.s = U), (this.recovery = $), this.assertValidity();
    }
    static fromCompact(L) {
      const U = e.nByteLength;
      return (
        (L = Ys("compactSignature", L, U * 2)),
        new y(w(L, 0, U), w(L, U, 2 * U))
      );
    }
    static fromDER(L) {
      const { r: U, s: $ } = Jd.toSig(Ys("DER", L));
      return new y(U, $);
    }
    assertValidity() {
      if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(L) {
      return new y(this.r, this.s, L);
    }
    recoverPublicKey(L) {
      const { r: U, s: $, recovery: B } = this,
        R = x(Ys("msgHash", L));
      if (B == null || ![0, 1, 2, 3].includes(B))
        throw new Error("recovery id invalid");
      const V = B === 2 || B === 3 ? U + e.n : U;
      if (V >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const oe = B & 1 ? "03" : "02",
        le = u.fromHex(oe + p(V)),
        fe = l(V),
        z = o(-R * fe),
        se = o($ * fe),
        Y = u.BASE.multiplyAndAddUnsafe(le, z, se);
      if (!Y) throw new Error("point at infinify");
      return Y.assertValidity(), Y;
    }
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new y(this.r, o(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return X0(this.toDERHex());
    }
    toDERHex() {
      return Jd.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return X0(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const v = {
    isValidPrivateKey(k) {
      try {
        return f(k), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    randomPrivateKey: () => {
      const k = fV(e.n);
      return Vge(e.randomBytes(k), e.n);
    },
    precompute(k = 8, L = u.BASE) {
      return L._setWindowSize(k), L.multiply(BigInt(3)), L;
    },
  };
  function E(k, L = !0) {
    return u.fromPrivateKey(k).toRawBytes(L);
  }
  function S(k) {
    const L = k instanceof Uint8Array,
      U = typeof k == "string",
      $ = (L || U) && k.length;
    return L
      ? $ === i || $ === s
      : U
      ? $ === 2 * i || $ === 2 * s
      : k instanceof u;
  }
  function D(k, L, U = !0) {
    if (S(k)) throw new Error("first arg must be private key");
    if (!S(L)) throw new Error("second arg must be public key");
    return u.fromHex(L).multiply(f(k)).toRawBytes(U);
  }
  const P =
      e.bits2int ||
      function (k) {
        const L = Aa(k),
          U = k.length * 8 - e.nBitLength;
        return U > 0 ? L >> BigInt(U) : L;
      },
    x =
      e.bits2int_modN ||
      function (k) {
        return o(P(k));
      },
    _ = xT(e.nBitLength);
  function A(k) {
    if (typeof k != "bigint") throw new Error("bigint expected");
    if (!(Yl <= k && k < _))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return cd(k, e.nByteLength);
  }
  function N(k, L, U = M) {
    if (["recovered", "canonical"].some((ee) => ee in U))
      throw new Error("sign() legacy options not supported");
    const { hash: $, randomBytes: B } = e;
    let { lowS: R, prehash: V, extraEntropy: oe } = U;
    R == null && (R = !0),
      (k = Ys("msgHash", k)),
      V && (k = Ys("prehashed msgHash", $(k)));
    const le = x(k),
      fe = f(L),
      z = [A(fe), A(le)];
    if (oe != null) {
      const ee = oe === !0 ? B(n.BYTES) : oe;
      z.push(Ys("extraEntropy", ee));
    }
    const se = ko(...z),
      Y = le;
    function Q(ee) {
      const F = P(ee);
      if (!d(F)) return;
      const te = l(F),
        he = u.BASE.multiply(F).toAffine(),
        Te = o(he.x);
      if (Te === Yl) return;
      const Ce = o(te * o(Y + Te * fe));
      if (Ce === Yl) return;
      let ke = (he.x === Te ? 0 : 2) | Number(he.y & bi),
        at = Ce;
      return R && m(Ce) && ((at = g(Ce)), (ke ^= 1)), new y(Te, at, ke);
    }
    return { seed: se, k2sig: Q };
  }
  const M = { lowS: e.lowS, prehash: !1 },
    T = { lowS: e.lowS, prehash: !1 };
  function O(k, L, U = M) {
    const { seed: $, k2sig: B } = N(k, L, U),
      R = e;
    return oV(R.hash.outputLen, R.nByteLength, R.hmac)($, B);
  }
  u.BASE._setWindowSize(8);
  function I(k, L, U, $ = T) {
    const B = k;
    if (((L = Ys("msgHash", L)), (U = Ys("publicKey", U)), "strict" in $))
      throw new Error("options.strict was renamed to lowS");
    const { lowS: R, prehash: V } = $;
    let oe, le;
    try {
      if (typeof B == "string" || B instanceof Uint8Array)
        try {
          oe = y.fromDER(B);
        } catch (he) {
          if (!(he instanceof Jd.Err)) throw he;
          oe = y.fromCompact(B);
        }
      else if (
        typeof B == "object" &&
        typeof B.r == "bigint" &&
        typeof B.s == "bigint"
      ) {
        const { r: he, s: Te } = B;
        oe = new y(he, Te);
      } else throw new Error("PARSE");
      le = u.fromHex(U);
    } catch (he) {
      if (he.message === "PARSE")
        throw new Error(
          "signature must be Signature instance, Uint8Array or hex string"
        );
      return !1;
    }
    if (R && oe.hasHighS()) return !1;
    V && (L = e.hash(L));
    const { r: fe, s: z } = oe,
      se = x(L),
      Y = l(z),
      Q = o(se * Y),
      ee = o(fe * Y),
      F = u.BASE.multiplyAndAddUnsafe(le, Q, ee)?.toAffine();
    return F ? o(F.x) === fe : !1;
  }
  return {
    CURVE: e,
    getPublicKey: E,
    getSharedSecret: D,
    sign: O,
    verify: I,
    ProjectivePoint: u,
    Signature: y,
    utils: v,
  };
}
function Jge(t, e) {
  const n = t.ORDER;
  let r = Yl;
  for (let m = n - bi; m % Af === Yl; m /= Af) r += bi;
  const i = r,
    s = Af << (i - bi - bi),
    a = s * Af,
    o = (n - bi) / a,
    l = (o - bi) / Af,
    u = a - bi,
    f = s,
    c = t.pow(e, o),
    d = t.pow(e, (o + bi) / Af);
  let p = (m, g) => {
    let w = c,
      y = t.pow(g, u),
      v = t.sqr(y);
    v = t.mul(v, g);
    let E = t.mul(m, v);
    (E = t.pow(E, l)), (E = t.mul(E, y)), (y = t.mul(E, g)), (v = t.mul(E, m));
    let S = t.mul(v, y);
    E = t.pow(S, f);
    let D = t.eql(E, t.ONE);
    (y = t.mul(v, d)),
      (E = t.mul(S, w)),
      (v = t.cmov(y, v, D)),
      (S = t.cmov(E, S, D));
    for (let P = i; P > bi; P--) {
      let x = P - Af;
      x = Af << (x - bi);
      let _ = t.pow(S, x);
      const A = t.eql(_, t.ONE);
      (y = t.mul(v, w)),
        (w = t.mul(w, w)),
        (_ = t.mul(S, w)),
        (v = t.cmov(y, v, A)),
        (S = t.cmov(_, S, A));
    }
    return { isValid: D, value: v };
  };
  if (t.ORDER % zP === N5) {
    const m = (t.ORDER - N5) / zP,
      g = t.sqrt(t.neg(e));
    p = (w, y) => {
      let v = t.sqr(y);
      const E = t.mul(w, y);
      v = t.mul(v, E);
      let S = t.pow(v, m);
      S = t.mul(S, E);
      const D = t.mul(S, g),
        P = t.mul(t.sqr(S), y),
        x = t.eql(P, w);
      let _ = t.cmov(D, S, x);
      return { isValid: x, value: _ };
    };
  }
  return p;
}
function eye(t, e) {
  if ((lV(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z)))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const n = Jge(t, e.Z);
  if (!t.isOdd) throw new Error("Fp.isOdd is not implemented!");
  return (r) => {
    let i, s, a, o, l, u, f, c;
    (i = t.sqr(r)),
      (i = t.mul(i, e.Z)),
      (s = t.sqr(i)),
      (s = t.add(s, i)),
      (a = t.add(s, t.ONE)),
      (a = t.mul(a, e.B)),
      (o = t.cmov(e.Z, t.neg(s), !t.eql(s, t.ZERO))),
      (o = t.mul(o, e.A)),
      (s = t.sqr(a)),
      (u = t.sqr(o)),
      (l = t.mul(u, e.A)),
      (s = t.add(s, l)),
      (s = t.mul(s, a)),
      (u = t.mul(u, o)),
      (l = t.mul(u, e.B)),
      (s = t.add(s, l)),
      (f = t.mul(i, a));
    const { isValid: d, value: p } = n(s, u);
    (c = t.mul(i, r)),
      (c = t.mul(c, p)),
      (f = t.cmov(f, a, d)),
      (c = t.cmov(c, p, d));
    const m = t.isOdd(r) === t.isOdd(c);
    return (c = t.cmov(t.neg(c), c, m)), (f = t.div(f, o)), { x: f, y: c };
  };
}
function tye(t) {
  if (t instanceof Uint8Array) return t;
  if (typeof t == "string") return Jw(t);
  throw new Error("DST must be Uint8Array or string");
}
const nye = Aa;
function Df(t, e) {
  if (t < 0 || t >= 1 << (8 * e))
    throw new Error(`bad I2OSP call: value=${t} length=${e}`);
  const n = Array.from({ length: e }).fill(0);
  for (let r = e - 1; r >= 0; r--) (n[r] = t & 255), (t >>>= 8);
  return new Uint8Array(n);
}
function rye(t, e) {
  const n = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++) n[r] = t[r] ^ e[r];
  return n;
}
function Zg(t) {
  if (!(t instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
function TT(t) {
  if (!Number.isSafeInteger(t)) throw new Error("number expected");
}
function iye(t, e, n, r) {
  Zg(t),
    Zg(e),
    TT(n),
    e.length > 255 && (e = r(ko(Jw("H2C-OVERSIZE-DST-"), e)));
  const { outputLen: i, blockLen: s } = r,
    a = Math.ceil(n / i);
  if (a > 255) throw new Error("Invalid xmd length");
  const o = ko(e, Df(e.length, 1)),
    l = Df(0, s),
    u = Df(n, 2),
    f = new Array(a),
    c = r(ko(l, t, u, Df(0, 1), o));
  f[0] = r(ko(c, Df(1, 1), o));
  for (let p = 1; p <= a; p++) {
    const m = [rye(c, f[p - 1]), Df(p + 1, 1), o];
    f[p] = r(ko(...m));
  }
  return ko(...f).slice(0, n);
}
function sye(t, e, n, r, i) {
  if ((Zg(t), Zg(e), TT(n), e.length > 255)) {
    const s = Math.ceil((2 * r) / 8);
    e = i
      .create({ dkLen: s })
      .update(Jw("H2C-OVERSIZE-DST-"))
      .update(e)
      .digest();
  }
  if (n > 65535 || e.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return i
    .create({ dkLen: n })
    .update(t)
    .update(Df(n, 2))
    .update(e)
    .update(Df(e.length, 1))
    .digest();
}
function VP(t, e, n) {
  E1(n, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash",
  });
  const { p: r, k: i, m: s, hash: a, expand: o, DST: l } = n;
  Zg(t), TT(e);
  const u = tye(l),
    f = r.toString(2).length,
    c = Math.ceil((f + i) / 8),
    d = e * s * c;
  let p;
  if (o === "xmd") p = iye(t, u, d, a);
  else if (o === "xof") p = sye(t, u, d, i, a);
  else if (o === "_internal_pass") p = t;
  else throw new Error('expand must be "xmd" or "xof"');
  const m = new Array(e);
  for (let g = 0; g < e; g++) {
    const w = new Array(s);
    for (let y = 0; y < s; y++) {
      const v = c * (y + g * s),
        E = p.subarray(v, v + c);
      w[y] = ws(nye(E), r);
    }
    m[g] = w;
  }
  return m;
}
function aye(t, e) {
  const n = e.map((r) => Array.from(r).reverse());
  return (r, i) => {
    const [s, a, o, l] = n.map((u) =>
      u.reduce((f, c) => t.add(t.mul(f, r), c))
    );
    return (r = t.div(s, a)), (i = t.mul(i, t.div(o, l))), { x: r, y: i };
  };
}
function oye(t, e, n) {
  if (typeof e != "function") throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(r, i) {
      const s = VP(r, 2, { ...n, DST: n.DST, ...i }),
        a = t.fromAffine(e(s[0])),
        o = t.fromAffine(e(s[1])),
        l = a.add(o).clearCofactor();
      return l.assertValidity(), l;
    },
    encodeToCurve(r, i) {
      const s = VP(r, 1, { ...n, DST: n.encodeDST, ...i }),
        a = t.fromAffine(e(s[0])).clearCofactor();
      return a.assertValidity(), a;
    },
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function lye(
  t
) {
  return { hash: t, hmac: (e, ...n) => Xz(t, e, Yme(...n)), randomBytes: qz };
}
function uye(t, e) {
  const n = (r) => Qge({ ...t, ...lye(r) });
  return Object.freeze({ ...n(e), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const e6 =
    BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
  D5 = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
  ),
  hV = BigInt(1),
  R5 = BigInt(2),
  GP = (t, e) => (t + e / R5) / e;
function pV(t) {
  const e = e6,
    n = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    a = BigInt(23),
    o = BigInt(44),
    l = BigInt(88),
    u = (t * t * t) % e,
    f = (u * u * t) % e,
    c = (nl(f, n, e) * f) % e,
    d = (nl(c, n, e) * f) % e,
    p = (nl(d, R5, e) * u) % e,
    m = (nl(p, i, e) * p) % e,
    g = (nl(m, s, e) * m) % e,
    w = (nl(g, o, e) * g) % e,
    y = (nl(w, l, e) * w) % e,
    v = (nl(y, o, e) * g) % e,
    E = (nl(v, n, e) * f) % e,
    S = (nl(E, a, e) * m) % e,
    D = (nl(S, r, e) * u) % e,
    P = nl(D, R5, e);
  if (!fd.eql(fd.sqr(P), t)) throw new Error("Cannot find square root");
  return P;
}
const fd = zge(e6, void 0, void 0, { sqrt: pV }),
  ol = uye(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: fd,
      n: D5,
      Gx: BigInt(
        "55066263022277343669578718895168534326250603453777594175500187360389116729240"
      ),
      Gy: BigInt(
        "32670510020758816978083085130507043184471273380659243275938904335757337482424"
      ),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt(
          "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
        ),
        splitScalar: (t) => {
          const e = D5,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -hV * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            s = n,
            a = BigInt("0x100000000000000000000000000000000"),
            o = GP(s * t, e),
            l = GP(-r * t, e);
          let u = ws(t - o * n - l * i, e),
            f = ws(-o * r - l * s, e);
          const c = u > a,
            d = f > a;
          if ((c && (u = e - u), d && (f = e - f), u > a || f > a))
            throw new Error("splitScalar: Endomorphism failed, k=" + t);
          return { k1neg: c, k1: u, k2neg: d, k2: f };
        },
      },
    },
    P5
  ),
  t6 = BigInt(0),
  mV = (t) => typeof t == "bigint" && t6 < t && t < e6,
  cye = (t) => typeof t == "bigint" && t6 < t && t < D5,
  WP = {};
function M5(t, ...e) {
  let n = WP[t];
  if (n === void 0) {
    const r = P5(Uint8Array.from(t, (i) => i.charCodeAt(0)));
    (n = ko(r, r)), (WP[t] = n);
  }
  return P5(ko(n, ...e));
}
const ST = (t) => t.toRawBytes(!0).slice(1),
  HE = (t) => cd(t, 32),
  o8 = (t) => ws(t, e6),
  Yg = (t) => ws(t, D5),
  AT = ol.ProjectivePoint,
  fye = (t, e, n) => AT.BASE.multiplyAndAddUnsafe(t, e, n);
function zE(t) {
  let e = ol.utils.normPrivateKeyToScalar(t),
    n = AT.fromPrivateKey(e);
  return { scalar: n.hasEvenY() ? e : Yg(-e), bytes: ST(n) };
}
function gV(t) {
  if (!mV(t)) throw new Error("bad x: need 0 < x < p");
  const e = o8(t * t),
    n = o8(e * t + BigInt(7));
  let r = pV(n);
  r % R5 !== t6 && (r = o8(-r));
  const i = new AT(t, r, hV);
  return i.assertValidity(), i;
}
function yV(...t) {
  return Yg(Aa(M5("BIP0340/challenge", ...t)));
}
function dye(t) {
  return zE(t).bytes;
}
function hye(t, e, n = qz(32)) {
  const r = Ys("message", t),
    { bytes: i, scalar: s } = zE(e),
    a = Ys("auxRand", n, 32),
    o = HE(s ^ Aa(M5("BIP0340/aux", a))),
    l = M5("BIP0340/nonce", o, i, r),
    u = Yg(Aa(l));
  if (u === t6) throw new Error("sign failed: k is zero");
  const { bytes: f, scalar: c } = zE(u),
    d = yV(f, i, r),
    p = new Uint8Array(64);
  if ((p.set(f, 0), p.set(HE(Yg(c + d * s)), 32), !vV(p, r, i)))
    throw new Error("sign: Invalid signature produced");
  return p;
}
function vV(t, e, n) {
  const r = Ys("signature", t, 64),
    i = Ys("message", e),
    s = Ys("publicKey", n, 32);
  try {
    const a = gV(Aa(s)),
      o = Aa(r.subarray(0, 32));
    if (!mV(o)) return !1;
    const l = Aa(r.subarray(32, 64));
    if (!cye(l)) return !1;
    const u = yV(HE(o), ST(a), i),
      f = fye(a, l, Yg(-u));
    return !(!f || !f.hasEvenY() || f.toAffine().x !== o);
  } catch {
    return !1;
  }
}
const pye = (() => ({
    getPublicKey: dye,
    sign: hye,
    verify: vV,
    utils: {
      randomPrivateKey: ol.utils.randomPrivateKey,
      lift_x: gV,
      pointToBytes: ST,
      numberToBytesBE: cd,
      bytesToNumberBE: Aa,
      taggedHash: M5,
      mod: ws,
    },
  }))(),
  mye = (() =>
    aye(
      fd,
      [
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
        ],
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001",
        ],
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
        ],
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001",
        ],
      ].map((t) => t.map((e) => BigInt(e)))
    ))(),
  gye = (() =>
    eye(fd, {
      A: BigInt(
        "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"
      ),
      B: BigInt("1771"),
      Z: fd.create(BigInt("-11")),
    }))(),
  bV = (() =>
    oye(
      ol.ProjectivePoint,
      (t) => {
        const { x: e, y: n } = gye(fd.create(t[0]));
        return mye(e, n);
      },
      {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: fd.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: P5,
      }
    ))(),
  yye = (() => bV.hashToCurve)(),
  vye = (() => bV.encodeToCurve)(),
  NDe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        encodeToCurve: vye,
        hashToCurve: yye,
        schnorr: pye,
        secp256k1: ol,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  dd = "0x0000000000000000000000000000000000000000",
  qP = "0x0000000000000000000000000000000000000000000000000000000000000000";
BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
BigInt("1000000000000000000");
const bye = BigInt(
  "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
);
BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") *
  BigInt(-1);
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const KP = BigInt(0),
  XP = BigInt(1),
  ZP = BigInt(2),
  YP = BigInt(27),
  QP = BigInt(28),
  gv = BigInt(35),
  pp = {};
function JP(t) {
  return _h(_a(t), 32);
}
class Zi {
  #e;
  #t;
  #n;
  #r;
  get r() {
    return this.#e;
  }
  set r(e) {
    ge(h0(e) === 32, "invalid r", "value", e), (this.#e = Gt(e));
  }
  get s() {
    return this.#t;
  }
  set s(e) {
    ge(h0(e) === 32, "invalid s", "value", e);
    const n = Gt(e);
    ge(parseInt(n.substring(0, 3)) < 8, "non-canonical s", "value", n),
      (this.#t = n);
  }
  get v() {
    return this.#n;
  }
  set v(e) {
    const n = kn(e, "value");
    ge(n === 27 || n === 28, "invalid v", "v", e), (this.#n = n);
  }
  get networkV() {
    return this.#r;
  }
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : Zi.getChainId(e);
  }
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  get yParityAndS() {
    const e = er(this.s);
    return this.yParity && (e[0] |= 128), Gt(e);
  }
  get compactSerialized() {
    return Di([this.r, this.yParityAndS]);
  }
  get serialized() {
    return Di([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  constructor(e, n, r, i) {
    Oy(e, pp, "Signature"),
      (this.#e = n),
      (this.#t = r),
      (this.#n = i),
      (this.#r = null);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  clone() {
    const e = new Zi(pp, this.r, this.s, this.v);
    return this.networkV && (e.#r = this.networkV), e;
  }
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v,
    };
  }
  static getChainId(e) {
    const n = Lt(e, "v");
    return n == YP || n == QP
      ? KP
      : (ge(n >= gv, "invalid EIP-155 v", "v", e), (n - gv) / ZP);
  }
  static getChainIdV(e, n) {
    return Lt(e) * ZP + BigInt(35 + n - 27);
  }
  static getNormalizedV(e) {
    const n = Lt(e);
    return n === KP || n === YP
      ? 27
      : n === XP || n === QP
      ? 28
      : (ge(n >= gv, "invalid v", "v", e), n & XP ? 27 : 28);
  }
  static from(e) {
    function n(u, f) {
      ge(u, f, "signature", e);
    }
    if (e == null) return new Zi(pp, qP, qP, 27);
    if (typeof e == "string") {
      const u = er(e, "signature");
      if (u.length === 64) {
        const f = Gt(u.slice(0, 32)),
          c = u.slice(32, 64),
          d = c[0] & 128 ? 28 : 27;
        return (c[0] &= 127), new Zi(pp, f, Gt(c), d);
      }
      if (u.length === 65) {
        const f = Gt(u.slice(0, 32)),
          c = u.slice(32, 64);
        n((c[0] & 128) === 0, "non-canonical s");
        const d = Zi.getNormalizedV(u[64]);
        return new Zi(pp, f, Gt(c), d);
      }
      n(!1, "invalid raw signature length");
    }
    if (e instanceof Zi) return e.clone();
    const r = e.r;
    n(r != null, "missing r");
    const i = JP(r),
      s = (function (u, f) {
        if (u != null) return JP(u);
        if (f != null) {
          n(Mr(f, 32), "invalid yParityAndS");
          const c = er(f);
          return (c[0] &= 127), Gt(c);
        }
        n(!1, "missing s");
      })(e.s, e.yParityAndS);
    n((er(s)[0] & 128) == 0, "non-canonical s");
    const { networkV: a, v: o } = (function (u, f, c) {
        if (u != null) {
          const d = Lt(u);
          return { networkV: d >= gv ? d : void 0, v: Zi.getNormalizedV(d) };
        }
        if (f != null)
          return (
            n(Mr(f, 32), "invalid yParityAndS"), { v: er(f)[0] & 128 ? 28 : 27 }
          );
        if (c != null) {
          switch (kn(c, "sig.yParity")) {
            case 0:
              return { v: 27 };
            case 1:
              return { v: 28 };
          }
          n(!1, "invalid yParity");
        }
        n(!1, "missing v");
      })(e.v, e.yParityAndS, e.yParity),
      l = new Zi(pp, i, s, o);
    return (
      a && (l.#r = a),
      n(
        e.yParity == null || kn(e.yParity, "sig.yParity") === l.yParity,
        "yParity mismatch"
      ),
      n(
        e.yParityAndS == null || e.yParityAndS === l.yParityAndS,
        "yParityAndS mismatch"
      ),
      l
    );
  }
}
class Rc {
  #e;
  constructor(e) {
    ge(h0(e) === 32, "invalid private key", "privateKey", "[REDACTED]"),
      (this.#e = Gt(e));
  }
  get privateKey() {
    return this.#e;
  }
  get publicKey() {
    return Rc.computePublicKey(this.#e);
  }
  get compressedPublicKey() {
    return Rc.computePublicKey(this.#e, !0);
  }
  sign(e) {
    ge(h0(e) === 32, "invalid digest length", "digest", e);
    const n = ol.sign(va(e), va(this.#e), { lowS: !0 });
    return Zi.from({ r: ud(n.r, 32), s: ud(n.s, 32), v: n.recovery ? 28 : 27 });
  }
  computeSharedSecret(e) {
    const n = Rc.computePublicKey(e);
    return Gt(ol.getSharedSecret(va(this.#e), er(n), !1));
  }
  static computePublicKey(e, n) {
    let r = er(e, "key");
    if (r.length === 32) {
      const s = ol.getPublicKey(r, !!n);
      return Gt(s);
    }
    if (r.length === 64) {
      const s = new Uint8Array(65);
      (s[0] = 4), s.set(r, 1), (r = s);
    }
    const i = ol.ProjectivePoint.fromHex(r);
    return Gt(i.toRawBytes(n));
  }
  static recoverPublicKey(e, n) {
    ge(h0(e) === 32, "invalid digest length", "digest", e);
    const r = Zi.from(n);
    let i = ol.Signature.fromCompact(va(Di([r.r, r.s])));
    i = i.addRecoveryBit(r.yParity);
    const s = i.recoverPublicKey(va(e));
    return (
      ge(s != null, "invalid signautre for digest", "signature", n),
      "0x" + s.toHex(!1)
    );
  }
  static addPoints(e, n, r) {
    const i = ol.ProjectivePoint.fromHex(Rc.computePublicKey(e).substring(2)),
      s = ol.ProjectivePoint.fromHex(Rc.computePublicKey(n).substring(2));
    return "0x" + i.add(s).toHex(!!r);
  }
}
const wye = BigInt(0),
  _ye = BigInt(36);
function eN(t) {
  t = t.toLowerCase();
  const e = t.substring(2).split(""),
    n = new Uint8Array(40);
  for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
  const r = er(Zr(n));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
      (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const CT = {};
for (let t = 0; t < 10; t++) CT[String(t)] = String(t);
for (let t = 0; t < 26; t++) CT[String.fromCharCode(65 + t)] = String(10 + t);
const tN = 15;
function Eye(t) {
  (t = t.toUpperCase()), (t = t.substring(4) + t.substring(0, 2) + "00");
  let e = t
    .split("")
    .map((r) => CT[r])
    .join("");
  for (; e.length >= tN; ) {
    let r = e.substring(0, tN);
    e = (parseInt(r, 10) % 97) + e.substring(r.length);
  }
  let n = String(98 - (parseInt(e, 10) % 97));
  for (; n.length < 2; ) n = "0" + n;
  return n;
}
const xye = (function () {
  const t = {};
  for (let e = 0; e < 36; e++) {
    const n = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    t[n] = BigInt(e);
  }
  return t;
})();
function Tye(t) {
  t = t.toLowerCase();
  let e = wye;
  for (let n = 0; n < t.length; n++) e = e * _ye + xye[t[n]];
  return e;
}
function yr(t) {
  if (
    (ge(typeof t == "string", "invalid address", "address", t),
    t.match(/^(0x)?[0-9a-fA-F]{40}$/))
  ) {
    t.startsWith("0x") || (t = "0x" + t);
    const e = eN(t);
    return (
      ge(
        !t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t,
        "bad address checksum",
        "address",
        t
      ),
      e
    );
  }
  if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    ge(t.substring(2, 4) === Eye(t), "bad icap checksum", "address", t);
    let e = Tye(t.substring(4)).toString(16);
    for (; e.length < 40; ) e = "0" + e;
    return eN("0x" + e);
  }
  ge(!1, "invalid address", "address", t);
}
function wV(t) {
  const e = yr(t.from);
  let r = Lt(t.nonce, "tx.nonce").toString(16);
  return (
    r === "0" ? (r = "0x") : r.length % 2 ? (r = "0x0" + r) : (r = "0x" + r),
    yr(vi(Zr(W0([e, r])), 12))
  );
}
function _V(t) {
  return t && typeof t.getAddress == "function";
}
function l8(t) {
  try {
    return yr(t), !0;
  } catch {}
  return !1;
}
async function u8(t, e) {
  const n = await e;
  return (
    (n == null || n === "0x0000000000000000000000000000000000000000") &&
      (Ue(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", {
        value: t,
      }),
      ge(
        !1,
        "invalid AddressLike value; did not resolve to a value address",
        "target",
        t
      )),
    yr(n)
  );
}
function xa(t, e) {
  if (typeof t == "string")
    return t.match(/^0x[0-9a-f]{40}$/i)
      ? yr(t)
      : (Ue(
          e != null,
          "ENS resolution requires a provider",
          "UNSUPPORTED_OPERATION",
          { operation: "resolveName" }
        ),
        u8(t, e.resolveName(t)));
  if (_V(t)) return u8(t, t.getAddress());
  if (t && typeof t.then == "function") return u8(t, t);
  ge(!1, "unsupported addressable value", "target", t);
}
const Cc = {};
function At(t, e) {
  let n = !1;
  return (
    e < 0 && ((n = !0), (e *= -1)),
    new _i(Cc, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e })
  );
}
function or(t, e) {
  return new _i(Cc, `bytes${e || ""}`, t, { size: e });
}
const nN = Symbol.for("_ethers_typed");
class _i {
  type;
  value;
  #e;
  _typedSymbol;
  constructor(e, n, r, i) {
    i == null && (i = null),
      Oy(Cc, e, "Typed"),
      nn(this, { _typedSymbol: nN, type: n, value: r }),
      (this.#e = i),
      this.format();
  }
  format() {
    if (this.type === "array") throw new Error("");
    if (this.type === "dynamicArray") throw new Error("");
    return this.type === "tuple"
      ? `tuple(${this.value.map((e) => e.format()).join(",")})`
      : this.type;
  }
  defaultValue() {
    return 0;
  }
  minValue() {
    return 0;
  }
  maxValue() {
    return 0;
  }
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  isData() {
    return this.type.startsWith("bytes");
  }
  isString() {
    return this.type === "string";
  }
  get tupleName() {
    if (this.type !== "tuple") throw TypeError("not a tuple");
    return this.#e;
  }
  get arrayLength() {
    if (this.type !== "array") throw TypeError("not an array");
    return this.#e === !0 ? -1 : this.#e === !1 ? this.value.length : null;
  }
  static from(e, n) {
    return new _i(Cc, e, n);
  }
  static uint8(e) {
    return At(e, 8);
  }
  static uint16(e) {
    return At(e, 16);
  }
  static uint24(e) {
    return At(e, 24);
  }
  static uint32(e) {
    return At(e, 32);
  }
  static uint40(e) {
    return At(e, 40);
  }
  static uint48(e) {
    return At(e, 48);
  }
  static uint56(e) {
    return At(e, 56);
  }
  static uint64(e) {
    return At(e, 64);
  }
  static uint72(e) {
    return At(e, 72);
  }
  static uint80(e) {
    return At(e, 80);
  }
  static uint88(e) {
    return At(e, 88);
  }
  static uint96(e) {
    return At(e, 96);
  }
  static uint104(e) {
    return At(e, 104);
  }
  static uint112(e) {
    return At(e, 112);
  }
  static uint120(e) {
    return At(e, 120);
  }
  static uint128(e) {
    return At(e, 128);
  }
  static uint136(e) {
    return At(e, 136);
  }
  static uint144(e) {
    return At(e, 144);
  }
  static uint152(e) {
    return At(e, 152);
  }
  static uint160(e) {
    return At(e, 160);
  }
  static uint168(e) {
    return At(e, 168);
  }
  static uint176(e) {
    return At(e, 176);
  }
  static uint184(e) {
    return At(e, 184);
  }
  static uint192(e) {
    return At(e, 192);
  }
  static uint200(e) {
    return At(e, 200);
  }
  static uint208(e) {
    return At(e, 208);
  }
  static uint216(e) {
    return At(e, 216);
  }
  static uint224(e) {
    return At(e, 224);
  }
  static uint232(e) {
    return At(e, 232);
  }
  static uint240(e) {
    return At(e, 240);
  }
  static uint248(e) {
    return At(e, 248);
  }
  static uint256(e) {
    return At(e, 256);
  }
  static uint(e) {
    return At(e, 256);
  }
  static int8(e) {
    return At(e, -8);
  }
  static int16(e) {
    return At(e, -16);
  }
  static int24(e) {
    return At(e, -24);
  }
  static int32(e) {
    return At(e, -32);
  }
  static int40(e) {
    return At(e, -40);
  }
  static int48(e) {
    return At(e, -48);
  }
  static int56(e) {
    return At(e, -56);
  }
  static int64(e) {
    return At(e, -64);
  }
  static int72(e) {
    return At(e, -72);
  }
  static int80(e) {
    return At(e, -80);
  }
  static int88(e) {
    return At(e, -88);
  }
  static int96(e) {
    return At(e, -96);
  }
  static int104(e) {
    return At(e, -104);
  }
  static int112(e) {
    return At(e, -112);
  }
  static int120(e) {
    return At(e, -120);
  }
  static int128(e) {
    return At(e, -128);
  }
  static int136(e) {
    return At(e, -136);
  }
  static int144(e) {
    return At(e, -144);
  }
  static int152(e) {
    return At(e, -152);
  }
  static int160(e) {
    return At(e, -160);
  }
  static int168(e) {
    return At(e, -168);
  }
  static int176(e) {
    return At(e, -176);
  }
  static int184(e) {
    return At(e, -184);
  }
  static int192(e) {
    return At(e, -192);
  }
  static int200(e) {
    return At(e, -200);
  }
  static int208(e) {
    return At(e, -208);
  }
  static int216(e) {
    return At(e, -216);
  }
  static int224(e) {
    return At(e, -224);
  }
  static int232(e) {
    return At(e, -232);
  }
  static int240(e) {
    return At(e, -240);
  }
  static int248(e) {
    return At(e, -248);
  }
  static int256(e) {
    return At(e, -256);
  }
  static int(e) {
    return At(e, -256);
  }
  static bytes1(e) {
    return or(e, 1);
  }
  static bytes2(e) {
    return or(e, 2);
  }
  static bytes3(e) {
    return or(e, 3);
  }
  static bytes4(e) {
    return or(e, 4);
  }
  static bytes5(e) {
    return or(e, 5);
  }
  static bytes6(e) {
    return or(e, 6);
  }
  static bytes7(e) {
    return or(e, 7);
  }
  static bytes8(e) {
    return or(e, 8);
  }
  static bytes9(e) {
    return or(e, 9);
  }
  static bytes10(e) {
    return or(e, 10);
  }
  static bytes11(e) {
    return or(e, 11);
  }
  static bytes12(e) {
    return or(e, 12);
  }
  static bytes13(e) {
    return or(e, 13);
  }
  static bytes14(e) {
    return or(e, 14);
  }
  static bytes15(e) {
    return or(e, 15);
  }
  static bytes16(e) {
    return or(e, 16);
  }
  static bytes17(e) {
    return or(e, 17);
  }
  static bytes18(e) {
    return or(e, 18);
  }
  static bytes19(e) {
    return or(e, 19);
  }
  static bytes20(e) {
    return or(e, 20);
  }
  static bytes21(e) {
    return or(e, 21);
  }
  static bytes22(e) {
    return or(e, 22);
  }
  static bytes23(e) {
    return or(e, 23);
  }
  static bytes24(e) {
    return or(e, 24);
  }
  static bytes25(e) {
    return or(e, 25);
  }
  static bytes26(e) {
    return or(e, 26);
  }
  static bytes27(e) {
    return or(e, 27);
  }
  static bytes28(e) {
    return or(e, 28);
  }
  static bytes29(e) {
    return or(e, 29);
  }
  static bytes30(e) {
    return or(e, 30);
  }
  static bytes31(e) {
    return or(e, 31);
  }
  static bytes32(e) {
    return or(e, 32);
  }
  static address(e) {
    return new _i(Cc, "address", e);
  }
  static bool(e) {
    return new _i(Cc, "bool", !!e);
  }
  static bytes(e) {
    return new _i(Cc, "bytes", e);
  }
  static string(e) {
    return new _i(Cc, "string", e);
  }
  static array(e, n) {
    throw new Error("not implemented yet");
  }
  static tuple(e, n) {
    throw new Error("not implemented yet");
  }
  static overrides(e) {
    return new _i(Cc, "overrides", Object.assign({}, e));
  }
  static isTyped(e) {
    return (
      e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === nN
    );
  }
  static dereference(e, n) {
    if (_i.isTyped(e)) {
      if (e.type !== n)
        throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
}
class Sye extends lf {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, n) {
    let r = _i.dereference(n, "string");
    try {
      r = yr(r);
    } catch (i) {
      return this._throwError(i.message, n);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return yr(ud(e.readValue(), 20));
  }
}
class Aye extends lf {
  coder;
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, n) {
    return this.coder.encode(e, n);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function EV(t, e, n) {
  let r = [];
  if (Array.isArray(n)) r = n;
  else if (n && typeof n == "object") {
    let l = {};
    r = e.map((u) => {
      const f = u.localName;
      return (
        Ue(
          f,
          "cannot encode object for signature with missing names",
          "INVALID_ARGUMENT",
          { argument: "values", info: { coder: u }, value: n }
        ),
        Ue(
          !l[f],
          "cannot encode object for signature with duplicate names",
          "INVALID_ARGUMENT",
          { argument: "values", info: { coder: u }, value: n }
        ),
        (l[f] = !0),
        n[f]
      );
    });
  } else ge(!1, "invalid tuple value", "tuple", n);
  ge(e.length === r.length, "types/value length mismatch", "tuple", n);
  let i = new $E(),
    s = new $E(),
    a = [];
  e.forEach((l, u) => {
    let f = r[u];
    if (l.dynamic) {
      let c = s.length;
      l.encode(s, f);
      let d = i.writeUpdatableValue();
      a.push((p) => {
        d(p + c);
      });
    } else l.encode(i, f);
  }),
    a.forEach((l) => {
      l(i.length);
    });
  let o = t.appendWriter(i);
  return (o += t.appendWriter(s)), o;
}
function xV(t, e) {
  let n = [],
    r = [],
    i = t.subReader(0);
  return (
    e.forEach((s) => {
      let a = null;
      if (s.dynamic) {
        let o = t.readIndex(),
          l = i.subReader(o);
        try {
          a = s.decode(l);
        } catch (u) {
          if (ra(u, "BUFFER_OVERRUN")) throw u;
          (a = u),
            (a.baseType = s.name),
            (a.name = s.localName),
            (a.type = s.type);
        }
      } else
        try {
          a = s.decode(t);
        } catch (o) {
          if (ra(o, "BUFFER_OVERRUN")) throw o;
          (a = o),
            (a.baseType = s.name),
            (a.name = s.localName),
            (a.type = s.type);
        }
      if (a == null) throw new Error("investigate");
      n.push(a), r.push(s.localName || null);
    }),
    m0.fromItems(n, r)
  );
}
class Cye extends lf {
  coder;
  length;
  constructor(e, n, r) {
    const i = e.type + "[" + (n >= 0 ? n : "") + "]",
      s = n === -1 || e.dynamic;
    super("array", i, r, s), nn(this, { coder: e, length: n });
  }
  defaultValue() {
    const e = this.coder.defaultValue(),
      n = [];
    for (let r = 0; r < this.length; r++) n.push(e);
    return n;
  }
  encode(e, n) {
    const r = _i.dereference(n, "array");
    Array.isArray(r) || this._throwError("expected array value", r);
    let i = this.length;
    i === -1 && ((i = r.length), e.writeValue(r.length)),
      Oz(
        r.length,
        i,
        "coder array" + (this.localName ? " " + this.localName : "")
      );
    let s = [];
    for (let a = 0; a < r.length; a++) s.push(this.coder);
    return EV(e, s, r);
  }
  decode(e) {
    let n = this.length;
    n === -1 &&
      ((n = e.readIndex()),
      Ue(n * Ea <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
        buffer: e.bytes,
        offset: n * Ea,
        length: e.dataLength,
      }));
    let r = [];
    for (let i = 0; i < n; i++) r.push(new Aye(this.coder));
    return xV(e, r);
  }
}
class kye extends lf {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, n) {
    const r = _i.dereference(n, "bool");
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class TV extends lf {
  constructor(e, n) {
    super(e, e, n, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, n) {
    n = va(n);
    let r = e.writeValue(n.length);
    return (r += e.writeBytes(n)), r;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class Iye extends TV {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return Gt(super.decode(e));
  }
}
class Oye extends lf {
  size;
  constructor(e, n) {
    let r = "bytes" + String(e);
    super(r, r, n, !1), nn(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
      0,
      2 + this.size * 2
    );
  }
  encode(e, n) {
    let r = va(_i.dereference(n, this.type));
    return (
      r.length !== this.size && this._throwError("incorrect data length", n),
      e.writeBytes(r)
    );
  }
  decode(e) {
    return Gt(e.readBytes(this.size));
  }
}
const Pye = new Uint8Array([]);
class Nye extends lf {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, n) {
    return n != null && this._throwError("not null", n), e.writeBytes(Pye);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const Dye = BigInt(0),
  Rye = BigInt(1),
  Mye = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
class Lye extends lf {
  size;
  signed;
  constructor(e, n, r) {
    const i = (n ? "int" : "uint") + e * 8;
    super(i, i, r, !1),
      nn(this, { size: e, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, n) {
    let r = Lt(_i.dereference(n, this.type)),
      i = Yd(Mye, Ea * 8);
    if (this.signed) {
      let s = Yd(i, this.size * 8 - 1);
      (r > s || r < -(s + Rye)) && this._throwError("value out-of-bounds", n),
        (r = Dz(r, 8 * Ea));
    } else
      (r < Dye || r > Yd(i, this.size * 8)) &&
        this._throwError("value out-of-bounds", n);
    return e.writeValue(r);
  }
  decode(e) {
    let n = Yd(e.readValue(), this.size * 8);
    return this.signed && (n = k5(n, this.size * 8)), n;
  }
}
class Bye extends TV {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, n) {
    return super.encode(e, Hc(_i.dereference(n, "string")));
  }
  decode(e) {
    return I5(super.decode(e));
  }
}
class yv extends lf {
  coders;
  constructor(e, n) {
    let r = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (r = !0), i.push(a.type);
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, n, r), nn(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    const n = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return (
      this.coders.forEach((r, i) => {
        let s = r.localName;
        !s ||
          n[s] !== 1 ||
          (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, n) {
    const r = _i.dereference(n, "tuple");
    return EV(e, this.coders, r);
  }
  decode(e) {
    return xV(e, this.coders);
  }
}
function xh(t) {
  return Zr(Hc(t));
}
var Fye =
  "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const rN = new Map([
    [8217, "apostrophe"],
    [8260, "fraction slash"],
    [12539, "middle dot"],
  ]),
  iN = 4;
function $ye(t) {
  let e = 0;
  function n() {
    return (t[e++] << 8) | t[e++];
  }
  let r = n(),
    i = 1,
    s = [0, 1];
  for (let D = 1; D < r; D++) s.push((i += n()));
  let a = n(),
    o = e;
  e += a;
  let l = 0,
    u = 0;
  function f() {
    return l == 0 && ((u = (u << 8) | t[e++]), (l = 8)), (u >> --l) & 1;
  }
  const c = 31,
    d = 2 ** c,
    p = d >>> 1,
    m = p >> 1,
    g = d - 1;
  let w = 0;
  for (let D = 0; D < c; D++) w = (w << 1) | f();
  let y = [],
    v = 0,
    E = d;
  for (;;) {
    let D = Math.floor(((w - v + 1) * i - 1) / E),
      P = 0,
      x = r;
    for (; x - P > 1; ) {
      let N = (P + x) >>> 1;
      D < s[N] ? (x = N) : (P = N);
    }
    if (P == 0) break;
    y.push(P);
    let _ = v + Math.floor((E * s[P]) / i),
      A = v + Math.floor((E * s[P + 1]) / i) - 1;
    for (; !((_ ^ A) & p); )
      (w = ((w << 1) & g) | f()), (_ = (_ << 1) & g), (A = ((A << 1) & g) | 1);
    for (; _ & ~A & m; )
      (w = (w & p) | ((w << 1) & (g >>> 1)) | f()),
        (_ = (_ << 1) ^ p),
        (A = ((A ^ p) << 1) | p | 1);
    (v = _), (E = 1 + A - _);
  }
  let S = r - 4;
  return y.map((D) => {
    switch (D - S) {
      case 3:
        return S + 65792 + ((t[o++] << 16) | (t[o++] << 8) | t[o++]);
      case 2:
        return S + 256 + ((t[o++] << 8) | t[o++]);
      case 1:
        return S + t[o++];
      default:
        return D - 1;
    }
  });
}
function Uye(t) {
  let e = 0;
  return () => t[e++];
}
function SV(t) {
  return Uye($ye(jye(t)));
}
function jye(t) {
  let e = [];
  [
    ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  ].forEach((i, s) => (e[i.charCodeAt(0)] = s));
  let n = t.length,
    r = new Uint8Array((6 * n) >> 3);
  for (let i = 0, s = 0, a = 0, o = 0; i < n; i++)
    (o = (o << 6) | e[t.charCodeAt(i)]),
      (a += 6),
      a >= 8 && (r[s++] = o >> (a -= 8));
  return r;
}
function Hye(t) {
  return t & 1 ? ~t >> 1 : t >> 1;
}
function zye(t, e) {
  let n = Array(t);
  for (let r = 0, i = 0; r < t; r++) n[r] = i += Hye(e());
  return n;
}
function Qg(t, e = 0) {
  let n = [];
  for (;;) {
    let r = t(),
      i = t();
    if (!i) break;
    e += r;
    for (let s = 0; s < i; s++) n.push(e + s);
    e += i + 1;
  }
  return n;
}
function AV(t) {
  return Jg(() => {
    let e = Qg(t);
    if (e.length) return e;
  });
}
function CV(t) {
  let e = [];
  for (;;) {
    let n = t();
    if (n == 0) break;
    e.push(Vye(n, t));
  }
  for (;;) {
    let n = t() - 1;
    if (n < 0) break;
    e.push(Gye(n, t));
  }
  return e.flat();
}
function Jg(t) {
  let e = [];
  for (;;) {
    let n = t(e.length);
    if (!n) break;
    e.push(n);
  }
  return e;
}
function kV(t, e, n) {
  let r = Array(t)
    .fill()
    .map(() => []);
  for (let i = 0; i < e; i++) zye(t, n).forEach((s, a) => r[a].push(s));
  return r;
}
function Vye(t, e) {
  let n = 1 + e(),
    r = e(),
    i = Jg(e);
  return kV(i.length, 1 + t, e).flatMap((a, o) => {
    let [l, ...u] = a;
    return Array(i[o])
      .fill()
      .map((f, c) => {
        let d = c * r;
        return [l + c * n, u.map((p) => p + d)];
      });
  });
}
function Gye(t, e) {
  let n = 1 + e();
  return kV(n, 1 + t, e).map((i) => [i[0], i.slice(1)]);
}
function Wye(t) {
  let e = [],
    n = Qg(t);
  return i(r([]), []), e;
  function r(s) {
    let a = t(),
      o = Jg(() => {
        let l = Qg(t).map((u) => n[u]);
        if (l.length) return r(l);
      });
    return { S: a, B: o, Q: s };
  }
  function i({ S: s, B: a }, o, l) {
    if (!(s & 4 && l === o[o.length - 1])) {
      s & 2 && (l = o[o.length - 1]), s & 1 && e.push(o);
      for (let u of a) for (let f of u.Q) i(u, [...o, f], l);
    }
  }
}
function qye(t) {
  return t.toString(16).toUpperCase().padStart(2, "0");
}
function IV(t) {
  return `{${qye(t)}}`;
}
function Kye(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; ) {
    let i = t.codePointAt(n);
    (n += i < 65536 ? 1 : 2), e.push(i);
  }
  return e;
}
function Z0(t) {
  let n = t.length;
  if (n < 4096) return String.fromCodePoint(...t);
  let r = [];
  for (let i = 0; i < n; )
    r.push(String.fromCodePoint(...t.slice(i, (i += 4096))));
  return r.join("");
}
function Xye(t, e) {
  let n = t.length,
    r = n - e.length;
  for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i];
  return r;
}
var Zye =
  "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const ey = 44032,
  L5 = 4352,
  B5 = 4449,
  F5 = 4519,
  OV = 19,
  PV = 21,
  Y0 = 28,
  $5 = PV * Y0,
  Yye = OV * $5,
  Qye = ey + Yye,
  Jye = L5 + OV,
  e2e = B5 + PV,
  t2e = F5 + Y0;
function jm(t) {
  return (t >> 24) & 255;
}
function NV(t) {
  return t & 16777215;
}
let VE, sN, GE, ub;
function n2e() {
  let t = SV(Zye);
  (VE = new Map(AV(t).flatMap((e, n) => e.map((r) => [r, (n + 1) << 24])))),
    (sN = new Set(Qg(t))),
    (GE = new Map()),
    (ub = new Map());
  for (let [e, n] of CV(t)) {
    if (!sN.has(e) && n.length == 2) {
      let [r, i] = n,
        s = ub.get(r);
      s || ((s = new Map()), ub.set(r, s)), s.set(i, e);
    }
    GE.set(e, n.reverse());
  }
}
function DV(t) {
  return t >= ey && t < Qye;
}
function r2e(t, e) {
  if (t >= L5 && t < Jye && e >= B5 && e < e2e)
    return ey + (t - L5) * $5 + (e - B5) * Y0;
  if (DV(t) && e > F5 && e < t2e && (t - ey) % Y0 == 0) return t + (e - F5);
  {
    let n = ub.get(t);
    return n && ((n = n.get(e)), n) ? n : -1;
  }
}
function RV(t) {
  VE || n2e();
  let e = [],
    n = [],
    r = !1;
  function i(s) {
    let a = VE.get(s);
    a && ((r = !0), (s |= a)), e.push(s);
  }
  for (let s of t)
    for (;;) {
      if (s < 128) e.push(s);
      else if (DV(s)) {
        let a = s - ey,
          o = (a / $5) | 0,
          l = ((a % $5) / Y0) | 0,
          u = a % Y0;
        i(L5 + o), i(B5 + l), u > 0 && i(F5 + u);
      } else {
        let a = GE.get(s);
        a ? n.push(...a) : i(s);
      }
      if (!n.length) break;
      s = n.pop();
    }
  if (r && e.length > 1) {
    let s = jm(e[0]);
    for (let a = 1; a < e.length; a++) {
      let o = jm(e[a]);
      if (o == 0 || s <= o) {
        s = o;
        continue;
      }
      let l = a - 1;
      for (;;) {
        let u = e[l + 1];
        if (((e[l + 1] = e[l]), (e[l] = u), !l || ((s = jm(e[--l])), s <= o)))
          break;
      }
      s = jm(e[a]);
    }
  }
  return e;
}
function i2e(t) {
  let e = [],
    n = [],
    r = -1,
    i = 0;
  for (let s of t) {
    let a = jm(s),
      o = NV(s);
    if (r == -1) a == 0 ? (r = o) : e.push(o);
    else if (i > 0 && i >= a)
      a == 0 ? (e.push(r, ...n), (n.length = 0), (r = o)) : n.push(o), (i = a);
    else {
      let l = r2e(r, o);
      l >= 0
        ? (r = l)
        : i == 0 && a == 0
        ? (e.push(r), (r = o))
        : (n.push(o), (i = a));
    }
  }
  return r >= 0 && e.push(r, ...n), e;
}
function MV(t) {
  return RV(t).map(NV);
}
function s2e(t) {
  return i2e(RV(t));
}
const aN = 45,
  LV = ".",
  BV = 65039,
  FV = 1,
  U5 = (t) => Array.from(t);
function ty(t, e) {
  return t.P.has(e) || t.Q.has(e);
}
class a2e extends Array {
  get is_emoji() {
    return !0;
  }
}
let WE, $V, eh, qE, UV, g0, c8, Ip, Hd, oN, KE;
function kT() {
  if (WE) return;
  let t = SV(Fye);
  const e = () => Qg(t),
    n = () => new Set(e()),
    r = (f, c) => c.forEach((d) => f.add(d));
  (WE = new Map(CV(t))),
    ($V = n()),
    (eh = e()),
    (qE = new Set(e().map((f) => eh[f]))),
    (eh = new Set(eh)),
    (UV = n()),
    n();
  let i = AV(t),
    s = t();
  const a = () => {
    let f = new Set();
    return e().forEach((c) => r(f, i[c])), r(f, e()), f;
  };
  (g0 = Jg((f) => {
    let c = Jg(t).map((d) => d + 96);
    if (c.length) {
      let d = f >= s;
      (c[0] -= 32), (c = Z0(c)), d && (c = `Restricted[${c}]`);
      let p = a(),
        m = a(),
        g = !t();
      return { N: c, P: p, Q: m, M: g, R: d };
    }
  })),
    (c8 = n()),
    (Ip = new Map());
  let o = e()
    .concat(U5(c8))
    .sort((f, c) => f - c);
  o.forEach((f, c) => {
    let d = t(),
      p = (o[c] = d ? o[c - d] : { V: [], M: new Map() });
    p.V.push(f), c8.has(f) || Ip.set(f, p);
  });
  for (let { V: f, M: c } of new Set(Ip.values())) {
    let d = [];
    for (let m of f) {
      let g = g0.filter((y) => ty(y, m)),
        w = d.find(({ G: y }) => g.some((v) => y.has(v)));
      w || ((w = { G: new Set(), V: [] }), d.push(w)), w.V.push(m), r(w.G, g);
    }
    let p = d.flatMap((m) => U5(m.G));
    for (let { G: m, V: g } of d) {
      let w = new Set(p.filter((y) => !m.has(y)));
      for (let y of g) c.set(y, w);
    }
  }
  Hd = new Set();
  let l = new Set();
  const u = (f) => (Hd.has(f) ? l.add(f) : Hd.add(f));
  for (let f of g0) {
    for (let c of f.P) u(c);
    for (let c of f.Q) u(c);
  }
  for (let f of Hd) !Ip.has(f) && !l.has(f) && Ip.set(f, FV);
  r(Hd, MV(Hd)),
    (oN = Wye(t)
      .map((f) => a2e.from(f))
      .sort(Xye)),
    (KE = new Map());
  for (let f of oN) {
    let c = [KE];
    for (let d of f) {
      let p = c.map((m) => {
        let g = m.get(d);
        return g || ((g = new Map()), m.set(d, g)), g;
      });
      d === BV ? c.push(...p) : (c = p);
    }
    for (let d of c) d.V = f;
  }
}
function IT(t) {
  return (jV(t) ? "" : `${OT(n6([t]))} `) + IV(t);
}
function OT(t) {
  return `"${t}"‎`;
}
function o2e(t) {
  if (t.length >= 4 && t[2] == aN && t[3] == aN)
    throw new Error(`invalid label extension: "${Z0(t.slice(0, 4))}"`);
}
function l2e(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95) throw new Error("underscore allowed only at start");
}
function u2e(t) {
  let e = t[0],
    n = rN.get(e);
  if (n) throw ug(`leading ${n}`);
  let r = t.length,
    i = -1;
  for (let s = 1; s < r; s++) {
    e = t[s];
    let a = rN.get(e);
    if (a) {
      if (i == s) throw ug(`${n} + ${a}`);
      (i = s + 1), (n = a);
    }
  }
  if (i == r) throw ug(`trailing ${n}`);
}
function n6(t, e = 1 / 0, n = IV) {
  let r = [];
  c2e(t[0]) && r.push("◌"),
    t.length > e && ((e >>= 1), (t = [...t.slice(0, e), 8230, ...t.slice(-e)]));
  let i = 0,
    s = t.length;
  for (let a = 0; a < s; a++) {
    let o = t[a];
    jV(o) && (r.push(Z0(t.slice(i, a))), r.push(n(o)), (i = a + 1));
  }
  return r.push(Z0(t.slice(i, s))), r.join("");
}
function c2e(t) {
  return kT(), eh.has(t);
}
function jV(t) {
  return kT(), UV.has(t);
}
function f2e(t) {
  return m2e(d2e(t, s2e, v2e));
}
function d2e(t, e, n) {
  if (!t) return [];
  kT();
  let r = 0;
  return t.split(LV).map((i) => {
    let s = Kye(i),
      a = { input: s, offset: r };
    r += s.length + 1;
    try {
      let o = (a.tokens = y2e(s, e, n)),
        l = o.length,
        u;
      if (!l) throw new Error("empty label");
      let f = (a.output = o.flat());
      if (
        (l2e(f), !(a.emoji = l > 1 || o[0].is_emoji) && f.every((d) => d < 128))
      )
        o2e(f), (u = "ASCII");
      else {
        let d = o.flatMap((p) => (p.is_emoji ? [] : p));
        if (!d.length) u = "Emoji";
        else {
          if (eh.has(f[0])) throw ug("leading combining mark");
          for (let g = 1; g < l; g++) {
            let w = o[g];
            if (!w.is_emoji && eh.has(w[0]))
              throw ug(
                `emoji + combining mark: "${Z0(o[g - 1])} + ${n6([w[0]])}"`
              );
          }
          u2e(f);
          let p = U5(new Set(d)),
            [m] = p2e(p);
          g2e(m, d), h2e(m, p), (u = m.N);
        }
      }
      a.type = u;
    } catch (o) {
      a.error = o;
    }
    return a;
  });
}
function h2e(t, e) {
  let n,
    r = [];
  for (let i of e) {
    let s = Ip.get(i);
    if (s === FV) return;
    if (s) {
      let a = s.M.get(i);
      if (((n = n ? n.filter((o) => a.has(o)) : U5(a)), !n.length)) return;
    } else r.push(i);
  }
  if (n) {
    for (let i of n)
      if (r.every((s) => ty(i, s)))
        throw new Error(`whole-script confusable: ${t.N}/${i.N}`);
  }
}
function p2e(t) {
  let e = g0;
  for (let n of t) {
    let r = e.filter((i) => ty(i, n));
    if (!r.length) throw g0.some((i) => ty(i, n)) ? zV(e[0], n) : HV(n);
    if (((e = r), r.length == 1)) break;
  }
  return e;
}
function m2e(t) {
  return t
    .map(({ input: e, error: n, output: r }) => {
      if (n) {
        let i = n.message;
        throw new Error(
          t.length == 1 ? i : `Invalid label ${OT(n6(e, 63))}: ${i}`
        );
      }
      return Z0(r);
    })
    .join(LV);
}
function HV(t) {
  return new Error(`disallowed character: ${IT(t)}`);
}
function zV(t, e) {
  let n = IT(e),
    r = g0.find((i) => i.P.has(e));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`);
}
function ug(t) {
  return new Error(`illegal placement: ${t}`);
}
function g2e(t, e) {
  for (let n of e) if (!ty(t, n)) throw zV(t, n);
  if (t.M) {
    let n = MV(e);
    for (let r = 1, i = n.length; r < i; r++)
      if (qE.has(n[r])) {
        let s = r + 1;
        for (let a; s < i && qE.has((a = n[s])); s++)
          for (let o = r; o < s; o++)
            if (n[o] == a)
              throw new Error(`duplicate non-spacing marks: ${IT(a)}`);
        if (s - r > iN)
          throw new Error(
            `excessive non-spacing marks: ${OT(n6(n.slice(r - 1, s)))} (${
              s - r
            }/${iN})`
          );
        r = s;
      }
  }
}
function y2e(t, e, n) {
  let r = [],
    i = [];
  for (t = t.slice().reverse(); t.length; ) {
    let s = b2e(t);
    if (s) i.length && (r.push(e(i)), (i = [])), r.push(n(s));
    else {
      let a = t.pop();
      if (Hd.has(a)) i.push(a);
      else {
        let o = WE.get(a);
        if (o) i.push(...o);
        else if (!$V.has(a)) throw HV(a);
      }
    }
  }
  return i.length && r.push(e(i)), r;
}
function v2e(t) {
  return t.filter((e) => e != BV);
}
function b2e(t, e) {
  let n = KE,
    r,
    i = t.length;
  for (; i && ((n = n.get(t[--i])), !!n); ) {
    let { V: s } = n;
    s && ((r = s), e && e.push(...t.slice(i).reverse()), (t.length = i));
  }
  return r;
}
const VV = new Uint8Array(32);
VV.fill(0);
function lN(t) {
  return ge(t.length !== 0, "invalid ENS name; empty component", "comp", t), t;
}
function GV(t) {
  const e = Hc(w2e(t)),
    n = [];
  if (t.length === 0) return n;
  let r = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (n.push(lN(e.slice(r, i))), (r = i + 1));
  return (
    ge(r < e.length, "invalid ENS name; empty component", "name", t),
    n.push(lN(e.slice(r))),
    n
  );
}
function w2e(t) {
  try {
    if (t.length === 0) throw new Error("empty label");
    return f2e(t);
  } catch (e) {
    ge(!1, `invalid ENS name (${e.message})`, "name", t);
  }
}
function XE(t) {
  ge(typeof t == "string", "invalid ENS name; not a string", "name", t),
    ge(t.length, "invalid ENS name (empty label)", "name", t);
  let e = VV;
  const n = GV(t);
  for (; n.length; ) e = Zr(Di([e, Zr(n.pop())]));
  return Gt(e);
}
function _2e(t, e) {
  const n = e ?? 63;
  return (
    ge(n <= 255, "DNS encoded label cannot exceed 255", "length", n),
    Gt(
      Di(
        GV(t).map((r) => {
          ge(
            r.length <= n,
            `label ${JSON.stringify(t)} exceeds ${n} bytes`,
            "name",
            t
          );
          const i = new Uint8Array(r.length + 1);
          return i.set(r, 1), (i[0] = i.length - 1), i;
        })
      )
    ) + "00"
  );
}
function f8(t, e) {
  return {
    address: yr(t),
    storageKeys: e.map(
      (n, r) => (
        ge(Mr(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()
      )
    ),
  };
}
function Fh(t) {
  if (Array.isArray(t))
    return t.map((n, r) =>
      Array.isArray(n)
        ? (ge(n.length === 2, "invalid slot set", `value[${r}]`, n),
          f8(n[0], n[1]))
        : (ge(
            n != null && typeof n == "object",
            "invalid address-slot set",
            "value",
            t
          ),
          f8(n.address, n.storageKeys))
    );
  ge(t != null && typeof t == "object", "invalid access list", "value", t);
  const e = Object.keys(t).map((n) => {
    const r = t[n].reduce((i, s) => ((i[s] = !0), i), {});
    return f8(n, Object.keys(r).sort());
  });
  return e.sort((n, r) => n.address.localeCompare(r.address)), e;
}
function E2e(t) {
  let e;
  return (
    typeof t == "string" ? (e = Rc.computePublicKey(t, !1)) : (e = t.publicKey),
    yr(Zr("0x" + e.substring(4)).substring(26))
  );
}
function x2e(t, e) {
  return E2e(Rc.recoverPublicKey(t, e));
}
const _s = BigInt(0),
  T2e = BigInt(2),
  S2e = BigInt(27),
  A2e = BigInt(28),
  C2e = BigInt(35),
  k2e = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function r6(t) {
  return t === "0x" ? null : yr(t);
}
function PT(t, e) {
  try {
    return Fh(t);
  } catch (n) {
    ge(!1, n.message, e, t);
  }
}
function Dy(t, e) {
  return t === "0x" ? 0 : kn(t, e);
}
function Pi(t, e) {
  if (t === "0x") return _s;
  const n = Lt(t, e);
  return ge(n <= k2e, "value exceeds uint size", e, n), n;
}
function $r(t, e) {
  const n = Lt(t, "value"),
    r = _a(n);
  return ge(r.length <= 32, "value too large", `tx.${e}`, n), r;
}
function NT(t) {
  return Fh(t).map((e) => [e.address, e.storageKeys]);
}
function I2e(t, e) {
  ge(Array.isArray(t), `invalid ${e}`, "value", t);
  for (let n = 0; n < t.length; n++)
    ge(Mr(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
  return t;
}
function O2e(t) {
  const e = Zw(t);
  ge(
    Array.isArray(e) && (e.length === 9 || e.length === 6),
    "invalid field count for legacy transaction",
    "data",
    t
  );
  const n = {
    type: 0,
    nonce: Dy(e[0], "nonce"),
    gasPrice: Pi(e[1], "gasPrice"),
    gasLimit: Pi(e[2], "gasLimit"),
    to: r6(e[3]),
    value: Pi(e[4], "value"),
    data: Gt(e[5]),
    chainId: _s,
  };
  if (e.length === 6) return n;
  const r = Pi(e[6], "v"),
    i = Pi(e[7], "r"),
    s = Pi(e[8], "s");
  if (i === _s && s === _s) n.chainId = r;
  else {
    let a = (r - C2e) / T2e;
    a < _s && (a = _s),
      (n.chainId = a),
      ge(
        a !== _s || r === S2e || r === A2e,
        "non-canonical legacy v",
        "v",
        e[6]
      ),
      (n.signature = Zi.from({ r: _h(e[7], 32), s: _h(e[8], 32), v: r })),
      (n.hash = Zr(t));
  }
  return n;
}
function uN(t, e) {
  const n = [
    $r(t.nonce, "nonce"),
    $r(t.gasPrice || 0, "gasPrice"),
    $r(t.gasLimit, "gasLimit"),
    t.to || "0x",
    $r(t.value, "value"),
    t.data,
  ];
  let r = _s;
  if (t.chainId != _s)
    (r = Lt(t.chainId, "tx.chainId")),
      ge(
        !e || e.networkV == null || e.legacyChainId === r,
        "tx.chainId/sig.v mismatch",
        "sig",
        e
      );
  else if (t.signature) {
    const s = t.signature.legacyChainId;
    s != null && (r = s);
  }
  if (!e) return r !== _s && (n.push(_a(r)), n.push("0x"), n.push("0x")), W0(n);
  let i = BigInt(27 + e.yParity);
  return (
    r !== _s
      ? (i = Zi.getChainIdV(r, e.v))
      : BigInt(e.v) !== i && ge(!1, "tx.chainId/sig.v mismatch", "sig", e),
    n.push(_a(i)),
    n.push(_a(e.r)),
    n.push(_a(e.s)),
    W0(n)
  );
}
function DT(t, e) {
  let n;
  try {
    if (((n = Dy(e[0], "yParity")), n !== 0 && n !== 1))
      throw new Error("bad yParity");
  } catch {
    ge(!1, "invalid yParity", "yParity", e[0]);
  }
  const r = _h(e[1], 32),
    i = _h(e[2], 32),
    s = Zi.from({ r, s: i, yParity: n });
  t.signature = s;
}
function P2e(t) {
  const e = Zw(er(t).slice(1));
  ge(
    Array.isArray(e) && (e.length === 9 || e.length === 12),
    "invalid field count for transaction type: 2",
    "data",
    Gt(t)
  );
  const n = {
    type: 2,
    chainId: Pi(e[0], "chainId"),
    nonce: Dy(e[1], "nonce"),
    maxPriorityFeePerGas: Pi(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Pi(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Pi(e[4], "gasLimit"),
    to: r6(e[5]),
    value: Pi(e[6], "value"),
    data: Gt(e[7]),
    accessList: PT(e[8], "accessList"),
  };
  return e.length === 9 || ((n.hash = Zr(t)), DT(n, e.slice(9))), n;
}
function cN(t, e) {
  const n = [
    $r(t.chainId, "chainId"),
    $r(t.nonce, "nonce"),
    $r(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    $r(t.maxFeePerGas || 0, "maxFeePerGas"),
    $r(t.gasLimit, "gasLimit"),
    t.to || "0x",
    $r(t.value, "value"),
    t.data,
    NT(t.accessList || []),
  ];
  return (
    e && (n.push($r(e.yParity, "yParity")), n.push(_a(e.r)), n.push(_a(e.s))),
    Di(["0x02", W0(n)])
  );
}
function N2e(t) {
  const e = Zw(er(t).slice(1));
  ge(
    Array.isArray(e) && (e.length === 8 || e.length === 11),
    "invalid field count for transaction type: 1",
    "data",
    Gt(t)
  );
  const n = {
    type: 1,
    chainId: Pi(e[0], "chainId"),
    nonce: Dy(e[1], "nonce"),
    gasPrice: Pi(e[2], "gasPrice"),
    gasLimit: Pi(e[3], "gasLimit"),
    to: r6(e[4]),
    value: Pi(e[5], "value"),
    data: Gt(e[6]),
    accessList: PT(e[7], "accessList"),
  };
  return e.length === 8 || ((n.hash = Zr(t)), DT(n, e.slice(8))), n;
}
function fN(t, e) {
  const n = [
    $r(t.chainId, "chainId"),
    $r(t.nonce, "nonce"),
    $r(t.gasPrice || 0, "gasPrice"),
    $r(t.gasLimit, "gasLimit"),
    t.to || "0x",
    $r(t.value, "value"),
    t.data,
    NT(t.accessList || []),
  ];
  return (
    e &&
      (n.push($r(e.yParity, "recoveryParam")),
      n.push(_a(e.r)),
      n.push(_a(e.s))),
    Di(["0x01", W0(n)])
  );
}
function D2e(t) {
  const e = Zw(er(t).slice(1));
  ge(
    Array.isArray(e) && (e.length === 11 || e.length === 14),
    "invalid field count for transaction type: 3",
    "data",
    Gt(t)
  );
  const n = {
    type: 3,
    chainId: Pi(e[0], "chainId"),
    nonce: Dy(e[1], "nonce"),
    maxPriorityFeePerGas: Pi(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Pi(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Pi(e[4], "gasLimit"),
    to: r6(e[5]),
    value: Pi(e[6], "value"),
    data: Gt(e[7]),
    accessList: PT(e[8], "accessList"),
    maxFeePerBlobGas: Pi(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10],
  };
  ge(n.to != null, "invalid address for transaction type: 3", "data", t),
    ge(
      Array.isArray(n.blobVersionedHashes),
      "invalid blobVersionedHashes: must be an array",
      "data",
      t
    );
  for (let r = 0; r < n.blobVersionedHashes.length; r++)
    ge(
      Mr(n.blobVersionedHashes[r], 32),
      `invalid blobVersionedHash at index ${r}: must be length 32`,
      "data",
      t
    );
  return e.length === 11 || ((n.hash = Zr(t)), DT(n, e.slice(11))), n;
}
function dN(t, e) {
  const n = [
    $r(t.chainId, "chainId"),
    $r(t.nonce, "nonce"),
    $r(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    $r(t.maxFeePerGas || 0, "maxFeePerGas"),
    $r(t.gasLimit, "gasLimit"),
    t.to || dd,
    $r(t.value, "value"),
    t.data,
    NT(t.accessList || []),
    $r(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    I2e(t.blobVersionedHashes || [], "blobVersionedHashes"),
  ];
  return (
    e && (n.push($r(e.yParity, "yParity")), n.push(_a(e.r)), n.push(_a(e.s))),
    Di(["0x03", W0(n)])
  );
}
let WV = class If {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  #s;
  #o;
  #c;
  #u;
  #d;
  #h;
  #l;
  #f;
  get type() {
    return this.#e;
  }
  set type(e) {
    switch (e) {
      case null:
        this.#e = null;
        break;
      case 0:
      case "legacy":
        this.#e = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#e = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#e = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#e = 3;
        break;
      default:
        ge(!1, "unsupported transaction type", "type", e);
    }
  }
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  get to() {
    const e = this.#t;
    return e == null && this.type === 3 ? dd : e;
  }
  set to(e) {
    this.#t = e == null ? null : yr(e);
  }
  get nonce() {
    return this.#r;
  }
  set nonce(e) {
    this.#r = kn(e, "value");
  }
  get gasLimit() {
    return this.#i;
  }
  set gasLimit(e) {
    this.#i = Lt(e);
  }
  get gasPrice() {
    const e = this.#a;
    return e == null && (this.type === 0 || this.type === 1) ? _s : e;
  }
  set gasPrice(e) {
    this.#a = e == null ? null : Lt(e, "gasPrice");
  }
  get maxPriorityFeePerGas() {
    const e = this.#s;
    return e ?? (this.type === 2 || this.type === 3 ? _s : null);
  }
  set maxPriorityFeePerGas(e) {
    this.#s = e == null ? null : Lt(e, "maxPriorityFeePerGas");
  }
  get maxFeePerGas() {
    const e = this.#o;
    return e ?? (this.type === 2 || this.type === 3 ? _s : null);
  }
  set maxFeePerGas(e) {
    this.#o = e == null ? null : Lt(e, "maxFeePerGas");
  }
  get data() {
    return this.#n;
  }
  set data(e) {
    this.#n = Gt(e);
  }
  get value() {
    return this.#c;
  }
  set value(e) {
    this.#c = Lt(e, "value");
  }
  get chainId() {
    return this.#u;
  }
  set chainId(e) {
    this.#u = Lt(e);
  }
  get signature() {
    return this.#d || null;
  }
  set signature(e) {
    this.#d = e == null ? null : Zi.from(e);
  }
  get accessList() {
    const e = this.#h || null;
    return (
      e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
    );
  }
  set accessList(e) {
    this.#h = e == null ? null : Fh(e);
  }
  get maxFeePerBlobGas() {
    const e = this.#l;
    return e == null && this.type === 3 ? _s : e;
  }
  set maxFeePerBlobGas(e) {
    this.#l = e == null ? null : Lt(e, "maxFeePerBlobGas");
  }
  get blobVersionedHashes() {
    let e = this.#f;
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      ge(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e),
        (e = e.slice());
      for (let n = 0; n < e.length; n++)
        ge(Mr(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n]);
    }
    this.#f = e;
  }
  constructor() {
    (this.#e = null),
      (this.#t = null),
      (this.#r = 0),
      (this.#i = _s),
      (this.#a = null),
      (this.#s = null),
      (this.#o = null),
      (this.#n = "0x"),
      (this.#c = _s),
      (this.#u = _s),
      (this.#d = null),
      (this.#h = null),
      (this.#l = null),
      (this.#f = null);
  }
  get hash() {
    return this.signature == null ? null : Zr(this.serialized);
  }
  get unsignedHash() {
    return Zr(this.unsignedSerialized);
  }
  get from() {
    return this.signature == null
      ? null
      : x2e(this.unsignedHash, this.signature);
  }
  get fromPublicKey() {
    return this.signature == null
      ? null
      : Rc.recoverPublicKey(this.unsignedHash, this.signature);
  }
  isSigned() {
    return this.signature != null;
  }
  get serialized() {
    switch (
      (Ue(
        this.signature != null,
        "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
        "UNSUPPORTED_OPERATION",
        { operation: ".serialized" }
      ),
      this.inferType())
    ) {
      case 0:
        return uN(this, this.signature);
      case 1:
        return fN(this, this.signature);
      case 2:
        return cN(this, this.signature);
      case 3:
        return dN(this, this.signature);
    }
    Ue(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
      operation: ".serialized",
    });
  }
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return uN(this);
      case 1:
        return fN(this);
      case 2:
        return cN(this);
      case 3:
        return dN(this);
    }
    Ue(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
      operation: ".unsignedSerialized",
    });
  }
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  inferTypes() {
    const e = this.gasPrice != null,
      n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null,
      r = this.accessList != null,
      i = this.#l != null || this.#f;
    this.maxFeePerGas != null &&
      this.maxPriorityFeePerGas != null &&
      Ue(
        this.maxFeePerGas >= this.maxPriorityFeePerGas,
        "priorityFee cannot be more than maxFee",
        "BAD_DATA",
        { value: this }
      ),
      Ue(
        !n || (this.type !== 0 && this.type !== 1),
        "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
        "BAD_DATA",
        { value: this }
      ),
      Ue(
        this.type !== 0 || !r,
        "legacy transaction cannot have accessList",
        "BAD_DATA",
        { value: this }
      );
    const s = [];
    return (
      this.type != null
        ? s.push(this.type)
        : n
        ? s.push(2)
        : e
        ? (s.push(1), r || s.push(0))
        : r
        ? (s.push(1), s.push(2))
        : ((i && this.to) || (s.push(0), s.push(1), s.push(2)), s.push(3)),
      s.sort(),
      s
    );
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  clone() {
    return If.from(this);
  }
  toJSON() {
    const e = (n) => (n == null ? null : n.toString());
    return {
      type: this.type,
      to: this.to,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList,
    };
  }
  static from(e) {
    if (e == null) return new If();
    if (typeof e == "string") {
      const r = er(e);
      if (r[0] >= 127) return If.from(O2e(r));
      switch (r[0]) {
        case 1:
          return If.from(N2e(r));
        case 2:
          return If.from(P2e(r));
        case 3:
          return If.from(D2e(r));
      }
      Ue(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: "from",
      });
    }
    const n = new If();
    return (
      e.type != null && (n.type = e.type),
      e.to != null && (n.to = e.to),
      e.nonce != null && (n.nonce = e.nonce),
      e.gasLimit != null && (n.gasLimit = e.gasLimit),
      e.gasPrice != null && (n.gasPrice = e.gasPrice),
      e.maxPriorityFeePerGas != null &&
        (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
      e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas),
      e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas),
      e.data != null && (n.data = e.data),
      e.value != null && (n.value = e.value),
      e.chainId != null && (n.chainId = e.chainId),
      e.signature != null && (n.signature = Zi.from(e.signature)),
      e.accessList != null && (n.accessList = e.accessList),
      e.blobVersionedHashes != null &&
        (n.blobVersionedHashes = e.blobVersionedHashes),
      e.hash != null &&
        (ge(n.isSigned(), "unsigned transaction cannot define hash", "tx", e),
        ge(n.hash === e.hash, "hash mismatch", "tx", e)),
      e.from != null &&
        (ge(n.isSigned(), "unsigned transaction cannot define from", "tx", e),
        ge(
          n.from.toLowerCase() === (e.from || "").toLowerCase(),
          "from mismatch",
          "tx",
          e
        )),
      n
    );
  }
};
const qV = new Uint8Array(32);
qV.fill(0);
const R2e = BigInt(-1),
  KV = BigInt(0),
  XV = BigInt(1),
  M2e = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function L2e(t) {
  const e = er(t),
    n = e.length % 32;
  return n ? Di([e, qV.slice(n)]) : Gt(e);
}
const B2e = ud(XV, 32),
  F2e = ud(KV, 32),
  hN = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  d8 = ["name", "version", "chainId", "verifyingContract", "salt"];
function pN(t) {
  return function (e) {
    return (
      ge(
        typeof e == "string",
        `invalid domain value for ${JSON.stringify(t)}`,
        `domain.${t}`,
        e
      ),
      e
    );
  };
}
const $2e = {
  name: pN("name"),
  version: pN("version"),
  chainId: function (t) {
    const e = Lt(t, "domain.chainId");
    return (
      ge(e >= 0, "invalid chain ID", "domain.chainId", t),
      Number.isSafeInteger(e) ? Number(e) : Qd(e)
    );
  },
  verifyingContract: function (t) {
    try {
      return yr(t).toLowerCase();
    } catch {}
    ge(
      !1,
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      t
    );
  },
  salt: function (t) {
    const e = er(t, "domain.salt");
    return (
      ge(e.length === 32, 'invalid domain value "salt"', "domain.salt", t),
      Gt(e)
    );
  },
};
function h8(t) {
  {
    const e = t.match(/^(u?)int(\d+)$/);
    if (e) {
      const n = e[1] === "",
        r = parseInt(e[2]);
      ge(
        r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r),
        "invalid numeric width",
        "type",
        t
      );
      const i = Yd(M2e, n ? r - 1 : r),
        s = n ? (i + XV) * R2e : KV;
      return function (a) {
        const o = Lt(a, "value");
        return (
          ge(o >= s && o <= i, `value out-of-bounds for ${t}`, "value", o),
          ud(n ? Dz(o, 256) : o, 32)
        );
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const n = parseInt(e[1]);
      return (
        ge(
          n !== 0 && n <= 32 && e[1] === String(n),
          "invalid bytes width",
          "type",
          t
        ),
        function (r) {
          const i = er(r);
          return (
            ge(i.length === n, `invalid length for ${t}`, "value", r), L2e(r)
          );
        }
      );
    }
  }
  switch (t) {
    case "address":
      return function (e) {
        return _h(yr(e), 32);
      };
    case "bool":
      return function (e) {
        return e ? B2e : F2e;
      };
    case "bytes":
      return function (e) {
        return Zr(e);
      };
    case "string":
      return function (e) {
        return xh(e);
      };
  }
  return null;
}
function mN(t, e) {
  return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
function vv(t) {
  const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e
    ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
          base: e[1],
          prefix: e[1] + e[2],
          count: e[5] ? parseInt(e[5]) : -1,
        },
      }
    : { base: t };
}
class xo {
  primaryType;
  #e;
  get types() {
    return JSON.parse(this.#e);
  }
  #t;
  #n;
  constructor(e) {
    (this.#t = new Map()), (this.#n = new Map());
    const n = new Map(),
      r = new Map(),
      i = new Map(),
      s = {};
    Object.keys(e).forEach((l) => {
      (s[l] = e[l].map(({ name: u, type: f }) => {
        let { base: c, index: d } = vv(f);
        return (
          c === "int" && !e.int && (c = "int256"),
          c === "uint" && !e.uint && (c = "uint256"),
          { name: u, type: c + (d || "") }
        );
      })),
        n.set(l, new Set()),
        r.set(l, []),
        i.set(l, new Set());
    }),
      (this.#e = JSON.stringify(s));
    for (const l in s) {
      const u = new Set();
      for (const f of s[l]) {
        ge(
          !u.has(f.name),
          `duplicate variable name ${JSON.stringify(
            f.name
          )} in ${JSON.stringify(l)}`,
          "types",
          e
        ),
          u.add(f.name);
        const c = vv(f.type).base;
        ge(
          c !== l,
          `circular type reference to ${JSON.stringify(c)}`,
          "types",
          e
        ),
          !h8(c) &&
            (ge(r.has(c), `unknown type ${JSON.stringify(c)}`, "types", e),
            r.get(c).push(l),
            n.get(l).add(c));
      }
    }
    const a = Array.from(r.keys()).filter((l) => r.get(l).length === 0);
    ge(a.length !== 0, "missing primary type", "types", e),
      ge(
        a.length === 1,
        `ambiguous primary types or unused types: ${a
          .map((l) => JSON.stringify(l))
          .join(", ")}`,
        "types",
        e
      ),
      nn(this, { primaryType: a[0] });
    function o(l, u) {
      ge(
        !u.has(l),
        `circular type reference to ${JSON.stringify(l)}`,
        "types",
        e
      ),
        u.add(l);
      for (const f of n.get(l))
        if (r.has(f)) {
          o(f, u);
          for (const c of u) i.get(c).add(f);
        }
      u.delete(l);
    }
    o(this.primaryType, new Set());
    for (const [l, u] of i) {
      const f = Array.from(u);
      f.sort(),
        this.#t.set(l, mN(l, s[l]) + f.map((c) => mN(c, s[c])).join(""));
    }
  }
  getEncoder(e) {
    let n = this.#n.get(e);
    return n || ((n = this.#r(e)), this.#n.set(e, n)), n;
  }
  #r(e) {
    {
      const i = h8(e);
      if (i) return i;
    }
    const n = vv(e).array;
    if (n) {
      const i = n.prefix,
        s = this.getEncoder(i);
      return (a) => {
        ge(
          n.count === -1 || n.count === a.length,
          `array length mismatch; expected length ${n.count}`,
          "value",
          a
        );
        let o = a.map(s);
        return this.#t.has(i) && (o = o.map(Zr)), Zr(Di(o));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = xh(this.#t.get(e));
      return (s) => {
        const a = r.map(({ name: o, type: l }) => {
          const u = this.getEncoder(l)(s[o]);
          return this.#t.has(l) ? Zr(u) : u;
        });
        return a.unshift(i), Di(a);
      };
    }
    ge(!1, `unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const n = this.#t.get(e);
    return ge(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n;
  }
  encodeData(e, n) {
    return this.getEncoder(e)(n);
  }
  hashStruct(e, n) {
    return Zr(this.encodeData(e, n));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, n, r) {
    if (h8(e)) return r(e, n);
    const i = vv(e).array;
    if (i)
      return (
        ge(
          i.count === -1 || i.count === n.length,
          `array length mismatch; expected length ${i.count}`,
          "value",
          n
        ),
        n.map((a) => this._visit(i.prefix, a, r))
      );
    const s = this.types[e];
    if (s)
      return s.reduce(
        (a, { name: o, type: l }) => ((a[o] = this._visit(l, n[o], r)), a),
        {}
      );
    ge(!1, `unknown type: ${e}`, "type", e);
  }
  visit(e, n) {
    return this._visit(this.primaryType, e, n);
  }
  static from(e) {
    return new xo(e);
  }
  static getPrimaryType(e) {
    return xo.from(e).primaryType;
  }
  static hashStruct(e, n, r) {
    return xo.from(n).hashStruct(e, r);
  }
  static hashDomain(e) {
    const n = [];
    for (const r in e) {
      if (e[r] == null) continue;
      const i = hN[r];
      ge(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e),
        n.push({ name: r, type: i });
    }
    return (
      n.sort((r, i) => d8.indexOf(r.name) - d8.indexOf(i.name)),
      xo.hashStruct("EIP712Domain", { EIP712Domain: n }, e)
    );
  }
  static encode(e, n, r) {
    return Di(["0x1901", xo.hashDomain(e), xo.from(n).hash(r)]);
  }
  static hash(e, n, r) {
    return Zr(xo.encode(e, n, r));
  }
  static async resolveNames(e, n, r, i) {
    e = Object.assign({}, e);
    for (const o in e) e[o] == null && delete e[o];
    const s = {};
    e.verifyingContract &&
      !Mr(e.verifyingContract, 20) &&
      (s[e.verifyingContract] = "0x");
    const a = xo.from(n);
    a.visit(r, (o, l) => (o === "address" && !Mr(l, 20) && (s[l] = "0x"), l));
    for (const o in s) s[o] = await i(o);
    return (
      e.verifyingContract &&
        s[e.verifyingContract] &&
        (e.verifyingContract = s[e.verifyingContract]),
      (r = a.visit(r, (o, l) => (o === "address" && s[l] ? s[l] : l))),
      { domain: e, value: r }
    );
  }
  static getPayload(e, n, r) {
    xo.hashDomain(e);
    const i = {},
      s = [];
    d8.forEach((l) => {
      const u = e[l];
      u != null && ((i[l] = $2e[l](u)), s.push({ name: l, type: hN[l] }));
    });
    const a = xo.from(n);
    n = a.types;
    const o = Object.assign({}, n);
    return (
      ge(
        o.EIP712Domain == null,
        "types must not contain EIP712Domain type",
        "types.EIP712Domain",
        n
      ),
      (o.EIP712Domain = s),
      a.encode(r),
      {
        types: o,
        domain: i,
        primaryType: a.primaryType,
        message: a.visit(r, (l, u) => {
          if (l.match(/^bytes(\d*)/)) return Gt(er(u));
          if (l.match(/^u?int/)) return Lt(u).toString();
          switch (l) {
            case "address":
              return u.toLowerCase();
            case "bool":
              return !!u;
            case "string":
              return ge(typeof u == "string", "invalid string", "value", u), u;
          }
          ge(!1, "unsupported type", "type", l);
        }),
      }
    );
  }
}
function Ta(t) {
  const e = new Set();
  return t.forEach((n) => e.add(n)), Object.freeze(e);
}
const U2e = "external public payable override",
  j2e = Ta(U2e.split(" ")),
  ZV = "constant external internal payable private public pure view override",
  H2e = Ta(ZV.split(" ")),
  YV = "constructor error event fallback function receive struct",
  QV = Ta(YV.split(" ")),
  JV = "calldata memory storage payable indexed",
  z2e = Ta(JV.split(" ")),
  V2e = "tuple returns",
  G2e = [YV, JV, V2e, ZV].join(" "),
  W2e = Ta(G2e.split(" ")),
  q2e = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT",
  },
  K2e = new RegExp("^(\\s*)"),
  X2e = new RegExp("^([0-9]+)"),
  Z2e = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
  eG = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
  tG = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class vl {
  #e;
  #t;
  get offset() {
    return this.#e;
  }
  get length() {
    return this.#t.length - this.#e;
  }
  constructor(e) {
    (this.#e = 0), (this.#t = e.slice());
  }
  clone() {
    return new vl(this.#t);
  }
  reset() {
    this.#e = 0;
  }
  #n(e = 0, n = 0) {
    return new vl(
      this.#t.slice(e, n).map((r) =>
        Object.freeze(
          Object.assign({}, r, {
            match: r.match - e,
            linkBack: r.linkBack - e,
            linkNext: r.linkNext - e,
          })
        )
      )
    );
  }
  popKeyword(e) {
    const n = this.peek();
    if (n.type !== "KEYWORD" || !e.has(n.text))
      throw new Error(`expected keyword ${n.text}`);
    return this.pop().text;
  }
  popType(e) {
    if (this.peek().type !== e) {
      const n = this.peek();
      throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`);
    }
    return this.pop().text;
  }
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN") throw new Error("bad start");
    const n = this.#n(this.#e + 1, e.match + 1);
    return (this.#e = e.match + 1), n;
  }
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN") throw new Error("bad start");
    const n = [];
    for (; this.#e < e.match - 1; ) {
      const r = this.peek().linkNext;
      n.push(this.#n(this.#e + 1, r)), (this.#e = r);
    }
    return (this.#e = e.match + 1), n;
  }
  peek() {
    if (this.#e >= this.#t.length) throw new Error("out-of-bounds");
    return this.#t[this.#e];
  }
  peekKeyword(e) {
    const n = this.peekType("KEYWORD");
    return n != null && e.has(n) ? n : null;
  }
  peekType(e) {
    if (this.length === 0) return null;
    const n = this.peek();
    return n.type === e ? n.text : null;
  }
  pop() {
    const e = this.peek();
    return this.#e++, e;
  }
  toString() {
    const e = [];
    for (let n = this.#e; n < this.#t.length; n++) {
      const r = this.#t[n];
      e.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
}
function xd(t) {
  const e = [],
    n = (a) => {
      const o = s < t.length ? JSON.stringify(t[s]) : "$EOI";
      throw new Error(`invalid token ${o} at ${s}: ${a}`);
    };
  let r = [],
    i = [],
    s = 0;
  for (; s < t.length; ) {
    let a = t.substring(s),
      o = a.match(K2e);
    o && ((s += o[1].length), (a = t.substring(s)));
    const l = {
      depth: r.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset: s,
      value: -1,
    };
    e.push(l);
    let u = q2e[a[0]] || "";
    if (u) {
      if (((l.type = u), (l.text = a[0]), s++, u === "OPEN_PAREN"))
        r.push(e.length - 1), i.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        r.length === 0 && n("no matching open bracket"),
          (l.match = r.pop()),
          (e[l.match].match = e.length - 1),
          l.depth--,
          (l.linkBack = i.pop()),
          (e[l.linkBack].linkNext = e.length - 1);
      else if (u === "COMMA")
        (l.linkBack = i.pop()),
          (e[l.linkBack].linkNext = e.length - 1),
          i.push(e.length - 1);
      else if (u === "OPEN_BRACKET") l.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let f = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const c = e.pop().text;
          (f = c + f), (e[e.length - 1].value = kn(c));
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += f;
      }
      continue;
    }
    if (((o = a.match(Z2e)), o)) {
      if (((l.text = o[1]), (s += l.text.length), W2e.has(l.text))) {
        l.type = "KEYWORD";
        continue;
      }
      if (l.text.match(tG)) {
        l.type = "TYPE";
        continue;
      }
      l.type = "ID";
      continue;
    }
    if (((o = a.match(X2e)), o)) {
      (l.text = o[1]), (l.type = "NUMBER"), (s += l.text.length);
      continue;
    }
    throw new Error(
      `unexpected token ${JSON.stringify(a[0])} at position ${s}`
    );
  }
  return new vl(e.map((a) => Object.freeze(a)));
}
function gN(t, e) {
  let n = [];
  for (const r in e.keys()) t.has(r) && n.push(r);
  if (n.length > 1) throw new Error(`conflicting types: ${n.join(", ")}`);
}
function i6(t, e) {
  if (e.peekKeyword(QV)) {
    const n = e.pop().text;
    if (n !== t) throw new Error(`expected ${t}, got ${n}`);
  }
  return e.popType("ID");
}
function ef(t, e) {
  const n = new Set();
  for (;;) {
    const r = t.peekType("KEYWORD");
    if (r == null || (e && !e.has(r))) break;
    if ((t.pop(), n.has(r)))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    n.add(r);
  }
  return Object.freeze(n);
}
function nG(t) {
  let e = ef(t, H2e);
  return (
    gN(e, Ta("constant payable nonpayable".split(" "))),
    gN(e, Ta("pure view payable nonpayable".split(" "))),
    e.has("view")
      ? "view"
      : e.has("pure")
      ? "pure"
      : e.has("payable")
      ? "payable"
      : e.has("nonpayable")
      ? "nonpayable"
      : e.has("constant")
      ? "view"
      : "nonpayable"
  );
}
function zc(t, e) {
  return t.popParams().map((n) => Dr.from(n, e));
}
function rG(t) {
  if (t.peekType("AT")) {
    if ((t.pop(), t.peekType("NUMBER"))) return Lt(t.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function Th(t) {
  if (t.length)
    throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`);
}
const Y2e = new RegExp(/^(.*)\[([0-9]*)\]$/);
function yN(t) {
  const e = t.match(tG);
  if ((ge(e, "invalid type", "type", t), t === "uint")) return "uint256";
  if (t === "int") return "int256";
  if (e[2]) {
    const n = parseInt(e[2]);
    ge(n !== 0 && n <= 32, "invalid bytes length", "type", t);
  } else if (e[3]) {
    const n = parseInt(e[3]);
    ge(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t);
  }
  return t;
}
const ai = {},
  oo = Symbol.for("_ethers_internal"),
  vN = "_ParamTypeInternal",
  bN = "_ErrorInternal",
  wN = "_EventInternal",
  _N = "_ConstructorInternal",
  EN = "_FallbackInternal",
  xN = "_FunctionInternal",
  TN = "_StructInternal";
class Dr {
  name;
  type;
  baseType;
  indexed;
  components;
  arrayLength;
  arrayChildren;
  constructor(e, n, r, i, s, a, o, l) {
    if (
      (Oy(e, ai, "ParamType"),
      Object.defineProperty(this, oo, { value: vN }),
      a && (a = Object.freeze(a.slice())),
      i === "array")
    ) {
      if (o == null || l == null) throw new Error("");
    } else if (o != null || l != null) throw new Error("");
    if (i === "tuple") {
      if (a == null) throw new Error("");
    } else if (a != null) throw new Error("");
    nn(this, {
      name: n,
      type: r,
      baseType: i,
      indexed: s,
      components: a,
      arrayLength: o,
      arrayChildren: l,
    });
  }
  format(e) {
    if ((e == null && (e = "sighash"), e === "json")) {
      const r = this.name || "";
      if (this.isArray()) {
        const s = JSON.parse(this.arrayChildren.format("json"));
        return (
          (s.name = r),
          (s.type += `[${
            this.arrayLength < 0 ? "" : String(this.arrayLength)
          }]`),
          JSON.stringify(s)
        );
      }
      const i = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r,
      };
      return (
        typeof this.indexed == "boolean" && (i.indexed = this.indexed),
        this.isTuple() &&
          (i.components = this.components.map((s) => JSON.parse(s.format(e)))),
        JSON.stringify(i)
      );
    }
    let n = "";
    return (
      this.isArray()
        ? ((n += this.arrayChildren.format(e)),
          (n += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`))
        : this.isTuple()
        ? (n +=
            "(" +
            this.components
              .map((r) => r.format(e))
              .join(e === "full" ? ", " : ",") +
            ")")
        : (n += this.type),
      e !== "sighash" &&
        (this.indexed === !0 && (n += " indexed"),
        e === "full" && this.name && (n += " " + this.name)),
      n
    );
  }
  isArray() {
    return this.baseType === "array";
  }
  isTuple() {
    return this.baseType === "tuple";
  }
  isIndexable() {
    return this.indexed != null;
  }
  walk(e, n) {
    if (this.isArray()) {
      if (!Array.isArray(e)) throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((i) => r.arrayChildren.walk(i, n));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e)) throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((i, s) => r.components[s].walk(i, n));
    }
    return n(this.type, e);
  }
  #e(e, n, r, i) {
    if (this.isArray()) {
      if (!Array.isArray(n)) throw new Error("invalid array value");
      if (this.arrayLength !== -1 && n.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const a = this.arrayChildren,
        o = n.slice();
      o.forEach((l, u) => {
        a.#e(e, l, r, (f) => {
          o[u] = f;
        });
      }),
        i(o);
      return;
    }
    if (this.isTuple()) {
      const a = this.components;
      let o;
      if (Array.isArray(n)) o = n.slice();
      else {
        if (n == null || typeof n != "object")
          throw new Error("invalid tuple value");
        o = a.map((l) => {
          if (!l.name)
            throw new Error("cannot use object value with unnamed components");
          if (!(l.name in n))
            throw new Error(`missing value for component ${l.name}`);
          return n[l.name];
        });
      }
      if (o.length !== this.components.length)
        throw new Error("array is wrong length");
      o.forEach((l, u) => {
        a[u].#e(e, l, r, (f) => {
          o[u] = f;
        });
      }),
        i(o);
      return;
    }
    const s = r(this.type, n);
    s.then
      ? e.push(
          (async function () {
            i(await s);
          })()
        )
      : i(s);
  }
  async walkAsync(e, n) {
    const r = [],
      i = [e];
    return (
      this.#e(r, e, n, (s) => {
        i[0] = s;
      }),
      r.length && (await Promise.all(r)),
      i[0]
    );
  }
  static from(e, n) {
    if (Dr.isParamType(e)) return e;
    if (typeof e == "string")
      try {
        return Dr.from(xd(e), n);
      } catch {
        ge(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof vl) {
      let o = "",
        l = "",
        u = null;
      ef(e, Ta(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN")
        ? ((l = "tuple"),
          (u = e.popParams().map((g) => Dr.from(g))),
          (o = `tuple(${u.map((g) => g.format()).join(",")})`))
        : ((o = yN(e.popType("TYPE"))), (l = o));
      let f = null,
        c = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const g = e.pop();
        (f = new Dr(ai, "", o, l, null, u, c, f)),
          (c = g.value),
          (o += g.text),
          (l = "array"),
          (u = null);
      }
      let d = null;
      if (ef(e, z2e).has("indexed")) {
        if (!n) throw new Error("");
        d = !0;
      }
      const m = e.peekType("ID") ? e.pop().text : "";
      if (e.length) throw new Error("leftover tokens");
      return new Dr(ai, m, o, l, d, u, c, f);
    }
    const r = e.name;
    ge(
      !r || (typeof r == "string" && r.match(eG)),
      "invalid name",
      "obj.name",
      r
    );
    let i = e.indexed;
    i != null &&
      (ge(n, "parameter cannot be indexed", "obj.indexed", e.indexed),
      (i = !!i));
    let s = e.type,
      a = s.match(Y2e);
    if (a) {
      const o = parseInt(a[2] || "-1"),
        l = Dr.from({ type: a[1], components: e.components });
      return new Dr(ai, r || "", s, "array", i, null, o, l);
    }
    if (s === "tuple" || s.startsWith("tuple(") || s.startsWith("(")) {
      const o =
        e.components != null ? e.components.map((u) => Dr.from(u)) : null;
      return new Dr(ai, r || "", s, "tuple", i, o, null, null);
    }
    return (s = yN(e.type)), new Dr(ai, r || "", s, s, i, null, null, null);
  }
  static isParamType(e) {
    return e && e[oo] === vN;
  }
}
class Sh {
  type;
  inputs;
  constructor(e, n, r) {
    Oy(e, ai, "Fragment"),
      (r = Object.freeze(r.slice())),
      nn(this, { type: n, inputs: r });
  }
  static from(e) {
    if (typeof e == "string") {
      try {
        Sh.from(JSON.parse(e));
      } catch {}
      return Sh.from(xd(e));
    }
    if (e instanceof vl)
      switch (e.peekKeyword(QV)) {
        case "constructor":
          return Fc.from(e);
        case "error":
          return Ya.from(e);
        case "event":
          return Lu.from(e);
        case "fallback":
        case "receive":
          return Dc.from(e);
        case "function":
          return Bu.from(e);
        case "struct":
          return lh.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return Fc.from(e);
        case "error":
          return Ya.from(e);
        case "event":
          return Lu.from(e);
        case "fallback":
        case "receive":
          return Dc.from(e);
        case "function":
          return Bu.from(e);
        case "struct":
          return lh.from(e);
      }
      Ue(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from",
      });
    }
    ge(!1, "unsupported frgament object", "obj", e);
  }
  static isConstructor(e) {
    return Fc.isFragment(e);
  }
  static isError(e) {
    return Ya.isFragment(e);
  }
  static isEvent(e) {
    return Lu.isFragment(e);
  }
  static isFunction(e) {
    return Bu.isFragment(e);
  }
  static isStruct(e) {
    return lh.isFragment(e);
  }
}
class s6 extends Sh {
  name;
  constructor(e, n, r, i) {
    super(e, n, i),
      ge(typeof r == "string" && r.match(eG), "invalid identifier", "name", r),
      (i = Object.freeze(i.slice())),
      nn(this, { name: r });
  }
}
function ny(t, e) {
  return "(" + e.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")";
}
class Ya extends s6 {
  constructor(e, n, r) {
    super(e, "error", n, r), Object.defineProperty(this, oo, { value: bN });
  }
  get selector() {
    return xh(this.format("sighash")).substring(0, 10);
  }
  format(e) {
    if ((e == null && (e = "sighash"), e === "json"))
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    const n = [];
    return (
      e !== "sighash" && n.push("error"),
      n.push(this.name + ny(e, this.inputs)),
      n.join(" ")
    );
  }
  static from(e) {
    if (Ya.isFragment(e)) return e;
    if (typeof e == "string") return Ya.from(xd(e));
    if (e instanceof vl) {
      const n = i6("error", e),
        r = zc(e);
      return Th(e), new Ya(ai, n, r);
    }
    return new Ya(ai, e.name, e.inputs ? e.inputs.map(Dr.from) : []);
  }
  static isFragment(e) {
    return e && e[oo] === bN;
  }
}
class Lu extends s6 {
  anonymous;
  constructor(e, n, r, i) {
    super(e, "event", n, r),
      Object.defineProperty(this, oo, { value: wN }),
      nn(this, { anonymous: i });
  }
  get topicHash() {
    return xh(this.format("sighash"));
  }
  format(e) {
    if ((e == null && (e = "sighash"), e === "json"))
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    const n = [];
    return (
      e !== "sighash" && n.push("event"),
      n.push(this.name + ny(e, this.inputs)),
      e !== "sighash" && this.anonymous && n.push("anonymous"),
      n.join(" ")
    );
  }
  static getTopicHash(e, n) {
    return (
      (n = (n || []).map((i) => Dr.from(i))), new Lu(ai, e, n, !1).topicHash
    );
  }
  static from(e) {
    if (Lu.isFragment(e)) return e;
    if (typeof e == "string")
      try {
        return Lu.from(xd(e));
      } catch {
        ge(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof vl) {
      const n = i6("event", e),
        r = zc(e, !0),
        i = !!ef(e, Ta(["anonymous"])).has("anonymous");
      return Th(e), new Lu(ai, n, r, i);
    }
    return new Lu(
      ai,
      e.name,
      e.inputs ? e.inputs.map((n) => Dr.from(n, !0)) : [],
      !!e.anonymous
    );
  }
  static isFragment(e) {
    return e && e[oo] === wN;
  }
}
class Fc extends Sh {
  payable;
  gas;
  constructor(e, n, r, i, s) {
    super(e, n, r),
      Object.defineProperty(this, oo, { value: _N }),
      nn(this, { payable: i, gas: s });
  }
  format(e) {
    if (
      (Ue(
        e != null && e !== "sighash",
        "cannot format a constructor for sighash",
        "UNSUPPORTED_OPERATION",
        { operation: "format(sighash)" }
      ),
      e === "json")
    )
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    const n = [`constructor${ny(e, this.inputs)}`];
    return (
      this.payable && n.push("payable"),
      this.gas != null && n.push(`@${this.gas.toString()}`),
      n.join(" ")
    );
  }
  static from(e) {
    if (Fc.isFragment(e)) return e;
    if (typeof e == "string")
      try {
        return Fc.from(xd(e));
      } catch {
        ge(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof vl) {
      ef(e, Ta(["constructor"]));
      const n = zc(e),
        r = !!ef(e, j2e).has("payable"),
        i = rG(e);
      return Th(e), new Fc(ai, "constructor", n, r, i);
    }
    return new Fc(
      ai,
      "constructor",
      e.inputs ? e.inputs.map(Dr.from) : [],
      !!e.payable,
      e.gas != null ? e.gas : null
    );
  }
  static isFragment(e) {
    return e && e[oo] === _N;
  }
}
class Dc extends Sh {
  payable;
  constructor(e, n, r) {
    super(e, "fallback", n),
      Object.defineProperty(this, oo, { value: EN }),
      nn(this, { payable: r });
  }
  format(e) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const r = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: r });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  static from(e) {
    if (Dc.isFragment(e)) return e;
    if (typeof e == "string")
      try {
        return Dc.from(xd(e));
      } catch {
        ge(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof vl) {
      const n = e.toString(),
        r = e.peekKeyword(Ta(["fallback", "receive"]));
      if (
        (ge(r, "type must be fallback or receive", "obj", n),
        e.popKeyword(Ta(["fallback", "receive"])) === "receive")
      ) {
        const o = zc(e);
        return (
          ge(o.length === 0, "receive cannot have arguments", "obj.inputs", o),
          ef(e, Ta(["payable"])),
          Th(e),
          new Dc(ai, [], !0)
        );
      }
      let s = zc(e);
      s.length
        ? ge(
            s.length === 1 && s[0].type === "bytes",
            "invalid fallback inputs",
            "obj.inputs",
            s.map((o) => o.format("minimal")).join(", ")
          )
        : (s = [Dr.from("bytes")]);
      const a = nG(e);
      if (
        (ge(
          a === "nonpayable" || a === "payable",
          "fallback cannot be constants",
          "obj.stateMutability",
          a
        ),
        ef(e, Ta(["returns"])).has("returns"))
      ) {
        const o = zc(e);
        ge(
          o.length === 1 && o[0].type === "bytes",
          "invalid fallback outputs",
          "obj.outputs",
          o.map((l) => l.format("minimal")).join(", ")
        );
      }
      return Th(e), new Dc(ai, s, a === "payable");
    }
    if (e.type === "receive") return new Dc(ai, [], !0);
    if (e.type === "fallback") {
      const n = [Dr.from("bytes")],
        r = e.stateMutability === "payable";
      return new Dc(ai, n, r);
    }
    ge(!1, "invalid fallback description", "obj", e);
  }
  static isFragment(e) {
    return e && e[oo] === EN;
  }
}
class Bu extends s6 {
  constant;
  outputs;
  stateMutability;
  payable;
  gas;
  constructor(e, n, r, i, s, a) {
    super(e, "function", n, i),
      Object.defineProperty(this, oo, { value: xN }),
      (s = Object.freeze(s.slice())),
      nn(this, {
        constant: r === "view" || r === "pure",
        gas: a,
        outputs: s,
        payable: r === "payable",
        stateMutability: r,
      });
  }
  get selector() {
    return xh(this.format("sighash")).substring(0, 10);
  }
  format(e) {
    if ((e == null && (e = "sighash"), e === "json"))
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e))),
      });
    const n = [];
    return (
      e !== "sighash" && n.push("function"),
      n.push(this.name + ny(e, this.inputs)),
      e !== "sighash" &&
        (this.stateMutability !== "nonpayable" && n.push(this.stateMutability),
        this.outputs &&
          this.outputs.length &&
          (n.push("returns"), n.push(ny(e, this.outputs))),
        this.gas != null && n.push(`@${this.gas.toString()}`)),
      n.join(" ")
    );
  }
  static getSelector(e, n) {
    return (
      (n = (n || []).map((i) => Dr.from(i))),
      new Bu(ai, e, "view", n, [], null).selector
    );
  }
  static from(e) {
    if (Bu.isFragment(e)) return e;
    if (typeof e == "string")
      try {
        return Bu.from(xd(e));
      } catch {
        ge(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof vl) {
      const r = i6("function", e),
        i = zc(e),
        s = nG(e);
      let a = [];
      ef(e, Ta(["returns"])).has("returns") && (a = zc(e));
      const o = rG(e);
      return Th(e), new Bu(ai, r, s, i, a, o);
    }
    let n = e.stateMutability;
    return (
      n == null &&
        ((n = "payable"),
        typeof e.constant == "boolean"
          ? ((n = "view"),
            e.constant ||
              ((n = "payable"),
              typeof e.payable == "boolean" &&
                !e.payable &&
                (n = "nonpayable")))
          : typeof e.payable == "boolean" && !e.payable && (n = "nonpayable")),
      new Bu(
        ai,
        e.name,
        n,
        e.inputs ? e.inputs.map(Dr.from) : [],
        e.outputs ? e.outputs.map(Dr.from) : [],
        e.gas != null ? e.gas : null
      )
    );
  }
  static isFragment(e) {
    return e && e[oo] === xN;
  }
}
class lh extends s6 {
  constructor(e, n, r) {
    super(e, "struct", n, r), Object.defineProperty(this, oo, { value: TN });
  }
  format() {
    throw new Error("@TODO");
  }
  static from(e) {
    if (typeof e == "string")
      try {
        return lh.from(xd(e));
      } catch {
        ge(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof vl) {
      const n = i6("struct", e),
        r = zc(e);
      return Th(e), new lh(ai, n, r);
    }
    return new lh(ai, e.name, e.inputs ? e.inputs.map(Dr.from) : []);
  }
  static isFragment(e) {
    return e && e[oo] === TN;
  }
}
const lu = new Map();
lu.set(0, "GENERIC_PANIC");
lu.set(1, "ASSERT_FALSE");
lu.set(17, "OVERFLOW");
lu.set(18, "DIVIDE_BY_ZERO");
lu.set(33, "ENUM_RANGE_ERROR");
lu.set(34, "BAD_STORAGE_DATA");
lu.set(49, "STACK_UNDERFLOW");
lu.set(50, "ARRAY_RANGE_ERROR");
lu.set(65, "OUT_OF_MEMORY");
lu.set(81, "UNINITIALIZED_FUNCTION_CALL");
const Q2e = new RegExp(/^bytes([0-9]*)$/),
  J2e = new RegExp(/^(u?int)([0-9]*)$/);
let p8 = null,
  SN = 1024;
function eve(t, e, n, r) {
  let i = "missing revert data",
    s = null;
  const a = null;
  let o = null;
  if (n) {
    i = "execution reverted";
    const u = er(n);
    if (((n = Gt(n)), u.length === 0))
      (i += " (no data present; likely require(false) occurred"),
        (s = "require(false)");
    else if (u.length % 32 !== 4)
      i += " (could not decode reason; invalid data length)";
    else if (Gt(u.slice(0, 4)) === "0x08c379a0")
      try {
        (s = r.decode(["string"], u.slice(4))[0]),
          (o = { signature: "Error(string)", name: "Error", args: [s] }),
          (i += `: ${JSON.stringify(s)}`);
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
    else if (Gt(u.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(r.decode(["uint256"], u.slice(4))[0]);
        (o = { signature: "Panic(uint256)", name: "Panic", args: [f] }),
          (s = `Panic due to ${lu.get(f) || "UNKNOWN"}(${f})`),
          (i += `: ${s}`);
      } catch {
        i += " (could not decode panic code)";
      }
    else i += " (unknown custom error)";
  }
  const l = { to: e.to ? yr(e.to) : null, data: e.data || "0x" };
  return (
    e.from && (l.from = yr(e.from)),
    mi(i, "CALL_EXCEPTION", {
      action: t,
      data: n,
      reason: s,
      transaction: l,
      invocation: a,
      revert: o,
    })
  );
}
class Ah {
  #e(e) {
    if (e.isArray())
      return new Cye(this.#e(e.arrayChildren), e.arrayLength, e.name);
    if (e.isTuple())
      return new yv(
        e.components.map((r) => this.#e(r)),
        e.name
      );
    switch (e.baseType) {
      case "address":
        return new Sye(e.name);
      case "bool":
        return new kye(e.name);
      case "string":
        return new Bye(e.name);
      case "bytes":
        return new Iye(e.name);
      case "":
        return new Nye(e.name);
    }
    let n = e.type.match(J2e);
    if (n) {
      let r = parseInt(n[2] || "256");
      return (
        ge(
          r !== 0 && r <= 256 && r % 8 === 0,
          "invalid " + n[1] + " bit length",
          "param",
          e
        ),
        new Lye(r / 8, n[1] === "int", e.name)
      );
    }
    if (((n = e.type.match(Q2e)), n)) {
      let r = parseInt(n[1]);
      return (
        ge(r !== 0 && r <= 32, "invalid bytes length", "param", e),
        new Oye(r, e.name)
      );
    }
    ge(!1, "invalid type", "type", e.type);
  }
  getDefaultValue(e) {
    const n = e.map((i) => this.#e(Dr.from(i)));
    return new yv(n, "_").defaultValue();
  }
  encode(e, n) {
    Oz(n.length, e.length, "types/values length mismatch");
    const r = e.map((a) => this.#e(Dr.from(a))),
      i = new yv(r, "_"),
      s = new $E();
    return i.encode(s, n), s.data;
  }
  decode(e, n, r) {
    const i = e.map((a) => this.#e(Dr.from(a)));
    return new yv(i, "_").decode(new yT(n, r, SN));
  }
  static _setDefaultMaxInflation(e) {
    ge(
      typeof e == "number" && Number.isInteger(e),
      "invalid defaultMaxInflation factor",
      "value",
      e
    ),
      (SN = e);
  }
  static defaultAbiCoder() {
    return p8 == null && (p8 = new Ah()), p8;
  }
  static getBuiltinCallException(e, n, r) {
    return eve(e, n, r, Ah.defaultAbiCoder());
  }
}
class tve {
  fragment;
  name;
  signature;
  topic;
  args;
  constructor(e, n, r) {
    const i = e.name,
      s = e.format();
    nn(this, { fragment: e, name: i, signature: s, topic: n, args: r });
  }
}
class nve {
  fragment;
  name;
  args;
  signature;
  selector;
  value;
  constructor(e, n, r, i) {
    const s = e.name,
      a = e.format();
    nn(this, {
      fragment: e,
      name: s,
      args: r,
      signature: a,
      selector: n,
      value: i,
    });
  }
}
class rve {
  fragment;
  name;
  args;
  signature;
  selector;
  constructor(e, n, r) {
    const i = e.name,
      s = e.format();
    nn(this, { fragment: e, name: i, args: r, signature: s, selector: n });
  }
}
class AN {
  hash;
  _isIndexed;
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
  constructor(e) {
    nn(this, { hash: e, _isIndexed: !0 });
  }
}
const CN = {
    0: "generic panic",
    1: "assert(false)",
    17: "arithmetic overflow",
    18: "division or modulo by zero",
    33: "enum overflow",
    34: "invalid encoded storage byte array accessed",
    49: "out-of-bounds array access; popping on an empty array",
    50: "out-of-bounds access of an array or bytesN",
    65: "out of memory",
    81: "uninitialized function",
  },
  kN = {
    "0x08c379a0": {
      signature: "Error(string)",
      name: "Error",
      inputs: ["string"],
      reason: (t) => `reverted with reason string ${JSON.stringify(t)}`,
    },
    "0x4e487b71": {
      signature: "Panic(uint256)",
      name: "Panic",
      inputs: ["uint256"],
      reason: (t) => {
        let e = "unknown panic code";
        return (
          t >= 0 && t <= 255 && CN[t.toString()] && (e = CN[t.toString()]),
          `reverted with panic code 0x${t.toString(16)} (${e})`
        );
      },
    },
  };
class eu {
  fragments;
  deploy;
  fallback;
  receive;
  #e;
  #t;
  #n;
  #r;
  constructor(e) {
    let n = [];
    typeof e == "string" ? (n = JSON.parse(e)) : (n = e),
      (this.#n = new Map()),
      (this.#e = new Map()),
      (this.#t = new Map());
    const r = [];
    for (const a of n)
      try {
        r.push(Sh.from(a));
      } catch (o) {
        console.log(
          `[Warning] Invalid Fragment ${JSON.stringify(a)}:`,
          o.message
        );
      }
    nn(this, { fragments: Object.freeze(r) });
    let i = null,
      s = !1;
    (this.#r = this.getAbiCoder()),
      this.fragments.forEach((a, o) => {
        let l;
        switch (a.type) {
          case "constructor":
            if (this.deploy) {
              console.log("duplicate definition - constructor");
              return;
            }
            nn(this, { deploy: a });
            return;
          case "fallback":
            a.inputs.length === 0
              ? (s = !0)
              : (ge(
                  !i || a.payable !== i.payable,
                  "conflicting fallback fragments",
                  `fragments[${o}]`,
                  a
                ),
                (i = a),
                (s = i.payable));
            return;
          case "function":
            l = this.#n;
            break;
          case "event":
            l = this.#t;
            break;
          case "error":
            l = this.#e;
            break;
          default:
            return;
        }
        const u = a.format();
        l.has(u) || l.set(u, a);
      }),
      this.deploy || nn(this, { deploy: Fc.from("constructor()") }),
      nn(this, { fallback: i, receive: s });
  }
  format(e) {
    const n = e ? "minimal" : "full";
    return this.fragments.map((i) => i.format(n));
  }
  formatJson() {
    const e = this.fragments.map((n) => n.format("json"));
    return JSON.stringify(e.map((n) => JSON.parse(n)));
  }
  getAbiCoder() {
    return Ah.defaultAbiCoder();
  }
  #i(e, n, r) {
    if (Mr(e)) {
      const s = e.toLowerCase();
      for (const a of this.#n.values()) if (s === a.selector) return a;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [a, o] of this.#n) a.split("(")[0] === e && s.push(o);
      if (n) {
        const a = n.length > 0 ? n[n.length - 1] : null;
        let o = n.length,
          l = !0;
        _i.isTyped(a) && a.type === "overrides" && ((l = !1), o--);
        for (let u = s.length - 1; u >= 0; u--) {
          const f = s[u].inputs.length;
          f !== o && (!l || f !== o - 1) && s.splice(u, 1);
        }
        for (let u = s.length - 1; u >= 0; u--) {
          const f = s[u].inputs;
          for (let c = 0; c < n.length; c++)
            if (_i.isTyped(n[c])) {
              if (c >= f.length) {
                if (n[c].type === "overrides") continue;
                s.splice(u, 1);
                break;
              }
              if (n[c].type !== f[c].baseType) {
                s.splice(u, 1);
                break;
              }
            }
        }
      }
      if (s.length === 1 && n && n.length !== s[0].inputs.length) {
        const a = n[n.length - 1];
        (a == null || Array.isArray(a) || typeof a != "object") &&
          s.splice(0, 1);
      }
      if (s.length === 0) return null;
      if (s.length > 1 && r) {
        const a = s.map((o) => JSON.stringify(o.format())).join(", ");
        ge(!1, `ambiguous function description (i.e. matches ${a})`, "key", e);
      }
      return s[0];
    }
    const i = this.#n.get(Bu.from(e).format());
    return i || null;
  }
  getFunctionName(e) {
    const n = this.#i(e, null, !1);
    return ge(n, "no matching function", "key", e), n.name;
  }
  hasFunction(e) {
    return !!this.#i(e, null, !1);
  }
  getFunction(e, n) {
    return this.#i(e, n || null, !0);
  }
  forEachFunction(e) {
    const n = Array.from(this.#n.keys());
    n.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e(this.#n.get(i), r);
    }
  }
  #a(e, n, r) {
    if (Mr(e)) {
      const s = e.toLowerCase();
      for (const a of this.#t.values()) if (s === a.topicHash) return a;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [a, o] of this.#t) a.split("(")[0] === e && s.push(o);
      if (n) {
        for (let a = s.length - 1; a >= 0; a--)
          s[a].inputs.length < n.length && s.splice(a, 1);
        for (let a = s.length - 1; a >= 0; a--) {
          const o = s[a].inputs;
          for (let l = 0; l < n.length; l++)
            if (_i.isTyped(n[l]) && n[l].type !== o[l].baseType) {
              s.splice(a, 1);
              break;
            }
        }
      }
      if (s.length === 0) return null;
      if (s.length > 1 && r) {
        const a = s.map((o) => JSON.stringify(o.format())).join(", ");
        ge(!1, `ambiguous event description (i.e. matches ${a})`, "key", e);
      }
      return s[0];
    }
    const i = this.#t.get(Lu.from(e).format());
    return i || null;
  }
  getEventName(e) {
    const n = this.#a(e, null, !1);
    return ge(n, "no matching event", "key", e), n.name;
  }
  hasEvent(e) {
    return !!this.#a(e, null, !1);
  }
  getEvent(e, n) {
    return this.#a(e, n || null, !0);
  }
  forEachEvent(e) {
    const n = Array.from(this.#t.keys());
    n.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e(this.#t.get(i), r);
    }
  }
  getError(e, n) {
    if (Mr(e)) {
      const i = e.toLowerCase();
      if (kN[i]) return Ya.from(kN[i].signature);
      for (const s of this.#e.values()) if (i === s.selector) return s;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const i = [];
      for (const [s, a] of this.#e) s.split("(")[0] === e && i.push(a);
      if (i.length === 0)
        return e === "Error"
          ? Ya.from("error Error(string)")
          : e === "Panic"
          ? Ya.from("error Panic(uint256)")
          : null;
      if (i.length > 1) {
        const s = i.map((a) => JSON.stringify(a.format())).join(", ");
        ge(!1, `ambiguous error description (i.e. ${s})`, "name", e);
      }
      return i[0];
    }
    if (((e = Ya.from(e).format()), e === "Error(string)"))
      return Ya.from("error Error(string)");
    if (e === "Panic(uint256)") return Ya.from("error Panic(uint256)");
    const r = this.#e.get(e);
    return r || null;
  }
  forEachError(e) {
    const n = Array.from(this.#e.keys());
    n.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e(this.#e.get(i), r);
    }
  }
  _decodeParams(e, n) {
    return this.#r.decode(e, n);
  }
  _encodeParams(e, n) {
    return this.#r.encode(e, n);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      ge(r, "unknown error", "fragment", e), (e = r);
    }
    return (
      ge(
        vi(n, 0, 4) === e.selector,
        `data signature does not match error ${e.name}.`,
        "data",
        n
      ),
      this._decodeParams(e.inputs, vi(n, 4))
    );
  }
  encodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      ge(r, "unknown error", "fragment", e), (e = r);
    }
    return Di([e.selector, this._encodeParams(e.inputs, n || [])]);
  }
  decodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      ge(r, "unknown function", "fragment", e), (e = r);
    }
    return (
      ge(
        vi(n, 0, 4) === e.selector,
        `data signature does not match function ${e.name}.`,
        "data",
        n
      ),
      this._decodeParams(e.inputs, vi(n, 4))
    );
  }
  encodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      ge(r, "unknown function", "fragment", e), (e = r);
    }
    return Di([e.selector, this._encodeParams(e.inputs, n || [])]);
  }
  decodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const s = this.getFunction(e);
      ge(s, "unknown function", "fragment", e), (e = s);
    }
    let r = "invalid length for result data";
    const i = va(n);
    if (i.length % 32 === 0)
      try {
        return this.#r.decode(e.outputs, i);
      } catch {
        r = "could not decode result data";
      }
    Ue(!1, r, "BAD_DATA", {
      value: Gt(i),
      info: { method: e.name, signature: e.format() },
    });
  }
  makeError(e, n) {
    const r = er(e, "data"),
      i = Ah.getBuiltinCallException("call", n, r),
      s = "execution reverted (unknown custom error)";
    if (i.message.startsWith(s)) {
      const o = Gt(r.slice(0, 4)),
        l = this.getError(o);
      if (l)
        try {
          const u = this.#r.decode(l.inputs, r.slice(4));
          (i.revert = { name: l.name, signature: l.format(), args: u }),
            (i.reason = i.revert.signature),
            (i.message = `execution reverted: ${i.reason}`);
        } catch {
          i.message = "execution reverted (coult not decode custom error)";
        }
    }
    const a = this.parseTransaction(n);
    return (
      a &&
        (i.invocation = {
          method: a.name,
          signature: a.signature,
          args: a.args,
        }),
      i
    );
  }
  encodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      ge(r, "unknown function", "fragment", e), (e = r);
    }
    return Gt(this.#r.encode(e.outputs, n || []));
  }
  encodeFilterTopics(e, n) {
    if (typeof e == "string") {
      const s = this.getEvent(e);
      ge(s, "unknown event", "eventFragment", e), (e = s);
    }
    Ue(
      n.length <= e.inputs.length,
      `too many arguments for ${e.format()}`,
      "UNEXPECTED_ARGUMENT",
      { count: n.length, expectedCount: e.inputs.length }
    );
    const r = [];
    e.anonymous || r.push(e.topicHash);
    const i = (s, a) =>
      s.type === "string"
        ? xh(a)
        : s.type === "bytes"
        ? Zr(Gt(a))
        : (s.type === "bool" && typeof a == "boolean"
            ? (a = a ? "0x01" : "0x00")
            : s.type.match(/^u?int/)
            ? (a = ud(a))
            : s.type.match(/^bytes/)
            ? (a = Sme(a, 32))
            : s.type === "address" && this.#r.encode(["address"], [a]),
          _h(Gt(a), 32));
    for (
      n.forEach((s, a) => {
        const o = e.inputs[a];
        if (!o.indexed) {
          ge(
            s == null,
            "cannot filter non-indexed parameters; must be null",
            "contract." + o.name,
            s
          );
          return;
        }
        s == null
          ? r.push(null)
          : o.baseType === "array" || o.baseType === "tuple"
          ? ge(
              !1,
              "filtering with tuples or arrays not supported",
              "contract." + o.name,
              s
            )
          : Array.isArray(s)
          ? r.push(s.map((l) => i(o, l)))
          : r.push(i(o, s));
      });
      r.length && r[r.length - 1] === null;

    )
      r.pop();
    return r;
  }
  encodeEventLog(e, n) {
    if (typeof e == "string") {
      const a = this.getEvent(e);
      ge(a, "unknown event", "eventFragment", e), (e = a);
    }
    const r = [],
      i = [],
      s = [];
    return (
      e.anonymous || r.push(e.topicHash),
      ge(
        n.length === e.inputs.length,
        "event arguments/values mismatch",
        "values",
        n
      ),
      e.inputs.forEach((a, o) => {
        const l = n[o];
        if (a.indexed)
          if (a.type === "string") r.push(xh(l));
          else if (a.type === "bytes") r.push(Zr(l));
          else {
            if (a.baseType === "tuple" || a.baseType === "array")
              throw new Error("not implemented");
            r.push(this.#r.encode([a.type], [l]));
          }
        else i.push(a), s.push(l);
      }),
      { data: this.#r.encode(i, s), topics: r }
    );
  }
  decodeEventLog(e, n, r) {
    if (typeof e == "string") {
      const p = this.getEvent(e);
      ge(p, "unknown event", "eventFragment", e), (e = p);
    }
    if (r != null && !e.anonymous) {
      const p = e.topicHash;
      ge(
        Mr(r[0], 32) && r[0].toLowerCase() === p,
        "fragment/topic mismatch",
        "topics[0]",
        r[0]
      ),
        (r = r.slice(1));
    }
    const i = [],
      s = [],
      a = [];
    e.inputs.forEach((p, m) => {
      p.indexed
        ? p.type === "string" ||
          p.type === "bytes" ||
          p.baseType === "tuple" ||
          p.baseType === "array"
          ? (i.push(Dr.from({ type: "bytes32", name: p.name })), a.push(!0))
          : (i.push(p), a.push(!1))
        : (s.push(p), a.push(!1));
    });
    const o = r != null ? this.#r.decode(i, Di(r)) : null,
      l = this.#r.decode(s, n, !0),
      u = [],
      f = [];
    let c = 0,
      d = 0;
    return (
      e.inputs.forEach((p, m) => {
        let g = null;
        if (p.indexed)
          if (o == null) g = new AN(null);
          else if (a[m]) g = new AN(o[d++]);
          else
            try {
              g = o[d++];
            } catch (w) {
              g = w;
            }
        else
          try {
            g = l[c++];
          } catch (w) {
            g = w;
          }
        u.push(g), f.push(p.name || null);
      }),
      m0.fromItems(u, f)
    );
  }
  parseTransaction(e) {
    const n = er(e.data, "tx.data"),
      r = Lt(e.value != null ? e.value : 0, "tx.value"),
      i = this.getFunction(Gt(n.slice(0, 4)));
    if (!i) return null;
    const s = this.#r.decode(i.inputs, n.slice(4));
    return new nve(i, i.selector, s, r);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  parseLog(e) {
    const n = this.getEvent(e.topics[0]);
    return !n || n.anonymous
      ? null
      : new tve(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics));
  }
  parseError(e) {
    const n = Gt(e),
      r = this.getError(vi(n, 0, 4));
    if (!r) return null;
    const i = this.#r.decode(r.inputs, vi(n, 4));
    return new rve(r, r.selector, i);
  }
  static from(e) {
    return e instanceof eu
      ? e
      : typeof e == "string"
      ? new eu(JSON.parse(e))
      : typeof e.format == "function"
      ? new eu(e.format("json"))
      : new eu(e);
  }
}
const iG = BigInt(0);
function cg(t) {
  return t ?? null;
}
function Ci(t) {
  return t == null ? null : t.toString();
}
class IN {
  gasPrice;
  maxFeePerGas;
  maxPriorityFeePerGas;
  constructor(e, n, r) {
    nn(this, {
      gasPrice: cg(e),
      maxFeePerGas: cg(n),
      maxPriorityFeePerGas: cg(r),
    });
  }
  toJSON() {
    const { gasPrice: e, maxFeePerGas: n, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: Ci(e),
      maxFeePerGas: Ci(n),
      maxPriorityFeePerGas: Ci(r),
    };
  }
}
function j5(t) {
  const e = {};
  t.to && (e.to = t.to),
    t.from && (e.from = t.from),
    t.data && (e.data = Gt(t.data));
  const n =
    "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
      /,/
    );
  for (const i of n)
    !(i in t) || t[i] == null || (e[i] = Lt(t[i], `request.${i}`));
  const r = "type,nonce".split(/,/);
  for (const i of r)
    !(i in t) || t[i] == null || (e[i] = kn(t[i], `request.${i}`));
  return (
    t.accessList && (e.accessList = Fh(t.accessList)),
    "blockTag" in t && (e.blockTag = t.blockTag),
    "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead),
    "customData" in t && (e.customData = t.customData),
    e
  );
}
class ive {
  provider;
  number;
  hash;
  timestamp;
  parentHash;
  parentBeaconBlockRoot;
  nonce;
  difficulty;
  gasLimit;
  gasUsed;
  stateRoot;
  receiptsRoot;
  blobGasUsed;
  excessBlobGas;
  miner;
  extraData;
  baseFeePerGas;
  #e;
  constructor(e, n) {
    (this.#e = e.transactions.map((r) =>
      typeof r != "string" ? new My(r, n) : r
    )),
      nn(this, {
        provider: n,
        hash: cg(e.hash),
        number: e.number,
        timestamp: e.timestamp,
        parentHash: e.parentHash,
        parentBeaconBlockRoot: e.parentBeaconBlockRoot,
        nonce: e.nonce,
        difficulty: e.difficulty,
        gasLimit: e.gasLimit,
        gasUsed: e.gasUsed,
        blobGasUsed: e.blobGasUsed,
        excessBlobGas: e.excessBlobGas,
        miner: e.miner,
        extraData: e.extraData,
        baseFeePerGas: cg(e.baseFeePerGas),
        stateRoot: e.stateRoot,
        receiptsRoot: e.receiptsRoot,
      });
  }
  get transactions() {
    return this.#e.map((e) => (typeof e == "string" ? e : e.hash));
  }
  get prefetchedTransactions() {
    const e = this.#e.slice();
    return e.length === 0
      ? []
      : (Ue(
          typeof e[0] == "object",
          "transactions were not prefetched with block request",
          "UNSUPPORTED_OPERATION",
          { operation: "transactionResponses()" }
        ),
        e);
  }
  toJSON() {
    const {
      baseFeePerGas: e,
      difficulty: n,
      extraData: r,
      gasLimit: i,
      gasUsed: s,
      hash: a,
      miner: o,
      nonce: l,
      number: u,
      parentHash: f,
      parentBeaconBlockRoot: c,
      stateRoot: d,
      receiptsRoot: p,
      timestamp: m,
      transactions: g,
    } = this;
    return {
      _type: "Block",
      baseFeePerGas: Ci(e),
      difficulty: Ci(n),
      extraData: r,
      gasLimit: Ci(i),
      gasUsed: Ci(s),
      blobGasUsed: Ci(this.blobGasUsed),
      excessBlobGas: Ci(this.excessBlobGas),
      hash: a,
      miner: o,
      nonce: l,
      number: u,
      parentHash: f,
      timestamp: m,
      parentBeaconBlockRoot: c,
      stateRoot: d,
      receiptsRoot: p,
      transactions: g,
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const n = this.transactions;
    return {
      next: () =>
        e < this.length
          ? { value: n[e++], done: !1 }
          : { value: void 0, done: !0 },
    };
  }
  get length() {
    return this.#e.length;
  }
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  async getTransaction(e) {
    let n;
    if (typeof e == "number") n = this.#e[e];
    else {
      const r = e.toLowerCase();
      for (const i of this.#e)
        if (typeof i == "string") {
          if (i !== r) continue;
          n = i;
          break;
        } else {
          if (i.hash === r) continue;
          n = i;
          break;
        }
    }
    if (n == null) throw new Error("no such tx");
    return typeof n == "string" ? await this.provider.getTransaction(n) : n;
  }
  getPrefetchedTransaction(e) {
    const n = this.prefetchedTransactions;
    if (typeof e == "number") return n[e];
    e = e.toLowerCase();
    for (const r of n) if (r.hash === e) return r;
    ge(!1, "no matching transaction", "indexOrHash", e);
  }
  isMined() {
    return !!this.hash;
  }
  isLondon() {
    return !!this.baseFeePerGas;
  }
  orphanedEvent() {
    if (!this.isMined()) throw new Error("");
    return sve(this);
  }
}
class Ry {
  provider;
  transactionHash;
  blockHash;
  blockNumber;
  removed;
  address;
  data;
  topics;
  index;
  transactionIndex;
  constructor(e, n) {
    this.provider = n;
    const r = Object.freeze(e.topics.slice());
    nn(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: r,
      index: e.index,
      transactionIndex: e.transactionIndex,
    });
  }
  toJSON() {
    const {
      address: e,
      blockHash: n,
      blockNumber: r,
      data: i,
      index: s,
      removed: a,
      topics: o,
      transactionHash: l,
      transactionIndex: u,
    } = this;
    return {
      _type: "log",
      address: e,
      blockHash: n,
      blockNumber: r,
      data: i,
      index: s,
      removed: a,
      topics: o,
      transactionHash: l,
      transactionIndex: u,
    };
  }
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return Ue(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return Ue(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return (
      Ue(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e
    );
  }
  removedEvent() {
    return ave(this);
  }
}
class sG {
  provider;
  to;
  from;
  contractAddress;
  hash;
  index;
  blockHash;
  blockNumber;
  logsBloom;
  gasUsed;
  blobGasUsed;
  cumulativeGasUsed;
  gasPrice;
  blobGasPrice;
  type;
  status;
  root;
  #e;
  constructor(e, n) {
    this.#e = Object.freeze(e.logs.map((i) => new Ry(i, n)));
    let r = iG;
    e.effectiveGasPrice != null
      ? (r = e.effectiveGasPrice)
      : e.gasPrice != null && (r = e.gasPrice),
      nn(this, {
        provider: n,
        to: e.to,
        from: e.from,
        contractAddress: e.contractAddress,
        hash: e.hash,
        index: e.index,
        blockHash: e.blockHash,
        blockNumber: e.blockNumber,
        logsBloom: e.logsBloom,
        gasUsed: e.gasUsed,
        cumulativeGasUsed: e.cumulativeGasUsed,
        blobGasUsed: e.blobGasUsed,
        gasPrice: r,
        blobGasPrice: e.blobGasPrice,
        type: e.type,
        status: e.status,
        root: e.root,
      });
  }
  get logs() {
    return this.#e;
  }
  toJSON() {
    const {
      to: e,
      from: n,
      contractAddress: r,
      hash: i,
      index: s,
      blockHash: a,
      blockNumber: o,
      logsBloom: l,
      logs: u,
      status: f,
      root: c,
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: a,
      blockNumber: o,
      contractAddress: r,
      cumulativeGasUsed: Ci(this.cumulativeGasUsed),
      from: n,
      gasPrice: Ci(this.gasPrice),
      blobGasUsed: Ci(this.blobGasUsed),
      blobGasPrice: Ci(this.blobGasPrice),
      gasUsed: Ci(this.gasUsed),
      hash: i,
      index: s,
      logs: u,
      logsBloom: l,
      root: c,
      status: f,
      to: e,
    };
  }
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () =>
        e < this.length
          ? { value: this.logs[e++], done: !1 }
          : { value: void 0, done: !0 },
    };
  }
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null) throw new Error("TODO");
    return e;
  }
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null) throw new Error("TODO");
    return e;
  }
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  async confirmations() {
    return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
  }
  removedEvent() {
    return oG(this);
  }
  reorderedEvent(e) {
    return (
      Ue(
        !e || e.isMined(),
        "unmined 'other' transction cannot be orphaned",
        "UNSUPPORTED_OPERATION",
        { operation: "reorderedEvent(other)" }
      ),
      aG(this, e)
    );
  }
}
class My {
  provider;
  blockNumber;
  blockHash;
  index;
  hash;
  type;
  to;
  from;
  nonce;
  gasLimit;
  gasPrice;
  maxPriorityFeePerGas;
  maxFeePerGas;
  maxFeePerBlobGas;
  data;
  value;
  chainId;
  signature;
  accessList;
  blobVersionedHashes;
  #e;
  constructor(e, n) {
    (this.provider = n),
      (this.blockNumber = e.blockNumber != null ? e.blockNumber : null),
      (this.blockHash = e.blockHash != null ? e.blockHash : null),
      (this.hash = e.hash),
      (this.index = e.index),
      (this.type = e.type),
      (this.from = e.from),
      (this.to = e.to || null),
      (this.gasLimit = e.gasLimit),
      (this.nonce = e.nonce),
      (this.data = e.data),
      (this.value = e.value),
      (this.gasPrice = e.gasPrice),
      (this.maxPriorityFeePerGas =
        e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null),
      (this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null),
      (this.maxFeePerBlobGas =
        e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null),
      (this.chainId = e.chainId),
      (this.signature = e.signature),
      (this.accessList = e.accessList != null ? e.accessList : null),
      (this.blobVersionedHashes =
        e.blobVersionedHashes != null ? e.blobVersionedHashes : null),
      (this.#e = -1);
  }
  toJSON() {
    const {
      blockNumber: e,
      blockHash: n,
      index: r,
      hash: i,
      type: s,
      to: a,
      from: o,
      nonce: l,
      data: u,
      signature: f,
      accessList: c,
      blobVersionedHashes: d,
    } = this;
    return {
      _type: "TransactionResponse",
      accessList: c,
      blockNumber: e,
      blockHash: n,
      blobVersionedHashes: d,
      chainId: Ci(this.chainId),
      data: u,
      from: o,
      gasLimit: Ci(this.gasLimit),
      gasPrice: Ci(this.gasPrice),
      hash: i,
      maxFeePerGas: Ci(this.maxFeePerGas),
      maxPriorityFeePerGas: Ci(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: Ci(this.maxFeePerBlobGas),
      nonce: l,
      signature: f,
      to: a,
      index: r,
      type: s,
      value: Ci(this.value),
    };
  }
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const r = await this.getTransaction();
      r && (e = r.blockNumber);
    }
    if (e == null) return null;
    const n = this.provider.getBlock(e);
    if (n == null) throw new Error("TODO");
    return n;
  }
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: n, blockNumber: r } = await ya({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber(),
      });
      return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1;
    }
    return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
  }
  async wait(e, n) {
    const r = e ?? 1,
      i = n ?? 0;
    let s = this.#e,
      a = -1,
      o = s === -1;
    const l = async () => {
        if (o) return null;
        const { blockNumber: d, nonce: p } = await ya({
          blockNumber: this.provider.getBlockNumber(),
          nonce: this.provider.getTransactionCount(this.from),
        });
        if (p < this.nonce) {
          s = d;
          return;
        }
        if (o) return null;
        const m = await this.getTransaction();
        if (!(m && m.blockNumber != null))
          for (
            a === -1 && ((a = s - 3), a < this.#e && (a = this.#e));
            a <= d;

          ) {
            if (o) return null;
            const g = await this.provider.getBlock(a, !0);
            if (g == null) return;
            for (const w of g) if (w === this.hash) return;
            for (let w = 0; w < g.length; w++) {
              const y = await g.getTransaction(w);
              if (y.from === this.from && y.nonce === this.nonce) {
                if (o) return null;
                const v = await this.provider.getTransactionReceipt(y.hash);
                if (v == null || d - v.blockNumber + 1 < r) return;
                let E = "replaced";
                y.data === this.data &&
                y.to === this.to &&
                y.value === this.value
                  ? (E = "repriced")
                  : y.data === "0x" &&
                    y.from === y.to &&
                    y.value === iG &&
                    (E = "cancelled"),
                  Ue(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                    cancelled: E === "replaced" || E === "cancelled",
                    reason: E,
                    replacement: y.replaceableTransaction(s),
                    hash: y.hash,
                    receipt: v,
                  });
              }
            }
            a++;
          }
      },
      u = (d) => {
        if (d == null || d.status !== 0) return d;
        Ue(!1, "transaction execution reverted", "CALL_EXCEPTION", {
          action: "sendTransaction",
          data: null,
          reason: null,
          invocation: null,
          revert: null,
          transaction: { to: d.to, from: d.from, data: "" },
          receipt: d,
        });
      },
      f = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0) return u(f);
    if (f) {
      if ((await f.confirmations()) >= r) return u(f);
    } else if ((await l(), r === 0)) return null;
    return await new Promise((d, p) => {
      const m = [],
        g = () => {
          m.forEach((y) => y());
        };
      if (
        (m.push(() => {
          o = !0;
        }),
        i > 0)
      ) {
        const y = setTimeout(() => {
          g(), p(mi("wait for transaction timeout", "TIMEOUT"));
        }, i);
        m.push(() => {
          clearTimeout(y);
        });
      }
      const w = async (y) => {
        if ((await y.confirmations()) >= r) {
          g();
          try {
            d(u(y));
          } catch (v) {
            p(v);
          }
        }
      };
      if (
        (m.push(() => {
          this.provider.off(this.hash, w);
        }),
        this.provider.on(this.hash, w),
        s >= 0)
      ) {
        const y = async () => {
          try {
            await l();
          } catch (v) {
            if (ra(v, "TRANSACTION_REPLACED")) {
              g(), p(v);
              return;
            }
          }
          o || this.provider.once("block", y);
        };
        m.push(() => {
          this.provider.off("block", y);
        }),
          this.provider.once("block", y);
      }
    });
  }
  isMined() {
    return this.blockHash != null;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  removedEvent() {
    return (
      Ue(
        this.isMined(),
        "unmined transaction canot be orphaned",
        "UNSUPPORTED_OPERATION",
        { operation: "removeEvent()" }
      ),
      oG(this)
    );
  }
  reorderedEvent(e) {
    return (
      Ue(
        this.isMined(),
        "unmined transaction canot be orphaned",
        "UNSUPPORTED_OPERATION",
        { operation: "removeEvent()" }
      ),
      Ue(
        !e || e.isMined(),
        "unmined 'other' transaction canot be orphaned",
        "UNSUPPORTED_OPERATION",
        { operation: "removeEvent()" }
      ),
      aG(this, e)
    );
  }
  replaceableTransaction(e) {
    ge(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const n = new My(this, this.provider);
    return (n.#e = e), n;
  }
}
function sve(t) {
  return { orphan: "drop-block", hash: t.hash, number: t.number };
}
function aG(t, e) {
  return { orphan: "reorder-transaction", tx: t, other: e };
}
function oG(t) {
  return { orphan: "drop-transaction", tx: t };
}
function ave(t) {
  return {
    orphan: "drop-log",
    log: {
      transactionHash: t.transactionHash,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      address: t.address,
      data: t.data,
      topics: Object.freeze(t.topics.slice()),
      index: t.index,
    },
  };
}
class RT extends Ry {
  interface;
  fragment;
  args;
  constructor(e, n, r) {
    super(e, e.provider);
    const i = n.decodeEventLog(r, e.data, e.topics);
    nn(this, { args: i, fragment: r, interface: n });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}
class lG extends Ry {
  error;
  constructor(e, n) {
    super(e, e.provider), nn(this, { error: n });
  }
}
class ove extends sG {
  #e;
  constructor(e, n, r) {
    super(r, n), (this.#e = e);
  }
  get logs() {
    return super.logs.map((e) => {
      const n = e.topics.length ? this.#e.getEvent(e.topics[0]) : null;
      if (n)
        try {
          return new RT(e, this.#e, n);
        } catch (r) {
          return new lG(e, r);
        }
      return e;
    });
  }
}
class MT extends My {
  #e;
  constructor(e, n, r) {
    super(r, n), (this.#e = e);
  }
  async wait(e, n) {
    const r = await super.wait(e, n);
    return r == null ? null : new ove(this.#e, this.provider, r);
  }
}
class uG extends Rz {
  log;
  constructor(e, n, r, i) {
    super(e, n, r), nn(this, { log: i });
  }
  async getBlock() {
    return await this.log.getBlock();
  }
  async getTransaction() {
    return await this.log.getTransaction();
  }
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class lve extends uG {
  constructor(e, n, r, i, s) {
    super(e, n, r, new RT(s, e.interface, i));
    const a = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
    nn(this, { args: a, fragment: i });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}
const ON = BigInt(0);
function cG(t) {
  return t && typeof t.call == "function";
}
function fG(t) {
  return t && typeof t.estimateGas == "function";
}
function a6(t) {
  return t && typeof t.resolveName == "function";
}
function dG(t) {
  return t && typeof t.sendTransaction == "function";
}
function hG(t) {
  if (t != null) {
    if (a6(t)) return t;
    if (t.provider) return t.provider;
  }
}
class uve {
  #e;
  fragment;
  constructor(e, n, r) {
    if ((nn(this, { fragment: n }), n.inputs.length < r.length))
      throw new Error("too many arguments");
    const i = Ch(e.runner, "resolveName"),
      s = a6(i) ? i : null;
    this.#e = (async function () {
      const a = await Promise.all(
        n.inputs.map((o, l) =>
          r[l] == null
            ? null
            : o.walkAsync(r[l], (f, c) =>
                f === "address"
                  ? Array.isArray(c)
                    ? Promise.all(c.map((d) => xa(d, s)))
                    : xa(c, s)
                  : c
              )
        )
      );
      return e.interface.encodeFilterTopics(n, a);
    })();
  }
  getTopicFilter() {
    return this.#e;
  }
}
function Ch(t, e) {
  return t == null
    ? null
    : typeof t[e] == "function"
    ? t
    : t.provider && typeof t.provider[e] == "function"
    ? t.provider
    : null;
}
function th(t) {
  return t == null ? null : t.provider || null;
}
async function LT(t, e) {
  const n = _i.dereference(t, "overrides");
  ge(typeof n == "object", "invalid overrides parameter", "overrides", t);
  const r = j5(n);
  return (
    ge(
      r.to == null || (e || []).indexOf("to") >= 0,
      "cannot override to",
      "overrides.to",
      r.to
    ),
    ge(
      r.data == null || (e || []).indexOf("data") >= 0,
      "cannot override data",
      "overrides.data",
      r.data
    ),
    r.from && (r.from = r.from),
    r
  );
}
async function pG(t, e, n) {
  const r = Ch(t, "resolveName"),
    i = a6(r) ? r : null;
  return await Promise.all(
    e.map((s, a) =>
      s.walkAsync(
        n[a],
        (o, l) => ((l = _i.dereference(l, o)), o === "address" ? xa(l, i) : l)
      )
    )
  );
}
function cve(t) {
  const e = async function (a) {
      const o = await LT(a, ["data"]);
      (o.to = await t.getAddress()),
        o.from && (o.from = await xa(o.from, hG(t.runner)));
      const l = t.interface,
        u = Lt(o.value || ON, "overrides.value") === ON,
        f = (o.data || "0x") === "0x";
      l.fallback &&
        !l.fallback.payable &&
        l.receive &&
        !f &&
        !u &&
        ge(
          !1,
          "cannot send data to receive or send value to non-payable fallback",
          "overrides",
          a
        ),
        ge(
          l.fallback || f,
          "cannot send data to receive-only contract",
          "overrides.data",
          o.data
        );
      const c = l.receive || (l.fallback && l.fallback.payable);
      return (
        ge(
          c || u,
          "cannot send value to non-payable fallback",
          "overrides.value",
          o.value
        ),
        ge(
          l.fallback || f,
          "cannot send data to receive-only contract",
          "overrides.data",
          o.data
        ),
        o
      );
    },
    n = async function (a) {
      const o = Ch(t.runner, "call");
      Ue(
        cG(o),
        "contract runner does not support calling",
        "UNSUPPORTED_OPERATION",
        { operation: "call" }
      );
      const l = await e(a);
      try {
        return await o.call(l);
      } catch (u) {
        throw gT(u) && u.data ? t.interface.makeError(u.data, l) : u;
      }
    },
    r = async function (a) {
      const o = t.runner;
      Ue(
        dG(o),
        "contract runner does not support sending transactions",
        "UNSUPPORTED_OPERATION",
        { operation: "sendTransaction" }
      );
      const l = await o.sendTransaction(await e(a)),
        u = th(t.runner);
      return new MT(t.interface, u, l);
    },
    i = async function (a) {
      const o = Ch(t.runner, "estimateGas");
      return (
        Ue(
          fG(o),
          "contract runner does not support gas estimation",
          "UNSUPPORTED_OPERATION",
          { operation: "estimateGas" }
        ),
        await o.estimateGas(await e(a))
      );
    },
    s = async (a) => await r(a);
  return (
    nn(s, {
      _contract: t,
      estimateGas: i,
      populateTransaction: e,
      send: r,
      staticCall: n,
    }),
    s
  );
}
function fve(t, e) {
  const n = function (...u) {
      const f = t.interface.getFunction(e, u);
      return (
        Ue(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key: e, args: u },
        }),
        f
      );
    },
    r = async function (...u) {
      const f = n(...u);
      let c = {};
      if (
        (f.inputs.length + 1 === u.length &&
          ((c = await LT(u.pop())),
          c.from && (c.from = await xa(c.from, hG(t.runner)))),
        f.inputs.length !== u.length)
      )
        throw new Error(
          "internal error: fragment inputs doesn't match arguments; should not happen"
        );
      const d = await pG(t.runner, f.inputs, u);
      return Object.assign(
        {},
        c,
        await ya({
          to: t.getAddress(),
          data: t.interface.encodeFunctionData(f, d),
        })
      );
    },
    i = async function (...u) {
      const f = await o(...u);
      return f.length === 1 ? f[0] : f;
    },
    s = async function (...u) {
      const f = t.runner;
      Ue(
        dG(f),
        "contract runner does not support sending transactions",
        "UNSUPPORTED_OPERATION",
        { operation: "sendTransaction" }
      );
      const c = await f.sendTransaction(await r(...u)),
        d = th(t.runner);
      return new MT(t.interface, d, c);
    },
    a = async function (...u) {
      const f = Ch(t.runner, "estimateGas");
      return (
        Ue(
          fG(f),
          "contract runner does not support gas estimation",
          "UNSUPPORTED_OPERATION",
          { operation: "estimateGas" }
        ),
        await f.estimateGas(await r(...u))
      );
    },
    o = async function (...u) {
      const f = Ch(t.runner, "call");
      Ue(
        cG(f),
        "contract runner does not support calling",
        "UNSUPPORTED_OPERATION",
        { operation: "call" }
      );
      const c = await r(...u);
      let d = "0x";
      try {
        d = await f.call(c);
      } catch (m) {
        throw gT(m) && m.data ? t.interface.makeError(m.data, c) : m;
      }
      const p = n(...u);
      return t.interface.decodeFunctionResult(p, d);
    },
    l = async (...u) => (n(...u).constant ? await i(...u) : await s(...u));
  return (
    nn(l, {
      name: t.interface.getFunctionName(e),
      _contract: t,
      _key: e,
      getFragment: n,
      estimateGas: a,
      populateTransaction: r,
      send: s,
      staticCall: i,
      staticCallResult: o,
    }),
    Object.defineProperty(l, "fragment", {
      configurable: !1,
      enumerable: !0,
      get: () => {
        const u = t.interface.getFunction(e);
        return (
          Ue(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key: e },
          }),
          u
        );
      },
    }),
    l
  );
}
function dve(t, e) {
  const n = function (...i) {
      const s = t.interface.getEvent(e, i);
      return (
        Ue(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key: e, args: i },
        }),
        s
      );
    },
    r = function (...i) {
      return new uve(t, n(...i), i);
    };
  return (
    nn(r, {
      name: t.interface.getEventName(e),
      _contract: t,
      _key: e,
      getFragment: n,
    }),
    Object.defineProperty(r, "fragment", {
      configurable: !1,
      enumerable: !0,
      get: () => {
        const i = t.interface.getEvent(e);
        return (
          Ue(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key: e },
          }),
          i
        );
      },
    }),
    r
  );
}
const H5 = Symbol.for("_ethersInternal_contract"),
  mG = new WeakMap();
function hve(t, e) {
  mG.set(t[H5], e);
}
function To(t) {
  return mG.get(t[H5]);
}
function pve(t) {
  return (
    t &&
    typeof t == "object" &&
    "getTopicFilter" in t &&
    typeof t.getTopicFilter == "function" &&
    t.fragment
  );
}
async function BT(t, e) {
  let n,
    r = null;
  if (Array.isArray(e)) {
    const s = function (a) {
      if (Mr(a, 32)) return a;
      const o = t.interface.getEvent(a);
      return ge(o, "unknown fragment", "name", a), o.topicHash;
    };
    n = e.map((a) => (a == null ? null : Array.isArray(a) ? a.map(s) : s(a)));
  } else
    e === "*"
      ? (n = [null])
      : typeof e == "string"
      ? Mr(e, 32)
        ? (n = [e])
        : ((r = t.interface.getEvent(e)),
          ge(r, "unknown fragment", "event", e),
          (n = [r.topicHash]))
      : pve(e)
      ? (n = await e.getTopicFilter())
      : "fragment" in e
      ? ((r = e.fragment), (n = [r.topicHash]))
      : ge(!1, "unknown event name", "event", e);
  n = n.map((s) => {
    if (s == null) return null;
    if (Array.isArray(s)) {
      const a = Array.from(new Set(s.map((o) => o.toLowerCase())).values());
      return a.length === 1 ? a[0] : (a.sort(), a);
    }
    return s.toLowerCase();
  });
  const i = n
    .map((s) => (s == null ? "null" : Array.isArray(s) ? s.join("|") : s))
    .join("&");
  return { fragment: r, tag: i, topics: n };
}
async function Hm(t, e) {
  const { subs: n } = To(t);
  return n.get((await BT(t, e)).tag) || null;
}
async function PN(t, e, n) {
  const r = th(t.runner);
  Ue(
    r,
    "contract runner does not support subscribing",
    "UNSUPPORTED_OPERATION",
    { operation: e }
  );
  const { fragment: i, tag: s, topics: a } = await BT(t, n),
    { addr: o, subs: l } = To(t);
  let u = l.get(s);
  if (!u) {
    const c = { address: o || t, topics: a },
      d = (w) => {
        let y = i;
        if (y == null)
          try {
            y = t.interface.getEvent(w.topics[0]);
          } catch {}
        if (y) {
          const v = y,
            E = i ? t.interface.decodeEventLog(i, w.data, w.topics) : [];
          YE(t, n, E, (S) => new lve(t, S, n, v, w));
        } else YE(t, n, [], (v) => new uG(t, v, n, w));
      };
    let p = [];
    (u = {
      tag: s,
      listeners: [],
      start: () => {
        p.length || p.push(r.on(c, d));
      },
      stop: async () => {
        if (p.length == 0) return;
        let w = p;
        (p = []), await Promise.all(w), r.off(c, d);
      },
    }),
      l.set(s, u);
  }
  return u;
}
let ZE = Promise.resolve();
async function mve(t, e, n, r) {
  await ZE;
  const i = await Hm(t, e);
  if (!i) return !1;
  const s = i.listeners.length;
  return (
    (i.listeners = i.listeners.filter(({ listener: a, once: o }) => {
      const l = Array.from(n);
      r && l.push(r(o ? null : a));
      try {
        a.call(t, ...l);
      } catch {}
      return !o;
    })),
    i.listeners.length === 0 && (i.stop(), To(t).subs.delete(i.tag)),
    s > 0
  );
}
async function YE(t, e, n, r) {
  try {
    await ZE;
  } catch {}
  const i = mve(t, e, n, r);
  return (ZE = i), await i;
}
const bv = ["then"];
class uh {
  target;
  interface;
  runner;
  filters;
  [H5];
  fallback;
  constructor(e, n, r, i) {
    ge(
      typeof e == "string" || _V(e),
      "invalid value for Contract target",
      "target",
      e
    ),
      r == null && (r = null);
    const s = eu.from(n);
    nn(this, { target: e, runner: r, interface: s }),
      Object.defineProperty(this, H5, { value: {} });
    let a,
      o = null,
      l = null;
    if (i) {
      const c = th(r);
      l = new MT(this.interface, c, i);
    }
    let u = new Map();
    if (typeof e == "string")
      if (Mr(e)) (o = e), (a = Promise.resolve(e));
      else {
        const c = Ch(r, "resolveName");
        if (!a6(c))
          throw mi(
            "contract runner does not support name resolution",
            "UNSUPPORTED_OPERATION",
            { operation: "resolveName" }
          );
        a = c.resolveName(e).then((d) => {
          if (d == null)
            throw mi(
              "an ENS name used for a contract target must be correctly configured",
              "UNCONFIGURED_NAME",
              { value: e }
            );
          return (To(this).addr = d), d;
        });
      }
    else
      a = e.getAddress().then((c) => {
        if (c == null) throw new Error("TODO");
        return (To(this).addr = c), c;
      });
    hve(this, { addrPromise: a, addr: o, deployTx: l, subs: u });
    const f = new Proxy(
      {},
      {
        get: (c, d, p) => {
          if (typeof d == "symbol" || bv.indexOf(d) >= 0)
            return Reflect.get(c, d, p);
          try {
            return this.getEvent(d);
          } catch (m) {
            if (!ra(m, "INVALID_ARGUMENT") || m.argument !== "key") throw m;
          }
        },
        has: (c, d) =>
          bv.indexOf(d) >= 0
            ? Reflect.has(c, d)
            : Reflect.has(c, d) || this.interface.hasEvent(String(d)),
      }
    );
    return (
      nn(this, { filters: f }),
      nn(this, { fallback: s.receive || s.fallback ? cve(this) : null }),
      new Proxy(this, {
        get: (c, d, p) => {
          if (typeof d == "symbol" || d in c || bv.indexOf(d) >= 0)
            return Reflect.get(c, d, p);
          try {
            return c.getFunction(d);
          } catch (m) {
            if (!ra(m, "INVALID_ARGUMENT") || m.argument !== "key") throw m;
          }
        },
        has: (c, d) =>
          typeof d == "symbol" || d in c || bv.indexOf(d) >= 0
            ? Reflect.has(c, d)
            : c.interface.hasFunction(d),
      })
    );
  }
  connect(e) {
    return new uh(this.target, this.interface, e);
  }
  attach(e) {
    return new uh(e, this.interface, this.runner);
  }
  async getAddress() {
    return await To(this).addrPromise;
  }
  async getDeployedCode() {
    const e = th(this.runner);
    Ue(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
      operation: "getDeployedCode",
    });
    const n = await e.getCode(await this.getAddress());
    return n === "0x" ? null : n;
  }
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e) return await e.wait(), this;
    if ((await this.getDeployedCode()) != null) return this;
    const r = th(this.runner);
    return (
      Ue(
        r != null,
        "contract runner does not support .provider",
        "UNSUPPORTED_OPERATION",
        { operation: "waitForDeployment" }
      ),
      new Promise((i, s) => {
        const a = async () => {
          try {
            if ((await this.getDeployedCode()) != null) return i(this);
            r.once("block", a);
          } catch (o) {
            s(o);
          }
        };
        a();
      })
    );
  }
  deploymentTransaction() {
    return To(this).deployTx;
  }
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), fve(this, e);
  }
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), dve(this, e);
  }
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  async queryFilter(e, n, r) {
    n == null && (n = 0), r == null && (r = "latest");
    const { addr: i, addrPromise: s } = To(this),
      a = i || (await s),
      { fragment: o, topics: l } = await BT(this, e),
      u = { address: a, topics: l, fromBlock: n, toBlock: r },
      f = th(this.runner);
    return (
      Ue(
        f,
        "contract runner does not have a provider",
        "UNSUPPORTED_OPERATION",
        { operation: "queryFilter" }
      ),
      (await f.getLogs(u)).map((c) => {
        let d = o;
        if (d == null)
          try {
            d = this.interface.getEvent(c.topics[0]);
          } catch {}
        if (d)
          try {
            return new RT(c, this.interface, d);
          } catch (p) {
            return new lG(c, p);
          }
        return new Ry(c, f);
      })
    );
  }
  async on(e, n) {
    const r = await PN(this, "on", e);
    return r.listeners.push({ listener: n, once: !1 }), r.start(), this;
  }
  async once(e, n) {
    const r = await PN(this, "once", e);
    return r.listeners.push({ listener: n, once: !0 }), r.start(), this;
  }
  async emit(e, ...n) {
    return await YE(this, e, n, null);
  }
  async listenerCount(e) {
    if (e) {
      const i = await Hm(this, e);
      return i ? i.listeners.length : 0;
    }
    const { subs: n } = To(this);
    let r = 0;
    for (const { listeners: i } of n.values()) r += i.length;
    return r;
  }
  async listeners(e) {
    if (e) {
      const i = await Hm(this, e);
      return i ? i.listeners.map(({ listener: s }) => s) : [];
    }
    const { subs: n } = To(this);
    let r = [];
    for (const { listeners: i } of n.values())
      r = r.concat(i.map(({ listener: s }) => s));
    return r;
  }
  async off(e, n) {
    const r = await Hm(this, e);
    if (!r) return this;
    if (n) {
      const i = r.listeners.map(({ listener: s }) => s).indexOf(n);
      i >= 0 && r.listeners.splice(i, 1);
    }
    return (
      (n == null || r.listeners.length === 0) &&
        (r.stop(), To(this).subs.delete(r.tag)),
      this
    );
  }
  async removeAllListeners(e) {
    if (e) {
      const n = await Hm(this, e);
      if (!n) return this;
      n.stop(), To(this).subs.delete(n.tag);
    } else {
      const { subs: n } = To(this);
      for (const { tag: r, stop: i } of n.values()) i(), n.delete(r);
    }
    return this;
  }
  async addListener(e, n) {
    return await this.on(e, n);
  }
  async removeListener(e, n) {
    return await this.off(e, n);
  }
  static buildClass(e) {
    class n extends uh {
      constructor(i, s = null) {
        super(i, e, s);
      }
    }
    return n;
  }
  static from(e, n, r) {
    return r == null && (r = null), new this(e, n, r);
  }
}
function gve() {
  return uh;
}
class kr extends gve() {}
class Ly {
  interface;
  bytecode;
  runner;
  constructor(e, n, r) {
    const i = eu.from(e);
    n instanceof Uint8Array ||
      (typeof n == "object" && (n = n.object),
      n.startsWith("0x") || (n = "0x" + n)),
      (n = Gt(er(n))),
      nn(this, { bytecode: n, interface: i, runner: r || null });
  }
  attach(e) {
    return new uh(e, this.interface, this.runner);
  }
  async getDeployTransaction(...e) {
    let n = {};
    const r = this.interface.deploy;
    if (
      (r.inputs.length + 1 === e.length && (n = await LT(e.pop())),
      r.inputs.length !== e.length)
    )
      throw new Error("incorrect number of arguments to constructor");
    const i = await pG(this.runner, r.inputs, e),
      s = Di([this.bytecode, this.interface.encodeDeploy(i)]);
    return Object.assign({}, n, { data: s });
  }
  async deploy(...e) {
    const n = await this.getDeployTransaction(...e);
    Ue(
      this.runner && typeof this.runner.sendTransaction == "function",
      "factory runner does not support sending transactions",
      "UNSUPPORTED_OPERATION",
      { operation: "sendTransaction" }
    );
    const r = await this.runner.sendTransaction(n),
      i = wV(r);
    return new uh(i, this.interface, this.runner, r);
  }
  connect(e) {
    return new Ly(this.interface, this.bytecode, e);
  }
  static fromSolidity(e, n) {
    ge(e != null, "bad compiler output", "output", e),
      typeof e == "string" && (e = JSON.parse(e));
    const r = e.abi;
    let i = "";
    return (
      e.bytecode
        ? (i = e.bytecode)
        : e.evm && e.evm.bytecode && (i = e.evm.bytecode),
      new this(r, i, n)
    );
  }
}
function m8(t) {
  return (
    t.match(/^ipfs:\/\/ipfs\//i)
      ? (t = t.substring(12))
      : t.match(/^ipfs:\/\//i)
      ? (t = t.substring(7))
      : ge(!1, "unsupported IPFS format", "link", t),
    `https://gateway.ipfs.io/ipfs/${t}`
  );
}
class yve {
  name;
  constructor(e) {
    nn(this, { name: e });
  }
  connect(e) {
    return this;
  }
  supportsCoinType(e) {
    return !1;
  }
  async encodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
  async decodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
}
const gG = new RegExp("^(ipfs)://(.*)$", "i"),
  NN = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    gG,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
  ];
class y0 {
  provider;
  address;
  name;
  #e;
  #t;
  constructor(e, n, r) {
    nn(this, { provider: e, address: n, name: r }),
      (this.#e = null),
      (this.#t = new kr(
        n,
        [
          "function supportsInterface(bytes4) view returns (bool)",
          "function resolve(bytes, bytes) view returns (bytes)",
          "function addr(bytes32) view returns (address)",
          "function addr(bytes32, uint) view returns (bytes)",
          "function text(bytes32, string) view returns (string)",
          "function contenthash(bytes32) view returns (bytes)",
        ],
        e
      ));
  }
  async supportsWildcard() {
    return (
      this.#e == null &&
        (this.#e = (async () => {
          try {
            return await this.#t.supportsInterface("0x9061b923");
          } catch (e) {
            if (ra(e, "CALL_EXCEPTION")) return !1;
            throw ((this.#e = null), e);
          }
        })()),
      await this.#e
    );
  }
  async #n(e, n) {
    n = (n || []).slice();
    const r = this.#t.interface;
    n.unshift(XE(this.name));
    let i = null;
    (await this.supportsWildcard()) &&
      ((i = r.getFunction(e)),
      Ue(i, "missing fragment", "UNKNOWN_ERROR", { info: { funcName: e } }),
      (n = [_2e(this.name, 255), r.encodeFunctionData(i, n)]),
      (e = "resolve(bytes,bytes)")),
      n.push({ enableCcipRead: !0 });
    try {
      const s = await this.#t[e](...n);
      return i ? r.decodeFunctionResult(i, s)[0] : s;
    } catch (s) {
      if (!ra(s, "CALL_EXCEPTION")) throw s;
    }
    return null;
  }
  async getAddress(e) {
    if ((e == null && (e = 60), e === 60))
      try {
        const s = await this.#n("addr(bytes32)");
        return s == null || s === dd ? null : s;
      } catch (s) {
        if (ra(s, "CALL_EXCEPTION")) return null;
        throw s;
      }
    if (e >= 0 && e < 2147483648) {
      let s = e + 2147483648;
      const a = await this.#n("addr(bytes32,uint)", [s]);
      if (Mr(a, 20)) return yr(a);
    }
    let n = null;
    for (const s of this.provider.plugins)
      if (s instanceof yve && s.supportsCoinType(e)) {
        n = s;
        break;
      }
    if (n == null) return null;
    const r = await this.#n("addr(bytes32,uint)", [e]);
    if (r == null || r === "0x") return null;
    const i = await n.decodeAddress(e, r);
    if (i != null) return i;
    Ue(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: r },
    });
  }
  async getText(e) {
    const n = await this.#n("text(bytes32,string)", [e]);
    return n == null || n === "0x" ? null : n;
  }
  async getContentHash() {
    const e = await this.#n("contenthash(bytes32)");
    if (e == null || e === "0x") return null;
    const n = e.match(
      /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
    );
    if (n) {
      const i = n[1] === "e3010170" ? "ipfs" : "ipns",
        s = parseInt(n[4], 16);
      if (n[5].length === s * 2) return `${i}://${Cme("0x" + n[2])}`;
    }
    const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64) return `bzz://${r[1]}`;
    Ue(
      !1,
      "invalid or unsupported content hash data",
      "UNSUPPORTED_OPERATION",
      { operation: "getContentHash()", info: { data: e } }
    );
  }
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const n = await this.getText("avatar");
      if (n == null)
        return (
          e.push({ type: "!avatar", value: "" }), { url: null, linkage: e }
        );
      e.push({ type: "avatar", value: n });
      for (let r = 0; r < NN.length; r++) {
        const i = n.match(NN[r]);
        if (i == null) continue;
        const s = i[1].toLowerCase();
        switch (s) {
          case "https":
          case "data":
            return e.push({ type: "url", value: n }), { linkage: e, url: n };
          case "ipfs": {
            const a = m8(n);
            return (
              e.push({ type: "ipfs", value: n }),
              e.push({ type: "url", value: a }),
              { linkage: e, url: a }
            );
          }
          case "erc721":
          case "erc1155": {
            const a = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: s, value: n });
            const o = await this.getAddress();
            if (o == null)
              return (
                e.push({ type: "!owner", value: "" }), { url: null, linkage: e }
              );
            const l = (i[2] || "").split("/");
            if (l.length !== 2)
              return (
                e.push({ type: `!${s}caip`, value: i[2] || "" }),
                { url: null, linkage: e }
              );
            const u = l[1],
              f = new kr(
                l[0],
                [
                  "function tokenURI(uint) view returns (string)",
                  "function ownerOf(uint) view returns (address)",
                  "function uri(uint) view returns (string)",
                  "function balanceOf(address, uint256) view returns (uint)",
                ],
                this.provider
              );
            if (s === "erc721") {
              const g = await f.ownerOf(u);
              if (o !== g)
                return (
                  e.push({ type: "!owner", value: g }),
                  { url: null, linkage: e }
                );
              e.push({ type: "owner", value: g });
            } else if (s === "erc1155") {
              const g = await f.balanceOf(o, u);
              if (!g)
                return (
                  e.push({ type: "!balance", value: "0" }),
                  { url: null, linkage: e }
                );
              e.push({ type: "balance", value: g.toString() });
            }
            let c = await f[a](u);
            if (c == null || c === "0x")
              return (
                e.push({ type: "!metadata-url", value: "" }),
                { url: null, linkage: e }
              );
            e.push({ type: "metadata-url-base", value: c }),
              s === "erc1155" &&
                ((c = c.replace("{id}", ud(u, 32).substring(2))),
                e.push({ type: "metadata-url-expanded", value: c })),
              c.match(/^ipfs:/i) && (c = m8(c)),
              e.push({ type: "metadata-url", value: c });
            let d = {};
            const p = await new ec(c).send();
            p.assertOk();
            try {
              d = p.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: p.bodyText });
              } catch {
                const y = p.body;
                return (
                  y && e.push({ type: "!metadata", value: Gt(y) }),
                  { url: null, linkage: e }
                );
              }
              return { url: null, linkage: e };
            }
            if (!d)
              return (
                e.push({ type: "!metadata", value: "" }),
                { url: null, linkage: e }
              );
            e.push({ type: "metadata", value: JSON.stringify(d) });
            let m = d.image;
            if (typeof m != "string")
              return (
                e.push({ type: "!imageUrl", value: "" }),
                { url: null, linkage: e }
              );
            if (!m.match(/^(https:\/\/|data:)/i)) {
              if (m.match(gG) == null)
                return (
                  e.push({ type: "!imageUrl-ipfs", value: m }),
                  { url: null, linkage: e }
                );
              e.push({ type: "imageUrl-ipfs", value: m }), (m = m8(m));
            }
            return e.push({ type: "url", value: m }), { linkage: e, url: m };
          }
        }
      }
    } catch {}
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const n = await e.getNetwork(),
      r = n.getPlugin("org.ethers.plugins.network.Ens");
    return (
      Ue(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
        operation: "getEnsAddress",
        info: { network: n },
      }),
      r.address
    );
  }
  static async #r(e, n) {
    const r = await y0.getEnsAddress(e);
    try {
      const s = await new kr(
        r,
        ["function resolver(bytes32) view returns (address)"],
        e
      ).resolver(XE(n), { enableCcipRead: !0 });
      return s === dd ? null : s;
    } catch (i) {
      throw i;
    }
    return null;
  }
  static async fromName(e, n) {
    let r = n;
    for (;;) {
      if (r === "" || r === "." || (n !== "eth" && r === "eth")) return null;
      const i = await y0.#r(e, r);
      if (i != null) {
        const s = new y0(e, i, n);
        return r !== n && !(await s.supportsWildcard()) ? null : s;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
}
const DN = BigInt(0);
function tr(t, e) {
  return function (n) {
    return n == null ? e : t(n);
  };
}
function o6(t, e) {
  return (n) => {
    if (e && n == null) return null;
    if (!Array.isArray(n)) throw new Error("not an array");
    return n.map((r) => t(r));
  };
}
function By(t, e) {
  return (n) => {
    const r = {};
    for (const i in t) {
      let s = i;
      if (e && i in e && !(s in n)) {
        for (const a of e[i])
          if (a in n) {
            s = a;
            break;
          }
      }
      try {
        const a = t[i](n[s]);
        a !== void 0 && (r[i] = a);
      } catch (a) {
        const o = a instanceof Error ? a.message : "not-an-error";
        Ue(!1, `invalid value for value.${i} (${o})`, "BAD_DATA", { value: n });
      }
    }
    return r;
  };
}
function vve(t) {
  switch (t) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  ge(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
}
function Q0(t) {
  return ge(Mr(t, !0), "invalid data", "value", t), t;
}
function na(t) {
  return ge(Mr(t, 32), "invalid hash", "value", t), t;
}
const bve = By(
  {
    address: yr,
    blockHash: na,
    blockNumber: kn,
    data: Q0,
    index: kn,
    removed: tr(vve, !1),
    topics: o6(na),
    transactionHash: na,
    transactionIndex: kn,
  },
  { index: ["logIndex"] }
);
function wve(t) {
  return bve(t);
}
const _ve = By({
  hash: tr(na),
  parentHash: na,
  parentBeaconBlockRoot: tr(na, null),
  number: kn,
  timestamp: kn,
  nonce: tr(Q0),
  difficulty: Lt,
  gasLimit: Lt,
  gasUsed: Lt,
  stateRoot: tr(na, null),
  receiptsRoot: tr(na, null),
  blobGasUsed: tr(Lt, null),
  excessBlobGas: tr(Lt, null),
  miner: tr(yr),
  extraData: Q0,
  baseFeePerGas: tr(Lt),
});
function Eve(t) {
  const e = _ve(t);
  return (
    (e.transactions = t.transactions.map((n) =>
      typeof n == "string" ? n : yG(n)
    )),
    e
  );
}
const xve = By(
  {
    transactionIndex: kn,
    blockNumber: kn,
    transactionHash: na,
    address: yr,
    topics: o6(na),
    data: Q0,
    index: kn,
    blockHash: na,
  },
  { index: ["logIndex"] }
);
function Tve(t) {
  return xve(t);
}
const Sve = By(
  {
    to: tr(yr, null),
    from: tr(yr, null),
    contractAddress: tr(yr, null),
    index: kn,
    root: tr(Gt),
    gasUsed: Lt,
    blobGasUsed: tr(Lt, null),
    logsBloom: tr(Q0),
    blockHash: na,
    hash: na,
    logs: o6(Tve),
    blockNumber: kn,
    cumulativeGasUsed: Lt,
    effectiveGasPrice: tr(Lt),
    blobGasPrice: tr(Lt, null),
    status: tr(kn),
    type: tr(kn, 0),
  },
  {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"],
  }
);
function Ave(t) {
  return Sve(t);
}
function yG(t) {
  t.to &&
    Lt(t.to) === DN &&
    (t.to = "0x0000000000000000000000000000000000000000");
  const e = By(
    {
      hash: na,
      index: tr(kn, void 0),
      type: (n) => (n === "0x" || n == null ? 0 : kn(n)),
      accessList: tr(Fh, null),
      blobVersionedHashes: tr(o6(na, !0), null),
      blockHash: tr(na, null),
      blockNumber: tr(kn, null),
      transactionIndex: tr(kn, null),
      from: yr,
      gasPrice: tr(Lt),
      maxPriorityFeePerGas: tr(Lt),
      maxFeePerGas: tr(Lt),
      maxFeePerBlobGas: tr(Lt, null),
      gasLimit: Lt,
      to: tr(yr, null),
      value: Lt,
      nonce: kn,
      data: Q0,
      creates: tr(yr, null),
      chainId: tr(Lt, null),
    },
    { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
  )(t);
  if (
    (e.to == null && e.creates == null && (e.creates = wV(e)),
    (t.type === 1 || t.type === 2) &&
      t.accessList == null &&
      (e.accessList = []),
    t.signature
      ? (e.signature = Zi.from(t.signature))
      : (e.signature = Zi.from(t)),
    e.chainId == null)
  ) {
    const n = e.signature.legacyChainId;
    n != null && (e.chainId = n);
  }
  return e.blockHash && Lt(e.blockHash) === DN && (e.blockHash = null), e;
}
const Cve = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Fy {
  name;
  constructor(e) {
    nn(this, { name: e });
  }
  clone() {
    return new Fy(this.name);
  }
}
class l6 extends Fy {
  effectiveBlock;
  txBase;
  txCreate;
  txDataZero;
  txDataNonzero;
  txAccessListStorageKey;
  txAccessListAddress;
  constructor(e, n) {
    e == null && (e = 0), super(`org.ethers.network.plugins.GasCost#${e || 0}`);
    const r = { effectiveBlock: e };
    function i(s, a) {
      let o = (n || {})[s];
      o == null && (o = a),
        ge(typeof o == "number", `invalud value for ${s}`, "costs", n),
        (r[s] = o);
    }
    i("txBase", 21e3),
      i("txCreate", 32e3),
      i("txDataZero", 4),
      i("txDataNonzero", 16),
      i("txAccessListStorageKey", 1900),
      i("txAccessListAddress", 2400),
      nn(this, r);
  }
  clone() {
    return new l6(this.effectiveBlock, this);
  }
}
class u6 extends Fy {
  address;
  targetNetwork;
  constructor(e, n) {
    super("org.ethers.plugins.network.Ens"),
      nn(this, { address: e || Cve, targetNetwork: n ?? 1 });
  }
  clone() {
    return new u6(this.address, this.targetNetwork);
  }
}
class kve extends Fy {
  #e;
  #t;
  get url() {
    return this.#e;
  }
  get processFunc() {
    return this.#t;
  }
  constructor(e, n) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
      (this.#e = e),
      (this.#t = n);
  }
  clone() {
    return this;
  }
}
const g8 = new Map();
class Po {
  #e;
  #t;
  #n;
  constructor(e, n) {
    (this.#e = e), (this.#t = Lt(n)), (this.#n = new Map());
  }
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  get name() {
    return this.#e;
  }
  set name(e) {
    this.#e = e;
  }
  get chainId() {
    return this.#t;
  }
  set chainId(e) {
    this.#t = Lt(e, "chainId");
  }
  matches(e) {
    if (e == null) return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === Lt(e);
      } catch {}
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === Lt(e);
      } catch {}
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === Lt(e.chainId);
        } catch {}
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  get plugins() {
    return Array.from(this.#n.values());
  }
  attachPlugin(e) {
    if (this.#n.get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return this.#n.set(e.name, e.clone()), this;
  }
  getPlugin(e) {
    return this.#n.get(e) || null;
  }
  getPlugins(e) {
    return this.plugins.filter((n) => n.name.split("#")[0] === e);
  }
  clone() {
    const e = new Po(this.name, this.chainId);
    return (
      this.plugins.forEach((n) => {
        e.attachPlugin(n.clone());
      }),
      e
    );
  }
  computeIntrinsicGas(e) {
    const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new l6();
    let r = n.txBase;
    if ((e.to == null && (r += n.txCreate), e.data))
      for (let i = 2; i < e.data.length; i += 2)
        e.data.substring(i, i + 2) === "00"
          ? (r += n.txDataZero)
          : (r += n.txDataNonzero);
    if (e.accessList) {
      const i = Fh(e.accessList);
      for (const s in i)
        r +=
          n.txAccessListAddress +
          n.txAccessListStorageKey * i[s].storageKeys.length;
    }
    return r;
  }
  static from(e) {
    if ((Ive(), e == null)) return Po.from("mainnet");
    if (
      (typeof e == "number" && (e = BigInt(e)),
      typeof e == "string" || typeof e == "bigint")
    ) {
      const n = g8.get(e);
      if (n) return n();
      if (typeof e == "bigint") return new Po("unknown", e);
      ge(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function") return e.clone();
    if (typeof e == "object") {
      ge(
        typeof e.name == "string" && typeof e.chainId == "number",
        "invalid network object name or chainId",
        "network",
        e
      );
      const n = new Po(e.name, e.chainId);
      return (
        (e.ensAddress || e.ensNetwork != null) &&
          n.attachPlugin(new u6(e.ensAddress, e.ensNetwork)),
        n
      );
    }
    ge(!1, "invalid network", "network", e);
  }
  static register(e, n) {
    typeof e == "number" && (e = BigInt(e));
    const r = g8.get(e);
    r &&
      ge(
        !1,
        `conflicting network for ${JSON.stringify(r.name)}`,
        "nameOrChainId",
        e
      ),
      g8.set(e, n);
  }
}
function RN(t, e) {
  const n = String(t);
  if (!n.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${t}`);
  const r = n.split(".");
  if ((r.length === 1 && r.push(""), r.length !== 2))
    throw new Error(`invalid gwei value: ${t}`);
  for (; r[1].length < e; ) r[1] += "0";
  if (r[1].length > 9) {
    let i = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || i++, (r[1] = i.toString());
  }
  return BigInt(r[0] + r[1]);
}
function MN(t) {
  return new kve(t, async (e, n, r) => {
    r.setHeader("User-Agent", "ethers");
    let i;
    try {
      const [s, a] = await Promise.all([r.send(), e()]);
      i = s;
      const o = i.bodyJson.standard;
      return {
        gasPrice: a.gasPrice,
        maxFeePerGas: RN(o.maxFee, 9),
        maxPriorityFeePerGas: RN(o.maxPriorityFee, 9),
      };
    } catch (s) {
      Ue(
        !1,
        `error encountered with polygon gas station (${JSON.stringify(r.url)})`,
        "SERVER_ERROR",
        { request: r, response: i, error: s }
      );
    }
  });
}
let LN = !1;
function Ive() {
  if (LN) return;
  LN = !0;
  function t(e, n, r) {
    const i = function () {
      const s = new Po(e, n);
      return (
        r.ensNetwork != null && s.attachPlugin(new u6(null, r.ensNetwork)),
        s.attachPlugin(new l6()),
        (r.plugins || []).forEach((a) => {
          s.attachPlugin(a);
        }),
        s
      );
    };
    Po.register(e, i),
      Po.register(n, i),
      r.altNames &&
        r.altNames.forEach((s) => {
          Po.register(s, i);
        });
  }
  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
    t("ropsten", 3, { ensNetwork: 3 }),
    t("rinkeby", 4, { ensNetwork: 4 }),
    t("goerli", 5, { ensNetwork: 5 }),
    t("kovan", 42, { ensNetwork: 42 }),
    t("sepolia", 11155111, { ensNetwork: 11155111 }),
    t("holesky", 17e3, { ensNetwork: 17e3 }),
    t("classic", 61, {}),
    t("classicKotti", 6, {}),
    t("arbitrum", 42161, { ensNetwork: 1 }),
    t("arbitrum-goerli", 421613, {}),
    t("arbitrum-sepolia", 421614, {}),
    t("base", 8453, { ensNetwork: 1 }),
    t("base-goerli", 84531, {}),
    t("base-sepolia", 84532, {}),
    t("bnb", 56, { ensNetwork: 1 }),
    t("bnbt", 97, {}),
    t("linea", 59144, { ensNetwork: 1 }),
    t("linea-goerli", 59140, {}),
    t("matic", 137, {
      ensNetwork: 1,
      plugins: [MN("https://gasstation.polygon.technology/v2")],
    }),
    t("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [MN("https://gasstation-testnet.polygon.technology/v2")],
    }),
    t("optimism", 10, { ensNetwork: 1, plugins: [] }),
    t("optimism-goerli", 420, {}),
    t("optimism-sepolia", 11155420, {}),
    t("xdai", 100, { ensNetwork: 1 });
}
function QE(t) {
  return JSON.parse(JSON.stringify(t));
}
class Ove {
  #e;
  #t;
  #n;
  #r;
  constructor(e) {
    (this.#e = e), (this.#t = null), (this.#n = 4e3), (this.#r = -2);
  }
  get pollingInterval() {
    return this.#n;
  }
  set pollingInterval(e) {
    this.#n = e;
  }
  async #i() {
    try {
      const e = await this.#e.getBlockNumber();
      if (this.#r === -2) {
        this.#r = e;
        return;
      }
      if (e !== this.#r) {
        for (let n = this.#r + 1; n <= e; n++) {
          if (this.#t == null) return;
          await this.#e.emit("block", n);
        }
        this.#r = e;
      }
    } catch {}
    this.#t != null &&
      (this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n));
  }
  start() {
    this.#t ||
      ((this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n)), this.#i());
  }
  stop() {
    this.#t && (this.#e._clearTimeout(this.#t), (this.#t = null));
  }
  pause(e) {
    this.stop(), e && (this.#r = -2);
  }
  resume() {
    this.start();
  }
}
class FT {
  #e;
  #t;
  #n;
  constructor(e) {
    (this.#e = e),
      (this.#n = !1),
      (this.#t = (n) => {
        this._poll(n, this.#e);
      });
  }
  async _poll(e, n) {
    throw new Error("sub-classes must override this");
  }
  start() {
    this.#n || ((this.#n = !0), this.#t(-2), this.#e.on("block", this.#t));
  }
  stop() {
    this.#n && ((this.#n = !1), this.#e.off("block", this.#t));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
class Pve extends FT {
  #e;
  #t;
  constructor(e, n) {
    super(e), (this.#e = n), (this.#t = -2);
  }
  pause(e) {
    e && (this.#t = -2), super.pause(e);
  }
  async _poll(e, n) {
    const r = await n.getBlock(this.#e);
    r != null &&
      (this.#t === -2
        ? (this.#t = r.number)
        : r.number > this.#t &&
          (n.emit(this.#e, r.number), (this.#t = r.number)));
  }
}
class Nve extends FT {
  #e;
  constructor(e, n) {
    super(e), (this.#e = QE(n));
  }
  async _poll(e, n) {
    throw new Error("@TODO");
  }
}
class Dve extends FT {
  #e;
  constructor(e, n) {
    super(e), (this.#e = n);
  }
  async _poll(e, n) {
    const r = await n.getTransactionReceipt(this.#e);
    r && n.emit(this.#e, r);
  }
}
class $T {
  #e;
  #t;
  #n;
  #r;
  #i;
  constructor(e, n) {
    (this.#e = e),
      (this.#t = QE(n)),
      (this.#n = this.#a.bind(this)),
      (this.#r = !1),
      (this.#i = -2);
  }
  async #a(e) {
    if (this.#i === -2) return;
    const n = QE(this.#t);
    (n.fromBlock = this.#i + 1), (n.toBlock = e);
    const r = await this.#e.getLogs(n);
    if (r.length === 0) {
      this.#i < e - 60 && (this.#i = e - 60);
      return;
    }
    for (const i of r) this.#e.emit(this.#t, i), (this.#i = i.blockNumber);
  }
  start() {
    this.#r ||
      ((this.#r = !0),
      this.#i === -2 &&
        this.#e.getBlockNumber().then((e) => {
          this.#i = e;
        }),
      this.#e.on("block", this.#n));
  }
  stop() {
    this.#r && ((this.#r = !1), this.#e.off("block", this.#n));
  }
  pause(e) {
    this.stop(), e && (this.#i = -2);
  }
  resume() {
    this.start();
  }
}
const Rve = BigInt(2),
  Mve = 10;
function wv(t) {
  return t && typeof t.then == "function";
}
function cb(t, e) {
  return (
    t +
    ":" +
    JSON.stringify(e, (n, r) => {
      if (r == null) return "null";
      if (typeof r == "bigint") return `bigint:${r.toString()}`;
      if (typeof r == "string") return r.toLowerCase();
      if (typeof r == "object" && !Array.isArray(r)) {
        const i = Object.keys(r);
        return i.sort(), i.reduce((s, a) => ((s[a] = r[a]), s), {});
      }
      return r;
    })
  );
}
class z5 {
  name;
  constructor(e) {
    nn(this, { name: e });
  }
  start() {}
  stop() {}
  pause(e) {}
  resume() {}
}
function Lve(t) {
  return JSON.parse(JSON.stringify(t));
}
function JE(t) {
  return (t = Array.from(new Set(t).values())), t.sort(), t;
}
async function y8(t, e) {
  if (t == null) throw new Error("invalid event");
  if ((Array.isArray(t) && (t = { topics: t }), typeof t == "string"))
    switch (t) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: t, tag: t };
    }
  if (Mr(t, 32)) {
    const n = t.toLowerCase();
    return { type: "transaction", tag: cb("tx", { hash: n }), hash: n };
  }
  if (t.orphan) {
    const n = t;
    return { type: "orphan", tag: cb("orphan", n), filter: Lve(n) };
  }
  if (t.address || t.topics) {
    const n = t,
      r = {
        topics: (n.topics || []).map((i) =>
          i == null
            ? null
            : Array.isArray(i)
            ? JE(i.map((s) => s.toLowerCase()))
            : i.toLowerCase()
        ),
      };
    if (n.address) {
      const i = [],
        s = [],
        a = (o) => {
          Mr(o)
            ? i.push(o)
            : s.push(
                (async () => {
                  i.push(await xa(o, e));
                })()
              );
        };
      Array.isArray(n.address) ? n.address.forEach(a) : a(n.address),
        s.length && (await Promise.all(s)),
        (r.address = JE(i.map((o) => o.toLowerCase())));
    }
    return { filter: r, tag: cb("event", r), type: "event" };
  }
  ge(!1, "unknown ProviderEvent", "event", t);
}
function v8() {
  return new Date().getTime();
}
const Bve = { cacheTimeout: 250, pollingInterval: 4e3 };
class Fve {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  #s;
  #o;
  #c;
  #u;
  #d;
  #h;
  constructor(e, n) {
    if (((this.#h = Object.assign({}, Bve, n || {})), e === "any"))
      (this.#a = !0), (this.#i = null);
    else if (e) {
      const r = Po.from(e);
      (this.#a = !1),
        (this.#i = Promise.resolve(r)),
        setTimeout(() => {
          this.emit("network", r, null);
        }, 0);
    } else (this.#a = !1), (this.#i = null);
    (this.#o = -1),
      (this.#s = new Map()),
      (this.#e = new Map()),
      (this.#t = new Map()),
      (this.#n = null),
      (this.#r = !1),
      (this.#c = 1),
      (this.#u = new Map()),
      (this.#d = !1);
  }
  get pollingInterval() {
    return this.#h.pollingInterval;
  }
  get provider() {
    return this;
  }
  get plugins() {
    return Array.from(this.#t.values());
  }
  attachPlugin(e) {
    if (this.#t.get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return this.#t.set(e.name, e.connect(this)), this;
  }
  getPlugin(e) {
    return this.#t.get(e) || null;
  }
  get disableCcipRead() {
    return this.#d;
  }
  set disableCcipRead(e) {
    this.#d = !!e;
  }
  async #l(e) {
    const n = this.#h.cacheTimeout;
    if (n < 0) return await this._perform(e);
    const r = cb(e.method, e);
    let i = this.#s.get(r);
    return (
      i ||
        ((i = this._perform(e)),
        this.#s.set(r, i),
        setTimeout(() => {
          this.#s.get(r) === i && this.#s.delete(r);
        }, n)),
      await i
    );
  }
  async ccipReadFetch(e, n, r) {
    if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
    const i = e.to.toLowerCase(),
      s = n.toLowerCase(),
      a = [];
    for (let o = 0; o < r.length; o++) {
      const l = r[o],
        u = l.replace("{sender}", i).replace("{data}", s),
        f = new ec(u);
      l.indexOf("{data}") === -1 && (f.body = { data: s, sender: i }),
        this.emit("debug", {
          action: "sendCcipReadFetchRequest",
          request: f,
          index: o,
          urls: r,
        });
      let c = "unknown error";
      const d = await f.send();
      try {
        const p = d.bodyJson;
        if (p.data)
          return (
            this.emit("debug", {
              action: "receiveCcipReadFetchResult",
              request: f,
              result: p,
            }),
            p.data
          );
        p.message && (c = p.message),
          this.emit("debug", {
            action: "receiveCcipReadFetchError",
            request: f,
            result: p,
          });
      } catch {}
      Ue(
        d.statusCode < 400 || d.statusCode >= 500,
        `response not found during CCIP fetch: ${c}`,
        "OFFCHAIN_FAULT",
        {
          reason: "404_MISSING_RESOURCE",
          transaction: e,
          info: { url: l, errorMessage: c },
        }
      ),
        a.push(c);
    }
    Ue(
      !1,
      `error encountered during CCIP fetch: ${a
        .map((o) => JSON.stringify(o))
        .join(", ")}`,
      "OFFCHAIN_FAULT",
      {
        reason: "500_SERVER_ERROR",
        transaction: e,
        info: { urls: r, errorMessages: a },
      }
    );
  }
  _wrapBlock(e, n) {
    return new ive(Eve(e), this);
  }
  _wrapLog(e, n) {
    return new Ry(wve(e), this);
  }
  _wrapTransactionReceipt(e, n) {
    return new sG(Ave(e), this);
  }
  _wrapTransactionResponse(e, n) {
    return new My(yG(e), this);
  }
  _detectNetwork() {
    Ue(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork",
    });
  }
  async _perform(e) {
    Ue(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e,
    });
  }
  async getBlockNumber() {
    const e = kn(await this.#l({ method: "getBlockNumber" }), "%response");
    return this.#o >= 0 && (this.#o = e), e;
  }
  _getAddress(e) {
    return xa(e, this);
  }
  _getBlockTag(e) {
    if (e == null) return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (Mr(e)) return Mr(e, 32) ? e : Qd(e);
    if ((typeof e == "bigint" && (e = kn(e, "blockTag")), typeof e == "number"))
      return e >= 0
        ? Qd(e)
        : this.#o >= 0
        ? Qd(this.#o + e)
        : this.getBlockNumber().then((n) => Qd(n + e));
    ge(!1, "invalid blockTag", "blockTag", e);
  }
  _getFilter(e) {
    const n = (e.topics || []).map((l) =>
        l == null
          ? null
          : Array.isArray(l)
          ? JE(l.map((u) => u.toLowerCase()))
          : l.toLowerCase()
      ),
      r = "blockHash" in e ? e.blockHash : void 0,
      i = (l, u, f) => {
        let c;
        switch (l.length) {
          case 0:
            break;
          case 1:
            c = l[0];
            break;
          default:
            l.sort(), (c = l);
        }
        if (r && (u != null || f != null)) throw new Error("invalid filter");
        const d = {};
        return (
          c && (d.address = c),
          n.length && (d.topics = n),
          u && (d.fromBlock = u),
          f && (d.toBlock = f),
          r && (d.blockHash = r),
          d
        );
      };
    let s = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const l of e.address) s.push(this._getAddress(l));
      else s.push(this._getAddress(e.address));
    let a;
    "fromBlock" in e && (a = this._getBlockTag(e.fromBlock));
    let o;
    return (
      "toBlock" in e && (o = this._getBlockTag(e.toBlock)),
      s.filter((l) => typeof l != "string").length ||
      (a != null && typeof a != "string") ||
      (o != null && typeof o != "string")
        ? Promise.all([Promise.all(s), a, o]).then((l) => i(l[0], l[1], l[2]))
        : i(s, a, o)
    );
  }
  _getTransactionRequest(e) {
    const n = j5(e),
      r = [];
    if (
      (["to", "from"].forEach((i) => {
        if (n[i] == null) return;
        const s = xa(n[i], this);
        wv(s)
          ? r.push(
              (async function () {
                n[i] = await s;
              })()
            )
          : (n[i] = s);
      }),
      n.blockTag != null)
    ) {
      const i = this._getBlockTag(n.blockTag);
      wv(i)
        ? r.push(
            (async function () {
              n.blockTag = await i;
            })()
          )
        : (n.blockTag = i);
    }
    return r.length
      ? (async function () {
          return await Promise.all(r), n;
        })()
      : n;
  }
  async getNetwork() {
    if (this.#i == null) {
      const i = (async () => {
        try {
          const s = await this._detectNetwork();
          return this.emit("network", s, null), s;
        } catch (s) {
          throw (this.#i === i && (this.#i = null), s);
        }
      })();
      return (this.#i = i), (await i).clone();
    }
    const e = this.#i,
      [n, r] = await Promise.all([e, this._detectNetwork()]);
    return (
      n.chainId !== r.chainId &&
        (this.#a
          ? (this.emit("network", r, n),
            this.#i === e && (this.#i = Promise.resolve(r)))
          : Ue(
              !1,
              `network changed: ${n.chainId} => ${r.chainId} `,
              "NETWORK_ERROR",
              { event: "changed" }
            )),
      n.clone()
    );
  }
  async getFeeData() {
    const e = await this.getNetwork(),
      n = async () => {
        const {
          _block: i,
          gasPrice: s,
          priorityFee: a,
        } = await ya({
          _block: this.#v("latest", !1),
          gasPrice: (async () => {
            try {
              const f = await this.#l({ method: "getGasPrice" });
              return Lt(f, "%response");
            } catch {}
            return null;
          })(),
          priorityFee: (async () => {
            try {
              const f = await this.#l({ method: "getPriorityFee" });
              return Lt(f, "%response");
            } catch {}
            return null;
          })(),
        });
        let o = null,
          l = null;
        const u = this._wrapBlock(i, e);
        return (
          u &&
            u.baseFeePerGas &&
            ((l = a ?? BigInt("1000000000")), (o = u.baseFeePerGas * Rve + l)),
          new IN(s, o, l)
        );
      },
      r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const i = new ec(r.url),
        s = await r.processFunc(n, this, i);
      return new IN(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas);
    }
    return await n();
  }
  async estimateGas(e) {
    let n = this._getTransactionRequest(e);
    return (
      wv(n) && (n = await n),
      Lt(await this.#l({ method: "estimateGas", transaction: n }), "%response")
    );
  }
  async #f(e, n, r) {
    Ue(r < Mve, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, e, { blockTag: n, enableCcipRead: !0 }),
    });
    const i = j5(e);
    try {
      return Gt(
        await this._perform({ method: "call", transaction: i, blockTag: n })
      );
    } catch (s) {
      if (
        !this.disableCcipRead &&
        gT(s) &&
        s.data &&
        r >= 0 &&
        n === "latest" &&
        i.to != null &&
        vi(s.data, 0, 4) === "0x556f1830"
      ) {
        const a = s.data,
          o = await xa(i.to, this);
        let l;
        try {
          l = zve(vi(s.data, 4));
        } catch (c) {
          Ue(!1, c.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction: i,
            info: { data: a },
          });
        }
        Ue(
          l.sender.toLowerCase() === o.toLowerCase(),
          "CCIP Read sender mismatch",
          "CALL_EXCEPTION",
          {
            action: "call",
            data: a,
            reason: "OffchainLookup",
            transaction: i,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: l.errorArgs,
            },
          }
        );
        const u = await this.ccipReadFetch(i, l.calldata, l.urls);
        Ue(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction: i,
          info: { data: s.data, errorArgs: l.errorArgs },
        });
        const f = { to: o, data: Di([l.selector, Hve([u, l.extraData])]) };
        this.emit("debug", { action: "sendCcipReadCall", transaction: f });
        try {
          const c = await this.#f(f, n, r + 1);
          return (
            this.emit("debug", {
              action: "receiveCcipReadCallResult",
              transaction: Object.assign({}, f),
              result: c,
            }),
            c
          );
        } catch (c) {
          throw (
            (this.emit("debug", {
              action: "receiveCcipReadCallError",
              transaction: Object.assign({}, f),
              error: c,
            }),
            c)
          );
        }
      }
      throw s;
    }
  }
  async #m(e) {
    const { value: n } = await ya({ network: this.getNetwork(), value: e });
    return n;
  }
  async call(e) {
    const { tx: n, blockTag: r } = await ya({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag),
    });
    return await this.#m(this.#f(n, r, e.enableCcipRead ? 0 : -1));
  }
  async #p(e, n, r) {
    let i = this._getAddress(n),
      s = this._getBlockTag(r);
    return (
      (typeof i != "string" || typeof s != "string") &&
        ([i, s] = await Promise.all([i, s])),
      await this.#m(this.#l(Object.assign(e, { address: i, blockTag: s })))
    );
  }
  async getBalance(e, n) {
    return Lt(await this.#p({ method: "getBalance" }, e, n), "%response");
  }
  async getTransactionCount(e, n) {
    return kn(
      await this.#p({ method: "getTransactionCount" }, e, n),
      "%response"
    );
  }
  async getCode(e, n) {
    return Gt(await this.#p({ method: "getCode" }, e, n));
  }
  async getStorage(e, n, r) {
    const i = Lt(n, "position");
    return Gt(await this.#p({ method: "getStorage", position: i }, e, r));
  }
  async broadcastTransaction(e) {
    const {
        blockNumber: n,
        hash: r,
        network: i,
      } = await ya({
        blockNumber: this.getBlockNumber(),
        hash: this._perform({
          method: "broadcastTransaction",
          signedTransaction: e,
        }),
        network: this.getNetwork(),
      }),
      s = WV.from(e);
    if (s.hash !== r) throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(s, i).replaceableTransaction(n);
  }
  async #v(e, n) {
    if (Mr(e, 32))
      return await this.#l({
        method: "getBlock",
        blockHash: e,
        includeTransactions: n,
      });
    let r = this._getBlockTag(e);
    return (
      typeof r != "string" && (r = await r),
      await this.#l({ method: "getBlock", blockTag: r, includeTransactions: n })
    );
  }
  async getBlock(e, n) {
    const { network: r, params: i } = await ya({
      network: this.getNetwork(),
      params: this.#v(e, !!n),
    });
    return i == null ? null : this._wrapBlock(i, r);
  }
  async getTransaction(e) {
    const { network: n, params: r } = await ya({
      network: this.getNetwork(),
      params: this.#l({ method: "getTransaction", hash: e }),
    });
    return r == null ? null : this._wrapTransactionResponse(r, n);
  }
  async getTransactionReceipt(e) {
    const { network: n, params: r } = await ya({
      network: this.getNetwork(),
      params: this.#l({ method: "getTransactionReceipt", hash: e }),
    });
    if (r == null) return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const i = await this.#l({ method: "getTransaction", hash: e });
      if (i == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = i.gasPrice;
    }
    return this._wrapTransactionReceipt(r, n);
  }
  async getTransactionResult(e) {
    const { result: n } = await ya({
      network: this.getNetwork(),
      result: this.#l({ method: "getTransactionResult", hash: e }),
    });
    return n == null ? null : Gt(n);
  }
  async getLogs(e) {
    let n = this._getFilter(e);
    wv(n) && (n = await n);
    const { network: r, params: i } = await ya({
      network: this.getNetwork(),
      params: this.#l({ method: "getLogs", filter: n }),
    });
    return i.map((s) => this._wrapLog(s, r));
  }
  _getProvider(e) {
    Ue(
      !1,
      "provider cannot connect to target network",
      "UNSUPPORTED_OPERATION",
      { operation: "_getProvider()" }
    );
  }
  async getResolver(e) {
    return await y0.fromName(this, e);
  }
  async getAvatar(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAvatar() : null;
  }
  async resolveName(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAddress() : null;
  }
  async lookupAddress(e) {
    e = yr(e);
    const n = XE(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await y0.getEnsAddress(this),
        s = await new kr(
          r,
          ["function resolver(bytes32) view returns (address)"],
          this
        ).resolver(n);
      if (s == null || s === dd) return null;
      const o = await new kr(
        s,
        ["function name(bytes32) view returns (string)"],
        this
      ).name(n);
      return (await this.resolveName(o)) !== e ? null : o;
    } catch (r) {
      if ((ra(r, "BAD_DATA") && r.value === "0x") || ra(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(e, n, r) {
    const i = n ?? 1;
    return i === 0
      ? this.getTransactionReceipt(e)
      : new Promise(async (s, a) => {
          let o = null;
          const l = async (u) => {
            try {
              const f = await this.getTransactionReceipt(e);
              if (f != null && u - f.blockNumber + 1 >= i) {
                s(f), o && (clearTimeout(o), (o = null));
                return;
              }
            } catch (f) {
              console.log("EEE", f);
            }
            this.once("block", l);
          };
          r != null &&
            (o = setTimeout(() => {
              o != null &&
                ((o = null),
                this.off("block", l),
                a(mi("timeout", "TIMEOUT", { reason: "timeout" })));
            }, r)),
            l(await this.getBlockNumber());
        });
  }
  async waitForBlock(e) {
    Ue(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock",
    });
  }
  _clearTimeout(e) {
    const n = this.#u.get(e);
    n && (n.timer && clearTimeout(n.timer), this.#u.delete(e));
  }
  _setTimeout(e, n) {
    n == null && (n = 0);
    const r = this.#c++,
      i = () => {
        this.#u.delete(r), e();
      };
    if (this.paused) this.#u.set(r, { timer: null, func: i, time: n });
    else {
      const s = setTimeout(i, n);
      this.#u.set(r, { timer: s, func: i, time: v8() });
    }
    return r;
  }
  _forEachSubscriber(e) {
    for (const n of this.#e.values()) e(n.subscriber);
  }
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new z5(e.type);
      case "block": {
        const n = new Ove(this);
        return (n.pollingInterval = this.pollingInterval), n;
      }
      case "safe":
      case "finalized":
        return new Pve(this, e.type);
      case "event":
        return new $T(this, e.filter);
      case "transaction":
        return new Dve(this, e.hash);
      case "orphan":
        return new Nve(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  _recoverSubscriber(e, n) {
    for (const r of this.#e.values())
      if (r.subscriber === e) {
        r.started && r.subscriber.stop(),
          (r.subscriber = n),
          r.started && n.start(),
          this.#n != null && n.pause(this.#n);
        break;
      }
  }
  async #g(e, n) {
    let r = await y8(e, this);
    return (
      r.type === "event" &&
        n &&
        n.length > 0 &&
        n[0].removed === !0 &&
        (r = await y8({ orphan: "drop-log", log: n[0] }, this)),
      this.#e.get(r.tag) || null
    );
  }
  async #y(e) {
    const n = await y8(e, this),
      r = n.tag;
    let i = this.#e.get(r);
    return (
      i ||
        ((i = {
          subscriber: this._getSubscriber(n),
          tag: r,
          addressableMap: new WeakMap(),
          nameMap: new Map(),
          started: !1,
          listeners: [],
        }),
        this.#e.set(r, i)),
      i
    );
  }
  async on(e, n) {
    const r = await this.#y(e);
    return (
      r.listeners.push({ listener: n, once: !1 }),
      r.started ||
        (r.subscriber.start(),
        (r.started = !0),
        this.#n != null && r.subscriber.pause(this.#n)),
      this
    );
  }
  async once(e, n) {
    const r = await this.#y(e);
    return (
      r.listeners.push({ listener: n, once: !0 }),
      r.started ||
        (r.subscriber.start(),
        (r.started = !0),
        this.#n != null && r.subscriber.pause(this.#n)),
      this
    );
  }
  async emit(e, ...n) {
    const r = await this.#g(e, n);
    if (!r || r.listeners.length === 0) return !1;
    const i = r.listeners.length;
    return (
      (r.listeners = r.listeners.filter(({ listener: s, once: a }) => {
        const o = new Rz(this, a ? null : s, e);
        try {
          s.call(this, ...n, o);
        } catch {}
        return !a;
      })),
      r.listeners.length === 0 &&
        (r.started && r.subscriber.stop(), this.#e.delete(r.tag)),
      i > 0
    );
  }
  async listenerCount(e) {
    if (e) {
      const r = await this.#g(e);
      return r ? r.listeners.length : 0;
    }
    let n = 0;
    for (const { listeners: r } of this.#e.values()) n += r.length;
    return n;
  }
  async listeners(e) {
    if (e) {
      const r = await this.#g(e);
      return r ? r.listeners.map(({ listener: i }) => i) : [];
    }
    let n = [];
    for (const { listeners: r } of this.#e.values())
      n = n.concat(r.map(({ listener: i }) => i));
    return n;
  }
  async off(e, n) {
    const r = await this.#g(e);
    if (!r) return this;
    if (n) {
      const i = r.listeners.map(({ listener: s }) => s).indexOf(n);
      i >= 0 && r.listeners.splice(i, 1);
    }
    return (
      (!n || r.listeners.length === 0) &&
        (r.started && r.subscriber.stop(), this.#e.delete(r.tag)),
      this
    );
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: n, started: r, subscriber: i } = await this.#y(e);
      r && i.stop(), this.#e.delete(n);
    } else
      for (const [n, { started: r, subscriber: i }] of this.#e)
        r && i.stop(), this.#e.delete(n);
    return this;
  }
  async addListener(e, n) {
    return await this.on(e, n);
  }
  async removeListener(e, n) {
    return this.off(e, n);
  }
  get destroyed() {
    return this.#r;
  }
  destroy() {
    this.removeAllListeners();
    for (const e of this.#u.keys()) this._clearTimeout(e);
    this.#r = !0;
  }
  get paused() {
    return this.#n != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  pause(e) {
    if (((this.#o = -1), this.#n != null)) {
      if (this.#n == !!e) return;
      Ue(
        !1,
        "cannot change pause type; resume first",
        "UNSUPPORTED_OPERATION",
        { operation: "pause" }
      );
    }
    this._forEachSubscriber((n) => n.pause(e)), (this.#n = !!e);
    for (const n of this.#u.values())
      n.timer && clearTimeout(n.timer), (n.time = v8() - n.time);
  }
  resume() {
    if (this.#n != null) {
      this._forEachSubscriber((e) => e.resume()), (this.#n = null);
      for (const e of this.#u.values()) {
        let n = e.time;
        n < 0 && (n = 0), (e.time = v8()), setTimeout(e.func, n);
      }
    }
  }
}
function $ve(t, e) {
  try {
    const n = ex(t, e);
    if (n) return I5(n);
  } catch {}
  return null;
}
function ex(t, e) {
  if (t === "0x") return null;
  try {
    const n = kn(vi(t, e, e + 32)),
      r = kn(vi(t, n, n + 32));
    return vi(t, n + 32, n + 32 + r);
  } catch {}
  return null;
}
function BN(t) {
  const e = _a(t);
  if (e.length > 32) throw new Error("internal; should not happen");
  const n = new Uint8Array(32);
  return n.set(e, 32 - e.length), n;
}
function Uve(t) {
  if (t.length % 32 === 0) return t;
  const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
  return e.set(t), e;
}
const jve = new Uint8Array([]);
function Hve(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++) e.push(jve), (n += 32);
  for (let r = 0; r < t.length; r++) {
    const i = er(t[r]);
    (e[r] = BN(n)),
      e.push(BN(i.length)),
      e.push(Uve(i)),
      (n += 32 + Math.ceil(i.length / 32) * 32);
  }
  return Di(e);
}
const FN = "0x0000000000000000000000000000000000000000000000000000000000000000";
function zve(t) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: [],
  };
  Ue(h0(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data",
  });
  const n = vi(t, 0, 32);
  Ue(
    vi(n, 0, 12) === vi(FN, 0, 12),
    "corrupt OffchainLookup sender",
    "OFFCHAIN_FAULT",
    { reason: "corrupt OffchainLookup sender" }
  ),
    (e.sender = vi(n, 12));
  try {
    const r = [],
      i = kn(vi(t, 32, 64)),
      s = kn(vi(t, i, i + 32)),
      a = vi(t, i + 32);
    for (let o = 0; o < s; o++) {
      const l = $ve(a, o * 32);
      if (l == null) throw new Error("abort");
      r.push(l);
    }
    e.urls = r;
  } catch {
    Ue(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls",
    });
  }
  try {
    const r = ex(t, 64);
    if (r == null) throw new Error("abort");
    e.calldata = r;
  } catch {
    Ue(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata",
    });
  }
  Ue(
    vi(t, 100, 128) === vi(FN, 0, 28),
    "corrupt OffchainLookup callbaackSelector",
    "OFFCHAIN_FAULT",
    { reason: "corrupt OffchainLookup callbaackSelector" }
  ),
    (e.selector = vi(t, 96, 100));
  try {
    const r = ex(t, 128);
    if (r == null) throw new Error("abort");
    e.extraData = r;
  } catch {
    Ue(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData",
    });
  }
  return (
    (e.errorArgs = "sender,urls,calldata,selector,extraData"
      .split(/,/)
      .map((r) => e[r])),
    e
  );
}
function mp(t, e) {
  if (t.provider) return t.provider;
  Ue(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function $N(t, e) {
  let n = j5(e);
  if ((n.to != null && (n.to = xa(n.to, t)), n.from != null)) {
    const r = n.from;
    n.from = Promise.all([t.getAddress(), xa(r, t)]).then(
      ([i, s]) => (
        ge(
          i.toLowerCase() === s.toLowerCase(),
          "transaction from mismatch",
          "tx.from",
          s
        ),
        i
      )
    );
  } else n.from = t.getAddress();
  return await ya(n);
}
class Vve {
  provider;
  constructor(e) {
    nn(this, { provider: e || null });
  }
  async getNonce(e) {
    return mp(this, "getTransactionCount").getTransactionCount(
      await this.getAddress(),
      e
    );
  }
  async populateCall(e) {
    return await $N(this, e);
  }
  async populateTransaction(e) {
    const n = mp(this, "populateTransaction"),
      r = await $N(this, e);
    r.nonce == null && (r.nonce = await this.getNonce("pending")),
      r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const i = await this.provider.getNetwork();
    if (r.chainId != null) {
      const a = Lt(r.chainId);
      ge(
        a === i.chainId,
        "transaction chainId mismatch",
        "tx.chainId",
        e.chainId
      );
    } else r.chainId = i.chainId;
    const s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (
      (r.gasPrice != null && (r.type === 2 || s)
        ? ge(!1, "eip-1559 transaction do not support gasPrice", "tx", e)
        : (r.type === 0 || r.type === 1) &&
          s &&
          ge(
            !1,
            "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
            "tx",
            e
          ),
      (r.type === 2 || r.type == null) &&
        r.maxFeePerGas != null &&
        r.maxPriorityFeePerGas != null)
    )
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const a = await n.getFeeData();
      Ue(
        a.gasPrice != null,
        "network does not support gasPrice",
        "UNSUPPORTED_OPERATION",
        { operation: "getGasPrice" }
      ),
        r.gasPrice == null && (r.gasPrice = a.gasPrice);
    } else {
      const a = await n.getFeeData();
      if (r.type == null)
        if (a.maxFeePerGas != null && a.maxPriorityFeePerGas != null)
          if (((r.type = 2), r.gasPrice != null)) {
            const o = r.gasPrice;
            delete r.gasPrice,
              (r.maxFeePerGas = o),
              (r.maxPriorityFeePerGas = o);
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas),
              r.maxPriorityFeePerGas == null &&
                (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas);
        else
          a.gasPrice != null
            ? (Ue(
                !s,
                "network does not support EIP-1559",
                "UNSUPPORTED_OPERATION",
                { operation: "populateTransaction" }
              ),
              r.gasPrice == null && (r.gasPrice = a.gasPrice),
              (r.type = 0))
            : Ue(
                !1,
                "failed to get consistent fee data",
                "UNSUPPORTED_OPERATION",
                { operation: "signer.getFeeData" }
              );
      else
        r.type === 2 &&
          (r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas),
          r.maxPriorityFeePerGas == null &&
            (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas));
    }
    return await ya(r);
  }
  async estimateGas(e) {
    return mp(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return mp(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await mp(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const n = mp(this, "sendTransaction"),
      r = await this.populateTransaction(e);
    delete r.from;
    const i = WV.from(r);
    return await n.broadcastTransaction(await this.signTransaction(i));
  }
}
function Gve(t) {
  return JSON.parse(JSON.stringify(t));
}
class vG {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  constructor(e) {
    (this.#e = e),
      (this.#t = null),
      (this.#n = this.#s.bind(this)),
      (this.#r = !1),
      (this.#i = null),
      (this.#a = !1);
  }
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  _emitResults(e, n) {
    throw new Error("subclasses must override this");
  }
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  async #s(e) {
    try {
      this.#t == null && (this.#t = this._subscribe(this.#e));
      let n = null;
      try {
        n = await this.#t;
      } catch (s) {
        if (!ra(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter")
          throw s;
      }
      if (n == null) {
        (this.#t = null),
          this.#e._recoverSubscriber(this, this._recover(this.#e));
        return;
      }
      const r = await this.#e.getNetwork();
      if ((this.#i || (this.#i = r), this.#i.chainId !== r.chainId))
        throw new Error("chaid changed");
      if (this.#a) return;
      const i = await this.#e.send("eth_getFilterChanges", [n]);
      await this._emitResults(this.#e, i);
    } catch (n) {
      console.log("@TODO", n);
    }
    this.#e.once("block", this.#n);
  }
  #o() {
    const e = this.#t;
    e &&
      ((this.#t = null),
      e.then((n) => {
        this.#e.send("eth_uninstallFilter", [n]);
      }));
  }
  start() {
    this.#r || ((this.#r = !0), this.#s(-2));
  }
  stop() {
    this.#r &&
      ((this.#r = !1),
      (this.#a = !0),
      this.#o(),
      this.#e.off("block", this.#n));
  }
  pause(e) {
    e && this.#o(), this.#e.off("block", this.#n);
  }
  resume() {
    this.start();
  }
}
class Wve extends vG {
  #e;
  constructor(e, n) {
    super(e), (this.#e = Gve(n));
  }
  _recover(e) {
    return new $T(e, this.#e);
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [this.#e]);
  }
  async _emitResults(e, n) {
    for (const r of n) e.emit(this.#e, e._wrapLog(r, e._network));
  }
}
class qve extends vG {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, n) {
    for (const r of n) e.emit("pending", r);
  }
}
const Kve = "bigint,boolean,function,number,string,symbol".split(/,/g);
function fb(t) {
  if (
    t == null ||
    Kve.indexOf(typeof t) >= 0 ||
    typeof t.getAddress == "function"
  )
    return t;
  if (Array.isArray(t)) return t.map(fb);
  if (typeof t == "object")
    return Object.keys(t).reduce((e, n) => ((e[n] = t[n]), e), {});
  throw new Error(`should not happen: ${t} (${typeof t})`);
}
function Xve(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function gp(t) {
  return t && t.toLowerCase();
}
function UN(t) {
  return t && typeof t.pollingInterval == "number";
}
const Zve = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3,
};
class b8 extends Vve {
  address;
  constructor(e, n) {
    super(e), (n = yr(n)), nn(this, { address: n });
  }
  connect(e) {
    Ue(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect",
    });
  }
  async getAddress() {
    return this.address;
  }
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  async sendUncheckedTransaction(e) {
    const n = fb(e),
      r = [];
    if (n.from) {
      const s = n.from;
      r.push(
        (async () => {
          const a = await xa(s, this.provider);
          ge(
            a != null && a.toLowerCase() === this.address.toLowerCase(),
            "from address mismatch",
            "transaction",
            e
          ),
            (n.from = a);
        })()
      );
    } else n.from = this.address;
    if (
      (n.gasLimit == null &&
        r.push(
          (async () => {
            n.gasLimit = await this.provider.estimateGas({
              ...n,
              from: this.address,
            });
          })()
        ),
      n.to != null)
    ) {
      const s = n.to;
      r.push(
        (async () => {
          n.to = await xa(s, this.provider);
        })()
      );
    }
    r.length && (await Promise.all(r));
    const i = this.provider.getRpcTransaction(n);
    return this.provider.send("eth_sendTransaction", [i]);
  }
  async sendTransaction(e) {
    const n = await this.provider.getBlockNumber(),
      r = await this.sendUncheckedTransaction(e);
    return await new Promise((i, s) => {
      const a = [1e3, 100];
      let o = 0;
      const l = async () => {
        try {
          const u = await this.provider.getTransaction(r);
          if (u != null) {
            i(u.replaceableTransaction(n));
            return;
          }
        } catch (u) {
          if (
            ra(u, "CANCELLED") ||
            ra(u, "BAD_DATA") ||
            ra(u, "NETWORK_ERROR")
          ) {
            u.info == null && (u.info = {}),
              (u.info.sendTransactionHash = r),
              s(u);
            return;
          }
          if (
            ra(u, "INVALID_ARGUMENT") &&
            (o++,
            u.info == null && (u.info = {}),
            (u.info.sendTransactionHash = r),
            o > 10)
          ) {
            s(u);
            return;
          }
          this.provider.emit(
            "error",
            mi(
              "failed to fetch transation after sending (will try again)",
              "UNKNOWN_ERROR",
              { error: u }
            )
          );
        }
        this.provider._setTimeout(() => {
          l();
        }, a.pop() || 4e3);
      };
      l();
    });
  }
  async signTransaction(e) {
    const n = fb(e);
    if (n.from) {
      const i = await xa(n.from, this.provider);
      ge(
        i != null && i.toLowerCase() === this.address.toLowerCase(),
        "from address mismatch",
        "transaction",
        e
      ),
        (n.from = i);
    } else n.from = this.address;
    const r = this.provider.getRpcTransaction(n);
    return await this.provider.send("eth_signTransaction", [r]);
  }
  async signMessage(e) {
    const n = typeof e == "string" ? Hc(e) : e;
    return await this.provider.send("personal_sign", [
      Gt(n),
      this.address.toLowerCase(),
    ]);
  }
  async signTypedData(e, n, r) {
    const i = fb(r),
      s = await xo.resolveNames(e, n, i, async (a) => {
        const o = await xa(a);
        return (
          ge(o != null, "TypedData does not support null address", "value", a),
          o
        );
      });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(xo.getPayload(s.domain, n, s.value)),
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null,
    ]);
  }
  async _legacySignMessage(e) {
    const n = typeof e == "string" ? Hc(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      Gt(n),
    ]);
  }
}
class bG extends Fve {
  #e;
  #t;
  #n;
  #r;
  #i;
  #a;
  #s;
  #o() {
    if (this.#r) return;
    const e =
      this._getOption("batchMaxCount") === 1
        ? 0
        : this._getOption("batchStallTime");
    this.#r = setTimeout(() => {
      this.#r = null;
      const n = this.#n;
      for (this.#n = []; n.length; ) {
        const r = [n.shift()];
        for (; n.length && r.length !== this.#e.batchMaxCount; )
          if (
            (r.push(n.shift()),
            JSON.stringify(r.map((s) => s.payload)).length >
              this.#e.batchMaxSize)
          ) {
            n.unshift(r.pop());
            break;
          }
        (async () => {
          const i = r.length === 1 ? r[0].payload : r.map((s) => s.payload);
          this.emit("debug", { action: "sendRpcPayload", payload: i });
          try {
            const s = await this._send(i);
            this.emit("debug", { action: "receiveRpcResult", result: s });
            for (const { resolve: a, reject: o, payload: l } of r) {
              if (this.destroyed) {
                o(
                  mi(
                    "provider destroyed; cancelled request",
                    "UNSUPPORTED_OPERATION",
                    { operation: l.method }
                  )
                );
                continue;
              }
              const u = s.filter((f) => f.id === l.id)[0];
              if (u == null) {
                const f = mi("missing response for request", "BAD_DATA", {
                  value: s,
                  info: { payload: l },
                });
                this.emit("error", f), o(f);
                continue;
              }
              if ("error" in u) {
                o(this.getRpcError(l, u));
                continue;
              }
              a(u.result);
            }
          } catch (s) {
            this.emit("debug", { action: "receiveRpcError", error: s });
            for (const { reject: a } of r) a(s);
          }
        })();
      }
    }, e);
  }
  constructor(e, n) {
    super(e, n),
      (this.#t = 1),
      (this.#e = Object.assign({}, Zve, n || {})),
      (this.#n = []),
      (this.#r = null),
      (this.#a = null),
      (this.#s = null);
    {
      let i = null;
      const s = new Promise((a) => {
        i = a;
      });
      this.#i = { promise: s, resolve: i };
    }
    const r = this._getOption("staticNetwork");
    typeof r == "boolean"
      ? (ge(
          !r || e !== "any",
          "staticNetwork cannot be used on special network 'any'",
          "options",
          n
        ),
        r && e != null && (this.#a = Po.from(e)))
      : r &&
        (ge(
          e == null || r.matches(e),
          "staticNetwork MUST match network object",
          "options",
          n
        ),
        (this.#a = r));
  }
  _getOption(e) {
    return this.#e[e];
  }
  get _network() {
    return (
      Ue(this.#a, "network is not available yet", "NETWORK_ERROR"), this.#a
    );
  }
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let r = e.transaction;
      if (
        r &&
        r.type != null &&
        Lt(r.type) &&
        r.maxFeePerGas == null &&
        r.maxPriorityFeePerGas == null
      ) {
        const i = await this.getFeeData();
        i.maxFeePerGas == null &&
          i.maxPriorityFeePerGas == null &&
          (e = Object.assign({}, e, {
            transaction: Object.assign({}, r, { type: void 0 }),
          }));
      }
    }
    const n = this.getRpcRequest(e);
    return n != null ? await this.send(n.method, n.args) : super._perform(e);
  }
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      if (e === !0) {
        if (this.#a) return this.#a;
      } else return e;
    return this.#s
      ? await this.#s
      : this.ready
      ? ((this.#s = (async () => {
          try {
            const n = Po.from(Lt(await this.send("eth_chainId", [])));
            return (this.#s = null), n;
          } catch (n) {
            throw ((this.#s = null), n);
          }
        })()),
        await this.#s)
      : ((this.#s = (async () => {
          const n = {
            id: this.#t++,
            method: "eth_chainId",
            params: [],
            jsonrpc: "2.0",
          };
          this.emit("debug", { action: "sendRpcPayload", payload: n });
          let r;
          try {
            (r = (await this._send(n))[0]), (this.#s = null);
          } catch (i) {
            throw (
              ((this.#s = null),
              this.emit("debug", { action: "receiveRpcError", error: i }),
              i)
            );
          }
          if (
            (this.emit("debug", { action: "receiveRpcResult", result: r }),
            "result" in r)
          )
            return Po.from(Lt(r.result));
          throw this.getRpcError(n, r);
        })()),
        await this.#s);
  }
  _start() {
    this.#i == null ||
      this.#i.resolve == null ||
      (this.#i.resolve(),
      (this.#i = null),
      (async () => {
        for (; this.#a == null && !this.destroyed; )
          try {
            this.#a = await this._detectNetwork();
          } catch (e) {
            if (this.destroyed) break;
            console.log(
              "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
            ),
              this.emit(
                "error",
                mi("failed to bootstrap network detection", "NETWORK_ERROR", {
                  event: "initial-network-discovery",
                  info: { error: e },
                })
              ),
              await Xve(1e3);
          }
        this.#o();
      })());
  }
  async _waitUntilReady() {
    if (this.#i != null) return await this.#i.promise;
  }
  _getSubscriber(e) {
    return e.type === "pending"
      ? new qve(this)
      : e.type === "event"
      ? this._getOption("polling")
        ? new $T(this, e.filter)
        : new Wve(this, e.filter)
      : e.type === "orphan" && e.filter.orphan === "drop-log"
      ? new z5("orphan")
      : super._getSubscriber(e);
  }
  get ready() {
    return this.#i == null;
  }
  getRpcTransaction(e) {
    const n = {};
    return (
      [
        "chainId",
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value",
      ].forEach((r) => {
        if (e[r] == null) return;
        let i = r;
        r === "gasLimit" && (i = "gas"), (n[i] = Qd(Lt(e[r], `tx.${r}`)));
      }),
      ["from", "to", "data"].forEach((r) => {
        e[r] != null && (n[r] = Gt(e[r]));
      }),
      e.accessList && (n.accessList = Fh(e.accessList)),
      n
    );
  }
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return { method: "eth_getBalance", args: [gp(e.address), e.blockTag] };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [gp(e.address), e.blockTag],
        };
      case "getCode":
        return { method: "eth_getCode", args: [gp(e.address), e.blockTag] };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [gp(e.address), "0x" + e.position.toString(16), e.blockTag],
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction],
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions],
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions],
          };
        break;
      case "getTransaction":
        return { method: "eth_getTransactionByHash", args: [e.hash] };
      case "getTransactionReceipt":
        return { method: "eth_getTransactionReceipt", args: [e.hash] };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag],
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)],
        };
      case "getLogs":
        return (
          e.filter &&
            e.filter.address != null &&
            (Array.isArray(e.filter.address)
              ? (e.filter.address = e.filter.address.map(gp))
              : (e.filter.address = gp(e.filter.address))),
          { method: "eth_getLogs", args: [e.filter] }
        );
    }
    return null;
  }
  getRpcError(e, n) {
    const { method: r } = e,
      { error: i } = n;
    if (r === "eth_estimateGas" && i.message) {
      const o = i.message;
      if (!o.match(/revert/i) && o.match(/insufficient funds/i))
        return mi("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: i },
        });
    }
    if (r === "eth_call" || r === "eth_estimateGas") {
      const o = tx(i),
        l = Ah.getBuiltinCallException(
          r === "eth_call" ? "call" : "estimateGas",
          e.params[0],
          o ? o.data : null
        );
      return (l.info = { error: i, payload: e }), l;
    }
    const s = JSON.stringify(Qve(i));
    if (
      typeof i.message == "string" &&
      i.message.match(/user denied|ethers-user-denied/i)
    )
      return mi("user rejected action", "ACTION_REJECTED", {
        action:
          {
            eth_sign: "signMessage",
            personal_sign: "signMessage",
            eth_signTypedData_v4: "signTypedData",
            eth_signTransaction: "signTransaction",
            eth_sendTransaction: "sendTransaction",
            eth_requestAccounts: "requestAccess",
            wallet_requestAccounts: "requestAccess",
          }[r] || "unknown",
        reason: "rejected",
        info: { payload: e, error: i },
      });
    if (r === "eth_sendRawTransaction" || r === "eth_sendTransaction") {
      const o = e.params[0];
      if (s.match(/insufficient funds|base fee exceeds gas limit/i))
        return mi(
          "insufficient funds for intrinsic transaction cost",
          "INSUFFICIENT_FUNDS",
          { transaction: o, info: { error: i } }
        );
      if (s.match(/nonce/i) && s.match(/too low/i))
        return mi("nonce has already been used", "NONCE_EXPIRED", {
          transaction: o,
          info: { error: i },
        });
      if (s.match(/replacement transaction/i) && s.match(/underpriced/i))
        return mi("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
          transaction: o,
          info: { error: i },
        });
      if (s.match(/only replay-protected/i))
        return mi(
          "legacy pre-eip-155 transactions not supported",
          "UNSUPPORTED_OPERATION",
          { operation: r, info: { transaction: o, info: { error: i } } }
        );
    }
    let a = !!s.match(/the method .* does not exist/i);
    return (
      a ||
        (i &&
          i.details &&
          i.details.startsWith("Unauthorized method:") &&
          (a = !0)),
      a
        ? mi("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: { error: i, payload: e },
          })
        : mi("could not coalesce error", "UNKNOWN_ERROR", {
            error: i,
            payload: e,
          })
    );
  }
  send(e, n) {
    if (this.destroyed)
      return Promise.reject(
        mi("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
          operation: e,
        })
      );
    const r = this.#t++,
      i = new Promise((s, a) => {
        this.#n.push({
          resolve: s,
          reject: a,
          payload: { method: e, params: n, id: r, jsonrpc: "2.0" },
        });
      });
    return this.#o(), i;
  }
  async getSigner(e) {
    e == null && (e = 0);
    const n = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const i = await n;
      if (e >= i.length) throw new Error("no such account");
      return new b8(this, i[e]);
    }
    const { accounts: r } = await ya({
      network: this.getNetwork(),
      accounts: n,
    });
    e = yr(e);
    for (const i of r) if (yr(i) === e) return new b8(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((n) => new b8(this, n));
  }
  destroy() {
    this.#r && (clearTimeout(this.#r), (this.#r = null));
    for (const { payload: e, reject: n } of this.#n)
      n(
        mi("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
          operation: e.method,
        })
      );
    (this.#n = []), super.destroy();
  }
}
class wG extends bG {
  #e;
  constructor(e, n) {
    super(e, n), (this.#e = 4e3);
  }
  _getSubscriber(e) {
    const n = super._getSubscriber(e);
    return UN(n) && (n.pollingInterval = this.#e), n;
  }
  get pollingInterval() {
    return this.#e;
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0) throw new Error("invalid interval");
    (this.#e = e),
      this._forEachSubscriber((n) => {
        UN(n) && (n.pollingInterval = this.#e);
      });
  }
}
let Yve = class extends wG {
  #e;
  constructor(e, n, r) {
    e == null && (e = "http://localhost:8545"),
      super(n, r),
      typeof e == "string" ? (this.#e = new ec(e)) : (this.#e = e.clone());
  }
  _getConnection() {
    return this.#e.clone();
  }
  async send(e, n) {
    return await this._start(), await super.send(e, n);
  }
  async _send(e) {
    const n = this._getConnection();
    (n.body = JSON.stringify(e)),
      n.setHeader("content-type", "application/json");
    const r = await n.send();
    r.assertOk();
    let i = r.bodyJson;
    return Array.isArray(i) || (i = [i]), i;
  }
};
function tx(t) {
  if (t == null) return null;
  if (typeof t.message == "string" && t.message.match(/revert/i) && Mr(t.data))
    return { message: t.message, data: t.data };
  if (typeof t == "object") {
    for (const e in t) {
      const n = tx(t[e]);
      if (n) return n;
    }
    return null;
  }
  if (typeof t == "string")
    try {
      return tx(JSON.parse(t));
    } catch {}
  return null;
}
function nx(t, e) {
  if (t != null) {
    if (
      (typeof t.message == "string" && e.push(t.message), typeof t == "object")
    )
      for (const n in t) nx(t[n], e);
    if (typeof t == "string")
      try {
        return nx(JSON.parse(t), e);
      } catch {}
  }
}
function Qve(t) {
  const e = [];
  return nx(t, e), e;
}
function Jve() {
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw new Error("unable to locate global object");
}
const ebe = Jve().WebSocket;
class UT {
  #e;
  #t;
  get filter() {
    return JSON.parse(this.#t);
  }
  #n;
  #r;
  #i;
  constructor(e, n) {
    (this.#e = e),
      (this.#t = JSON.stringify(n)),
      (this.#n = null),
      (this.#r = null),
      (this.#i = null);
  }
  start() {
    this.#n = this.#e
      .send("eth_subscribe", this.filter)
      .then((e) => (this.#e._register(e, this), e));
  }
  stop() {
    this.#n.then((e) => {
      this.#e.send("eth_unsubscribe", [e]);
    }),
      (this.#n = null);
  }
  pause(e) {
    Ue(
      e,
      "preserve logs while paused not supported by SocketSubscriber yet",
      "UNSUPPORTED_OPERATION",
      { operation: "pause(false)" }
    ),
      (this.#r = !!e);
  }
  resume() {
    this.#r = null;
  }
  _handleMessage(e) {
    if (this.#n != null && this.#r === null) {
      let n = this.#i;
      n == null
        ? (n = this._emit(this.#e, e))
        : (n = n.then(async () => {
            await this._emit(this.#e, e);
          })),
        (this.#i = n.then(() => {
          this.#i === n && (this.#i = null);
        }));
    }
  }
  async _emit(e, n) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}
class tbe extends UT {
  constructor(e) {
    super(e, ["newHeads"]);
  }
  async _emit(e, n) {
    e.emit("block", parseInt(n.number));
  }
}
class nbe extends UT {
  constructor(e) {
    super(e, ["newPendingTransactions"]);
  }
  async _emit(e, n) {
    e.emit("pending", n);
  }
}
class rbe extends UT {
  #e;
  get logFilter() {
    return JSON.parse(this.#e);
  }
  constructor(e, n) {
    super(e, ["logs", n]), (this.#e = JSON.stringify(n));
  }
  async _emit(e, n) {
    e.emit(this.logFilter, e._wrapLog(n, e._network));
  }
}
class ibe extends bG {
  #e;
  #t;
  #n;
  constructor(e, n) {
    const r = Object.assign({}, n ?? {});
    ge(
      r.batchMaxCount == null || r.batchMaxCount === 1,
      "sockets-based providers do not support batches",
      "options.batchMaxCount",
      n
    ),
      (r.batchMaxCount = 1),
      r.staticNetwork == null && (r.staticNetwork = !0),
      super(e, r),
      (this.#e = new Map()),
      (this.#t = new Map()),
      (this.#n = new Map());
  }
  _getSubscriber(e) {
    switch (e.type) {
      case "close":
        return new z5("close");
      case "block":
        return new tbe(this);
      case "pending":
        return new nbe(this);
      case "event":
        return new rbe(this, e.filter);
      case "orphan":
        if (e.filter.orphan === "drop-log") return new z5("drop-log");
    }
    return super._getSubscriber(e);
  }
  _register(e, n) {
    this.#t.set(e, n);
    const r = this.#n.get(e);
    if (r) {
      for (const i of r) n._handleMessage(i);
      this.#n.delete(e);
    }
  }
  async _send(e) {
    ge(
      !Array.isArray(e),
      "WebSocket does not support batch send",
      "payload",
      e
    );
    const n = new Promise((r, i) => {
      this.#e.set(e.id, { payload: e, resolve: r, reject: i });
    });
    return (
      await this._waitUntilReady(),
      await this._write(JSON.stringify(e)),
      [await n]
    );
  }
  async _processMessage(e) {
    const n = JSON.parse(e);
    if (n && typeof n == "object" && "id" in n) {
      const r = this.#e.get(n.id);
      if (r == null) {
        this.emit(
          "error",
          mi("received result for unknown id", "UNKNOWN_ERROR", {
            reasonCode: "UNKNOWN_ID",
            result: n,
          })
        );
        return;
      }
      this.#e.delete(n.id), r.resolve(n);
    } else if (n && n.method === "eth_subscription") {
      const r = n.params.subscription,
        i = this.#t.get(r);
      if (i) i._handleMessage(n.params.result);
      else {
        let s = this.#n.get(r);
        s == null && ((s = []), this.#n.set(r, s)), s.push(n.params.result);
      }
    } else {
      this.emit(
        "error",
        mi("received unexpected message", "UNKNOWN_ERROR", {
          reasonCode: "UNEXPECTED_MESSAGE",
          result: n,
        })
      );
      return;
    }
  }
  async _write(e) {
    throw new Error("sub-classes must override this");
  }
}
class sbe extends ibe {
  #e;
  #t;
  get websocket() {
    if (this.#t == null) throw new Error("websocket closed");
    return this.#t;
  }
  constructor(e, n, r) {
    super(n, r),
      typeof e == "string"
        ? ((this.#e = () => new ebe(e)), (this.#t = this.#e()))
        : typeof e == "function"
        ? ((this.#e = e), (this.#t = e()))
        : ((this.#e = null), (this.#t = e)),
      (this.websocket.onopen = async () => {
        try {
          await this._start(), this.resume();
        } catch (i) {
          console.log("failed to start WebsocketProvider", i);
        }
      }),
      (this.websocket.onmessage = (i) => {
        this._processMessage(i.data);
      });
  }
  async _write(e) {
    this.websocket.send(e);
  }
  async destroy() {
    this.#t != null && (this.#t.close(), (this.#t = null)), super.destroy();
  }
}
class abe extends wG {
  #e;
  constructor(e, n) {
    ge(e && e.request, "invalid EIP-1193 provider", "ethereum", e),
      super(n, { batchMaxCount: 1 }),
      (this.#e = async (r, i) => {
        const s = { method: r, params: i };
        this.emit("debug", { action: "sendEip1193Request", payload: s });
        try {
          const a = await e.request(s);
          return (
            this.emit("debug", { action: "receiveEip1193Result", result: a }), a
          );
        } catch (a) {
          const o = new Error(a.message);
          throw (
            ((o.code = a.code),
            (o.data = a.data),
            (o.payload = s),
            this.emit("debug", { action: "receiveEip1193Error", error: o }),
            o)
          );
        }
      });
  }
  async send(e, n) {
    return await this._start(), await super.send(e, n);
  }
  async _send(e) {
    ge(
      !Array.isArray(e),
      "EIP-1193 does not support batch request",
      "payload",
      e
    );
    try {
      const n = await this.#e(e.method, e.params || []);
      return [{ id: e.id, result: n }];
    } catch (n) {
      return [
        { id: e.id, error: { code: n.code, data: n.data, message: n.message } },
      ];
    }
  }
  getRpcError(e, n) {
    switch (((n = JSON.parse(JSON.stringify(n))), n.error.code || -1)) {
      case 4001:
        n.error.message = `ethers-user-denied: ${n.error.message}`;
        break;
      case 4200:
        n.error.message = `ethers-unsupported: ${n.error.message}`;
        break;
    }
    return super.getRpcError(e, n);
  }
  async hasSigner(e) {
    e == null && (e = 0);
    const n = await this.send("eth_accounts", []);
    return typeof e == "number"
      ? n.length > e
      : ((e = e.toLowerCase()),
        n.filter((r) => r.toLowerCase() === e).length !== 0);
  }
  async getSigner(e) {
    if ((e == null && (e = 0), !(await this.hasSigner(e))))
      try {
        await this.#e("eth_requestAccounts", []);
      } catch (n) {
        const r = n.payload;
        throw this.getRpcError(r, { id: r.id, error: n });
      }
    return await super.getSigner(e);
  }
}
class zm {
  abis = [];
  calls = [];
  defaultFunc = void 0;
  defaultAddress = void 0;
  constructor() {
    (this.abis = []), (this.calls = []);
  }
  addCall(e, n = [], r = void 0, i = void 0, s = 0, a = void 0) {
    r === void 0 && (r = [e]),
      !a && this.defaultFunc && (a = this.defaultFunc),
      !i && this.defaultAddress && (i = this.defaultAddress),
      this.calls.push({
        method: e,
        address: i,
        path: r,
        params: n,
        abiIndex: s,
        processValueFunc: a,
      });
  }
  addDefaultProcessValueFunc(e) {
    (this.defaultFunc = e),
      this.calls.map((n) => {
        n.processValueFunc || (n.processValueFunc = e);
      });
  }
  replaceProcessValueFunc(e) {
    this.calls.map((n) => {
      n.processValueFunc = e;
    });
  }
  addDefaultAddress(e) {
    (this.defaultAddress = e),
      this.calls.map((n) => {
        n.address || (n.address = e);
      });
  }
  cleanCalls() {
    this.calls = [];
  }
}
const obe = "hh-sol-artifact-1",
  lbe = "Multicall2",
  ube = "contracts/MultiCall2.sol",
  cbe = [
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "target", type: "address" },
            { internalType: "bytes", name: "callData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Call[]",
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "aggregate",
      outputs: [
        { internalType: "uint256", name: "blockNumber", type: "uint256" },
        { internalType: "bytes[]", name: "returnData", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "target", type: "address" },
            { internalType: "bytes", name: "callData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Call[]",
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "blockAndAggregate",
      outputs: [
        { internalType: "uint256", name: "blockNumber", type: "uint256" },
        { internalType: "bytes32", name: "blockHash", type: "bytes32" },
        {
          components: [
            { internalType: "bool", name: "success", type: "bool" },
            { internalType: "bytes", name: "returnData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Result[]",
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "blockNumber", type: "uint256" },
      ],
      name: "getBlockHash",
      outputs: [
        { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getBlockNumber",
      outputs: [
        { internalType: "uint256", name: "blockNumber", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getCurrentBlockCoinbase",
      outputs: [{ internalType: "address", name: "coinbase", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getCurrentBlockDifficulty",
      outputs: [
        { internalType: "uint256", name: "difficulty", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getCurrentBlockGasLimit",
      outputs: [{ internalType: "uint256", name: "gaslimit", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getCurrentBlockTimestamp",
      outputs: [
        { internalType: "uint256", name: "timestamp", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "addr", type: "address" }],
      name: "getEthBalance",
      outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getLastBlockHash",
      outputs: [
        { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bool", name: "requireSuccess", type: "bool" },
        {
          components: [
            { internalType: "address", name: "target", type: "address" },
            { internalType: "bytes", name: "callData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Call[]",
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "tryAggregate",
      outputs: [
        {
          components: [
            { internalType: "bool", name: "success", type: "bool" },
            { internalType: "bytes", name: "returnData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Result[]",
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bool", name: "requireSuccess", type: "bool" },
        {
          components: [
            { internalType: "address", name: "target", type: "address" },
            { internalType: "bytes", name: "callData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Call[]",
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "tryBlockAndAggregate",
      outputs: [
        { internalType: "uint256", name: "blockNumber", type: "uint256" },
        { internalType: "bytes32", name: "blockHash", type: "bytes32" },
        {
          components: [
            { internalType: "bool", name: "success", type: "bool" },
            { internalType: "bytes", name: "returnData", type: "bytes" },
          ],
          internalType: "struct Multicall2.Result[]",
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  fbe = {},
  dbe = {},
  hbe = {
    _format: obe,
    contractName: lbe,
    sourceName: ube,
    abi: cbe,
    linkReferences: fbe,
    deployedLinkReferences: dbe,
  };
class Td {
  abiCoder = new Ah();
  static NullAddress = dd;
  getCurrentNetworkInfo(e = void 0) {
    const n = {
      name: "mainnet",
      id: parseInt("1"),
      rpc: "https://rpc.ankr.com/eth",
      explorer: "https://etherscan.io/",
      multiCallAddress: "0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696",
    };
    return e ? n[e] || void 0 : n;
  }
  async excuteChainView(e, n, r) {
    let i;
    try {
      await e.estimateGas(n);
    } catch (a) {
      i = a.data;
    }
    const s = r.parseError(i);
    if (s?.args?.length === 1 && s?.args?.at(0)) {
      const a = s.args[0];
      if (a) return rx(a);
    }
    if (s?.args?.length > 1) return s?.args.map((a) => rx(a));
  }
  async getStaticProvider() {
    const e = this.getCurrentNetworkInfo();
    if (e.rpc) {
      let n;
      return (
        e.rpc.startsWith("http") &&
          (n = new Yve(e.rpc, { chainId: e.id, name: e.name })),
        e.rpc.startsWith("ws") &&
          (n = new sbe(e.rpc, { chainId: e.id, name: e.name })),
        n
      );
    }
  }
}
const pbe = new Td(),
  Vm = (t) => (e, n) => {
    let r = t;
    e.path.forEach((i, s) => {
      const a = i?.toString().endsWith("[]");
      s !== e.path.length - 1
        ? ((r[i] = r[i] || {}), (r = r[i]))
        : a
        ? ((i = i.replace("[]", "")), (r[i] = r[i] || []), r[i].push(n[0]))
        : n.length === 1
        ? (r[i] = n[0])
        : (r[i] = n);
    });
  },
  RDe = (t) =>
    t && t.usd > 0 ? { eth: al(t.eth, !0, 6), usd: al(t.usd) } : void 0,
  Gm = async (t, e, n = !1) => {
    const r = pbe.getCurrentNetworkInfo("multiCallAddress"),
      i = new kr(r, hbe.abi, e),
      s = t.abis.map((l) => new eu(l)),
      a = t.calls.map((l) => {
        const u = l.abiIndex ? s[l.abiIndex] : s[0];
        return {
          target: l.address.toLowerCase(),
          callData: u.encodeFunctionData(l.method, l.params || []),
        };
      });
    n && console.info(`multiCallWithBag callData ${n} `, a);
    const o = await i.tryAggregate(!1, a);
    return (
      n && console.info(`multiCallWithBag returnData ${n} `, o),
      o.map((l, u) => {
        const f = t.calls[u].abiIndex ? s[t.calls[u].abiIndex] : s[0];
        if (l[0] === !0) {
          const c = f.decodeFunctionResult(t.calls[u].method, l[1]);
          n &&
            console.info(
              `multiCallWithBag parsedResult ${n} `,
              t.calls[u].method,
              c
            ),
            typeof t.calls[u].processValueFunc == "function" &&
              t.calls[u].processValueFunc(t.calls[u], c);
        }
      })
    );
  },
  MDe = (t, e = 18n) => {
    if (!t) return 0n;
    const n = Number(t);
    return isNaN(n)
      ? 0n
      : zz(
          n.toLocaleString("fullwide", { useGrouping: !1 }).replace(",", "."),
          e
        ) || 0n;
  },
  LDe = (t, e = 0) =>
    typeof t == "bigint" ? parseInt(Eh(t.toString(), e)) : NaN,
  v0 = (t, e = 0) =>
    typeof t == "bigint" ? parseFloat(Eh(t.toString(), e)) : NaN;
async function BDe(t, e) {
  const n = new Promise((i) => setTimeout(i, e)),
    r = t();
  return await Promise.all([n, r]), r;
}
const mbe = (t, e, n = !1) => {
    if (typeof t == "bigint") {
      const r = Eh(t.toString(), e),
        i = parseFloat(r);
      t = al(i, n);
    }
    return t || "-";
  },
  _G = (t) => t?.toString()?.padStart(4, "0");
function FDe(t, e = 2) {
  const n = new Intl.NumberFormat("en-US", { maximumFractionDigits: e });
  return isNaN(t) ? 0 : n.format(t);
}
function al(t, e = !1, n) {
  if ((typeof t == "string" && (t = parseFloat(t)), t < 0))
    return t.toFixed(n === void 0 ? 4 : n);
  if (t === 0) return e ? "0" : "-";
  if (((n = isNaN(n) ? (t <= 1 ? 4 : 2) : parseInt(n)), t < 1))
    return t > 0.001 || n > 4
      ? t.toFixed(n)
      : n !== void 0
      ? "≈0"
      : t?.toExponential(2);
  if (t < 100) return t.toFixed(n);
  t = parseInt(t);
  const r = [
      { value: 1, symbol: "" },
      { value: 1e6, symbol: "M" },
      { value: 1e9, symbol: "B" },
    ],
    i = /\.0+$|(\.[0-9]*[1-9])0+$/,
    s = r
      .slice()
      .reverse()
      .find(function (o) {
        return t >= o.value;
      }),
    a = new Intl.NumberFormat("en-US");
  return s ? a.format(t / s.value).replace(i, "$1") + s.symbol : "-";
}
function $De(t) {
  return t
    ? Number(t) > 1e3
      ? Math.trunc(t).toLocaleString("en-US")
      : Number(t.toFixed(2))
    : "-";
}
const jN = (t) => {
  const e = Math.trunc(t / 86400);
  if (e >= 1) {
    const n = Math.trunc((t / 3600 + 24) % 24);
    return `${e} days, ${n} hours`;
  } else {
    const n = Math.trunc(t / 60),
      r = Math.trunc(n / 60),
      i = n % 60;
    return `${r} hrs, ${i} mins`;
  }
};
function gbe(t, e, n) {
  if (!e || !n) return { durationNextCvg: "-", durationNextTde: "-" };
  const r = parseInt(12 * (1 + parseInt(t / 12))),
    s = Number(e) + 86400 * 7,
    a = s + (r - t) * 86400 * 7,
    o = jN(new Date(s) - n),
    l = jN(new Date(a) - n);
  return { durationNextCvg: o, durationNextTde: l };
}
function UDe(t, e) {
  if (!t || !e) return "-";
  let n, r;
  t > e
    ? ((n = new Date(e * 1e3)), (r = new Date(t * 1e3)))
    : ((n = new Date(t * 1e3)), (r = new Date(e * 1e3)));
  const i = Math.floor((r.getTime() - n.getTime()) / 1e3);
  let s = Math.floor(i / 60);
  const a = Math.floor(s / 60);
  return a >= 24
    ? { days: Math.trunc(a / 24), hours: a % 24 }
    : ((s = s - a * 60), { hours: a, minutes: s });
}
const jDe = (t, e) => {
    const n = [t, "en-US"];
    let r;
    switch (e) {
      case "1d":
        r = new Intl.DateTimeFormat(n, {
          dateStyle: "short",
          timeStyle: "medium",
        });
        break;
      case "3d":
      case "1w":
      case "1m":
        r = new Intl.DateTimeFormat(n, {
          dateStyle: "short",
          timeStyle: "short",
        });
        break;
      case "3m":
      case "6m":
      case "1y":
      default:
        r = new Intl.DateTimeFormat(n, { dateStyle: "short" });
        break;
    }
    return r;
  },
  HDe = async (t, e, n, r) => {
    try {
      const i = await t();
      n(i, () => {
        e && e();
      });
    } catch (i) {
      r(i);
    }
  },
  zDe = async (t, e) => {
    e({ loading: !0 });
    try {
      const n = await t();
      e(n);
    } catch (n) {
      console.error(n), e({ error: !0 });
    }
  },
  VDe = async (t, e) => {
    e({ loading: !0 });
    try {
      const n = await Promise.all(t);
      e(n.flat());
    } catch (n) {
      console.error(n), e({ error: !0 });
    }
  };
function jT(t, e) {
  if (!e || typeof e != "object" || !t) return t;
  let n = t;
  for (let r in e) n = n.replace(new RegExp(`{${r}}`, "g"), e[r]);
  return n;
}
function GDe(t) {
  return t && !t.loading && !t.error;
}
function HN(t) {
  return t !== null && typeof t == "object";
}
function rx(t) {
  if (!HN(t)) return t;
  let e;
  try {
    (t = t.toObject()), (e = {});
  } catch {
    (t = t.toArray()), (e = []);
  }
  for (const n of Object.keys(t)) {
    const r = t[n];
    e[n] = HN(r) ? rx(r) : r;
  }
  return (
    Object.keys(e).length === 1 && Object.keys(e)[0] === "_" && (e = [e._]), e
  );
}
const WDe = (t, e) => t - (t * BigInt(e * 1e3)) / 100000n,
  qDe = async (t, e, n) => {
    const r = JSON.parse(localStorage.getItem(t) || "{}");
    if (r.timestamp && r.timestamp + e >= Date.now()) return r;
    let i = {};
    try {
      const s = await fetch(n);
      if (s.status !== 200) return {};
      (i = await s.json()),
        localStorage.setItem(
          t,
          JSON.stringify({ ...i, timestamp: Date.now() })
        );
    } catch (s) {
      console.error(s);
    }
    return i;
  },
  ybe = "hh-sol-artifact-1",
  vbe = "IERC20",
  bbe = "contracts/interfaces/IERC20.sol",
  wbe = [
    {
      constant: !0,
      inputs: [],
      name: "name",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_spender", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "totalSupply",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_from", type: "address" },
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "decimals",
      outputs: [{ name: "", type: "uint8" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "_owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ name: "balance", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "symbol",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [
        { name: "_owner", type: "address" },
        { name: "_spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    { payable: !0, stateMutability: "payable", type: "fallback" },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "owner", type: "address" },
        { indexed: !0, name: "spender", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "from", type: "address" },
        { indexed: !0, name: "to", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Transfer",
      type: "event",
    },
  ],
  yp = { _format: ybe, contractName: vbe, sourceName: bbe, abi: wbe },
  _be = "hh-sol-artifact-1",
  Ebe = "CvgControlTowerV2",
  xbe = "contracts/CvgControlTowerV2.sol",
  Tbe = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgCycleId",
          type: "uint256",
        },
      ],
      name: "NewCycle",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "bondCalculator",
      outputs: [
        { internalType: "contract IBondCalculator", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "bondDepository",
      outputs: [
        { internalType: "contract IBondDepository", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "bondPositionManager",
      outputs: [
        {
          internalType: "contract IBondPositionManager",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cloneFactory",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgCvxStaking",
      outputs: [
        {
          internalType: "contract ICvxStakingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgCycle",
      outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgOracle",
      outputs: [
        { internalType: "contract ICvgOracle", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgRewards",
      outputs: [
        { internalType: "contract ICvgRewards", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgSDT",
      outputs: [
        { internalType: "contract IERC20Mintable", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgSdtBuffer",
      outputs: [
        { internalType: "contract ISdtBuffer", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgSdtStaking",
      outputs: [
        {
          internalType: "contract ISdtStakingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgToken",
      outputs: [{ internalType: "contract ICvg", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvx",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "cvxAssetStaking",
      outputs: [
        {
          internalType: "contract ICvxStakingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgCVX",
      outputs: [
        {
          internalType: "contract ICvxConvergenceLocker",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvxConvergenceMultisig",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvxRewardDistributor",
      outputs: [
        {
          internalType: "contract ICvxRewardDistributor",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvxStakingPositionManager",
      outputs: [
        {
          internalType: "contract ICvxStakingPositionManager",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "gaugeController",
      outputs: [
        {
          internalType: "contract IGaugeController",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_cursorStart", type: "uint256" },
        { internalType: "uint256", name: "_lengthDesired", type: "uint256" },
      ],
      name: "getCvxStakings",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "stakingContract",
              type: "address",
            },
            { internalType: "string", name: "stakingName", type: "string" },
          ],
          internalType: "struct CvgControlTowerV2.Staking[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_cursorStart", type: "uint256" },
        { internalType: "uint256", name: "_lengthDesired", type: "uint256" },
      ],
      name: "getSdtStakings",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "stakingContract",
              type: "address",
            },
            { internalType: "string", name: "stakingName", type: "string" },
          ],
          internalType: "struct CvgControlTowerV2.Staking[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "ibo",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ISdtStakingPositionService",
          name: "_sdtStakingClone",
          type: "address",
        },
      ],
      name: "insertNewSdtStaking",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "isBond",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "isSdtStaking",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "isStakingContract",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionDelegate",
      outputs: [
        {
          internalType: "contract ILockingPositionDelegate",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionManager",
      outputs: [
        {
          internalType: "contract ILockingPositionManager",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionService",
      outputs: [
        {
          internalType: "contract ILockingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "poolCvgSdt",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "sdAndLpAssetStaking",
      outputs: [
        {
          internalType: "contract ISdtStakingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdt",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtBlackHole",
      outputs: [
        { internalType: "contract ISdtBlackHole", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtFeeCollector",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtRewardDistributor",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtStakingPositionManager",
      outputs: [
        {
          internalType: "contract ISdtStakingPositionManager",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtStakingViewer",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "sdtUtilities",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IBondCalculator",
          name: "newBondCalculator",
          type: "address",
        },
      ],
      name: "setBondCalculator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IBondDepository",
          name: "newBondDepository",
          type: "address",
        },
      ],
      name: "setBondDepository",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IBondPositionManager",
          name: "_bondPositionManager",
          type: "address",
        },
      ],
      name: "setBondPositionManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "newCloneFactory", type: "address" },
      ],
      name: "setCloneFactory",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract ICvg", name: "_cvgToken", type: "address" },
      ],
      name: "setCvg",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvxStakingPositionService",
          name: "_cvgCvxStaking",
          type: "address",
        },
      ],
      name: "setCvgCvxStaking",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgRewards",
          name: "newCvgRewards",
          type: "address",
        },
      ],
      name: "setCvgRewards",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IERC20Mintable",
          name: "_cvgSDT",
          type: "address",
        },
      ],
      name: "setCvgSdt",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ISdtBuffer",
          name: "_cvgSdtBuffer",
          type: "address",
        },
      ],
      name: "setCvgSdtBuffer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ISdtStakingPositionService",
          name: "_cvgSdtStaking",
          type: "address",
        },
      ],
      name: "setCvgSdtStaking",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract IERC20", name: "_cvx", type: "address" },
      ],
      name: "setCvx",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvxConvergenceLocker",
          name: "_cvxConvergenceLocker",
          type: "address",
        },
      ],
      name: "setCvxConvergenceLocker",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_cvxConvergenceMultisig",
          type: "address",
        },
      ],
      name: "setCvxConvergenceMultisig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvxRewardDistributor",
          name: "_cvxRewardDistributor",
          type: "address",
        },
      ],
      name: "setCvxRewardDistributor",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvxStakingPositionManager",
          name: "_cvxStakingPositionManager",
          type: "address",
        },
      ],
      name: "setCvxStakingPositionManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IGaugeController",
          name: "newGaugeController",
          type: "address",
        },
      ],
      name: "setGaugeController",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_ibo", type: "address" }],
      name: "setIbo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ILockingPositionDelegate",
          name: "newLockingPositionDelegate",
          type: "address",
        },
      ],
      name: "setLockingPositionDelegate",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ILockingPositionManager",
          name: "newLockingPositionManager",
          type: "address",
        },
      ],
      name: "setLockingPositionManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ILockingPositionService",
          name: "newLockingPositionService",
          type: "address",
        },
      ],
      name: "setLockingPositionService",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgOracle",
          name: "newCvgOracle",
          type: "address",
        },
      ],
      name: "setOracle",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_poolCvgSDT", type: "address" },
      ],
      name: "setPoolCvgSdt",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract IERC20", name: "_sdt", type: "address" },
      ],
      name: "setSdt",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ISdtBlackHole",
          name: "_sdtBlackHole",
          type: "address",
        },
      ],
      name: "setSdtBlackHole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_sdtFeeCollector", type: "address" },
      ],
      name: "setSdtFeeCollector",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_sdtRewardDistributor",
          type: "address",
        },
      ],
      name: "setSdtRewardDistributor",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ISdtStakingPositionManager",
          name: "_sdtStakingPositionManager",
          type: "address",
        },
      ],
      name: "setSdtStakingPositionManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_sdtStakingViewer", type: "address" },
      ],
      name: "setSdtStakingViewer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_sdtUtilities", type: "address" },
      ],
      name: "setSdtUtilities",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newTreasuryAirdrop",
          type: "address",
        },
      ],
      name: "setTreasuryAirdrop",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "newTreasuryDao", type: "address" },
      ],
      name: "setTreasuryDao",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newtreasuryPartners",
          type: "address",
        },
      ],
      name: "setTreasuryPartners",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newTreasuryPddMultisig",
          type: "address",
        },
      ],
      name: "setTreasuryPdd",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newTreasuryPodMultisig",
          type: "address",
        },
      ],
      name: "setTreasuryPod",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "newTreasuryTeam", type: "address" },
      ],
      name: "setTreasuryTeam",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IVotingPowerEscrow",
          name: "newVotingPowerEscrow",
          type: "address",
        },
      ],
      name: "setVeCVG",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_veSdtMultisig", type: "address" },
      ],
      name: "setVeSdtMultisig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IVestingCvg",
          name: "_vestingCvg",
          type: "address",
        },
      ],
      name: "setVestingCvg",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IYsDistributor",
          name: "_ysDistributor",
          type: "address",
        },
      ],
      name: "setYsDistributor",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_bondDepository", type: "address" },
      ],
      name: "toggleBond",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "contractAddress", type: "address" },
      ],
      name: "toggleStakingContract",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryAirdrop",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryDao",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryPartners",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryPdd",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryPod",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryTeam",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "updateCvgCycle",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "veSdtMultisig",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "vestingCvg",
      outputs: [
        { internalType: "contract IVestingCvg", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "votingPowerEscrow",
      outputs: [
        {
          internalType: "contract IVotingPowerEscrow",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "ysDistributor",
      outputs: [
        { internalType: "contract IYsDistributor", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  zN = { _format: _be, contractName: Ebe, sourceName: xbe, abi: Tbe },
  Sbe = (t, e) => {
    const n = t[e];
    return n
      ? typeof n == "function"
        ? n()
        : Promise.resolve(n)
      : new Promise((r, i) => {
          (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(
            i.bind(null, new Error("Unknown variable dynamic import: " + e))
          );
        });
  };
let Abe = "mainnet".toLowerCase();
const Cbe = Sbe(
  Object.assign({
    "../config/contracts.cvg.json": () =>
      qe(() => import("./contracts.cvg-33cdcf10.js"), []),
    "../config/contracts.mainnet.json": () =>
      qe(() => import("./contracts.mainnet-4f756ca3.js"), []),
  }),
  `../config/contracts.${Abe}.json`
)
  .then((t) => t.default)
  .catch((t) => console.error("Failed to load contracts", t));
class kc {
  bcService = new Td();
  static staticData;
  static stakings = {};
  async getStaticData() {
    if (kc.staticData) return kc.staticData;
    const e = await Cbe;
    kc.staticData = e;
    const n = this.bcService.getCurrentNetworkInfo();
    return { ...e, networkInfos: n };
  }
  async getActualCycle() {
    return await new kr(
      (
        await this.getStaticData()
      ).cvgControlTower,
      zN.abi,
      await this.bcService.getStaticProvider()
    ).cvgCycle();
  }
  async getStakings(e, n = 100) {
    if (kc.stakings?.[e]) return kc.stakings[e];
    let r = "";
    if ((e === "stakedao" && (r = "getSdtStakings"), !r)) return [];
    const i = {},
      s = new zm(),
      a = await this.bcService.getStaticProvider(),
      { cvgControlTower: o } = await this.getStaticData();
    return (
      s.addDefaultProcessValueFunc(Vm(i)),
      s.addDefaultAddress(o),
      s.abis.push(zN.abi),
      s.addCall(r, [0n, BigInt(n)], ["stakings"]),
      await Gm(s, a),
      (i.controlTower = o),
      (kc.stakings[e] = i?.stakings || []),
      kc.stakings[e]
    );
  }
  async getCurrentBlock() {
    const e = await this.bcService.getStaticProvider(),
      n = await e.getBlockNumber();
    return await e.getBlock(n);
  }
}
const oi = new kc(),
  kbe = "hh-sol-artifact-1",
  Ibe = "CvgOracle",
  Obe = "contracts/Bond/CvgOracle.sol",
  Pbe = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "WETH",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "curveDuoParams",
      outputs: [
        { internalType: "bool", name: "isReversed", type: "bool" },
        { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
        { internalType: "address", name: "poolAddress", type: "address" },
        { internalType: "uint40", name: "deltaLimitOracle", type: "uint40" },
        { internalType: "uint40", name: "maxLastUpdate", type: "uint40" },
        { internalType: "uint128", name: "minPrice", type: "uint128" },
        { internalType: "uint128", name: "maxPrice", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "curveTriParams",
      outputs: [
        { internalType: "bool", name: "isReversed", type: "bool" },
        { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
        { internalType: "address", name: "poolAddress", type: "address" },
        { internalType: "uint40", name: "deltaLimitOracle", type: "uint40" },
        { internalType: "uint40", name: "maxLastUpdate", type: "uint40" },
        { internalType: "uint8", name: "k", type: "uint8" },
        { internalType: "uint120", name: "minPrice", type: "uint120" },
        { internalType: "uint128", name: "maxPrice", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvg",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "token0", type: "address" },
        { internalType: "address", name: "token1", type: "address" },
      ],
      name: "getAndVerifyTwoPrices",
      outputs: [
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "uint256", name: "", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "erc20", type: "address" }],
      name: "getPoolAddressByToken",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
      ],
      name: "getPriceAndValidationData",
      outputs: [
        { internalType: "uint256", name: "executionPrice", type: "uint256" },
        { internalType: "uint256", name: "limitPrice", type: "uint256" },
        { internalType: "bool", name: "isInLimit", type: "bool" },
        { internalType: "bool", name: "isEthVerified", type: "bool" },
        { internalType: "bool", name: "isNotStale", type: "bool" },
        { internalType: "bool", name: "isUsdRangeRespected", type: "bool" },
        { internalType: "bool", name: "areStableVerified", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
      ],
      name: "getPriceUnverified",
      outputs: [
        { internalType: "uint256", name: "executionPrice", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
      ],
      name: "getPriceVerified",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "token0", type: "address" },
        { internalType: "address", name: "token1", type: "address" },
      ],
      name: "getTwoPricesAndIsValid",
      outputs: [
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "bool", name: "", type: "bool" },
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "bool", name: "", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "poolTypePerErc20",
      outputs: [
        {
          internalType: "enum IOracleStruct.PoolType",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          components: [
            { internalType: "bool", name: "isReversed", type: "bool" },
            { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
            { internalType: "address", name: "poolAddress", type: "address" },
            {
              internalType: "uint40",
              name: "deltaLimitOracle",
              type: "uint40",
            },
            { internalType: "uint40", name: "maxLastUpdate", type: "uint40" },
            { internalType: "uint128", name: "minPrice", type: "uint128" },
            { internalType: "uint128", name: "maxPrice", type: "uint128" },
            {
              internalType: "address[]",
              name: "stablesToCheck",
              type: "address[]",
            },
          ],
          internalType: "struct IOracleStruct.CurveDuoParams",
          name: "_curveDuoParams",
          type: "tuple",
        },
      ],
      name: "setCurveDuoParams",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          components: [
            { internalType: "bool", name: "isReversed", type: "bool" },
            { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
            { internalType: "address", name: "poolAddress", type: "address" },
            {
              internalType: "uint40",
              name: "deltaLimitOracle",
              type: "uint40",
            },
            { internalType: "uint40", name: "maxLastUpdate", type: "uint40" },
            { internalType: "uint8", name: "k", type: "uint8" },
            { internalType: "uint120", name: "minPrice", type: "uint120" },
            { internalType: "uint128", name: "maxPrice", type: "uint128" },
            {
              internalType: "address[]",
              name: "stablesToCheck",
              type: "address[]",
            },
          ],
          internalType: "struct IOracleStruct.CurveTriParams",
          name: "_curveTriParams",
          type: "tuple",
        },
      ],
      name: "setCurveTriParams",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_cvg", type: "address" }],
      name: "setCvg",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          internalType: "enum IOracleStruct.PoolType",
          name: "_poolType",
          type: "uint8",
        },
      ],
      name: "setPoolTypeForToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          components: [
            {
              internalType: "contract AggregatorV3Interface",
              name: "aggregatorOracle",
              type: "address",
            },
            {
              internalType: "uint40",
              name: "deltaLimitOracle",
              type: "uint40",
            },
            { internalType: "uint56", name: "maxLastUpdate", type: "uint56" },
            { internalType: "uint128", name: "minPrice", type: "uint128" },
            { internalType: "uint128", name: "maxPrice", type: "uint128" },
          ],
          internalType: "struct IOracleStruct.StableParams",
          name: "_stableParams",
          type: "tuple",
        },
      ],
      name: "setStableParams",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          components: [
            { internalType: "bool", name: "isReversed", type: "bool" },
            { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
            { internalType: "address", name: "poolAddress", type: "address" },
            {
              internalType: "uint80",
              name: "deltaLimitOracle",
              type: "uint80",
            },
            { internalType: "uint96", name: "maxLastUpdate", type: "uint96" },
            {
              internalType: "contract AggregatorV3Interface",
              name: "aggregatorOracle",
              type: "address",
            },
            { internalType: "uint128", name: "minPrice", type: "uint128" },
            { internalType: "uint128", name: "maxPrice", type: "uint128" },
            {
              internalType: "address[]",
              name: "stablesToCheck",
              type: "address[]",
            },
          ],
          internalType: "struct IOracleStruct.UniV2Params",
          name: "_uniV2Params",
          type: "tuple",
        },
      ],
      name: "setUniV2Params",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_erc20Address", type: "address" },
        {
          components: [
            { internalType: "bool", name: "isReversed", type: "bool" },
            { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
            { internalType: "address", name: "poolAddress", type: "address" },
            {
              internalType: "uint80",
              name: "deltaLimitOracle",
              type: "uint80",
            },
            { internalType: "uint80", name: "maxLastUpdate", type: "uint80" },
            { internalType: "uint16", name: "twap", type: "uint16" },
            {
              internalType: "contract AggregatorV3Interface",
              name: "aggregatorOracle",
              type: "address",
            },
            { internalType: "uint128", name: "minPrice", type: "uint128" },
            { internalType: "uint128", name: "maxPrice", type: "uint128" },
            {
              internalType: "address[]",
              name: "stablesToCheck",
              type: "address[]",
            },
          ],
          internalType: "struct IOracleStruct.UniV3Params",
          name: "_uniV3Params",
          type: "tuple",
        },
      ],
      name: "setUniV3Params",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "stableParams",
      outputs: [
        {
          internalType: "contract AggregatorV3Interface",
          name: "aggregatorOracle",
          type: "address",
        },
        { internalType: "uint40", name: "deltaLimitOracle", type: "uint40" },
        { internalType: "uint56", name: "maxLastUpdate", type: "uint56" },
        { internalType: "uint128", name: "minPrice", type: "uint128" },
        { internalType: "uint128", name: "maxPrice", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "univ2Params",
      outputs: [
        { internalType: "bool", name: "isReversed", type: "bool" },
        { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
        { internalType: "address", name: "poolAddress", type: "address" },
        { internalType: "uint80", name: "deltaLimitOracle", type: "uint80" },
        { internalType: "uint96", name: "maxLastUpdate", type: "uint96" },
        {
          internalType: "contract AggregatorV3Interface",
          name: "aggregatorOracle",
          type: "address",
        },
        { internalType: "uint128", name: "minPrice", type: "uint128" },
        { internalType: "uint128", name: "maxPrice", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "univ3Params",
      outputs: [
        { internalType: "bool", name: "isReversed", type: "bool" },
        { internalType: "bool", name: "isEthPriceRelated", type: "bool" },
        { internalType: "address", name: "poolAddress", type: "address" },
        { internalType: "uint80", name: "deltaLimitOracle", type: "uint80" },
        { internalType: "uint80", name: "maxLastUpdate", type: "uint80" },
        { internalType: "uint16", name: "twap", type: "uint16" },
        {
          internalType: "contract AggregatorV3Interface",
          name: "aggregatorOracle",
          type: "address",
        },
        { internalType: "uint128", name: "minPrice", type: "uint128" },
        { internalType: "uint128", name: "maxPrice", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Nbe = { _format: kbe, contractName: Ibe, sourceName: Obe, abi: Pbe },
  Dbe = "120";
class Rbe {
  bcService = new Td();
  async getActualCvgPrice() {
    const { cvgToken: e, cvgOracle: n } = await oi.getStaticData(),
      i = await new kr(
        n,
        Nbe.abi,
        await this.bcService.getStaticProvider()
      ).getPriceUnverified(e);
    return i === 0n ? 0.33 : Number(v0(i, 18));
  }
  async _getAssetPriceFromCvg(e) {
    if (!e?.length) return {};
    const n = `https://api.cvg.finance//asset-prices/${e.join(",")}`,
      { remain: r, prices: i } = this.getPriceFromCache(e);
    if (r.length === 0) return i;
    let s;
    try {
      const u = await fetch(n);
      if (u.status !== 200) return {};
      s = await u.json();
    } catch (u) {
      console.error(u), (s = {});
    }
    this.savePriceInCache(s);
    const a = { ...i, ...s },
      o = Object.keys(a),
      l = e.filter((u) => !o.includes(u));
    return { ...i, ...s, notFound: l };
  }
  async _getPriceFromDefiLlama(e) {
    if (!e?.length) return {};
    const { remain: n, prices: r } = this.getPriceFromCache(e);
    if (n.length === 0) return r;
    let i = `ethereum:${n.join(",ethereum:")}`,
      s = await fetch(
        `https://coins.llama.fi/prices/current/${i}?searchWidth=4h`
      );
    if (s.status !== 200)
      return (
        console.error(`Fail to fetch coins.llama.fi ${s.status}`),
        { notFound: e }
      );
    const a = await s.json(),
      o = Object.entries(a.coins).reduce(
        (c, [d, p]) => ((c[d.replace("ethereum:", "")] = p.price), c),
        {}
      );
    this.savePriceInCache(o);
    const l = { ...r, ...o },
      u = Object.keys(l),
      f = e.filter((c) => !u.includes(c));
    return { ...r, ...o, notFound: f };
  }
  async getPrices(e) {
    const { cvgToken: n } = await oi.getStaticData();
    let r = await this._getPriceFromDefiLlama(e);
    if (r.notFound)
      try {
        let i = await this._getAssetPriceFromCvg(r.notFound);
        r = { ...r, ...i };
      } catch (i) {
        console.error(i);
      }
    return e.includes(n) && (r.cvg = r[n]), r;
  }
  savePriceInCache = (e) => {
    if (!e) return;
    const n = localStorage?.getItem("convergence.prices"),
      r = n ? { ...JSON.parse(n) } : {};
    Object.entries(e).forEach(([i, s]) => {
      r[i] = { price: s, date: new Date().getTime() };
    }),
      localStorage?.setItem("convergence.prices", JSON.stringify(r));
  };
  getPriceFromCache = (e) => {
    if (!e?.length) return { remain: [], prices: {} };
    const n = localStorage?.getItem("convergence.prices");
    if (!n) return { remain: e, prices: {} };
    const r = JSON.parse(n),
      i = new Date().setSeconds(new Date().getSeconds() + Number(Dbe)),
      s = { remain: [...e], prices: {} };
    return (
      e.forEach((a) => {
        r[a] &&
          r[a].date >= i &&
          ((s.prices[a] = r[a].price),
          (s.remain = s.remain.filter((o) => o !== a)));
      }),
      s
    );
  };
  async getCvgPrices(e) {
    let n = new Array(52).fill(0);
    try {
      const r = await fetch(`https://api.cvg.finance//cvg-prices/${e}`);
      return r.status === 200 ? await r.json() : n;
    } catch (r) {
      return console.error(r), n;
    }
  }
  makeFakePrice = () => {
    const r = new Date().getTime(),
      i = 86400 / 49,
      s = [{ price: 0.33, index: 0, date: r }],
      a = (o) => (o - 0.5) / 2;
    for (let o = 0; o < 49 - 1; o++)
      s.push({
        price: s[o].price + s[o].price * a(Math.random()),
        index: o + 1,
        date: Math.round(s[o].date - i),
      });
    return s.reverse();
  };
}
const db = new Rbe(),
  hb = "0x97efFB790f2fbB701D88f89DB4521348A2B77be8",
  VN = "0x2191DF768ad71140F9F3E96c1e4407A4aA31d082",
  GN = "0x6C9815826FdF8c7a45cCfEd2064dbaB33a078712",
  WN = "0x830614aE209FF9d8706d386fcdBc7a55206fcffC",
  J0 = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  ix = "0xD533a949740bb3306d119CC777fa900bA034cd52",
  qN = "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B",
  sx = "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0",
  KN = "0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F",
  XN = "0x9ae380f0272e2162340a5bb646c354271c0f5cfc",
  V5 = "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
  ZN = "0x18084fba666a33d37592fa2633fd49a74dd93a88",
  ax = "0xef3A930e1FfFFAcd2fc13434aC81bD278B0ecC8d",
  YN = "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32",
  QN = "0x365AccFCa291e7D3914637ABf1F7635dB165Bb09",
  ox = "0x808507121B80c02388fAd14726482e061B8da827",
  lx = "0x31429d1856aD1377A8A0079410B297e1a9e214c2",
  ux = "0xba100000625a3754423978a60c9317c58a424e3D",
  JN = "0xdA47862a83dac0c112BA89c6abC2159b95afd71C",
  eD = "0x4591DBfF62656E7859Afe5e45f6f47D3669fBB28",
  cx = "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e",
  fx = "0x4104b135DBC9609Fc1A9490E61369036497660c8",
  dx = "0x41252E8691e964f7DE35156B68493bAb6797a275",
  hx = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  tD = "0x853d955aCEf822Db058eb8505911ED77F175b99e",
  px = "0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E",
  mx = "0xD1b5651E55D4CeeD36251c61c50C889B36F6abB5",
  gx = "0x752B4c6e92d96467fE9b9a2522EF07228E00F87c",
  yx = "0x402F878BDd1f5C66FdAF0fabaBcF74741B68ac36",
  vx = "0xF24d8651578a55b0C119B9910759a351A3458895",
  nD = "0xe19d1c837B8A1C83A56cD9165b2c0256D39653aD",
  bx = "0x5Ea630e00D6eE438d3deA1556A110359ACdc10A9",
  rD = "0x97983236bE88107Cc8998733Ef73D8d969c52E37",
  iD = "0x26f01FE3BE55361b0643bc9d5D60980E37A2770D",
  sD = "0x7f50786A0b15723D741727882ee99a0BF34e3466",
  aD = "0xE55843a90672f7d8218285e51EE8fF8E233F35d5",
  oD = "0xF3C6e8fbB946260e8c2a55d48a5e01C82fD63106",
  lD = "0x3E8C72655e48591d93e6dfdA16823dB0fF23d859",
  uD = "0xbcfE5c47129253C6B8a9A00565B3358b488D42E0",
  cD = "0x50DC9aE51f78C593d4138263da7088A973b8184E",
  fD = "0x5AdF559f5D24aaCbE4FA3A3a4f44Fdc7431E6b52",
  dD = "0x9c9d06C7378909C6d0A2A0017Bb409F7fb8004E0",
  hD = "0x5af15DA84A4a6EDf2d9FA6720De921E1026E37b7",
  pD = "0x5c6Ee304399DBdB9C8Ef030aB642B10820DB8F56",
  mD = "0x7B50775383d3D6f0215A8F290f2C9e2eEBBEceb2",
  gD = "0x9C215206Da4bf108aE5aEEf9dA7caD3352A36Dad",
  wx = "0x1a7e4e63778B4f12a199C062f3eFdD288afCBce8",
  yD = "0x44b4e01c249e35B2803f947C5CcB9868C3421437",
  vD = "0xdd571E39aa0DF0bf142f6b81CBA5923dDacf06a7",
  bD = "0x4D69ad5F243571AA9628bd88ebfFA2C913427b0b",
  wD = "0x608E4105e49ce2562521e31936815e2E20dA6609",
  _D = "0x86F8d09EfD8ad2c85Fee831f2730d1766A39ec18",
  ED = "0x46fBC1BB799C1D71548f69Ad0603DCcDb52d8341",
  xD = "0x4875D5E7987C93431E6DB9DC53A136F46270F0Dc",
  TD = "0xA89B9c336764c9Ae5f64Bc19688601341974bc22",
  SD = "0xA9812ED1077938E88577be7A8eaf097b5337fF5b",
  AD = "0x1f1a798cBDf4E9d533CEB9386e0A19b8C3F99121",
  CD = "0x131Dc928F9Dad07F43CEfF269e1674b7eBbFcBB1",
  kD = "0x63f222079608EEc2DDC7a9acdCD9344a21428Ce7",
  ID = "0x28766020a5A8D3325863Bf533459130DDb0c3657",
  OD = "0x799b35467C53F388D0c41D5f4EFFf8bAd7b33e96",
  PD = "0xc0A63f4f3033a1f09804624f9666Fd214925FD06",
  ND = "0x2A2E11aA2B7988Ae4B5D21048699e4a4905bFCBA",
  DD = "0xBe77585F4159e674767Acf91284160E8C09b96D8",
  RD = "0x1B31C86024145583Ff37024A6B9aa8581A5070De",
  MD = "0x0bDabcDc2d2d41789A8F225F66ADbdc0CbDF6641",
  LD = "0x081312d469377507c05B9AE89340EB6fCE8242e9",
  BD = "0x83EB53801dDaC98eCaaA6Ee5Ed859F08b1f4D905",
  FD = "0x3A34c9bE0C5E19F39A9774b9E7e5eB4c7f763A61",
  $D = "0xf95E265F70874a0261F8F4a59822451c86f65b68",
  UD = "0x9343EB26c0b5fC4d13362920eA6C194b5476d366",
  jD = "0xE2568D65EeD31E6772CEf183f537032efEb68c23",
  HD = "0x4b95F9f85857341cC2876c15C88091a04eE5Cb31",
  zD = "0x087143dDEc7e00028AA0e446f486eAB8071b1f53",
  VD = "0xc31f496aaE237599872ac78611b245Bfe70fB06e",
  GD = "0xE94aFF2Bd6A12DD16C21648Cae71D2B47E405a9C",
  WD = "0xC891a1BaCF802127874054e703b386346fE94b00",
  qD = "0x6e1B39d3da150AF18518Ad56D3Caf6AFc39afD7d",
  KD = "0xb940c40EE41Aa18972A9CE04112B500E108a997b",
  XD = "0xFFd2a916bcAE236e3745bE894Ed51597e8eA6f3D",
  ZD = "0xd79d3329560489835265D4d100583f21AC9C4A3e",
  YD = "0x0897f99a36aB964CfD12AC66335602BA9C9FD82B",
  KDe = 7 * 24 * 60 * 60 * 1e3,
  XDe = {
    ve: "#526EE9",
    oldVe: "#7b7f98",
    ys: "#F7F760",
    oldYs: "#f8f8a7",
    mg: "#52E9A9",
    oldMg: "#99e7c4",
  },
  ZDe = 1.05,
  YDe = 1.05,
  QDe = "/images/token/empty.webp",
  JDe = ["1d", "3d", "1w", "1m", "3m", "6m", "1y"],
  eRe = "1d",
  tRe = [
    "#00A0E6",
    "#00C0E1",
    "#00E0DC",
    "#00FFD7",
    "#22FFD0",
    "#44FFC9",
    "#66FFC2",
    "#88FFBB",
    "#AAFFB4",
    "#CCFFAD",
    "#EEFFA6",
    "#F4FF9D",
    "#FAFF95",
    "#FFFE8C",
    "#FFFD84",
    "#FFF97B",
    "#FFF773",
    "#FFF46A",
    "#FFF262",
    "#FFEF59",
    "#FFEC51",
    "#FFEA49",
    "#FFE741",
    "#FFE438",
    "#FFE130",
    "#FFDE27",
    "#FFDC1F",
    "#FFD917",
    "#FFD70E",
    "#FFD506",
    "#FFD2FE",
    "#FFD0F5",
    "#FFCDFD",
    "#FFCBF5",
    "#FFC9EC",
    "#FFC6E4",
    "#FFBBCA",
    "#FFB9C1",
    "#FFB6B8",
    "#FFB4B0",
    "#FFA77C",
    "#FFA474",
    "#FF9959",
    "#FF9750",
    "#FF9548",
    "#FF8B26",
    "#FF892E",
    "#FF8725",
    "#FF852D",
    "#FF7922",
    "#FF772A",
    "#FF7521",
    "#FF7219",
    "#FF7010",
    "#FF6E18",
    "#FF6B0F",
    "#FF6907",
    "#FF6C03",
    "#FF6F00",
  ],
  nRe = "/images/BigcvgPepeSmoke.PNG",
  _x = "/images/token/CVG.webp",
  EG = "/images/token/cvgSDT.webp",
  Mbe = "/images/token/CRV.webp",
  Lbe = "/images/token/SDT.webp",
  rRe = "/images/token/FRAX.webp",
  iRe = "/images/token/CVX.webp",
  Bbe = "/images/token/CVX1.webp",
  sRe = "/images/token/ETH.webp",
  Fbe = "/images/token/cvgCVX.webp",
  $be = "/images/token/cvgCVX-CVX1.webp",
  aRe = [
    { source: "cvgSDT", name: "cvgSDT", logo: EG },
    {
      source: "crvUSDCWBTCWETH",
      name: "triUSDC",
      sub: "USDC/WBTC/ETH",
      logo: "/images/token/triUSDC.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-tricrypto-0/deposit",
    },
    {
      source: "crv3crypto",
      name: "triUSDT2",
      sub: "USDT/WBTC/ETH",
      logo: "/images/token/triUSDT2.webp",
      curveDepositUrl: "https://curve.fi/#/ethereum/pools/tricrypto2/deposit",
    },
    {
      source: "crvCRVUSDTBTCWSTETH",
      name: "triLLAMA",
      sub: "crvUSD/tBTC/wstETH",
      logo: "/images/token/triLLAMA.webp",
      rewards: [V5],
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-tricrypto-2/deposit",
    },
    {
      source: "crvUSDETHCRV",
      name: "triCRV",
      sub: "crvUSD/ETH/CRV",
      logo: "/images/token/triCRV.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-tricrypto-4/deposit",
    },
    {
      source: "crvUSDUSDT-f",
      name: "crvUSD-USDT",
      logo: "/images/token/crvUSD-USDT.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crvusd-1/deposit",
    },
    {
      source: "STGUSDC-f",
      name: "STG-USDC",
      logo: "/images/token/STG-USDC.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crypto-37/deposit",
    },
    {
      source: "sdCRVlp-f",
      name: "sdCRV-CRV",
      logo: "/images/token/sdCRV-CRV.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-v2-300/deposit",
    },
    {
      source: "crvUSDUSDC-f",
      name: "crvUSD-USDC",
      gaugeName: "USDC-crvUSD",
      logo: "/images/token/crvUSD-USDC.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crvusd-0/deposit",
    },
    {
      source: "frxETHCRV",
      name: "frxETH-ETH",
      logo: "/images/token/frxETH-ETH.webp",
      curveDepositUrl: "https://curve.fi/#/ethereum/pools/frxeth/deposit",
    },
    {
      source: "cvxcrv-crv-f",
      name: "cvxCRV-CRV",
      logo: "/images/token/cvxCRV-CRV.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-v2-283/deposit",
    },
    {
      source: "crvFRAX",
      name: "FRAX-USDC",
      gaugeName: "FRAXBP",
      logo: "/images/token/FRAX-USDC.webp",
      curveDepositUrl: "https://curve.fi/#/ethereum/pools/fraxusdc/deposit",
    },
    {
      source: "alUSDFRAXB3CRV-f",
      name: "alUSD-FRAXBP",
      logo: "/images/token/alUSD-FRAXBP.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-v2-147/deposit",
    },
    {
      source: "rCRV",
      name: "ETH-rETH",
      logo: "/images/token/ETH-rETH.webp",
      rewards: [ax],
      curveDepositUrl: "https://curve.fi/#/ethereum/pools/reth/deposit",
    },
    {
      source: "COILFRAX-f",
      name: "COIL-FRAXBP",
      logo: "/images/token/COIL-FRAXBP.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crypto-236/deposit",
    },
    {
      source: "crvUSDDOLA-f",
      name: "DOLA-crvUSD",
      logo: "/images/token/DOLA-crvUSD.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crvusd-12/deposit",
    },
    {
      source: "XAIFRAXBP3CRV-f",
      name: "XAI-FRAXBP",
      logo: "/images/token/XAI-FRAXBP.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-v2-223/deposit",
    },
    {
      source: "crvUSDFRAX-f",
      name: "crvUSD-FRAX",
      logo: "/images/token/crvUSD-FRAX.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crvusd-4/deposit",
    },
    {
      source: "dETHfrxETH-f",
      name: "dETH-frxETH",
      logo: "/images/token/dETH-frxETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-v2-287/deposit",
    },
    {
      source: "ETH+ETH-f",
      name: "ETH+-WETH",
      logo: "/images/token/ETH+-WETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crypto-256/deposit",
    },
    {
      source: "SDTETH-f",
      name: "WETH-SDT",
      logo: "/images/token/WETH-SDT.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-crypto-11/deposit",
    },
    {
      source: "pxsteth",
      name: "pxETH-stETH",
      logo: "/images/token/pxETH-stETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-30/deposit",
    },
    {
      source: "pxfrxeth",
      name: "pxETH-frxETH",
      logo: "/images/token/pxETH-frxETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-29/deposit",
    },
    {
      source: "PYUSDUSDC",
      name: "PYUSD-USDC",
      logo: "/images/token/PYUSD-USDC.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-43/deposit",
    },
    {
      source: "CVGETH",
      name: "CVG-ETH",
      logo: "/images/token/CVG-ETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-twocrypto-0/deposit",
    },
    {
      source: "cvgSDTSDT",
      name: "cvgSDT-SDT",
      logo: "/images/token/cvgSDT-SDT.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-81/deposit",
    },
    {
      source: "cvgCVXCVX1",
      name: "cvgCVX-CVX1",
      logo: $be,
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-186/deposit",
    },
    {
      source: "cvgCVXCVX1",
      name: "cvgCVX-CVX1",
      logo: "/images/token/cvgCVX-CVX1.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-186/deposit",
    },
    {
      source: "CRVZUNUSD",
      name: "zunUSD-crvUSD",
      logo: "/images/token/zunUSD-crvUSD.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-104/deposit",
    },
    {
      source: "ZUNFRXETH",
      name: "zunETH-frxETH",
      logo: "/images/token/zunETH-frxETH.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-121/deposit",
    },
    {
      source: "PYcrvUSD",
      name: "PYUSD-crvUSD",
      logo: "/images/token/PYUSD-crvUSD.webp",
      curveDepositUrl:
        "https://curve.fi/#/ethereum/pools/factory-stable-ng-42/deposit",
    },
    {
      source: "sdANGLE",
      name: "sdANGLE",
      isSdAsset: !0,
      logo: "/images/token/sdANGLE.webp",
      pool: "0x96aae323e111a19b1e0e26f55e8de21f1dd01f26",
      rewards: [lx, wx, gx],
    },
    {
      source: "sdCRV",
      name: "sdCRV",
      isSdAsset: !0,
      logo: "/images/token/sdCRV.webp",
      pool: "0xca0253a98d16e9c1e3614cafda19318ee69772d0",
      rewards: [px, ix, mx],
    },
    {
      source: "sdFXN",
      name: "sdFXN",
      isSdAsset: !0,
      pool: "0x28ca243dc0ac075dd012fcf9375c25d18a844d96",
      logo: "/images/token/sdFXN.webp",
      rewards: [V5],
    },
    {
      source: "sdFXS",
      name: "sdFXS",
      isSdAsset: !0,
      pool: "0x71c91b173984d3955f7756914bbf9a7332538595",
      logo: "/images/token/sdFXS.webp",
      rewards: [sx, yx],
    },
    {
      source: "sdPENDLE",
      name: "sdPENDLE",
      isSdAsset: !0,
      pool: "0x26f3f26f46cbee59d1f8860865e13aa39e36a8c0",
      logo: "/images/token/sdPENDLE.webp",
      rewards: [ox, J0, bx],
    },
    {
      source: "sdBAL",
      name: "sdBAL",
      isSdAsset: !0,
      logo: "/images/token/sdBAL.webp",
      rewards: [ux, hx, vx],
    },
    {
      source: "sdYFI",
      name: "sdYFI",
      isSdAsset: !0,
      pool: "0x852b90239C5034b5bb7a5e54eF1bEF3Ce3359CC8",
      logo: "/images/token/sdYFI.webp",
      rewards: [cx, dx],
    },
    {
      source: "sdAPW",
      name: "sdAPW",
      isSdAsset: !0,
      pool: "0x6788f608CfE5CfCD02e6152eC79505341E0774be",
      logo: "/images/token/sdAPW.webp",
      rewards: [fx],
    },
    { source: "sCvgCvx", name: "cvgCVX", logo: "/images/token/cvgCVX.webp" },
    { source: "sCvxCRV", name: "cvxCRV", logo: "/images/token/cvxCRV.webp" },
    { source: "sCvxFxn", name: "cvxFXN", logo: "/images/token/cvxFXN.webp" },
    {
      source: "sCvxPrisma",
      name: "cvxPRISMA",
      logo: "/images/token/cvxPRISMA.webp",
    },
  ],
  QD = "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490",
  JD = "0x2889302a794dA87fBF1D6Db415C1492194663D13",
  eR = "0x4eBdF703948ddCEA3B11f675B4D1Fba9d2414A14",
  tR = "0x7F86Bf177Dd4F3494b841a37e810A34dD56c829B",
  nR = "0xf5f5b97624542d72a9e06f04804bf81baa15e2b4",
  rR = "0xc4AD29ba4B3c580e6D59105FFf484999997675Ff",
  iR = "0x954313005c56b555bdc41b84d6c63b69049d7847",
  sR = "0xdf55670e27bE5cDE7228dD0A6849181891c9ebA1",
  aR = "0xF9835375f6b268743Ea0a54d742Aa156947f8C06",
  oR = "0x390f3595bCa2Df7d23783dFd126427CCeb997BF4",
  lR = "0xCA0253A98D16e9C1e3614caFDA19318EE69772D0",
  Ube = "0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E",
  uR = "0xf43211935C781D5ca1a41d2041F397B8A7366C7A",
  cR = "0xBa3436Fd341F2C8A928452Db3C5A3670d1d5Cc73",
  fR = "0x5a6A4D54456819380173272A5E8E9B9904BdF41B",
  dR = "0x7C0d189E1FecB124487226dCbA3748bD758F98E4",
  hR = "0x971add32Ea87f10bD192671630be3BE8A11b8623",
  pR = "0x3175Df0976dFA876431C2E9eE6Bc45b65d3473CC",
  mR = "0xB30dA2376F63De30b42dC055C93fa474F31330A5",
  gR = "0x53a901d48795C58f485cBB38df08FA96a24669D5",
  yR = "0xA8a02c7D9ada50444F8c658F43Dc440675B21797",
  vR = "0xb85010193FD15aF8390dbD62790Da70F46c1126B",
  bR = "0x94cC50e4521bD271C1a997a3A4Dc815C2F920b41",
  wR = "0x8272E1A3dBef607C04AA6e5BD3a1A134c8ac063B",
  _R = "0x0CFe5C777A7438C9Dd8Add53ed671cEc7A5FAeE5",
  ER = "0x06325440D014e39736583c165C2963BA99fAf14E",
  xR = "0x326290A1B0004eeE78fa6ED4F1d8f4b2523ab669",
  TR = "0x71c91b173984d3955f7756914bbf9a7332538595",
  SR = "0x0CD6f267b2086bea681E922E19D40512511BE538",
  AR = "0xe8a5677171c87fCB65b76957f2852515B404C7b1",
  CR = "0x6359B6d3e327c497453d4376561eE276c6933323",
  kR = "0x6951bDC4734b9f7F3E1B74afeBC670c736A0EDB6",
  IR = "0xe2Ed1dAc3A9547BC6057e32bf8133b5268D7d987",
  OR = "0x383e6b4437b59fff47b619cba855ca29342a8559",
  PR = "0xc50E191F703FB3160fC15d8b168A8c740fec3666",
  NR = "0x8c24b3213fd851db80245fccc42c40b94ac9a745",
  DR = "0x3a65cbaebbfecbea5d0cb523ab56fdbda7ff9aaa",
  RR = "0x625e92624bc2d88619accc1788365a69767f6200",
  MR = "0x62b9c7356a2dc64a1969e19c23e4f579f9810aa7",
  LR = "0xaa0C3f5F7DFD688C6E646F66CD2a6B66ACdbE434",
  BR = "0xFEEf77d3f69374f66429C91d732A244f074bdf74",
  FR = "0x49b4d1dF40442f0C31b1BbAEA3EDE7c38e37E31a",
  $R = "0x34635280737b5BFe6c7DC2FC3065D60d66e78185",
  UR = "0x0c73f1cFd5C9dFc150C8707Aa47Acbd14F0BE108",
  jR = "0x183395DbD0B5e93323a7286D1973150697FFFCB3",
  HR = "0xEC60Cd4a5866fb3B0DD317A46d3B474a24e06beF",
  zR = "0xa2847348b58CEd0cA58d23c7e9106A49f1427Df6",
  VR = "0xfA87DB3EAa93B7293021e38416650D2E666bC483",
  oRe = "0x72a19342e8F1838460eBFCCEf09F6585e32db86E",
  lRe = "0xCF50b810E57Ac33B91dCF525C6ddd9881B139332",
  vp = {
    [mx]: {
      token: "sdCRV",
      name: "Stake DAO CRV",
      decimals: 18,
      tokenAddress: mx,
      logo: "/images/token/sdCRV.webp",
    },
    [gx]: {
      token: "sdANGLE",
      name: "Stake DAO ANGLE",
      decimals: 18,
      tokenAddress: gx,
      logo: "/images/token/sdANGLE.webp",
    },
    [yx]: {
      token: "sdFXS",
      name: "Stake DAO FXS",
      decimals: 18,
      tokenAddress: yx,
      logo: "/images/token/sdFXS.webp",
    },
    [vx]: {
      token: "sdBAL",
      name: "Stake DAO Balancer",
      decimals: 18,
      tokenAddress: vx,
      logo: "/images/token/sdBAL.webp",
    },
    [bx]: {
      token: "sdPENDLE",
      name: "Stake DAO PENDLE",
      decimals: 18,
      tokenAddress: bx,
      logo: "/images/token/sdPENDLE.webp",
    },
    [nD]: {
      token: "sdFXN",
      name: "Stake DAO FXN",
      decimals: 18,
      tokenAddress: nD,
      logo: "/images/token/sdFXN.webp",
    },
    [rD]: {
      token: "sdYFI",
      name: "Stake DAO YFI",
      decimals: 18,
      tokenAddress: rD,
      logo: "/images/token/sdYFI.webp",
    },
    [dx]: {
      token: "dYFI",
      name: "Discount YFI",
      decimals: 18,
      tokenAddress: dx,
      logo: "/images/token/dYFI.webp",
    },
    [iD]: {
      token: "sdAPW",
      name: "Stake DAO APW",
      decimals: 18,
      tokenAddress: iD,
      logo: "/images/token/sdAPW.webp",
    },
    [hD]: {
      token: "sdFRAX3CRV",
      name: "Stake DAO Curve.fi Factory USD Metapool: Frax",
      decimals: 18,
      tokenAddress: hD,
      logo: "/images/token/FRAX.webp",
    },
    [tR]: {
      token: "USDC-WBTC-WETH",
      name: "triUSDC",
      decimals: 18,
      tokenAddress: tR,
    },
    [gD]: {
      token: "sanUSDC-EUR",
      name: "sanUSDC_EUR",
      decimals: 6,
      tokenAddress: gD,
    },
    [mD]: {
      token: "bb-a-USD",
      name: "Balancer Aave Boosted StablePool (USD)",
      decimals: 18,
      tokenAddress: mD,
    },
    [pD]: {
      token: "B-80BAL-20WETH",
      name: "Balancer 80 BAL 20 WETH",
      decimals: 18,
      tokenAddress: pD,
    },
    [dR]: {
      token: "dETH-frxETH",
      name: "Curve.fi Factory Plain Pool: Stakehouse dETH / frxETH",
      decimals: 18,
      tokenAddress: dR,
    },
    [hR]: {
      token: "cvxCRV-CRV",
      name: "Curve.fi Factory Plain Pool: cvxCrv/Crv",
      decimals: 18,
      tokenAddress: hR,
    },
    [TR]: {
      token: "sdFXS-FXS",
      name: "Curve.fi Factory Plain Pool: sdFXS/FXS",
      decimals: 18,
      tokenAddress: TR,
    },
    [pR]: {
      token: "FRAXBP",
      name: "Curve.fi FRAX/USDC",
      decimals: 18,
      tokenAddress: pR,
    },
    [mR]: {
      token: "alUSD-FRAXBP",
      name: "Curve.fi Factory USD Metapool: alUSDFRAXBP",
      decimals: 18,
      tokenAddress: mR,
    },
    [rR]: {
      token: "triUSDT2",
      name: "Curve.fi USD-BTC-ETH",
      decimals: 18,
      tokenAddress: rR,
      logo: "/images/token/triUSDT2.webp",
    },
    [oR]: {
      token: "USDT-crvUSD",
      name: "Curve.fi Factory Plain Pool: crvUSD/USDT",
      decimals: 18,
      tokenAddress: oR,
    },
    [sR]: {
      token: "STG-USDC",
      name: "Curve.fi Factory Crypto Pool: STG/USDC",
      decimals: 18,
      tokenAddress: sR,
    },
    [lR]: {
      token: "sdCRV-CRV",
      name: "Curve.fi Factory Plain Pool: sdCRV/CRV",
      decimals: 18,
      tokenAddress: lR,
    },
    [Ube]: {
      token: "crvUSD-USDC",
      name: "Curve.fi Factory Plain Pool: crvUSD/USDC",
      decimals: 18,
      tokenAddress: "0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E",
    },
    [uR]: {
      token: "frxETH-ETH",
      name: "Curve.fi ETH/frxETH",
      decimals: 18,
      tokenAddress: uR,
    },
    [nR]: {
      token: "triUSDT",
      name: "TricryptoUSDT",
      decimals: 18,
      tokenAddress: nR,
    },
    [JD]: {
      token: "triLLAMA",
      name: "TricryptoLLAMA",
      decimals: 18,
      tokenAddress: JD,
    },
    [cR]: {
      token: "agEUR-EUROC",
      name: "Curve.fi Factory Plain Pool: agEUR/EUROC",
      decimals: 18,
      tokenAddress: cR,
    },
    [fR]: {
      token: "MIM-3CRV",
      name: "Curve.fi Factory USD Metapool: Magic Internet Money 3Pool",
      decimals: 18,
      tokenAddress: fR,
    },
    [gR]: {
      token: "ETH-rETH",
      name: "Curve.fi ETH/rETH",
      decimals: 18,
      tokenAddress: gR,
    },
    [yR]: {
      token: "XAI-crvUSD",
      name: "Curve.fi Factory Plain Pool: crvUSD/XAI",
      decimals: 18,
      tokenAddress: yR,
    },
    [vR]: {
      token: "COIL-FRAXBP",
      name: "Curve.fi Factory Crypto Pool: COIL/FRAXBP",
      decimals: 18,
      tokenAddress: vR,
    },
    [bR]: {
      token: "sUSD-crvUSD",
      name: "Curve.fi Factory Plain Pool: crvUSD/SUSD",
      decimals: 18,
      tokenAddress: bR,
    },
    [wR]: {
      token: "DOLA-crvUSD",
      name: "Curve.fi Factory Plain Pool: crvUSD/DOLA",
      decimals: 18,
      tokenAddress: wR,
    },
    [eR]: { token: "triCRV", name: "TriCRV", decimals: 18, tokenAddress: eR },
    [_R]: {
      token: "mkUSD-FRAXBP",
      name: "Curve.fi Factory USD Metapool: Prisma mkUSD",
      decimals: 18,
      tokenAddress: _R,
    },
    [aR]: {
      token: "ETH-CNC",
      name: "Curve.fi Factory Crypto Pool: CNC/ETH",
      decimals: 18,
      tokenAddress: aR,
    },
    [xR]: {
      token: "XAI-FRAXBP",
      name: "Curve.fi Factory USD Metapool: XAI/FRAXBP",
      decimals: 18,
      tokenAddress: xR,
    },
    [iR]: { token: "triSDT", name: "triSDT", decimals: 18, tokenAddress: iR },
    [ER]: {
      token: "stETH-ETH",
      name: "Curve.fi ETH/stETH",
      decimals: 18,
      tokenAddress: ER,
    },
    [QD]: {
      token: "3Crv",
      name: "Curve.fi DAI/USDC/USDT",
      decimals: 18,
      tokenAddress: QD,
      reward: !0,
      logo: "/images/token/3Crv.webp",
    },
    [SR]: {
      token: "crvUSDFRAX",
      name: "Curve.fi crvUSDFRAX-f",
      decimals: 18,
      tokenAddress: SR,
      logo: "/images/token/crvUSD-FRAX.webp",
    },
    [AR]: {
      token: "ETH+-WETH",
      name: "Curve.fi crvUSDFRAX-f",
      decimals: 18,
      tokenAddress: AR,
      logo: "/images/token/ETH+-WETH.webp",
    },
    [CR]: {
      token: "WETH-SDT",
      name: "Curve.fi WETH-SDT-f",
      decimals: 18,
      tokenAddress: CR,
    },
    [kR]: {
      token: "PXETH-STETH",
      name: "Curve.fi PXETH-STETH-f",
      decimals: 18,
      tokenAddress: kR,
    },
    [IR]: {
      token: "PXETH-FRXETH",
      name: "Curve.fi PXETH-FRXETH-f",
      decimals: 18,
      tokenAddress: IR,
    },
    [OR]: {
      token: "PYUSD-USDC",
      name: "PayPool",
      decimals: 18,
      tokenAddress: OR,
    },
    [PR]: {
      token: "cvgCVX-CVX1",
      name: "CvgCVX/CVX1",
      decimals: 18,
      tokenAddress: PR,
    },
    [NR]: {
      token: "crvUSD-zunUSD",
      name: "crvUSD/zunUSD",
      decimals: 18,
      tokenAddress: NR,
    },
    [DR]: {
      token: "zunETH-frxETH",
      name: "zunETH/frxETH",
      decimals: 18,
      tokenAddress: DR,
    },
    [RR]: {
      token: "PYUSD-crvUSD",
      name: "PYUSD/crvUSD",
      decimals: 18,
      tokenAddress: RR,
    },
    [sD]: {
      token: "sdCRV-gauge",
      name: "Stake DAO sdCRV Gauge",
      decimals: 18,
      tokenAddress: sD,
    },
    [aD]: {
      token: "sdANGLE-gauge",
      name: "Stake DAO sdANGLE Gauge",
      decimals: 18,
      tokenAddress: aD,
    },
    [oD]: {
      token: "sdFXS-gauge",
      name: "Stake DAO sdFXS Gauge",
      decimals: 18,
      tokenAddress: oD,
    },
    [cD]: {
      token: "sdPENDLE-gauge",
      name: "Stake DAO sdPENDLE Gauge",
      decimals: 18,
      tokenAddress: cD,
    },
    [lD]: {
      token: "sdBAL-gauge",
      name: "Stake DAO sdBAL Gauge",
      decimals: 18,
      tokenAddress: lD,
    },
    [uD]: {
      token: "sdFXN-gauge",
      name: "Stake DAO sdFXN Gauge",
      decimals: 18,
      tokenAddress: uD,
    },
    [fD]: {
      token: "sdYFI-gauge",
      name: "Stake DAO sdYFI Gauge",
      decimals: 18,
      tokenAddress: fD,
    },
    [dD]: {
      token: "sdAPW-gauge",
      name: "Stake DAO sdAPW Gauge",
      decimals: 18,
      tokenAddress: dD,
    },
    [OD]: {
      token: "dETH-frxETH-gauge",
      name: "Stake DAO dETHfrxETH-f Gauge",
      decimals: 18,
      tokenAddress: OD,
    },
    [PD]: {
      token: "cvxCRV-CRV-gauge",
      name: "Stake DAO cvxcrv-crv-f Gauge",
      decimals: 18,
      tokenAddress: PD,
    },
    [ND]: {
      token: "sdFXS-FXS-gauge",
      name: "Stake DAO sdFXSlp-f Gauge",
      decimals: 18,
      tokenAddress: ND,
    },
    [DD]: {
      token: "FRAXBP-gauge",
      name: "Stake DAO crvFRAX Gauge",
      decimals: 18,
      tokenAddress: DD,
    },
    [RD]: {
      token: "alUSD-FRAXBP-gauge",
      name: "Stake DAO alUSDFRAXB3CRV-f Gauge",
      decimals: 18,
      tokenAddress: RD,
    },
    [bD]: {
      token: "triUSDT2-gauge",
      name: "triUSDT2",
      decimals: 18,
      tokenAddress: bD,
    },
    [yD]: {
      token: "triUSDC-gauge",
      name: "Stake DAO triUSDC Gauge",
      decimals: 18,
      tokenAddress: yD,
    },
    [xD]: {
      token: "crvUSD-USDT-gauge",
      name: "Stake DAO crvUSDUSDT-f Gauge",
      decimals: 18,
      tokenAddress: xD,
    },
    [TD]: {
      token: "STG-USDC-gauge",
      name: "Stake DAO STGUSDC-f Gauge",
      decimals: 18,
      tokenAddress: TD,
    },
    [SD]: {
      token: "sdCRV-CRV-gauge",
      name: "Stake DAO sdCRVlp-f Gauge",
      decimals: 18,
      tokenAddress: SD,
    },
    [AD]: {
      token: "crvUSD-USDC-gauge",
      name: "Stake DAO crvUSDUSDC-f Gauge",
      decimals: 18,
      tokenAddress: AD,
    },
    [CD]: {
      token: "frxETH-ETH-gauge",
      name: "Stake DAO frxETHCRV Gauge",
      decimals: 18,
      tokenAddress: CD,
    },
    [vD]: {
      token: "triUSDT-gauge",
      name: "Stake DAO triUSDT Gauge",
      decimals: 18,
      tokenAddress: vD,
    },
    [wD]: {
      token: "triLLAMA-gauge",
      name: "Stake DAO triLLAMA Gauge",
      decimals: 18,
      tokenAddress: wD,
    },
    [kD]: {
      token: "agEUR-EUROC-gauge",
      name: "Stake DAO agEUREUROC-f Gauge",
      decimals: 18,
      tokenAddress: kD,
    },
    [ID]: {
      token: "MIM-3CRV-gauge",
      name: "Stake DAO MIM-3LP3CRV-f Gauge",
      decimals: 18,
      tokenAddress: ID,
    },
    [MD]: {
      token: "ETH-rETH-gauge",
      name: "Stake DAO rCRV Gauge",
      decimals: 18,
      tokenAddress: MD,
    },
    [LD]: {
      token: "XAI-crvUSD-gauge",
      name: "Stake DAO crvUSDXAI-f Gauge",
      decimals: 18,
      tokenAddress: LD,
    },
    [BD]: {
      token: "COIL-FRAXBP-gauge",
      name: "Stake DAO COILFRAX-f Gauge",
      decimals: 18,
      tokenAddress: BD,
    },
    [FD]: {
      token: "sUSD-crvUSD-gauge",
      name: "Stake DAO crvUSDSUSD-f Gauge",
      decimals: 18,
      tokenAddress: FD,
    },
    [$D]: {
      token: "DOLA-crvUSD-gauge",
      name: "Stake DAO crvUSDDOLA-f Gauge",
      decimals: 18,
      tokenAddress: $D,
    },
    [_D]: {
      token: "triCRV-gauge",
      name: "Stake DAO crvUSDETHCRV Gauge",
      decimals: 18,
      tokenAddress: _D,
    },
    [UD]: {
      token: "mkUSD-FRAXBP-gauge",
      name: "Stake DAO mkUSD3CRV-f Gauge",
      decimals: 18,
      tokenAddress: UD,
    },
    [jD]: {
      token: "CNC-ETH-gauge",
      name: "Stake DAO CNCETH-f Gauge",
      decimals: 18,
      tokenAddress: jD,
    },
    [HD]: {
      token: "XAI-FRAXBP-gauge",
      name: "Stake DAO XAIFRAXBP3CRV-f Gauge",
      decimals: 18,
      tokenAddress: HD,
    },
    [ED]: {
      token: "triSDT-gauge",
      name: "Stake DAO triSDT Gauge",
      decimals: 18,
      tokenAddress: [ED],
    },
    [zD]: {
      token: "stETH-ETH-gauge",
      name: "Stake DAO steCRV Gauge",
      decimals: 18,
      tokenAddress: zD,
    },
    [VD]: {
      token: "crvUSD-FRAX-gauge",
      name: "Stake DAO crvUSDFRAX-f Gauge",
      decimals: 18,
      tokenAddress: VD,
    },
    [GD]: {
      token: "ETH+-WETH-gauge",
      name: "Stake DAO ETH+-WETH-f Gauge",
      decimals: 18,
      tokenAddress: GD,
    },
    [WD]: {
      token: "WETH-SDT-gauge",
      name: "Stake DAO WETH-SDT Gauge",
      decimals: 18,
      tokenAddress: WD,
    },
    [qD]: {
      token: "pxETH-stETH-gauge",
      name: "Stake DAO pxETH-stETH Gauge",
      decimals: 18,
      tokenAddress: qD,
    },
    [KD]: {
      token: "pxETH-frxETH-gauge",
      name: "Stake DAO pxETH-frxETH Gauge",
      decimals: 18,
      tokenAddress: KD,
    },
    [XD]: {
      token: "PYUSD-USDC-gauge",
      name: "Stake DAO PYUSD-USDC Gauge",
      decimals: 18,
      tokenAddress: XD,
    },
    [ZD]: {
      token: "ETH-CVG-gauge",
      name: "Stake DAO ETH-CVG Gauge",
      decimals: 18,
      tokenAddress: ZD,
    },
    [YD]: {
      token: "cvgSDT-SDT-gauge",
      name: "Stake DAO cvgSDT-SDT Gauge",
      decimals: 18,
      tokenAddress: YD,
    },
    [ix]: {
      name: "Curve DAO",
      token: "CRV",
      decimals: 18,
      tokenAddress: ix,
      logo: Mbe,
    },
    [KN]: {
      token: "SDT",
      name: "SDT",
      decimals: 18,
      tokenAddress: KN,
      logo: Lbe,
    },
    [sx]: {
      token: "FXS",
      name: "Frax Share",
      decimals: 18,
      tokenAddress: sx,
      logo: "/images/token/FXS.webp",
    },
    [lx]: {
      token: "ANGLE",
      name: "ANGLE",
      decimals: 18,
      tokenAddress: lx,
      logo: "/images/token/ANGLE.webp",
    },
    [ux]: {
      token: "BAL",
      name: "Balancer",
      decimals: 18,
      tokenAddress: ux,
      logo: "/images/token/BAL.webp",
    },
    [hx]: {
      token: "USDC",
      name: "USD Coin",
      decimals: 6,
      tokenAddress: hx,
      logo: "/images/token/USDC.webp",
    },
    [J0]: {
      token: "WETH",
      name: "Wrapped Ether",
      decimals: 18,
      tokenAddress: [J0],
      logo: "/images/token/WETH.webp",
    },
    [ox]: {
      token: "PENDLE",
      name: "Pendle",
      decimals: 18,
      tokenAddress: ox,
      logo: "/images/token/PENDLE.webp",
    },
    [V5]: {
      token: "wstETH",
      name: "Wrapped liquid staked Ether 2.0",
      decimals: 18,
      tokenAddress: V5,
      logo: "/images/token/wstETH.webp",
    },
    [ax]: {
      token: "FIS",
      name: "StaFi",
      decimals: 18,
      tokenAddress: ax,
      logo: "/images/token/FIS.webp",
    },
    [XN]: {
      token: "CNC",
      name: "Conic Finance Token",
      decimals: 18,
      tokenAddress: XN,
      logo: "/images/token/CNC.webp",
    },
    [YN]: {
      token: "LDO",
      name: "Lido DAO Token",
      decimals: 18,
      tokenAddress: YN,
      logo: "/images/token/LDO.webp",
    },
    [QN]: {
      token: "FXN",
      name: "FXN Token",
      decimals: 18,
      tokenAddress: QN,
      logo: "/images/token/FXN.webp",
    },
    [cx]: {
      token: "YFI",
      name: "YFI Token",
      decimals: 18,
      tokenAddress: cx,
      logo: "/images/token/YFI.webp",
    },
    [fx]: {
      token: "APW",
      name: "APW Token",
      decimals: 18,
      tokenAddress: fx,
      logo: "/images/token/APW.webp",
    },
    [wx]: {
      token: "agEUR",
      name: "agEUR",
      decimals: 18,
      tokenAddress: wx,
      logo: "/images/token/agEUR.webp",
    },
    [qN]: {
      token: "CVX",
      name: "Convex",
      decimals: 18,
      tokenAddress: qN,
      logo: "/images/token/CVX.webp",
    },
    [JN]: {
      token: "PRISMA",
      name: "Prisma Governance Token",
      decimals: 18,
      tokenAddress: JN,
      logo: "/images/token/PRISMA.webp",
    },
    [eD]: {
      token: "mkUSD",
      name: "Prisma mkUSD ",
      decimals: 18,
      tokenAddress: eD,
      logo: "/images/token/mkUSD.webp",
    },
    [px]: {
      token: "crvUSD",
      name: "crvUSD",
      decimals: 18,
      tokenAddress: px,
      logo: "/images/token/crvUSD.webp",
    },
    ETH: {
      token: "ETH",
      name: "ETH",
      decimals: 18,
      logo: "/images/token/ETH.webp",
    },
    [tD]: {
      token: "FRAX",
      name: "FRAX",
      decimals: 18,
      tokenAddress: tD,
      logo: "/images/token/FRAX.webp",
    },
    [ZN]: {
      token: "tBTC",
      name: "tBTC",
      decimals: 18,
      tokenAddress: ZN,
      logo: "/images/token/tBTC.webp",
    },
    [hb]: {
      token: "CVG",
      name: "CVG",
      decimals: 18,
      tokenAddress: hb,
      logo: _x,
    },
    [WN]: {
      token: "cvgSDT",
      name: "cvgSDT",
      decimals: 18,
      tokenAddress: WN,
      logo: EG,
    },
    [zR]: { token: "cvxFpis", name: "cvxFpis", decimals: 18, tokenAddress: zR },
    [VR]: {
      token: "stkCvxFpis",
      name: "stkCvxFpis",
      decimals: 18,
      tokenAddress: VR,
    },
    [MR]: { token: "cvxCRV", name: "cvxCRV", decimals: 18, tokenAddress: MR },
    [LR]: {
      token: "stkCvxCRV",
      name: "stkCvxCRV",
      decimals: 18,
      tokenAddress: LR,
    },
    [jR]: { token: "cvxFXN", name: "cvxFXN", decimals: 18, tokenAddress: jR },
    [HR]: {
      token: "stkCvxFXN",
      name: "stkCvxFXN",
      decimals: 18,
      tokenAddress: HR,
    },
    [BR]: { token: "cvxFXX", name: "cvxFXX", decimals: 18, tokenAddress: BR },
    [FR]: {
      token: "stkCvxFXS",
      name: "stkCvxFXS",
      decimals: 18,
      tokenAddress: FR,
    },
    [$R]: {
      token: "cvxPrisma",
      name: "cvxPrisma",
      decimals: 18,
      tokenAddress: $R,
    },
    [UR]: {
      token: "stkCvxPrisma",
      name: "stkCvxPrisma",
      decimals: 18,
      tokenAddress: UR,
    },
    CVG: {
      token: "CVG",
      name: "CVG",
      decimals: 18,
      tokenAddress: hb,
      logo: _x,
    },
    [VN]: {
      token: "cvgCVX",
      name: "cvgCVX",
      decimals: 18,
      tokenAddress: VN,
      logo: Fbe,
    },
    [GN]: {
      token: "CVX1",
      name: "CVX1",
      decimals: 18,
      tokenAddress: GN,
      logo: Bbe,
    },
  };
class Hl {
  bcService = new Td();
  walletTokenInfos = {};
  signer = void 0;
  static Erc20Info = {};
  async doApprove(e, n, r) {
    if (!r) throw new Error("Signer is required");
    return await new kr(e, yp.abi, r).approve(n, bye);
  }
  async doRevoke(e, n, r) {
    if (!r) throw new Error("Signer is required");
    return await new kr(e, yp.abi, r).approve(n, 0n);
  }
  async getBalanceAllowance(e, n) {
    if (!n.length || !e) return [];
    const r = {},
      i = new zm();
    i.addDefaultProcessValueFunc(Vm(r)),
      i.abis.push(yp.abi),
      n.forEach((a) => {
        a.tokenAddress !== dd &&
          a.allowanceAddresses.forEach((o) => {
            this._addERC20TokenListToCallBag(i, e, a.tokenAddress, o);
          });
      }),
      await Gm(i, await this.bcService.getStaticProvider());
    let s = {};
    return (
      n.forEach((a) => {
        const o = r[a.tokenAddress];
        s[a.tokenAddress] = { hasToken: o?.balance > 0n, walletInfo: o };
      }),
      s
    );
  }
  async _addERC20TokenListToCallBag(e, n, r, i) {
    e.addCall("balanceOf", [n], [r, "balance"], r, 0),
      e.addCall("allowance", [n, i], [r, "allowances", i], r, 0);
  }
  async refreshTokenInfos(e, n) {
    (this.walletTokenInfos[e] = this.walletTokenInfos[e] || {}),
      (this.walletTokenInfos[e][n?.token] = null);
    let r = [n];
    return (
      Array.isArray(n?.contract) &&
        ((r = []),
        n.contract.forEach((i) => {
          r.push({ token: n?.token, contract: i });
        })),
      await this.getTokenInfos(e, r),
      this.walletTokenInfos[e][n?.token]
    );
  }
  async getEthBalance(e) {
    if (e)
      return await (await this.bcService.getStaticProvider()).getBalance(e);
  }
  async getTokenInfos(e, n) {
    if (!n || !n.length) return [];
    const r = [],
      i = this.walletTokenInfos[e] ? this.walletTokenInfos[e] : {};
    if (
      (n.forEach((o) => {
        if (!i[o?.token]) {
          r.push(o);
          return;
        }
        o?.contract &&
          (!i[o?.token].allowance || i[o?.token].allowance[o.contract]) &&
          r.push(o);
      }),
      r.length === 0)
    )
      return i;
    const s = new zm();
    await Promise.all(
      r.map(async ({ token: o, contract: l }) => {
        let u = o;
        o === "cvg" && (u = (await oi.getStaticData())?.cvgToken),
          s.addCall("balanceOf", [e], [o, "balanceOf"], u),
          l && s.addCall("allowance", [e, l], [o, "allowance", l], u);
      })
    ),
      s.addDefaultProcessValueFunc(Vm(i)),
      s.abis.push(yp.abi);
    const a = await this.bcService.getStaticProvider();
    return (
      await Gm(s, a),
      r.forEach((o) => {
        this.walletTokenInfos[e]
          ? ((this.walletTokenInfos[e][o?.token] = this.walletTokenInfos[e][
              o?.token
            ] || { allowance: {} }),
            (this.walletTokenInfos[e][o?.token].balanceOf =
              i[o?.token].balanceOf),
            i[o?.token]?.allowance &&
              Object.entries(i[o?.token]?.allowance).forEach(([l, u]) => {
                this.walletTokenInfos[e][o?.token].allowance[l] = u;
              }))
          : ((this.walletTokenInfos[e] = {}),
            (this.walletTokenInfos[e][o?.token] = i[o?.token])),
          (this.walletTokenInfos[e][o?.token] = i[o?.token]);
      }),
      this.walletTokenInfos[e]
    );
  }
  getErc20INfoSync = (e, n) => {
    if (!l8(e)) return;
    if (vp[e]) return vp[e];
    const r = this._getSpecialToken(n, e);
    if (r) return r;
    if (Hl.Erc20Info[e]) return Hl.Erc20Info[e];
  };
  _getSpecialToken = (e, n) => {
    if (n === e.cvgToken)
      return {
        token: "CVG",
        name: "Convergence",
        decimals: 18,
        tokenAddress: hb,
        logo: _x,
      };
  };
  getErc20INfo = async (e) => {
    const n = await oi.getStaticData();
    if (!l8(e)) return;
    if (vp[e]) return vp[e];
    const r = this._getSpecialToken(n, e);
    if (r) return r;
    if (Hl.Erc20Info[e]) return Hl.Erc20Info[e];
    const i = {},
      s = new zm();
    return (
      s.abis.push(yp.abi),
      s.addCall("symbol", [], ["erc20Infos", "token"], e),
      s.addCall("name", [], ["erc20Infos", "name"], e),
      s.addCall("decimals", [], ["erc20Infos", "decimals"], e),
      s.addDefaultProcessValueFunc(Vm(i)),
      await Gm(s, await this.bcService.getStaticProvider()),
      (Hl.Erc20Info[e] = { ...i.erc20Infos, tokenAddress: e }),
      Hl.Erc20Info[e]
    );
  };
  getErc20INfoMultiple = async (e) => {
    const n = new zm(),
      r = await oi.getStaticData(),
      i = (a) => {
        if (!l8(a)) return;
        const o = this._getSpecialToken(r, a);
        return (
          o ||
          (vp[a]
            ? vp[a]
            : Hl.Erc20Info[a]
            ? Hl.Erc20Info[a]
            : (n.addCall("symbol", [], ["erc20Infos", a, "token"], a),
              n.addCall("name", [], ["erc20Infos", a, "name"], a),
              n.addCall("decimals", [], ["erc20Infos", a, "decimals"], a),
              -1))
        );
      };
    let s = e.map(i).filter((a) => a !== -1);
    if (n.calls.length > 0) {
      const a = {};
      n.abis.push(yp.abi),
        n.addDefaultProcessValueFunc(Vm(a)),
        await Gm(n, await this.bcService.getStaticProvider());
      const o = Object.entries(a.erc20Infos).map(([l, u]) => {
        const f = { ...u, tokenAddress: l };
        return (Hl.Erc20Info[l] = f), f;
      });
      s = [...s, ...o];
    }
    return s;
  };
  doApproveLock = async (e) => {
    const n = await oi.getStaticData();
    return this.doApprove(n.cvgToken, n.lockingPositionManager, e);
  };
  addProtectedChain = async () => {
    window?.ethereum &&
      (await window.ethereum.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: "0x1",
            chainName: "Mainnet (Flashbots Protect) ",
            nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
            rpcUrls: ["https://rpc.flashbots.net"],
            blockExplorerUrls: ["https://etherscan.io"],
          },
        ],
      }));
  };
  async calculateGasCost(e) {
    const n = await this.bcService.getStaticProvider(),
      { gasPrice: r } = await n.getFeeData();
    if (!r) return null;
    const s = (await db.getPrices([J0]))[J0],
      a = Number(Eh(r, "gwei")),
      o = (Number(e) * a) / 10 ** 9;
    return { eth: o, usd: o * s };
  }
  async estimateTransaction(e, n, r) {
    let i = 0n;
    try {
      i = await e[n].estimateGas(...r);
    } catch {}
    return i;
  }
  async callContract(e, n, r) {
    return await e[n](...r);
  }
}
const tu = new Hl();
function x1() {
  const [t, e] = Z.useState(!1),
    [{ wallet: n }] = Iz(),
    i = n?.accounts?.at(0)?.address,
    [s, a] = Z.useState(i),
    o = n?.chains?.at(0)?.id,
    l = Number(o) === +"1",
    u = async () => {
      if (tu?.signer) return tu.signer;
      if (n?.provider) {
        const m = await new abe(n.provider).getSigner();
        return (tu.signer = m), m;
      }
    },
    f = async () => await tu.getEthBalance(i),
    d = !!i && o && l;
  return (
    i !== s && (e(!0), a(i)),
    {
      isWellConnected: d,
      address: i,
      hasChange: t,
      getSigner: u,
      getEthBalance: f,
    }
  );
}
function xG(t, e) {
  switch (e.type) {
    case "update":
      return { ...e.data };
    default:
      throw new Error();
  }
}
function uRe(t, e) {
  switch (e.type) {
    case "update":
      return Array.isArray(e.data) ? [...e.data] : { ...e.data };
    default:
      throw new Error();
  }
}
const $h = Qa.createContext(null),
  jbe = ({ children: t }) => {
    const [e, n] = Z.useState({}),
      [r, i] = Z.useState("black:grained");
    Z.useEffect(() => {
      const p =
        (localStorage && localStorage.getItem("cvg-dapp-theme")) ||
        "black:grained";
      i(p);
    }, []),
      Z.useEffect(() => {
        r &&
          (r.includes("black")
            ? document.body.classList.remove("blue", "dark-gray")
            : r.includes("blue")
            ? (document.body.classList.remove("dark-gray"),
              document.body.classList.add("blue"))
            : r.includes("dark-gray") &&
              (document.body.classList.remove("blue"),
              document.body.classList.add("dark-gray")));
      }, [r]);
    const s = (p, m) => {
        p || (p = r.split(":")?.at(0));
        const g = `${p}:${m ? "grained" : "nograin"}`;
        localStorage && localStorage.setItem("cvg-dapp-theme", g), i(g);
      },
      a = async (p, m) => {
        if (typeof p == "string") {
          u(p);
          return;
        }
        o(),
          p
            .wait()
            .then((g) => {
              g &&
                g.blockNumber &&
                (l(!0, g?.transactionHash), typeof m == "function" && m());
            })
            .catch(() => {
              l(!1);
            });
      },
      o = () => {
        n({ type: "warn", tx: !0 });
      },
      l = (p, m) => {
        const g = {}.VITE_ADDRESS_EXPLORER_TX;
        let w = p ? "Transaction succeed" : "Transaction failed";
        g &&
          m &&
          (w = G.jsxs("div", {
            children: [
              G.jsx("span", { children: w }),
              G.jsx("div", {
                className: "mt-2",
                children: G.jsx("a", {
                  href: `${g}/${m}`,
                  target: "_blank",
                  rel: "noreferrer",
                  children: "View on explorer",
                }),
              }),
            ],
          })),
          n({ message: w, type: p ? "success" : "error", tx: !0 });
      },
      u = (p) => {
        typeof p == "object" &&
          (console.error(p), (p = p?.reason || p?.message || "error")),
          n({ message: p, type: "error" });
      },
      d = {
        theme: r,
        updateTheme: s,
        notify: e,
        notifyError: u,
        notifySuccess: (p) => {
          n({ message: p, type: "success" });
        },
        notifyBeginTransaction: o,
        notifyEndTransaction: l,
        handleTransaction: a,
        addProtectedChain: async () => {
          await tu.addProtectedChain();
        },
      };
    return G.jsx($h.Provider, { value: d, children: t });
  },
  Hbe = "hh-sol-artifact-1",
  zbe = "CvgRewardsV2",
  Vbe = "contracts/Rewards/CvgRewardsV2.sol",
  Gbe = [
    { anonymous: !1, inputs: [], name: "Checkpoints", type: "event" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgCycle",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalGaugeWeight",
          type: "uint256",
        },
        {
          components: [
            { internalType: "address", name: "gauge", type: "address" },
            {
              internalType: "uint256",
              name: "cvgDistributed",
              type: "uint256",
            },
            { internalType: "uint256", name: "gaugeWeight", type: "uint256" },
          ],
          indexed: !1,
          internalType: "struct CvgRewardsV2.InflationInfo[]",
          name: "inflationInfos",
          type: "tuple[]",
        },
      ],
      name: "EventChunkWriteStakingRewards",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "cycleId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "adjustment",
          type: "uint256",
        },
      ],
      name: "InflationAdjustment",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgCycle",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalWeight",
          type: "uint256",
        },
      ],
      name: "SetTotalWeight",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "cycleId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "gaugeAddress",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "StakingDistribution",
      type: "event",
    },
    {
      inputs: [],
      name: "END_INFLATION_AMOUNT",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "END_INFLATION_CYCLE",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "INITIAL_CYCLE_INFLATION",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "gaugeAddress", type: "address" },
      ],
      name: "addGauge",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cursor",
      outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgRewardsConfig",
      outputs: [
        {
          internalType: "uint128",
          name: "maxChunkCheckpoint",
          type: "uint128",
        },
        {
          internalType: "uint128",
          name: "maxChunkDistribute",
          type: "uint128",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "firstCycleStartTimestamp",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "gaugeController",
      outputs: [
        {
          internalType: "contract IGaugeController",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "gauges",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "gaugesId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "gaugesLength",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "timestamp", type: "uint256" }],
      name: "getCycleLocking",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "from", type: "uint256" },
        { internalType: "uint256", name: "to", type: "uint256" },
      ],
      name: "getGaugeChunk",
      outputs: [
        {
          components: [
            { internalType: "string", name: "symbol", type: "string" },
            {
              internalType: "address",
              name: "stakingAddress",
              type: "address",
            },
            { internalType: "uint256", name: "weight", type: "uint256" },
            { internalType: "uint256", name: "typeWeight", type: "uint256" },
            { internalType: "int128", name: "gaugeType", type: "int128" },
          ],
          internalType: "struct CvgRewardsV2.GaugeView[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "inflationRatio",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lastTotalWeight",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lastUpdatedTimestamp",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "lastWeights",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "gaugeAddress", type: "address" },
      ],
      name: "removeGauge",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_inflationRatio", type: "uint256" },
      ],
      name: "setInflationRatio",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint128",
              name: "maxChunkCheckpoint",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "maxChunkDistribute",
              type: "uint128",
            },
          ],
          internalType: "struct CvgRewardsV2.CvgRewardsConfig",
          name: "newConfig",
          type: "tuple",
        },
      ],
      name: "setMaxChunkConfigs",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "stakingCycle", type: "uint256" },
      ],
      name: "stakingInflationAtCycle",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "state",
      outputs: [
        { internalType: "enum CvgRewardsV2.State", name: "", type: "uint8" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "stepAmount", type: "uint256" },
      ],
      name: "writeStakingRewards",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Wbe = { _format: Hbe, contractName: zbe, sourceName: Vbe, abi: Gbe };
class qbe {
  bcService = new Td();
  _toHoursAndMinutes(e) {
    const n = Math.trunc(e / 86400);
    if (n >= 1) {
      const r = Math.trunc((e / 3600 + 24) % 24);
      return `${n} days, ${r} hours`;
    } else {
      const r = Math.trunc(e / 60),
        i = Math.trunc(r / 60),
        s = r % 60;
      return `${i} hrs, ${s} mins`;
    }
  }
  async getNextDistributionDuration(e, n) {
    const r = new kr(
        e.cvgRewards,
        Wbe.abi,
        await this.bcService.getStaticProvider()
      ),
      i = Number(await r.lastUpdatedTimestamp()),
      s = (await (await this.bcService.getStaticProvider()).getBlock())
        .timestamp;
    return gbe(Number(n), i, s);
  }
}
const Kbe = new qbe(),
  Xbe = "hh-sol-artifact-1",
  Zbe = "BondDepositoryV2",
  Ybe = "contracts/Bond/BondDepositoryV2.sol",
  Qbe = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              components: [
                {
                  internalType: "enum IBondStruct.BondFunction",
                  name: "composedFunction",
                  type: "uint8",
                },
                { internalType: "address", name: "token", type: "address" },
                { internalType: "uint40", name: "gamma", type: "uint40" },
                {
                  internalType: "uint40",
                  name: "bondDuration",
                  type: "uint40",
                },
                { internalType: "bool", name: "isPaused", type: "bool" },
                { internalType: "uint32", name: "scale", type: "uint32" },
                { internalType: "uint24", name: "minRoi", type: "uint24" },
                { internalType: "uint24", name: "maxRoi", type: "uint24" },
                {
                  internalType: "uint24",
                  name: "percentageOneTx",
                  type: "uint24",
                },
                { internalType: "uint32", name: "vestingTerm", type: "uint32" },
                { internalType: "uint80", name: "cvgToSell", type: "uint80" },
                {
                  internalType: "uint40",
                  name: "startBondTimestamp",
                  type: "uint40",
                },
              ],
              internalType: "struct IBondStruct.BondParams",
              name: "bondParams",
              type: "tuple",
            },
            { internalType: "bool", name: "isLockMandatory", type: "bool" },
          ],
          indexed: !1,
          internalType: "struct IBondStruct.BondCreateStruct[]",
          name: "bondParams",
          type: "tuple[]",
        },
      ],
      name: "BondCreated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "bondId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDeposited",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDepositedUsd",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgMinted",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "vestingEnd",
          type: "uint256",
        },
      ],
      name: "BondDeposit",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "bondId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDeposited",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgMinted",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDepositedUsd",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenIdLock",
          type: "uint256",
        },
      ],
      name: "BondDepositToLock",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "payout", type: "uint256" },
            { internalType: "uint256", name: "vestingLeft", type: "uint256" },
          ],
          indexed: !1,
          internalType: "struct BondDepositoryV2.RedeemEventStruct[]",
          name: "redeemData",
          type: "tuple[]",
        },
      ],
      name: "BondRedeemed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "WETH",
      outputs: [{ internalType: "contract IWETH", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "bondParams",
      outputs: [
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "composedFunction",
          type: "uint8",
        },
        { internalType: "address", name: "token", type: "address" },
        { internalType: "uint40", name: "gamma", type: "uint40" },
        { internalType: "uint40", name: "bondDuration", type: "uint40" },
        { internalType: "bool", name: "isPaused", type: "bool" },
        { internalType: "uint32", name: "scale", type: "uint32" },
        { internalType: "uint24", name: "minRoi", type: "uint24" },
        { internalType: "uint24", name: "maxRoi", type: "uint24" },
        { internalType: "uint24", name: "percentageOneTx", type: "uint24" },
        { internalType: "uint32", name: "vestingTerm", type: "uint32" },
        { internalType: "uint80", name: "cvgToSell", type: "uint80" },
        { internalType: "uint40", name: "startBondTimestamp", type: "uint40" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "bondPositionManager",
      outputs: [
        {
          internalType: "contract IBondPositionManager",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              components: [
                {
                  internalType: "enum IBondStruct.BondFunction",
                  name: "composedFunction",
                  type: "uint8",
                },
                { internalType: "address", name: "token", type: "address" },
                { internalType: "uint40", name: "gamma", type: "uint40" },
                {
                  internalType: "uint40",
                  name: "bondDuration",
                  type: "uint40",
                },
                { internalType: "bool", name: "isPaused", type: "bool" },
                { internalType: "uint32", name: "scale", type: "uint32" },
                { internalType: "uint24", name: "minRoi", type: "uint24" },
                { internalType: "uint24", name: "maxRoi", type: "uint24" },
                {
                  internalType: "uint24",
                  name: "percentageOneTx",
                  type: "uint24",
                },
                { internalType: "uint32", name: "vestingTerm", type: "uint32" },
                { internalType: "uint80", name: "cvgToSell", type: "uint80" },
                {
                  internalType: "uint40",
                  name: "startBondTimestamp",
                  type: "uint40",
                },
              ],
              internalType: "struct IBondStruct.BondParams",
              name: "bondParams",
              type: "tuple",
            },
            { internalType: "bool", name: "isLockMandatory", type: "bool" },
          ],
          internalType: "struct IBondStruct.BondCreateStruct[]",
          name: "_bondCreateParams",
          type: "tuple[]",
        },
      ],
      name: "createBond",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cvg",
      outputs: [{ internalType: "contract ICvg", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "cvgSold",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "bondId", type: "uint256" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "amountIn", type: "uint256" },
        { internalType: "uint256", name: "cvgAmountOutMin", type: "uint256" },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "deposit",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "bondId", type: "uint256" },
        { internalType: "uint256", name: "amountIn", type: "uint256" },
        { internalType: "uint96", name: "cvgAmountOutMin", type: "uint96" },
        { internalType: "uint256", name: "lockTokenId", type: "uint256" },
        { internalType: "uint24", name: "duration", type: "uint24" },
        { internalType: "uint8", name: "ysPercentage", type: "uint8" },
      ],
      name: "depositAndLock",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "bondId", type: "uint256" },
        {
          components: [
            {
              internalType: "enum IBondStruct.BondFunction",
              name: "composedFunction",
              type: "uint8",
            },
            { internalType: "address", name: "token", type: "address" },
            { internalType: "uint40", name: "gamma", type: "uint40" },
            { internalType: "uint40", name: "bondDuration", type: "uint40" },
            { internalType: "bool", name: "isPaused", type: "bool" },
            { internalType: "uint32", name: "scale", type: "uint32" },
            { internalType: "uint24", name: "minRoi", type: "uint24" },
            { internalType: "uint24", name: "maxRoi", type: "uint24" },
            { internalType: "uint24", name: "percentageOneTx", type: "uint24" },
            { internalType: "uint32", name: "vestingTerm", type: "uint32" },
            { internalType: "uint80", name: "cvgToSell", type: "uint80" },
            {
              internalType: "uint40",
              name: "startBondTimestamp",
              type: "uint40",
            },
          ],
          internalType: "struct IBondStruct.BondParams",
          name: "_bondParams",
          type: "tuple",
        },
      ],
      name: "depositRoi",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
      ],
      name: "getBondInfosPerTokenIds",
      outputs: [
        {
          components: [
            { internalType: "uint128", name: "lastTimestamp", type: "uint128" },
            { internalType: "uint128", name: "vestingEnd", type: "uint128" },
            { internalType: "uint256", name: "claimableCvg", type: "uint256" },
            { internalType: "uint256", name: "leftClaimable", type: "uint256" },
          ],
          internalType: "struct IBondStruct.BondTokenView[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "from", type: "uint256" },
        { internalType: "uint256", name: "to", type: "uint256" },
      ],
      name: "getBondViews",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "actualRoi", type: "uint256" },
            {
              internalType: "uint256",
              name: "cvgAlreadySold",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "usdExecutionPrice",
              type: "uint256",
            },
            { internalType: "uint256", name: "usdLimitPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "assetBondPrice",
              type: "uint256",
            },
            { internalType: "uint256", name: "usdBondPrice", type: "uint256" },
            { internalType: "bool", name: "isOracleValid", type: "bool" },
            {
              components: [
                {
                  internalType: "enum IBondStruct.BondFunction",
                  name: "composedFunction",
                  type: "uint8",
                },
                { internalType: "address", name: "token", type: "address" },
                { internalType: "uint40", name: "gamma", type: "uint40" },
                {
                  internalType: "uint40",
                  name: "bondDuration",
                  type: "uint40",
                },
                { internalType: "bool", name: "isPaused", type: "bool" },
                { internalType: "uint32", name: "scale", type: "uint32" },
                { internalType: "uint24", name: "minRoi", type: "uint24" },
                { internalType: "uint24", name: "maxRoi", type: "uint24" },
                {
                  internalType: "uint24",
                  name: "percentageOneTx",
                  type: "uint24",
                },
                { internalType: "uint32", name: "vestingTerm", type: "uint32" },
                { internalType: "uint80", name: "cvgToSell", type: "uint80" },
                {
                  internalType: "uint40",
                  name: "startBondTimestamp",
                  type: "uint40",
                },
              ],
              internalType: "struct IBondStruct.BondParams",
              name: "bondParameters",
              type: "tuple",
            },
            {
              components: [
                { internalType: "string", name: "token", type: "string" },
                {
                  internalType: "address",
                  name: "tokenAddress",
                  type: "address",
                },
                { internalType: "uint256", name: "decimals", type: "uint256" },
              ],
              internalType: "struct IBondStruct.ERC20View",
              name: "token",
              type: "tuple",
            },
            { internalType: "bool", name: "isLockingMandatory", type: "bool" },
          ],
          internalType: "struct IBondStruct.BondViewV2[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getTokenVestingInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "term", type: "uint256" },
            { internalType: "uint256", name: "claimable", type: "uint256" },
            { internalType: "uint256", name: "pending", type: "uint256" },
          ],
          internalType: "struct IBondStruct.TokenVestingInfo",
          name: "vestingInfos",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "isLockedMandatory",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionService",
      outputs: [
        {
          internalType: "contract ILockingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextBondId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "pendingPayoutFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "percentVestedFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "positionInfos",
      outputs: [
        { internalType: "uint64", name: "lastTimestamp", type: "uint64" },
        { internalType: "uint64", name: "vestingTimeLeft", type: "uint64" },
        { internalType: "uint128", name: "leftClaimable", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
        { internalType: "address", name: "recipient", type: "address" },
      ],
      name: "redeem",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "bondIds", type: "uint256[]" },
      ],
      name: "togglePause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "uint256", name: "bondId", type: "uint256" },
            {
              internalType: "enum IBondStruct.BondFunction",
              name: "composedFunction",
              type: "uint8",
            },
            { internalType: "uint24", name: "percentageOneTx", type: "uint24" },
            { internalType: "uint24", name: "minRoi", type: "uint24" },
            { internalType: "uint24", name: "maxRoi", type: "uint24" },
          ],
          internalType: "struct BondDepositoryV2.UpdateBondParams[]",
          name: "_updateBondParams",
          type: "tuple[]",
        },
      ],
      name: "updateBondParams",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IERC20[]",
          name: "_erc20s",
          type: "address[]",
        },
      ],
      name: "withdrawTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Jbe = { _format: Xbe, contractName: Zbe, sourceName: Ybe, abi: Qbe },
  e5e = "hh-sol-artifact-1",
  t5e = "BondPositionManager",
  n5e = "contracts/Bond/BondPositionManager.sol",
  r5e = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "BUFFER",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "bondDepository",
      outputs: [
        { internalType: "contract IBondDepository", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "bondPerTokenId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "checkTokenRedeem",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
      ],
      name: "getBondIdsOfTokens",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "logoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "termTimestamp", type: "uint256" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct IBondLogo.LogoInfos",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "maxLockingTime",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "bondId", type: "uint256" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "mintOrCheck",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "baseURI_", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IBondDepository",
          name: "_bondDepository",
          type: "address",
        },
      ],
      name: "setBondDepository",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "timestamp", type: "uint256" },
      ],
      name: "setLock",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "newMaxLockingTime", type: "uint256" },
      ],
      name: "setMaxLockingTime",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "unlockingTimestampPerToken",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  TG = { _format: e5e, contractName: t5e, sourceName: n5e, abi: r5e },
  i5e = "hh-sol-artifact-1",
  s5e = "Cvg",
  a5e = "contracts/Token/Cvg.sol",
  o5e = [
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
        { internalType: "address", name: "_vestingCvg", type: "address" },
        { internalType: "address", name: "_airdrop", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "MAX_AIRDROP",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_BOND",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_STAKING",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_VESTING",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "airdrop",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "subtractedValue", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "addedValue", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "mintAirdrop",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "mintBond",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "mintStaking",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "mintedAirdrop",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "mintedBond",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "mintedStaking",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  l5e = { _format: i5e, contractName: s5e, sourceName: a5e, abi: o5e },
  u5e = "hh-sol-artifact-1",
  c5e = "BondCalculator",
  f5e = "contracts/Bond/BondCalculator.sol",
  d5e = [
    {
      inputs: [],
      name: "TEN_POWER_6",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "durationFromStart", type: "uint256" },
        { internalType: "uint256", name: "totalDuration", type: "uint256" },
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "composedFunction",
          type: "uint8",
        },
        { internalType: "uint256", name: "maxCvgToMint", type: "uint256" },
      ],
      name: "computeCvgExpectedUInt",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "durationFromStart", type: "uint256" },
        { internalType: "uint256", name: "totalDuration", type: "uint256" },
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "composedFunction",
          type: "uint8",
        },
        { internalType: "uint256", name: "totalOutToken", type: "uint256" },
        { internalType: "uint256", name: "soldTokenOut", type: "uint256" },
      ],
      name: "computeNtrDivNtc",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "durationFromStart", type: "uint256" },
        { internalType: "uint256", name: "totalDuration", type: "uint256" },
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "composedFunction",
          type: "uint8",
        },
        { internalType: "uint256", name: "totalOutToken", type: "uint256" },
        { internalType: "uint256", name: "amountTokenSold", type: "uint256" },
        { internalType: "uint256", name: "gamma", type: "uint256" },
        { internalType: "uint256", name: "scale", type: "uint256" },
        { internalType: "uint256", name: "minRoi", type: "uint256" },
        { internalType: "uint256", name: "maxRoi", type: "uint256" },
      ],
      name: "computeRoi",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "durationFromStart", type: "uint256" },
        { internalType: "uint256", name: "totalDuration", type: "uint256" },
      ],
      name: "computeTimeRatioUInt",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "pure",
      type: "function",
    },
  ],
  h5e = { _format: u5e, contractName: c5e, sourceName: f5e, abi: d5e },
  p5e = "hh-sol-artifact-1",
  m5e = "BondInfo",
  g5e = "contracts/chainView/BondInfo.sol",
  y5e = [
    {
      inputs: [
        { internalType: "address", name: "_wallet", type: "address" },
        {
          internalType: "contract IBondPositionManager",
          name: "_bondPositionManager",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "bondId", type: "uint256" },
            {
              components: [
                {
                  internalType: "uint128",
                  name: "lastTimestamp",
                  type: "uint128",
                },
                {
                  internalType: "uint128",
                  name: "vestingEnd",
                  type: "uint128",
                },
                {
                  internalType: "uint256",
                  name: "claimableCvg",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "leftClaimable",
                  type: "uint256",
                },
              ],
              internalType: "struct IBondStruct.BondTokenView",
              name: "bondTokenInfo",
              type: "tuple",
            },
          ],
          internalType: "struct BondTokenInfo[]",
          name: "bondInfos",
          type: "tuple[]",
        },
      ],
      name: "BondTokenInfosError",
      type: "error",
    },
  ],
  v5e =
    "0x608060405234801561001057600080fd5b506040516107b03803806107b083398101604081905261002f9161047c565b6100398282610040565b5050610763565b6000816001600160a01b031663bbf8ff046040518163ffffffff1660e01b8152600401602060405180830381865afa158015610080573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100a491906104b6565b604051633f28890160e11b81526001600160a01b038581166004830152919250600091841690637e51120290602401600060405180830381865afa1580156100f0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526101189190810190610520565b9050600081516001600160401b03811115610135576101356104da565b60405190808252806020026020018201604052801561016e57816020015b61015b610409565b8152602001906001900390816101535790505b50905060005b82518110156103e4576000846001600160a01b03166317893e3c8584815181106101a0576101a06105c5565b60200260200101516040518263ffffffff1660e01b81526004016101c691815260200190565b606060405180830381865afa1580156101e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020791906105f7565b90506040518060600160405280858481518110610226576102266105c5565b60200260200101518152602001876001600160a01b031663841b1a24878681518110610254576102546105c5565b60200260200101516040518263ffffffff1660e01b815260040161027a91815260200190565b602060405180830381865afa158015610297573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102bb9190610670565b8152602001604051806080016040528084600001516001600160401b03166001600160801b03168152602001846020015185600001516102fb919061069f565b6001600160401b03166001600160801b03168152602001886001600160a01b031663a44fd671898881518110610333576103336105c5565b60200260200101516040518263ffffffff1660e01b815260040161035991815260200190565b602060405180830381865afa158015610376573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039a9190610670565b815260200184604001516001600160801b03168152508152508383815181106103c5576103c56105c5565b60200260200101819052505080806103dc906106c6565b915050610174565b5080604051631a7d1c9b60e21b815260040161040091906106df565b60405180910390fd5b6040518060600160405280600081526020016000815260200161045f604051806080016040528060006001600160801b0316815260200160006001600160801b0316815260200160008152602001600081525090565b905290565b6001600160a01b038116811461047957600080fd5b50565b6000806040838503121561048f57600080fd5b825161049a81610464565b60208401519092506104ab81610464565b809150509250929050565b6000602082840312156104c857600080fd5b81516104d381610464565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715610518576105186104da565b604052919050565b6000602080838503121561053357600080fd5b82516001600160401b038082111561054a57600080fd5b818501915085601f83011261055e57600080fd5b815181811115610570576105706104da565b8060051b91506105818483016104f0565b818152918301840191848101908884111561059b57600080fd5b938501935b838510156105b9578451825293850193908501906105a0565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b80516001600160401b03811681146105f257600080fd5b919050565b60006060828403121561060957600080fd5b604051606081016001600160401b038111828210171561062b5761062b6104da565b604052610637836105db565b8152610645602084016105db565b602082015260408301516001600160801b038116811461066457600080fd5b60408201529392505050565b60006020828403121561068257600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6001600160401b038181168382160190808211156106bf576106bf610689565b5092915050565b6000600182016106d8576106d8610689565b5060010190565b602080825282518282018190526000919060409081850190868401855b8281101561075657815180518552868101518786015285015180516001600160801b03908116878701528188015116606080870191909152818701516080870152015160a085015260c090930192908501906001016106fc565b5091979650505050505050565b603f806107716000396000f3fe6080604052600080fdfea2646970667358221220cbc9adab238b19219003c2e21ca9d0a7a960a919f691d53f4bcff401bfbe1c4464736f6c63430008110033",
  b5e =
    "0x6080604052600080fdfea2646970667358221220cbc9adab238b19219003c2e21ca9d0a7a960a919f691d53f4bcff401bfbe1c4464736f6c63430008110033",
  w5e = {},
  _5e = {},
  w8 = {
    _format: p5e,
    contractName: m5e,
    sourceName: g5e,
    abi: y5e,
    bytecode: v5e,
    deployedBytecode: b5e,
    linkReferences: w5e,
    deployedLinkReferences: _5e,
  },
  _8 = +"5" || 0,
  E5e = 10;
class x5e {
  bcService = new Td();
  async getBondList() {
    try {
      const e = await oi.getCurrentBlock();
      return (
        await (
          await this._getBondDepositoryContract(
            await this.bcService.getStaticProvider()
          )
        ).getBondViews(_8, _8 + E5e)
      )
        .toArray()
        .map((i, s) =>
          this._addIndicatorToBond(
            {
              ...i.toObject(),
              bondParameters: { ...i.bondParameters.toObject() },
              token: { ...i.token.toObject() },
              bondId: _8 + s,
            },
            e
          )
        );
    } catch (e) {
      if (e.reason === "FROM_GREAT_THAN_NEXTID") return [];
      throw e;
    }
  }
  _addIndicatorToBond(e, n) {
    return (
      (e.bondEndTimestamp =
        Number(e.bondParameters.startBondTimestamp) +
        Number(e.bondParameters.bondDuration)),
      (e.startBondTimestamp = Number(e.bondParameters.startBondTimestamp)),
      (e.availableCvg = v0(e.bondParameters.cvgToSell - e.cvgAlreadySold, 18)),
      (e.vestingDays = parseInt(e?.bondParameters?.vestingTerm) / 86400),
      (e.isOver =
        (!!n?.timestamp && n.timestamp > e.bondEndTimestamp) ||
        e.availableCvg < 10),
      (e.isWethBond = e.token.tokenAddress === J0),
      e
    );
  }
  async getBondData(e) {
    const n = await oi.getCurrentBlock();
    return (
      (
        await (
          await this._getBondDepositoryContract(
            await this.bcService.getStaticProvider()
          )
        ).getBondViews(e, e)
      )
        .map((a) => this._addIndicatorToBond({ ...a.toObject(), bondId: e }, n))
        ?.at(0) || void 0
    );
  }
  async getTokenIds(e) {
    const n = await this.bcService.getStaticProvider();
    return (
      await (
        await this._getBondPositionManagerContract(n)
      ).getTokenIdsForWallet(e)
    ).toArray();
  }
  async getNftData(e) {
    const n = await this.getTokenIds(e);
    return this.getNftDataByTokens(n);
  }
  async getNftDataChainView(e) {
    const n = await oi.getStaticData(),
      r = [e, n.bondPositionManager],
      i = await this.bcService.getStaticProvider(),
      s = new eu(w8.abi),
      o = await new Ly(w8.abi, w8.bytecode).getDeployTransaction(...r);
    let l;
    try {
      await i.estimateGas(o);
    } catch (u) {
      const f = u.error.body;
      l = JSON.parse(f).error.data;
    }
    return s.parseError(l.data);
  }
  async getNftDataByTokens(e) {
    const n = await this.bcService.getStaticProvider(),
      r = await this._getBondDepositoryContract(n),
      s = (await this._getBondPositionManagerContract(n)).getBondIdsOfTokens(e),
      a = r.getBondInfosPerTokenIds(e),
      [o, l] = await Promise.all([s, a]),
      u = [];
    return (
      e.forEach((f, c) => {
        u.push({
          ...l[c].toObject(),
          tokenId: Number(f),
          endTime: Number(l[c].vestingEnd),
          bondId: Number(o[c]),
          claimable: v0(l[c].claimableCvg, 18),
          leftClaimable: v0(l[c].leftClaimable, 18),
        });
      }),
      u
    );
  }
  async _getBondPositionManagerContract(e) {
    const { bondPositionManager: n } = await oi.getStaticData();
    return new kr(n, TG.abi, e);
  }
  async _getBondDepositoryContract(e) {
    const { bondDepository: n } = await oi.getStaticData();
    return new kr(n, Jbe.abi, e);
  }
  _getBondCalculatorContract(e, n) {
    return new kr(e, h5e.abi, n);
  }
  sortList(e) {
    return (n, r) => {
      switch (e?.sort) {
        case "price":
          return (
            (Number(n.actualRoi) - Number(r.actualRoi)) *
            (e?.sortDirection || 1)
          );
        case "roi":
          return (
            (Number(n.actualRoi) - Number(r.actualRoi)) *
            (e?.sortDirection || 1) *
            -1
          );
        case "timeleft":
          return (
            (n.bondEndTimestamp - r.bondEndTimestamp) * (e?.sortDirection || 1)
          );
        case "available":
          return (n.availableCvg - r.availableCvg) * (e?.sortDirection || 1);
        case "vesting":
          return (n.vestingDays - r.vestingDays) * (e?.sortDirection || 1);
        default:
          return 0;
      }
    };
  }
  stables = ["FRAX", "DAI"];
  filterList(e, n) {
    if (
      (n?.keyword &&
        (e = e.filter((r) =>
          r?.token.token.toLowerCase().includes(n?.keyword?.toLowerCase())
        )),
      n?.category && n.category !== "All")
    ) {
      const r = n.category === "Stable",
        i = (s) =>
          r
            ? this.stables.includes(s.token.token.toUpperCase())
            : !this.stables.includes(s.token.token.toUpperCase());
      e = e.filter(i);
    }
    return e;
  }
  async getBondHeader(e) {
    const n = new kr(
        (await oi.getStaticData()).cvgToken,
        l5e.abi,
        await this.bcService.getStaticProvider()
      ),
      r = Number(ri(await n.MAX_BOND())) || "-",
      i = await (
        await fetch(`https://api.cvg.finance//bonds/header/${e || dd}`)
      ).json(),
      s = Number(ri(i?.globalCvgBonded)),
      a = Number(ri(i?.globalCvgRedeemed)),
      o = Number(ri(BigInt(i?.globalCvgBonded) - BigInt(i?.globalLocked)));
    let l = ((s / r) * 100).toFixed(1);
    l = l || "-";
    let u = ((a / s) * 100).toFixed(1);
    u = !u || isNaN(u) ? "-" : u;
    const f = `${al(s)} / ${al(r)} (${l} %)`,
      c = `${al(a)} / ${al(o)} (${u} %)`;
    return {
      userCvgRedeem: isNaN(i.userTotalRedeem) ? "-" : al(ri(i.userTotalRedeem)),
      userAssetDeposited: isNaN(i.userAssetDeposited)
        ? "-"
        : al(ri(i.userAssetDeposited)),
      userStablecoinDeposited: isNaN(i.userStablecoinDeposited)
        ? "-"
        : al(ri(i.userStablecoinDeposited)),
      userTotalDeposited: isNaN(i.userTotalDeposited)
        ? "-"
        : al(ri(i.userTotalDeposited)),
      globalCvgBonded: s,
      globalCvgRedeemed: a,
      percentageTotalBonded: l,
      percentageTotalRedeem: u,
      totalCvgBondedString: f,
      totalCvgRedeemedString: c,
    };
  }
  async doDeposit(e, n, r, i, s, a) {
    const o = a ? r : 0n;
    return (
      (r = a ? 0n : r),
      await (
        await this._getBondDepositoryContract(s)
      ).deposit(e, n, r, i, s.getAddress(), { value: o })
    );
  }
  async doRedeem(e, n, r) {
    return await (await this._getBondDepositoryContract(r)).redeem(e, n);
  }
  getCvgAmountOutMin(e, n) {
    return e - (e * n) / 100;
  }
  async doBondAndLock(e, n, r, i, s, a, o, l) {
    const u = await this._getBondDepositoryContract(o),
      f = l ? r : 0n;
    return (
      (r = l ? 0n : r), await u.depositAndLock(e, r, a, n, i, s, { value: f })
    );
  }
}
const T5e = new x5e(),
  S5e = "hh-sol-artifact-1",
  A5e = "NotificationChainview",
  C5e = "contracts/ChainView/NotificationChainview.sol",
  k5e = [
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256[]",
              name: "checkInNeeded",
              type: "uint256[]",
            },
          ],
          internalType: "struct Notification",
          name: "infos",
          type: "tuple",
        },
      ],
      name: "NotificationError",
      type: "error",
    },
  ],
  I5e =
    "0x608060405234801561000f575f80fd5b506040516103d63803806103d683398101604081905261002e9161020c565b6100378161003d565b5061038c565b604051633f28890160e11b81526001600160a01b03821660048201525f90730edb88aa3aa665782121fa2509b382f414a0c0ce90637e511202906024015f60405180830381865afa158015610094573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526100bb919081019061024d565b80519091505f816001600160401b038111156100d9576100d9610239565b604051908082528060200260200182016040528015610102578160200160208202803683370190505b5090505f805b838110156101dc575f85828151811061012357610123610305565b6020026020010151905073660a45986e9b8f60c41aadebd2941724200fbcf86001600160a01b031663e95a644f826040518263ffffffff1660e01b815260040161016f91815260200190565b5f604051808303815f87803b158015610186575f80fd5b505af1925050508015610197575060015b6101a757600184510384526101d3565b808484815181106101ba576101ba610305565b6020908102919091010152826101cf81610319565b9350505b50600101610108565b50604080516020810182528381529051632d56d32960e01b8152610203919060040161033d565b60405180910390fd5b5f6020828403121561021c575f80fd5b81516001600160a01b0381168114610232575f80fd5b9392505050565b634e487b7160e01b5f52604160045260245ffd5b5f602080838503121561025e575f80fd5b82516001600160401b0380821115610274575f80fd5b818501915085601f830112610287575f80fd5b81518181111561029957610299610239565b8060051b604051601f19603f830116810181811085821117156102be576102be610239565b6040529182528482019250838101850191888311156102db575f80fd5b938501935b828510156102f9578451845293850193928501926102e0565b98975050505050505050565b634e487b7160e01b5f52603260045260245ffd5b5f6001820161033657634e487b7160e01b5f52601160045260245ffd5b5060010190565b602080825282518282018290528051604084018190525f9291820190839060608601905b808310156103815783518252928401926001929092019190840190610361565b509695505050505050565b603e806103985f395ff3fe60806040525f80fdfea264697066735822122054881b7c6fbd1586a1f7303d8f7dfc94c4bbd907e2569debab0bca5dd5486a1564736f6c63430008180033",
  O5e =
    "0x60806040525f80fdfea264697066735822122054881b7c6fbd1586a1f7303d8f7dfc94c4bbd907e2569debab0bca5dd5486a1564736f6c63430008180033",
  P5e = {},
  N5e = {},
  E8 = {
    _format: S5e,
    contractName: A5e,
    sourceName: C5e,
    abi: k5e,
    bytecode: I5e,
    deployedBytecode: O5e,
    linkReferences: P5e,
    deployedLinkReferences: N5e,
  };
class D5e {
  bcService = new Td();
  async getNotificationData(e) {
    const n = [e],
      r = new eu(E8.abi),
      s = await new Ly(E8.abi, E8.bytecode).getDeployTransaction(...n);
    return await this.bcService.excuteChainView(
      await this.bcService.getStaticProvider(),
      s,
      r
    );
  }
}
const R5e = new D5e(),
  $y = Z.createContext(null),
  M5e = ({ children: t }) => {
    const { address: e } = x1(),
      [n, r] = Z.useReducer(xG, void 0),
      [i, s] = Z.useState(null),
      [a, o] = Z.useState(null),
      [l, u] = Z.useState({}),
      [f, c] = Z.useState({}),
      [d, p] = Z.useState(void 0),
      [m, g] = Z.useState(0),
      [w, y] = Z.useState(void 0),
      [v, E] = Z.useState(void 0),
      { notifyError: S } = Z.useContext($h),
      [D, P] = Z.useState(void 0),
      x = Z.useCallback(
        async (k) => (
          l[k] === void 0 &&
            a &&
            !a?.loading &&
            (u({ ...l, [k]: { loading: !0 } }),
            T5e.getBondList(a).then((L) => {
              u({ ...l, [k]: L });
            })),
          l[k]
        ),
        []
      ),
      _ = Z.useCallback(
        async (k) => (
          f[k] === void 0 &&
            (c({ ...f, [k]: { loading: !0 } }),
            oi.getStakings(k).then((L) => {
              c({ ...f, [k]: L });
            })),
          f[k]
        ),
        []
      );
    Z.useEffect(() => {
      e &&
        D === void 0 &&
        R5e.getNotificationData(e).then((k) => {
          P(k);
        });
    }, [e, D]);
    const A = () => {
      P(void 0);
    };
    Z.useEffect(() => {
      n === void 0 && T().then(),
        n !== void 0 &&
          !n.loading &&
          i === null &&
          !i?.loading &&
          v &&
          !v?.loading &&
          (s({ loading: !0 }), O().then());
    }, [n, v]),
      Z.useEffect(() => {
        v === void 0 && N();
      }, []),
      Z.useEffect(() => {
        db.getActualCvgPrice().then((L) => {
          p(L);
        });
        const k = setInterval(() => {
          db.getActualCvgPrice().then((L) => {
            p(L);
          });
        }, 6e4);
        return () => clearInterval(k);
      }, []),
      Z.useEffect(() => {
        !m && !w && d && M();
      }, [d]);
    const N = async () => {
        E({ loading: !0 }),
          await oi
            .getActualCycle()
            .then((k) => {
              E(k);
            })
            .catch((k) => {
              S(k);
            });
      },
      M = async () => {
        db.getCvgPrices("1d")
          .then((k) => {
            if (!k?.length) g("nd");
            else {
              let L = "nd";
              if (!isNaN(k[0].price)) {
                const U = parseFloat(k[0].price);
                L = (((d - U) / U) * 100).toFixed(2);
              }
              g(L);
            }
            y(k);
          })
          .catch((k) => {
            S(k);
          });
      },
      T = async () => {
        r({ data: { loading: !0 }, type: "update" }),
          oi
            .getStaticData()
            .then((k) => r({ data: k, type: "update" }))
            .catch((k) => {
              S(k), r({ data: { error: !0 }, type: "update" });
            }),
          await oi.getCurrentBlock().then((k) => {
            o(k);
          });
      },
      O = () =>
        new Promise((k, L) => {
          Kbe.getNextDistributionDuration(n, v)
            .then((U) => {
              s({ data: U, loading: !1 }), k(U);
            })
            .catch((U) => {
              s({ error: !0 }), S(U), L();
            });
        }),
      I = {
        ecosystemInfo: n,
        loadStaticData: T,
        nextDistributionDurations: i,
        loadBonds: x,
        loadStakings: _,
        stakingsPerIntegration: f,
        bondsPerVersion: l,
        currentBlock: a,
        cvgPrice: d,
        cvgPriceProgression: m,
        cvgPriceOneDayDatas: w,
        actualCycle: v,
        notifications: D,
        reloadNotifications: A,
      };
    return G.jsx($y.Provider, { value: I, children: t });
  },
  HT = Z.createContext(null),
  L5e = ({ children: t }) => {
    const { handleTransaction: e, notifyError: n } = Z.useContext($h),
      { ecosystemInfo: r } = Z.useContext($y),
      [i, s] = Z.useReducer(xG, void 0),
      { getSigner: a } = x1(),
      f = {
        walletTokenInfo: i,
        doApprove: async (c, d, p = void 0) => {
          try {
            const m = await a();
            e(await tu.doApprove(c, d, m), () => {
              s({ type: "update", data: {} }), p && p();
            });
          } catch (m) {
            n(m);
          }
        },
        doRevoke: async (c, d) => {
          try {
            const p = await a();
            e(await tu.doRevoke(c, d, p), () => {
              s({ type: "update", data: {} });
            });
          } catch (p) {
            n(p);
          }
        },
        initWalletTokenInfo: async (c) => {
          try {
            const d = { token: "cvg", contract: r.lockingPositionManager };
            await tu.getTokenInfos(c, [d]),
              s({ type: "update", data: tu.walletTokenInfos }),
              await a();
          } catch (d) {
            n(d);
          }
        },
      };
    return G.jsx(HT.Provider, { value: f, children: t });
  };
function GR({ displayDisconnect: t = !1 }) {
  const [{ wallet: e, connecting: n }, r, i] = Iz(),
    [{ chains: s, connectedChain: a }, o] = bme(),
    l = !!(a && s.find((u) => Number(u.id) === Number(a?.id)));
  if (e) {
    if (!l) {
      const u = { wallet: e?.label, chainId: s?.at(0).id };
      return G.jsx("div", {
        children: G.jsx("button", {
          className: "Btn",
          disabled: n,
          onClick: () => o(u),
          children: "Change network",
        }),
      });
    }
    return t
      ? G.jsx("div", {
          children: G.jsx("button", {
            className: "Btn",
            disabled: n,
            onClick: () => i(e),
            children: "Disconnect",
          }),
        })
      : G.jsx(G.Fragment, {});
  }
  return G.jsx("div", {
    children: G.jsx("button", {
      className: "Btn",
      disabled: n,
      onClick: () => r(),
      children: n ? "connecting" : "Connect Wallet",
    }),
  });
}
function B5e() {
  const { isWellConnected: t, address: e } = x1(),
    { walletTokenInfo: n } = Z.useContext(HT);
  let r = 0n;
  n && n[e] && n[e].cvg?.balanceOf && (r = n[e].cvg.balanceOf);
  function i({ children: s }) {
    return G.jsx("div", {
      className: " Panel Panel--noDouble mx-2",
      children: s,
    });
  }
  return t
    ? G.jsx(i, {
        children: G.jsxs("div", {
          className: "flex flex-column gap-2 text-left",
          children: [
            G.jsxs("div", {
              children: [
                "Connected as",
                " ",
                G.jsx("span", {
                  className: "color-tonic inline-block",
                  children: G.jsx(Mg, { size: 6, address: e }),
                }),
              ],
            }),
            G.jsxs("div", {
              children: [
                "Balance: ",
                G.jsx("span", {
                  className: "color-tonic",
                  children: mbe(r, 18),
                }),
                " CVG",
              ],
            }),
            G.jsx("div", { children: G.jsx(GR, { displayDisconnect: !0 }) }),
          ],
        }),
      })
    : G.jsx(i, { children: G.jsx(GR, { displayDisconnect: !0 }) });
}
function G5() {
  return (
    (G5 = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    G5.apply(this, arguments)
  );
}
function zT(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function Ex(t, e) {
  return (
    (Ex = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r;
        }),
    Ex(t, e)
  );
}
function VT(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    Ex(t, e);
}
function F5e(t, e) {
  return t.classList
    ? !!e && t.classList.contains(e)
    : (" " + (t.className.baseVal || t.className) + " ").indexOf(
        " " + e + " "
      ) !== -1;
}
function $5e(t, e) {
  t.classList
    ? t.classList.add(e)
    : F5e(t, e) ||
      (typeof t.className == "string"
        ? (t.className = t.className + " " + e)
        : t.setAttribute(
            "class",
            ((t.className && t.className.baseVal) || "") + " " + e
          ));
}
function WR(t, e) {
  return t
    .replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)", "g"), "$1")
    .replace(/\s+/g, " ")
    .replace(/^\s*|\s*$/g, "");
}
function U5e(t, e) {
  t.classList
    ? t.classList.remove(e)
    : typeof t.className == "string"
    ? (t.className = WR(t.className, e))
    : t.setAttribute(
        "class",
        WR((t.className && t.className.baseVal) || "", e)
      );
}
const qR = { disabled: !1 },
  W5 = Qa.createContext(null);
var SG = function (e) {
    return e.scrollTop;
  },
  Wm = "unmounted",
  zd = "exited",
  Vd = "entering",
  Op = "entered",
  xx = "exiting",
  uf = (function (t) {
    VT(e, t);
    function e(r, i) {
      var s;
      s = t.call(this, r, i) || this;
      var a = i,
        o = a && !a.isMounting ? r.enter : r.appear,
        l;
      return (
        (s.appearStatus = null),
        r.in
          ? o
            ? ((l = zd), (s.appearStatus = Vd))
            : (l = Op)
          : r.unmountOnExit || r.mountOnEnter
          ? (l = Wm)
          : (l = zd),
        (s.state = { status: l }),
        (s.nextCallback = null),
        s
      );
    }
    e.getDerivedStateFromProps = function (i, s) {
      var a = i.in;
      return a && s.status === Wm ? { status: zd } : null;
    };
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (n.componentDidUpdate = function (i) {
        var s = null;
        if (i !== this.props) {
          var a = this.state.status;
          this.props.in
            ? a !== Vd && a !== Op && (s = Vd)
            : (a === Vd || a === Op) && (s = xx);
        }
        this.updateStatus(!1, s);
      }),
      (n.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (n.getTimeouts = function () {
        var i = this.props.timeout,
          s,
          a,
          o;
        return (
          (s = a = o = i),
          i != null &&
            typeof i != "number" &&
            ((s = i.exit),
            (a = i.enter),
            (o = i.appear !== void 0 ? i.appear : a)),
          { exit: s, enter: a, appear: o }
        );
      }),
      (n.updateStatus = function (i, s) {
        if ((i === void 0 && (i = !1), s !== null))
          if ((this.cancelNextCallback(), s === Vd)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var a = this.props.nodeRef
                ? this.props.nodeRef.current
                : Mm.findDOMNode(this);
              a && SG(a);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === zd &&
            this.setState({ status: Wm });
      }),
      (n.performEnter = function (i) {
        var s = this,
          a = this.props.enter,
          o = this.context ? this.context.isMounting : i,
          l = this.props.nodeRef ? [o] : [Mm.findDOMNode(this), o],
          u = l[0],
          f = l[1],
          c = this.getTimeouts(),
          d = o ? c.appear : c.enter;
        if ((!i && !a) || qR.disabled) {
          this.safeSetState({ status: Op }, function () {
            s.props.onEntered(u);
          });
          return;
        }
        this.props.onEnter(u, f),
          this.safeSetState({ status: Vd }, function () {
            s.props.onEntering(u, f),
              s.onTransitionEnd(d, function () {
                s.safeSetState({ status: Op }, function () {
                  s.props.onEntered(u, f);
                });
              });
          });
      }),
      (n.performExit = function () {
        var i = this,
          s = this.props.exit,
          a = this.getTimeouts(),
          o = this.props.nodeRef ? void 0 : Mm.findDOMNode(this);
        if (!s || qR.disabled) {
          this.safeSetState({ status: zd }, function () {
            i.props.onExited(o);
          });
          return;
        }
        this.props.onExit(o),
          this.safeSetState({ status: xx }, function () {
            i.props.onExiting(o),
              i.onTransitionEnd(a.exit, function () {
                i.safeSetState({ status: zd }, function () {
                  i.props.onExited(o);
                });
              });
          });
      }),
      (n.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (n.safeSetState = function (i, s) {
        (s = this.setNextCallback(s)), this.setState(i, s);
      }),
      (n.setNextCallback = function (i) {
        var s = this,
          a = !0;
        return (
          (this.nextCallback = function (o) {
            a && ((a = !1), (s.nextCallback = null), i(o));
          }),
          (this.nextCallback.cancel = function () {
            a = !1;
          }),
          this.nextCallback
        );
      }),
      (n.onTransitionEnd = function (i, s) {
        this.setNextCallback(s);
        var a = this.props.nodeRef
            ? this.props.nodeRef.current
            : Mm.findDOMNode(this),
          o = i == null && !this.props.addEndListener;
        if (!a || o) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var l = this.props.nodeRef
              ? [this.nextCallback]
              : [a, this.nextCallback],
            u = l[0],
            f = l[1];
          this.props.addEndListener(u, f);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (n.render = function () {
        var i = this.state.status;
        if (i === Wm) return null;
        var s = this.props,
          a = s.children;
        s.in,
          s.mountOnEnter,
          s.unmountOnExit,
          s.appear,
          s.enter,
          s.exit,
          s.timeout,
          s.addEndListener,
          s.onEnter,
          s.onEntering,
          s.onEntered,
          s.onExit,
          s.onExiting,
          s.onExited,
          s.nodeRef;
        var o = zT(s, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return Qa.createElement(
          W5.Provider,
          { value: null },
          typeof a == "function"
            ? a(i, o)
            : Qa.cloneElement(Qa.Children.only(a), o)
        );
      }),
      e
    );
  })(Qa.Component);
uf.contextType = W5;
uf.propTypes = {};
function bp() {}
uf.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: bp,
  onEntering: bp,
  onEntered: bp,
  onExit: bp,
  onExiting: bp,
  onExited: bp,
};
uf.UNMOUNTED = Wm;
uf.EXITED = zd;
uf.ENTERING = Vd;
uf.ENTERED = Op;
uf.EXITING = xx;
const j5e = uf;
var H5e = function (e, n) {
    return (
      e &&
      n &&
      n.split(" ").forEach(function (r) {
        return $5e(e, r);
      })
    );
  },
  x8 = function (e, n) {
    return (
      e &&
      n &&
      n.split(" ").forEach(function (r) {
        return U5e(e, r);
      })
    );
  },
  GT = (function (t) {
    VT(e, t);
    function e() {
      for (var r, i = arguments.length, s = new Array(i), a = 0; a < i; a++)
        s[a] = arguments[a];
      return (
        (r = t.call.apply(t, [this].concat(s)) || this),
        (r.appliedClasses = { appear: {}, enter: {}, exit: {} }),
        (r.onEnter = function (o, l) {
          var u = r.resolveArguments(o, l),
            f = u[0],
            c = u[1];
          r.removeClasses(f, "exit"),
            r.addClass(f, c ? "appear" : "enter", "base"),
            r.props.onEnter && r.props.onEnter(o, l);
        }),
        (r.onEntering = function (o, l) {
          var u = r.resolveArguments(o, l),
            f = u[0],
            c = u[1],
            d = c ? "appear" : "enter";
          r.addClass(f, d, "active"),
            r.props.onEntering && r.props.onEntering(o, l);
        }),
        (r.onEntered = function (o, l) {
          var u = r.resolveArguments(o, l),
            f = u[0],
            c = u[1],
            d = c ? "appear" : "enter";
          r.removeClasses(f, d),
            r.addClass(f, d, "done"),
            r.props.onEntered && r.props.onEntered(o, l);
        }),
        (r.onExit = function (o) {
          var l = r.resolveArguments(o),
            u = l[0];
          r.removeClasses(u, "appear"),
            r.removeClasses(u, "enter"),
            r.addClass(u, "exit", "base"),
            r.props.onExit && r.props.onExit(o);
        }),
        (r.onExiting = function (o) {
          var l = r.resolveArguments(o),
            u = l[0];
          r.addClass(u, "exit", "active"),
            r.props.onExiting && r.props.onExiting(o);
        }),
        (r.onExited = function (o) {
          var l = r.resolveArguments(o),
            u = l[0];
          r.removeClasses(u, "exit"),
            r.addClass(u, "exit", "done"),
            r.props.onExited && r.props.onExited(o);
        }),
        (r.resolveArguments = function (o, l) {
          return r.props.nodeRef ? [r.props.nodeRef.current, o] : [o, l];
        }),
        (r.getClassNames = function (o) {
          var l = r.props.classNames,
            u = typeof l == "string",
            f = u && l ? l + "-" : "",
            c = u ? "" + f + o : l[o],
            d = u ? c + "-active" : l[o + "Active"],
            p = u ? c + "-done" : l[o + "Done"];
          return { baseClassName: c, activeClassName: d, doneClassName: p };
        }),
        r
      );
    }
    var n = e.prototype;
    return (
      (n.addClass = function (i, s, a) {
        var o = this.getClassNames(s)[a + "ClassName"],
          l = this.getClassNames("enter"),
          u = l.doneClassName;
        s === "appear" && a === "done" && u && (o += " " + u),
          a === "active" && i && SG(i),
          o && ((this.appliedClasses[s][a] = o), H5e(i, o));
      }),
      (n.removeClasses = function (i, s) {
        var a = this.appliedClasses[s],
          o = a.base,
          l = a.active,
          u = a.done;
        (this.appliedClasses[s] = {}),
          o && x8(i, o),
          l && x8(i, l),
          u && x8(i, u);
      }),
      (n.render = function () {
        var i = this.props;
        i.classNames;
        var s = zT(i, ["classNames"]);
        return Qa.createElement(
          j5e,
          G5({}, s, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited,
          })
        );
      }),
      e
    );
  })(Qa.Component);
GT.defaultProps = { classNames: "" };
GT.propTypes = {};
const z5e = GT;
function V5e(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
function WT(t, e) {
  var n = function (s) {
      return e && Z.isValidElement(s) ? e(s) : s;
    },
    r = Object.create(null);
  return (
    t &&
      Z.Children.map(t, function (i) {
        return i;
      }).forEach(function (i) {
        r[i.key] = n(i);
      }),
    r
  );
}
function G5e(t, e) {
  (t = t || {}), (e = e || {});
  function n(f) {
    return f in e ? e[f] : t[f];
  }
  var r = Object.create(null),
    i = [];
  for (var s in t) s in e ? i.length && ((r[s] = i), (i = [])) : i.push(s);
  var a,
    o = {};
  for (var l in e) {
    if (r[l])
      for (a = 0; a < r[l].length; a++) {
        var u = r[l][a];
        o[r[l][a]] = n(u);
      }
    o[l] = n(l);
  }
  for (a = 0; a < i.length; a++) o[i[a]] = n(i[a]);
  return o;
}
function nh(t, e, n) {
  return n[e] != null ? n[e] : t.props[e];
}
function W5e(t, e) {
  return WT(t.children, function (n) {
    return Z.cloneElement(n, {
      onExited: e.bind(null, n),
      in: !0,
      appear: nh(n, "appear", t),
      enter: nh(n, "enter", t),
      exit: nh(n, "exit", t),
    });
  });
}
function q5e(t, e, n) {
  var r = WT(t.children),
    i = G5e(e, r);
  return (
    Object.keys(i).forEach(function (s) {
      var a = i[s];
      if (Z.isValidElement(a)) {
        var o = s in e,
          l = s in r,
          u = e[s],
          f = Z.isValidElement(u) && !u.props.in;
        l && (!o || f)
          ? (i[s] = Z.cloneElement(a, {
              onExited: n.bind(null, a),
              in: !0,
              exit: nh(a, "exit", t),
              enter: nh(a, "enter", t),
            }))
          : !l && o && !f
          ? (i[s] = Z.cloneElement(a, { in: !1 }))
          : l &&
            o &&
            Z.isValidElement(u) &&
            (i[s] = Z.cloneElement(a, {
              onExited: n.bind(null, a),
              in: u.props.in,
              exit: nh(a, "exit", t),
              enter: nh(a, "enter", t),
            }));
      }
    }),
    i
  );
}
var K5e =
    Object.values ||
    function (t) {
      return Object.keys(t).map(function (e) {
        return t[e];
      });
    },
  X5e = {
    component: "div",
    childFactory: function (e) {
      return e;
    },
  },
  qT = (function (t) {
    VT(e, t);
    function e(r, i) {
      var s;
      s = t.call(this, r, i) || this;
      var a = s.handleExited.bind(V5e(s));
      return (
        (s.state = {
          contextValue: { isMounting: !0 },
          handleExited: a,
          firstRender: !0,
        }),
        s
      );
    }
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (n.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (e.getDerivedStateFromProps = function (i, s) {
        var a = s.children,
          o = s.handleExited,
          l = s.firstRender;
        return { children: l ? W5e(i, o) : q5e(i, a, o), firstRender: !1 };
      }),
      (n.handleExited = function (i, s) {
        var a = WT(this.props.children);
        i.key in a ||
          (i.props.onExited && i.props.onExited(s),
          this.mounted &&
            this.setState(function (o) {
              var l = G5({}, o.children);
              return delete l[i.key], { children: l };
            }));
      }),
      (n.render = function () {
        var i = this.props,
          s = i.component,
          a = i.childFactory,
          o = zT(i, ["component", "childFactory"]),
          l = this.state.contextValue,
          u = K5e(this.state.children).map(a);
        return (
          delete o.appear,
          delete o.enter,
          delete o.exit,
          s === null
            ? Qa.createElement(W5.Provider, { value: l }, u)
            : Qa.createElement(
                W5.Provider,
                { value: l },
                Qa.createElement(s, o, u)
              )
        );
      }),
      e
    );
  })(Qa.Component);
qT.propTypes = {};
qT.defaultProps = X5e;
const Z5e = qT;
function ry(t) {
  "@babel/helpers - typeof";
  return (
    (ry =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    ry(t)
  );
}
function Y5e(t, e) {
  if (ry(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (ry(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Q5e(t) {
  var e = Y5e(t, "string");
  return ry(e) === "symbol" ? e : String(e);
}
function J5e(t, e, n) {
  return (
    (e = Q5e(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function KR(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function T8(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? KR(Object(n), !0).forEach(function (r) {
          J5e(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : KR(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
var Uy = Z.forwardRef(function (t, e) {
  var n = t.disabled || (t.options && t.options.disabled) || !Lr.cssTransition,
    r = function (p, m) {
      t.onEnter && t.onEnter(p, m),
        t.options && t.options.onEnter && t.options.onEnter(p, m);
    },
    i = function (p, m) {
      t.onEntering && t.onEntering(p, m),
        t.options && t.options.onEntering && t.options.onEntering(p, m);
    },
    s = function (p, m) {
      t.onEntered && t.onEntered(p, m),
        t.options && t.options.onEntered && t.options.onEntered(p, m);
    },
    a = function (p) {
      t.onExit && t.onExit(p),
        t.options && t.options.onExit && t.options.onExit(p);
    },
    o = function (p) {
      t.onExiting && t.onExiting(p),
        t.options && t.options.onExiting && t.options.onExiting(p);
    },
    l = function (p) {
      t.onExited && t.onExited(p),
        t.options && t.options.onExited && t.options.onExited(p);
    };
  if (
    (zu(
      function () {
        if (n) {
          var d = Vn.getRefElement(t.nodeRef);
          t.in ? (r(d, !0), i(d, !0), s(d, !0)) : (a(d), o(d), l(d));
        }
      },
      [t.in]
    ),
    n)
  )
    return t.in ? t.children : null;
  var u = {
      nodeRef: t.nodeRef,
      in: t.in,
      onEnter: r,
      onEntering: i,
      onEntered: s,
      onExit: a,
      onExiting: o,
      onExited: l,
    },
    f = {
      classNames: t.classNames,
      timeout: t.timeout,
      unmountOnExit: t.unmountOnExit,
    },
    c = T8(T8(T8({}, f), t.options || {}), u);
  return Z.createElement(z5e, c, t.children);
});
Uy.displayName = "CSSTransition";
Uy.defaultProps = { __TYPE: "CSSTransition" };
var rh = wie();
function Tx() {
  return (
    (Tx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Tx.apply(this, arguments)
  );
}
function ewe(t) {
  if (Array.isArray(t)) return t;
}
function twe(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function XR(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function nwe(t, e) {
  if (t) {
    if (typeof t == "string") return XR(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return XR(t, e);
  }
}
function rwe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ZR(t, e) {
  return ewe(t) || twe(t, e) || nwe(t, e) || rwe();
}
var T1 = Z.forwardRef(function (t, e) {
  var n = Z.useState(!1),
    r = ZR(n, 2),
    i = r[0],
    s = r[1],
    a = Z.useRef(""),
    o = Z.useRef(null),
    l = Z.useRef(null),
    u = Z.useRef(!1),
    f = Z.useRef(null),
    c = Z.useRef(null),
    d = Mie({
      target: l,
      overlay: o,
      listener: function ($, B) {
        var R = B.type,
          V = B.valid;
        V && (R === "outside" ? t.dismissable && !u.current && x() : x()),
          (u.current = !1);
      },
      when: i,
    }),
    p = ZR(d, 2),
    m = p[0],
    g = p[1],
    w = function ($) {
      return (
        o && o.current && !(o.current.isSameNode($) || o.current.contains($))
      );
    },
    y = function ($, B) {
      return (
        l.current != null && l.current !== (B || $.currentTarget || $.target)
      );
    },
    v = function ($) {
      x(), $.preventDefault();
    },
    E = function ($) {
      (u.current = !0),
        rh.emit("overlay-click", { originalEvent: $, target: l.current });
    },
    S = function () {
      u.current = !0;
    },
    D = function ($, B) {
      i
        ? (x(),
          y($, B) &&
            ((l.current = B || $.currentTarget || $.target),
            setTimeout(function () {
              P($, l.current);
            }, 200)))
        : P($, B);
    },
    P = function ($, B) {
      (l.current = B || $.currentTarget || $.target),
        i
          ? T()
          : (s(!0),
            (c.current = function (R) {
              !w(R.target) && (u.current = !0);
            }),
            rh.on("overlay-click", c.current));
    },
    x = function () {
      s(!1), rh.off("overlay-click", c.current), (c.current = null);
    },
    _ = function () {
      o.current.setAttribute(a.current, ""),
        wa.set("overlay", o.current, Lr.autoZIndex, Lr.zIndex.overlay),
        T();
    },
    A = function () {
      m(), t.onShow && t.onShow();
    },
    N = function () {
      g();
    },
    M = function () {
      wa.clear(o.current), t.onHide && t.onHide();
    },
    T = function () {
      if (l.current && o.current) {
        it.absolutePosition(o.current, l.current);
        var $ = it.getOffset(o.current),
          B = it.getOffset(l.current),
          R = 0;
        $.left < B.left && (R = B.left - $.left),
          o.current.style.setProperty("--overlayArrowLeft", "".concat(R, "px")),
          $.top < B.top && it.addClass(o.current, "p-overlaypanel-flipped");
      }
    },
    O = function () {
      if (!f.current) {
        f.current = it.createInlineStyle(Lr.nonce);
        var $ = "";
        for (var B in t.breakpoints)
          $ += `
                    @media screen and (max-width: `
            .concat(
              B,
              `) {
                        .p-overlaypanel[`
            )
            .concat(
              a.current,
              `] {
                            width: `
            )
            .concat(
              t.breakpoints[B],
              ` !important;
                        }
                    }
                `
            );
        f.current.innerHTML = $;
      }
    };
  f1(function () {
    (a.current = lU()), t.breakpoints && O();
  }),
    bl(function () {
      (f.current = it.removeInlineStyle(f.current)),
        c.current && (rh.off("overlay-click", c.current), (c.current = null)),
        wa.clear(o.current);
    }),
    Z.useImperativeHandle(e, function () {
      return {
        props: t,
        toggle: D,
        show: P,
        hide: x,
        getElement: function () {
          return o.current;
        },
      };
    });
  var I = function () {
      if (t.showCloseIcon) {
        var $ = t.ariaCloseLabel || Zb("close");
        return Z.createElement(
          "button",
          {
            type: "button",
            className: "p-overlaypanel-close p-link",
            onClick: v,
            "aria-label": $,
          },
          Z.createElement("span", {
            className: "p-overlaypanel-close-icon pi pi-times",
            "aria-hidden": "true",
          }),
          Z.createElement(mh, null)
        );
      }
      return null;
    },
    k = function () {
      var $ = Vn.findDiffKeys(t, T1.defaultProps),
        B = ji("p-overlaypanel p-component", t.className),
        R = I();
      return Z.createElement(
        Uy,
        {
          nodeRef: o,
          classNames: "p-overlaypanel",
          in: i,
          timeout: { enter: 120, exit: 100 },
          options: t.transitionOptions,
          unmountOnExit: !0,
          onEnter: _,
          onEntered: A,
          onExit: N,
          onExited: M,
        },
        Z.createElement(
          "div",
          Tx({ ref: o, id: t.id, className: B, style: t.style }, $, {
            onClick: E,
          }),
          Z.createElement(
            "div",
            { className: "p-overlaypanel-content", onClick: S, onMouseDown: S },
            t.children
          ),
          R
        )
      );
    },
    L = k();
  return Z.createElement(Dh, { element: L, appendTo: t.appendTo });
});
T1.displayName = "OverlayPanel";
T1.defaultProps = {
  __TYPE: "OverlayPanel",
  id: null,
  dismissable: !0,
  showCloseIcon: !1,
  style: null,
  className: null,
  appendTo: null,
  breakpoints: null,
  ariaCloseLabel: null,
  transitionOptions: null,
  onShow: null,
  onHide: null,
};
function YR({ className: t, isMobile: e }) {
  const n = Z.useRef(null),
    { isWellConnected: r } = x1(),
    i = () => {
      const s = ` Link Btn Btn-nostyle font-main  ${t || ""}`;
      return r
        ? G.jsx("button", {
            className: s,
            onClick: (a) => n.current.toggle(a),
            "aria-haspopup": !0,
            "aria-controls": "connect_panel",
            children: G.jsx("i", {
              className: "pi pi-wallet color-tonic  text-lg ",
            }),
          })
        : G.jsxs("button", {
            style: { height: "2.5rem" },
            className: `${s} flex align-items-center gap-1 `,
            onClick: (a) => n.current.toggle(a),
            "aria-haspopup": !0,
            "aria-controls": "connect_panel",
            children: [
              G.jsx("i", { className: "pi pi-wallet  " }),
              G.jsx("span", {
                className: `${e ? "md:block hidden" : ""}`,
                children: "Connect",
              }),
            ],
          });
    };
  return G.jsxs(G.Fragment, {
    children: [
      i(),
      G.jsx(T1, {
        appendTo: "self",
        ref: n,
        showCloseIcon: !0,
        dismissable: !0,
        className: "max-w-full",
        style: { width: "450px" },
        id: "connect_panel",
        children: G.jsx(B5e, {}),
      }),
    ],
  });
}
const QR = ["black", "blue", "dark-gray"];
function JR() {
  const { updateTheme: t, theme: e } = Z.useContext($h),
    n = e.includes("nograin"),
    r = e.split(":")?.at(0),
    i = Z.useRef(null);
  return G.jsxs("div", {
    className: "flex gap-1 h-full align-items-center px-2",
    children: [
      G.jsxs("button", {
        type: "button",
        className: " bg-black my-auto w-1-5rem  border-none  h-1-5rem  ",
        onClick: () => t(null, n),
        children: [
          G.jsx("span", {
            className: "p-sr-only",
            children: " Change background grained",
          }),
          G.jsxs("svg", {
            viewBox: "0 0 12 12",
            xmlns: "http://www.w3.org/2000/svg",
            children: [
              G.jsx("g", {
                transform: "matrix(1,0,0,1,0,0)",
                children: G.jsx("g", {
                  id: "570:10416",
                  opacity: "1",
                  children: G.jsx("g", {
                    children: G.jsxs("g", {
                      children: [
                        G.jsx("g", {
                          transform: "matrix(1,0,0,1,0,0)",
                          children: G.jsx("g", {
                            id: "570:10415",
                            opacity: "0",
                            children: G.jsx("g", {
                              children: G.jsx("g", {
                                children: G.jsx("path", {
                                  id: "570:10415_fill_path",
                                  d: "M0,0h2v2h-2zM4,2h-2v2h-2v4h4v-2h4v-6h-4zM4,4v-2h2v2zM4,4v2h-2v-2zM2,10h4v2h-4zM10,8h-4v2h2v2h4v-2h-2zM10,8v-4h2v4zM10,0h2v2h-2zM10,4v-2",
                                  fillRule: "nonzero",
                                  fill: "rgb(72, 72, 72)",
                                  fillOpacity: "1",
                                }),
                              }),
                            }),
                          }),
                        }),
                        G.jsx("g", {
                          transform: "matrix(1,0,0,1,0,0)",
                          children: G.jsx("g", {
                            id: "570:10423",
                            opacity: "0",
                            children: G.jsx("g", {
                              children: G.jsx("g", {
                                children: G.jsx("path", {
                                  id: "570:10423_fill_path",
                                  d: "M10,0v2h-2v-2h-4v2h2v4h2v-2h2v2h2v-6zM0,6v-2h2v2zM4,8v-2h-2v2h-2v4h2v-4zM8,10v-2h-4v4h2v-2zM8,10h2v-2h2v4h-4zM0,0v2h2v-2z",
                                  fillRule: "nonzero",
                                  fill: "rgb(72, 72, 72)",
                                  fillOpacity: "1",
                                }),
                              }),
                            }),
                          }),
                        }),
                        G.jsx("g", {
                          transform: "matrix(1,0,0,1,0,0)",
                          children: G.jsx("g", {
                            id: "570:10430",
                            opacity: "0",
                            children: G.jsx("g", {
                              children: G.jsx("g", {
                                children: G.jsx("path", {
                                  id: "570:10430_fill_path",
                                  d: "M2,0h-2v4h2zM0,6h4v2h-4zM6,10v-2h-2v2h-4v2h4v-2zM8,10h-2v2h2zM10,2h2v4h-2v2h2v4h-2v-2h-2v-4h-4v-6h2v4h4zM10,2h-2v-2h2z",
                                  fillRule: "nonzero",
                                  fill: "rgb(72, 72, 72)",
                                  fillOpacity: "1",
                                }),
                              }),
                            }),
                          }),
                        }),
                        G.jsx("g", {
                          transform: "matrix(1,0,0,1,0,0)",
                          children: G.jsx("g", {
                            id: "570:10437",
                            opacity: "1",
                            children: G.jsx("g", {
                              children: G.jsx("g", {
                                children: G.jsx("path", {
                                  id: "570:10437_fill_path",
                                  d: "M2,0h-2v4h2v2h-2v2h2v2h-2v2h4v-2h4v2h2v-2h2v-2h-2v-2h2v-2h-2v2h-2v-4h4v-2h-4v2h-2v-2h-2v4h-2zM4,4h2v4h-4v-2h2zM10,8v2h-2v-2z",
                                  fillRule: "evenodd",
                                  fill: "rgb(72, 72, 72)",
                                  fillOpacity: "1",
                                }),
                              }),
                            }),
                          }),
                        }),
                      ],
                    }),
                  }),
                }),
              }),
              !n &&
                G.jsxs(G.Fragment, {
                  children: [
                    G.jsx("animate", {
                      href: "#570:10415",
                      attributeName: "opacity",
                      values: "0;0;1;1;0;0",
                      dur: "0.4s",
                      repeatCount: "indefinite",
                      calcMode: "spline",
                      keyTimes: "0;0.75;0.77;1;1;1",
                      keySplines:
                        "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
                      additive: "replace",
                      fill: "freeze",
                    }),
                    G.jsx("animate", {
                      href: "#570:10423",
                      attributeName: "opacity",
                      values: "0;0;1;1;0;0",
                      dur: "0.4s",
                      repeatCount: "indefinite",
                      calcMode: "spline",
                      keyTimes: "0;0.5;0.52;0.75;0.77;1",
                      keySplines:
                        "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
                      additive: "replace",
                      fill: "freeze",
                    }),
                    G.jsx("animate", {
                      href: "#570:10430",
                      attributeName: "opacity",
                      values: "0;0;1;1;0;0",
                      dur: "0.4s",
                      repeatCount: "indefinite",
                      calcMode: "spline",
                      keyTimes: "0;0.25;0.27;0.5;0.52;1",
                      keySplines:
                        "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
                      additive: "replace",
                      fill: "freeze",
                    }),
                    G.jsx("animate", {
                      href: "#570:10437",
                      attributeName: "opacity",
                      values: "1;1;0;0",
                      dur: "0.4s",
                      repeatCount: "indefinite",
                      calcMode: "spline",
                      keyTimes: "0;0.25;0.27;1",
                      keySplines:
                        "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
                      additive: "replace",
                      fill: "freeze",
                    }),
                  ],
                }),
            ],
          }),
        ],
      }),
      G.jsx("button", {
        type: "button",
        className: ` hidden lg:block my-auto  h-1rem border-1 w-1rem   border-quiet bg-${r}`,
        onClick: (s) => i?.current?.toggle(s),
        children: G.jsx("span", {
          className: "p-sr-only",
          children: " Open Background color selector",
        }),
      }),
      G.jsx("i", {
        className: "hidden lg:block pi pi-caret-down color-quiet ",
        onClick: (s) => i?.current?.toggle(s),
      }),
      G.jsx(T1, {
        ref: i,
        dismissable: !0,
        children: G.jsx("div", {
          className: "flex gap-2 p-2 bg-black",
          children: QR.filter((s) => s !== r).map((s) =>
            G.jsx(
              "button",
              {
                type: "button",
                className: ` my-auto w-1-5rem  h-1-5rem border-1  ${
                  r !== s ? "border-quiet" : "border-white"
                } bg-${s}`,
                onClick: (a) => {
                  t(s, !n), i?.current?.toggle(a);
                },
                children: G.jsxs("span", {
                  className: "p-sr-only",
                  children: [" Change background color to ", s],
                }),
              },
              s
            )
          ),
        }),
      }),
      G.jsx("div", {
        className: "flex gap-2 lg:hidden",
        children: QR.map((s) =>
          G.jsx(
            "button",
            {
              type: "button",
              className: ` my-auto w-1-5rem  h-1-5rem border-1  ${
                r !== s ? "border-quiet" : "border-white"
              } bg-${s}`,
              onClick: () => {
                t(s, !n);
              },
              children: G.jsxs("span", {
                className: "p-sr-only",
                children: [" Change background color to ", s],
              }),
            },
            s
          )
        ),
      }),
    ],
  });
}
function iwe() {
  const [t, e] = Z.useState(!1),
    n = Z.useRef(null),
    r = vy(),
    { notifications: i } = Z.useContext($y),
    s = (i && Object.values(i?.checkInNeeded)?.length) || 0,
    a = ({ className: f }) =>
      G.jsx("img", { alt: "convergence", src: ese, className: f });
  function o(f, c = "", d = 0) {
    const p = r.pathname === f.href ? "is-active" : "";
    return G.jsxs("li", {
      className: `${p} relative ${d > 0 && " "}`,
      children: [
        G.jsxs(rU, { to: f.href, children: [c, f.label] }),
        d > 0
          ? G.jsx(G.Fragment, {
              children: G.jsx("div", {
                className: "absolute bottom-0 translate-y-50 w-full ",
                children: G.jsx("div", {
                  className:
                    "   mx-auto text-sm border-round-3xl w-0-75rem h-0-75rem   p-1 color-white bg-red   ",
                  children: d,
                }),
              }),
            })
          : "",
      ],
    });
  }
  const l = (f) =>
      G.jsxs("ul", {
        className: `Nav flex  flex-column md:flex-row ${f}`,
        children: [
          G.jsxs("div", {
            className: "text-right before flex-grow-1",
            children: [
              o(gs.dashboard),
              G.jsxs("li", {
                children: [
                  G.jsx("a", {
                    className: "pointer-cursor",
                    onClick: (c) => n.current.toggle(c),
                    children: "Stake",
                  }),
                  G.jsx(T1, {
                    appendTo: "self",
                    ref: n,
                    id: "stake_panel",
                    children: G.jsxs("ul", {
                      className: "bg-black flex flex-column p -m-2",
                      onClick: (c) => n.current.toggle(c),
                      children: [
                        o(gs.stakeCvg),
                        o(gs.stakeCvx),
                        o(gs.stakeSdt),
                      ],
                    }),
                  }),
                ],
              }),
              o(gs.bond),
              o(gs.claim),
            ],
          }),
          G.jsx("li", {
            className: "Menu-desktop-logo hidden md:inline-block z-4 ",
            children: G.jsx(a, {}),
          }),
          G.jsxs("div", {
            className: "flex-grow-1 after",
            children: [
              o(gs.lock, "", s),
              o(gs.gauges),
              o(gs.positions),
              G.jsx("li", {
                className: "overflow-hidden",
                children: G.jsx(YR, {}),
              }),
              G.jsx("li", { children: G.jsx(JR, {}) }),
            ],
          }),
        ],
      }),
    u = () =>
      G.jsxs(G.Fragment, {
        children: [
          o(gs.dashboard),
          o(gs.bond),
          o(gs.stakeCvg, "Stake:"),
          o(gs.stakeCvx, "Stake:"),
          o(gs.stakeSdt, "Stake:"),
          o(gs.claim),
          o(gs.lock),
          o(gs.gauges),
          o(gs.positions),
        ],
      });
  return G.jsxs("div", {
    children: [
      G.jsx("div", {
        className: "Menu-desktop mb-5 md:mb-4 hidden md:block",
        children: G.jsx("nav", { className: "Menu", children: l("main") }),
      }),
      G.jsxs("div", {
        className: "md:hidden Menu-mobile",
        children: [
          G.jsx(iu, {
            icon: "pi pi-bars",
            onClick: () => e(!t),
            className: "Menu-mobile-toggle",
            children: G.jsx("span", {
              className: "p-sr-only",
              children: " Open the menu",
            }),
          }),
          G.jsx("div", {
            className: "Menu-mobile-logo  text-center ",
            children: G.jsx(a, { className: " Menu-mobile-logo" }),
          }),
          G.jsx(YR, { className: "Menu-mobile-connect ", isMobile: !0 }),
          G.jsx("div", {
            hidden: !t,
            className: "",
            children: G.jsx("nav", {
              className: "Menu",
              children: G.jsxs("ul", {
                onClick: () => e(!1),
                className: "w-full",
                children: [
                  u(),
                  G.jsx("li", {}),
                  G.jsxs("li", {
                    className: "flex justify-content-center mb-4",
                    children: [" ", G.jsx(JR, {})],
                  }),
                ],
              }),
            }),
          }),
        ],
      }),
    ],
  });
}
function swe() {
  return G.jsx("header", { children: G.jsx(iwe, {}) });
}
const awe = "/assets/twitter-47eed4a6.svg",
  owe = "/assets/discord-10637f17.svg",
  lwe = "/assets/medium-caa0dd6e.svg",
  uwe = "/assets/doc-89b2fb60.svg",
  cwe = [
    {
      name: "@ConvergenFi",
      href: "https://twitter.com/ConvergenFi",
      logo: awe,
    },
    { name: "medium", href: "https://medium.com/@ConverFi", logo: lwe },
    {
      name: "documentation",
      href: "https://ifrices-organization.gitbook.io/convergence/",
      logo: uwe,
    },
  ];
function eM({
  href: t,
  name: e,
  icon: n = "pi-external-link",
  target: r = "_blank",
}) {
  return t
    ? G.jsxs("a", {
        href: t,
        target: r,
        rel: "noreferrer",
        className: " Footer-link",
        children: [G.jsx("i", { className: `pi ${n}` }), " ", e],
      })
    : G.jsx(G.Fragment, { children: " " });
}
function fwe() {
  return G.jsx("footer", {
    children: G.jsxs("div", {
      className: "Footer text-center",
      role: "menu",
      children: [
        cwe.map((t, e) =>
          t.href
            ? G.jsxs(
                "a",
                {
                  href: t.href,
                  target: "_blank",
                  rel: "noreferrer",
                  className: "Footer-link text-sm ",
                  children: [
                    G.jsxs("i", {
                      children: [
                        G.jsx("img", { src: t.logo, alt: t.name }),
                        " ",
                      ],
                    }),
                    " ",
                    t.name,
                  ],
                },
                e
              )
            : null
        ),
        G.jsx(eM, { href: {}.VITE_LINK_DOCS, name: "docs" }),
        G.jsx(eM, { href: {}.VITE_LINK_GOVERNANCE, name: "governance" }),
      ],
    }),
  });
}
function dwe() {
  const { theme: t } = Z.useContext($h);
  return t?.includes("nograin")
    ? G.jsx(G.Fragment, {})
    : G.jsx("div", { className: "Grained" });
}
function Sx() {
  return (
    (Sx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Sx.apply(this, arguments)
  );
}
function Ax(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function hwe(t) {
  if (Array.isArray(t)) return Ax(t);
}
function pwe(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function AG(t, e) {
  if (t) {
    if (typeof t == "string") return Ax(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Ax(t, e);
  }
}
function mwe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function S8(t) {
  return hwe(t) || pwe(t) || AG(t) || mwe();
}
function gwe(t) {
  if (Array.isArray(t)) return t;
}
function ywe(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function vwe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Cx(t, e) {
  return gwe(t) || ywe(t, e) || AG(t, e) || vwe();
}
function iy(t) {
  "@babel/helpers - typeof";
  return (
    (iy =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    iy(t)
  );
}
function bwe(t, e) {
  if (iy(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (iy(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function CG(t) {
  var e = bwe(t, "string");
  return iy(e) === "symbol" ? e : String(e);
}
function uu(t, e, n) {
  return (
    (e = CG(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function tM(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, CG(r.key), r);
  }
}
function wwe(t, e, n) {
  return (
    e && tM(t.prototype, e),
    n && tM(t, n),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    t
  );
}
function _we(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var Xs = Object.freeze({
    STARTS_WITH: "startsWith",
    CONTAINS: "contains",
    NOT_CONTAINS: "notContains",
    ENDS_WITH: "endsWith",
    EQUALS: "equals",
    NOT_EQUALS: "notEquals",
    IN: "in",
    LESS_THAN: "lt",
    LESS_THAN_OR_EQUAL_TO: "lte",
    GREATER_THAN: "gt",
    GREATER_THAN_OR_EQUAL_TO: "gte",
    BETWEEN: "between",
    DATE_IS: "dateIs",
    DATE_IS_NOT: "dateIsNot",
    DATE_BEFORE: "dateBefore",
    DATE_AFTER: "dateAfter",
    CUSTOM: "custom",
  }),
  Tl = wwe(function t() {
    _we(this, t);
  });
uu(Tl, "ripple", !1);
uu(Tl, "inputStyle", "outlined");
uu(Tl, "locale", "en");
uu(Tl, "appendTo", null);
uu(Tl, "cssTransition", !0);
uu(Tl, "autoZIndex", !0);
uu(Tl, "nonce", null);
uu(Tl, "nullSortOrder", 1);
uu(Tl, "zIndex", {
  modal: 1100,
  overlay: 1e3,
  menu: 1e3,
  tooltip: 1100,
  toast: 1200,
});
uu(Tl, "filterMatchModeOptions", {
  text: [
    Xs.STARTS_WITH,
    Xs.CONTAINS,
    Xs.NOT_CONTAINS,
    Xs.ENDS_WITH,
    Xs.EQUALS,
    Xs.NOT_EQUALS,
  ],
  numeric: [
    Xs.EQUALS,
    Xs.NOT_EQUALS,
    Xs.LESS_THAN,
    Xs.LESS_THAN_OR_EQUAL_TO,
    Xs.GREATER_THAN,
    Xs.GREATER_THAN_OR_EQUAL_TO,
  ],
  date: [Xs.DATE_IS, Xs.DATE_IS_NOT, Xs.DATE_BEFORE, Xs.DATE_AFTER],
});
var Ewe = {
  en: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    filter: "Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    custom: "Custom",
    clear: "Clear",
    close: "Close",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    dayNames: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    monthNamesShort: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No available options",
    emptyMessage: "No results found",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      pageLabel: "Page",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      previousPageLabel: "Previous Page",
      selectLabel: "Select",
      unselectLabel: "Unselect",
      expandLabel: "Expand",
      collapseLabel: "Collapse",
    },
  },
};
function xwe(t, e) {
  var n = e || Tl.locale;
  try {
    return Twe(n)[t];
  } catch {
    throw new Error(
      "The "
        .concat(t, " option is not found in the current locale('")
        .concat(n, "').")
    );
  }
}
function Twe(t) {
  var e = t || Tl.locale;
  return Ewe[e];
}
var kG = Z.memo(
  Z.forwardRef(function (t, e) {
    var n = t.messageInfo,
      r = n.message,
      i = r.severity,
      s = r.content,
      a = r.summary,
      o = r.detail,
      l = r.closable,
      u = r.life,
      f = r.sticky,
      c = r.className,
      d = r.style,
      p = r.contentClassName,
      m = r.contentStyle,
      g = Z.useState(!1),
      w = Cx(g, 2),
      y = w[0],
      v = w[1],
      E = Lie(
        function () {
          P();
        },
        u || 3e3,
        !f && !y
      ),
      S = Cx(E, 1),
      D = S[0],
      P = function () {
        D(), t.onClose && t.onClose(n);
      },
      x = function (U) {
        t.onClick &&
          !(
            it.hasClass(U.target, "p-toast-icon-close") ||
            it.hasClass(U.target, "p-toast-icon-close-icon")
          ) &&
          t.onClick(n.message);
      },
      _ = function (U) {
        t.onMouseEnter && t.onMouseEnter(U),
          !U.defaultPrevented && (f || (D(), v(!0)));
      },
      A = function (U) {
        t.onMouseLeave && t.onMouseLeave(U),
          !U.defaultPrevented && (f || v(!1));
      },
      N = function () {
        return l !== !1
          ? Z.createElement(
              "div",
              null,
              Z.createElement(
                "button",
                {
                  type: "button",
                  className: "p-toast-icon-close p-link",
                  onClick: P,
                  "aria-label": xwe("close"),
                },
                Z.createElement("span", {
                  className: "p-toast-icon-close-icon pi pi-times",
                  "aria-hidden": "true",
                }),
                Z.createElement(mh, null)
              )
            )
          : null;
      },
      M = function () {
        if (n) {
          var U = Vn.getJSXElement(s, {
              message: n.message,
              onClick: x,
              onClose: P,
            }),
            $ = ji("p-toast-message-icon pi", {
              "pi-info-circle": i === "info",
              "pi-exclamation-triangle": i === "warn",
              "pi-times": i === "error",
              "pi-check": i === "success",
            });
          return (
            U ||
            Z.createElement(
              Z.Fragment,
              null,
              Z.createElement("span", { className: $ }),
              Z.createElement(
                "div",
                { className: "p-toast-message-text" },
                Z.createElement("span", { className: "p-toast-summary" }, a),
                o && Z.createElement("div", { className: "p-toast-detail" }, o)
              )
            )
          );
        }
        return null;
      },
      T = ji("p-toast-message", uu({}, "p-toast-message-".concat(i), i), c),
      O = ji("p-toast-message-content", p),
      I = M(),
      k = N();
    return Z.createElement(
      "div",
      {
        ref: e,
        className: T,
        style: d,
        role: "alert",
        "aria-live": "assertive",
        "aria-atomic": "true",
        onClick: x,
        onMouseEnter: _,
        onMouseLeave: A,
      },
      Z.createElement("div", { className: O, style: m }, I, k)
    );
  })
);
kG.displayName = "ToastMessage";
var nM = 0,
  sy = Z.memo(
    Z.forwardRef(function (t, e) {
      var n = Z.useState([]),
        r = Cx(n, 2),
        i = r[0],
        s = r[1],
        a = Z.useRef(null),
        o = function (v) {
          if (v) {
            var E = l(v, !0);
            i.length === 0 &&
              wa.set(
                "toast",
                a.current,
                Lr.autoZIndex,
                t.baseZIndex || Lr.zIndex.toast
              ),
              s(E);
          }
        },
        l = function (v, E) {
          var S;
          if (Array.isArray(v)) {
            var D = v.reduce(function (x, _) {
              return x.push({ _pId: nM++, message: _ }), x;
            }, []);
            E ? (S = i ? [].concat(S8(i), S8(D)) : D) : (S = D);
          } else {
            var P = { _pId: nM++, message: v };
            E ? (S = i ? [].concat(S8(i), [P]) : [P]) : (S = [P]);
          }
          return S;
        },
        u = function () {
          wa.clear(a.current), s([]);
        },
        f = function (v) {
          var E = l(v, !1);
          s(E);
        },
        c = function (v) {
          var E = i.filter(function (S) {
            return S._pId !== v._pId;
          });
          s(E), t.onRemove && t.onRemove(v.message);
        },
        d = function (v) {
          c(v);
        },
        p = function () {
          t.onShow && t.onShow();
        },
        m = function () {
          i.length === 1 && wa.clear(a.current), t.onHide && t.onHide();
        };
      bl(function () {
        wa.clear(a.current);
      }),
        Z.useImperativeHandle(e, function () {
          return {
            props: t,
            show: o,
            replace: f,
            remove: c,
            clear: u,
            getElement: function () {
              return a.current;
            },
          };
        });
      var g = function () {
          var v = Vn.findDiffKeys(t, sy.defaultProps),
            E = ji("p-toast p-component p-toast-" + t.position, t.className);
          return Z.createElement(
            "div",
            Sx({ ref: a, id: t.id, className: E, style: t.style }, v),
            Z.createElement(
              Z5e,
              null,
              i &&
                i.map(function (S) {
                  var D = Z.createRef();
                  return Z.createElement(
                    Uy,
                    {
                      nodeRef: D,
                      key: S._pId,
                      classNames: "p-toast-message",
                      unmountOnExit: !0,
                      timeout: { enter: 300, exit: 300 },
                      onEntered: p,
                      onExited: m,
                      options: t.transitionOptions,
                    },
                    Z.createElement(kG, {
                      ref: D,
                      messageInfo: S,
                      onClick: t.onClick,
                      onClose: d,
                      onMouseEnter: t.onMouseEnter,
                      onMouseLeave: t.onMouseLeave,
                    })
                  );
                })
            )
          );
        },
        w = g();
      return Z.createElement(Dh, { element: w, appendTo: t.appendTo });
    })
  );
sy.displayName = "Toast";
sy.defaultProps = {
  __TYPE: "Toast",
  id: null,
  className: null,
  style: null,
  baseZIndex: 0,
  position: "top-right",
  transitionOptions: null,
  appendTo: "self",
  onClick: null,
  onRemove: null,
  onShow: null,
  onHide: null,
  onMouseEnter: null,
  onMouseLeave: null,
};
function kx() {
  return (
    (kx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    kx.apply(this, arguments)
  );
}
var S1 = Z.memo(
  Z.forwardRef(function (t, e) {
    var n = Z.useRef(null),
      r = Vn.findDiffKeys(t, S1.defaultProps),
      i = t.size
        ? { width: t.size, height: t.size, borderRadius: t.borderRadius }
        : { width: t.width, height: t.height, borderRadius: t.borderRadius },
      s = ji(
        "p-skeleton p-component",
        {
          "p-skeleton-circle": t.shape === "circle",
          "p-skeleton-none": t.animation === "none",
        },
        t.className
      );
    return (
      Z.useImperativeHandle(e, function () {
        return {
          props: t,
          getElement: function () {
            return n.current;
          },
        };
      }),
      Z.createElement("div", kx({ ref: n, style: i, className: s }, r))
    );
  })
);
S1.displayName = "Skeleton";
S1.defaultProps = {
  __TYPE: "Skeleton",
  shape: "rectangle",
  size: null,
  width: "100%",
  height: "1rem",
  borderRadius: null,
  animation: "wave",
  style: null,
  className: null,
};
function KT() {
  return G.jsx("div", {
    children: G.jsx(S1, { className: "h2-rem w-full mx-2" }),
  });
}
function cRe({ className: t }) {
  return G.jsx(S1, { className: `h2-rem inline-block ${t || ""} mx-2` });
}
function Swe() {
  const { notify: t } = Z.useContext($h),
    e = Z.useRef(null),
    n = Z.useRef(null);
  return (
    Z.useEffect(() => {
      if (!t || !t.type) return;
      let r = t.message;
      t.tx &&
        t.type === "warn" &&
        (r = G.jsx(G.Fragment, {
          children: G.jsxs("div", {
            children: [
              G.jsx(KT, {}),
              G.jsx("span", {
                style: { verticalAlign: "middle" },
                children: " A transaction is running ",
              }),
            ],
          }),
        }));
      let i = !1,
        s = e?.current;
      t.tx && t.type === "warn"
        ? ((s = n?.current), (i = !0))
        : n?.current.clear(),
        s?.show({
          severity: t.type,
          summary: t.type + " Message",
          detail: r,
          life: 7e3,
          sticky: i,
        });
    }, [t]),
    G.jsxs(G.Fragment, {
      children: [
        G.jsx(sy, { ref: e, className: "Notify", position: "top-center" }),
        G.jsx(sy, { ref: n, className: "Notify", position: "top-center" }),
      ],
    })
  );
}
function Awe() {
  const { ecosystemInfo: t } = Z.useContext($y),
    { isWellConnected: e, address: n } = x1(),
    { initWalletTokenInfo: r } = Z.useContext(HT),
    [i, s] = Z.useState(void 0);
  return (
    Z.useEffect(() => {
      i && n && i !== n && window.location.reload(),
        !i && n && t && (s(n), r(n));
    }, [n, e]),
    G.jsx(G.Fragment, {})
  );
}
function Cwe() {
  return G.jsx("main", {
    className: "flex justify-content-center",
    children: G.jsx("div", {
      className: "w-12 text-center",
      children: G.jsx(KT, {}),
    }),
  });
}
var q5 = { exports: {} };
q5.exports;
(function (t, e) {
  var n = 200,
    r = "Expected a function",
    i = "__lodash_hash_undefined__",
    s = 1,
    a = 2,
    o = 1 / 0,
    l = 9007199254740991,
    u = "[object Arguments]",
    f = "[object Array]",
    c = "[object Boolean]",
    d = "[object Date]",
    p = "[object Error]",
    m = "[object Function]",
    g = "[object GeneratorFunction]",
    w = "[object Map]",
    y = "[object Number]",
    v = "[object Object]",
    E = "[object Promise]",
    S = "[object RegExp]",
    D = "[object Set]",
    P = "[object String]",
    x = "[object Symbol]",
    _ = "[object WeakMap]",
    A = "[object ArrayBuffer]",
    N = "[object DataView]",
    M = "[object Float32Array]",
    T = "[object Float64Array]",
    O = "[object Int8Array]",
    I = "[object Int16Array]",
    k = "[object Int32Array]",
    L = "[object Uint8Array]",
    U = "[object Uint8ClampedArray]",
    $ = "[object Uint16Array]",
    B = "[object Uint32Array]",
    R = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    V = /^\w*$/,
    oe = /^\./,
    le =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    fe = /[\\^$.*+?()[\]{}|]/g,
    z = /\\(\\)?/g,
    se = /^\[object .+?Constructor\]$/,
    Y = /^(?:0|[1-9]\d*)$/,
    Q = {};
  (Q[M] = Q[T] = Q[O] = Q[I] = Q[k] = Q[L] = Q[U] = Q[$] = Q[B] = !0),
    (Q[u] =
      Q[f] =
      Q[A] =
      Q[c] =
      Q[N] =
      Q[d] =
      Q[p] =
      Q[m] =
      Q[w] =
      Q[y] =
      Q[v] =
      Q[S] =
      Q[D] =
      Q[P] =
      Q[_] =
        !1);
  var ee = typeof Ur == "object" && Ur && Ur.Object === Object && Ur,
    F = typeof self == "object" && self && self.Object === Object && self,
    te = ee || F || Function("return this")(),
    he = e && !e.nodeType && e,
    Te = he && !0 && t && !t.nodeType && t,
    Ce = Te && Te.exports === he,
    ke = Ce && ee.process,
    at = (function () {
      try {
        return ke && ke.binding("util");
      } catch {}
    })(),
    Rt = at && at.isTypedArray;
  function Ft(j, K) {
    var ce = j ? j.length : 0;
    return !!ce && st(j, K, 0) > -1;
  }
  function Nt(j, K, ce) {
    for (var Ee = -1, Ne = j ? j.length : 0; ++Ee < Ne; )
      if (ce(K, j[Ee])) return !0;
    return !1;
  }
  function Ot(j, K) {
    for (var ce = -1, Ee = j ? j.length : 0; ++ce < Ee; )
      if (K(j[ce], ce, j)) return !0;
    return !1;
  }
  function et(j, K, ce, Ee) {
    for (var Ne = j.length, Ie = ce + (Ee ? 1 : -1); Ee ? Ie-- : ++Ie < Ne; )
      if (K(j[Ie], Ie, j)) return Ie;
    return -1;
  }
  function st(j, K, ce) {
    if (K !== K) return et(j, vt, ce);
    for (var Ee = ce - 1, Ne = j.length; ++Ee < Ne; )
      if (j[Ee] === K) return Ee;
    return -1;
  }
  function vt(j) {
    return j !== j;
  }
  function Re(j) {
    return function (K) {
      return K?.[j];
    };
  }
  function me(j, K) {
    for (var ce = -1, Ee = Array(j); ++ce < j; ) Ee[ce] = K(ce);
    return Ee;
  }
  function $e(j) {
    return function (K) {
      return j(K);
    };
  }
  function De(j, K) {
    return j.has(K);
  }
  function je(j, K) {
    return j?.[K];
  }
  function lt(j) {
    var K = !1;
    if (j != null && typeof j.toString != "function")
      try {
        K = !!(j + "");
      } catch {}
    return K;
  }
  function Ke(j) {
    var K = -1,
      ce = Array(j.size);
    return (
      j.forEach(function (Ee, Ne) {
        ce[++K] = [Ne, Ee];
      }),
      ce
    );
  }
  function tt(j, K) {
    return function (ce) {
      return j(K(ce));
    };
  }
  function jt(j) {
    var K = -1,
      ce = Array(j.size);
    return (
      j.forEach(function (Ee) {
        ce[++K] = Ee;
      }),
      ce
    );
  }
  var ct = Array.prototype,
    rt = Function.prototype,
    Dt = Object.prototype,
    Ht = te["__core-js_shared__"],
    Yt = (function () {
      var j = /[^.]+$/.exec((Ht && Ht.keys && Ht.keys.IE_PROTO) || "");
      return j ? "Symbol(src)_1." + j : "";
    })(),
    sr = rt.toString,
    Bt = Dt.hasOwnProperty,
    en = Dt.toString,
    Tr = RegExp(
      "^" +
        sr
          .call(Bt)
          .replace(fe, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    on = te.Symbol,
    Pt = te.Uint8Array,
    fn = Dt.propertyIsEnumerable,
    Wt = ct.splice,
    qt = tt(Object.keys, Object),
    Ye = Qr(te, "DataView"),
    xe = Qr(te, "Map"),
    nt = Qr(te, "Promise"),
    gt = Qr(te, "Set"),
    ht = Qr(te, "WeakMap"),
    wt = Qr(Object, "create"),
    rn = q(Ye),
    ot = q(xe),
    pt = q(nt),
    zt = q(gt),
    Zt = q(ht),
    $t = on ? on.prototype : void 0,
    Vr = $t ? $t.valueOf : void 0,
    $n = $t ? $t.toString : void 0;
  function En(j) {
    var K = -1,
      ce = j ? j.length : 0;
    for (this.clear(); ++K < ce; ) {
      var Ee = j[K];
      this.set(Ee[0], Ee[1]);
    }
  }
  function In() {
    this.__data__ = wt ? wt(null) : {};
  }
  function as(j) {
    return this.has(j) && delete this.__data__[j];
  }
  function os(j) {
    var K = this.__data__;
    if (wt) {
      var ce = K[j];
      return ce === i ? void 0 : ce;
    }
    return Bt.call(K, j) ? K[j] : void 0;
  }
  function ls(j) {
    var K = this.__data__;
    return wt ? K[j] !== void 0 : Bt.call(K, j);
  }
  function us(j, K) {
    var ce = this.__data__;
    return (ce[j] = wt && K === void 0 ? i : K), this;
  }
  (En.prototype.clear = In),
    (En.prototype.delete = as),
    (En.prototype.get = os),
    (En.prototype.has = ls),
    (En.prototype.set = us);
  function Or(j) {
    var K = -1,
      ce = j ? j.length : 0;
    for (this.clear(); ++K < ce; ) {
      var Ee = j[K];
      this.set(Ee[0], Ee[1]);
    }
  }
  function ar() {
    this.__data__ = [];
  }
  function cs(j) {
    var K = this.__data__,
      ce = Ma(K, j);
    if (ce < 0) return !1;
    var Ee = K.length - 1;
    return ce == Ee ? K.pop() : Wt.call(K, ce, 1), !0;
  }
  function lo(j) {
    var K = this.__data__,
      ce = Ma(K, j);
    return ce < 0 ? void 0 : K[ce][1];
  }
  function zi(j) {
    return Ma(this.__data__, j) > -1;
  }
  function la(j, K) {
    var ce = this.__data__,
      Ee = Ma(ce, j);
    return Ee < 0 ? ce.push([j, K]) : (ce[Ee][1] = K), this;
  }
  (Or.prototype.clear = ar),
    (Or.prototype.delete = cs),
    (Or.prototype.get = lo),
    (Or.prototype.has = zi),
    (Or.prototype.set = la);
  function xi(j) {
    var K = -1,
      ce = j ? j.length : 0;
    for (this.clear(); ++K < ce; ) {
      var Ee = j[K];
      this.set(Ee[0], Ee[1]);
    }
  }
  function ci() {
    this.__data__ = { hash: new En(), map: new (xe || Or)(), string: new En() };
  }
  function ua(j) {
    return hs(this, j).delete(j);
  }
  function Ra(j) {
    return hs(this, j).get(j);
  }
  function pr(j) {
    return hs(this, j).has(j);
  }
  function uo(j, K) {
    return hs(this, j).set(j, K), this;
  }
  (xi.prototype.clear = ci),
    (xi.prototype.delete = ua),
    (xi.prototype.get = Ra),
    (xi.prototype.has = pr),
    (xi.prototype.set = uo);
  function fs(j) {
    var K = -1,
      ce = j ? j.length : 0;
    for (this.__data__ = new xi(); ++K < ce; ) this.add(j[K]);
  }
  function co(j) {
    return this.__data__.set(j, i), this;
  }
  function lc(j) {
    return this.__data__.has(j);
  }
  (fs.prototype.add = fs.prototype.push = co), (fs.prototype.has = lc);
  function ds(j) {
    this.__data__ = new Or(j);
  }
  function cu() {
    this.__data__ = new Or();
  }
  function $s(j) {
    return this.__data__.delete(j);
  }
  function Al(j) {
    return this.__data__.get(j);
  }
  function fo(j) {
    return this.__data__.has(j);
  }
  function Cl(j, K) {
    var ce = this.__data__;
    if (ce instanceof Or) {
      var Ee = ce.__data__;
      if (!xe || Ee.length < n - 1) return Ee.push([j, K]), this;
      ce = this.__data__ = new xi(Ee);
    }
    return ce.set(j, K), this;
  }
  (ds.prototype.clear = cu),
    (ds.prototype.delete = $s),
    (ds.prototype.get = Al),
    (ds.prototype.has = fo),
    (ds.prototype.set = Cl);
  function ho(j, K) {
    var ce = kt(j) || St(j) ? me(j.length, String) : [],
      Ee = ce.length,
      Ne = !!Ee;
    for (var Ie in j)
      (K || Bt.call(j, Ie)) &&
        !(Ne && (Ie == "length" || js(Ie, Ee))) &&
        ce.push(Ie);
    return ce;
  }
  function Ma(j, K) {
    for (var ce = j.length; ce--; ) if (Me(j[ce][0], K)) return ce;
    return -1;
  }
  function po(j, K) {
    K = Hs(K, j) ? [K] : Il(K);
    for (var ce = 0, Ee = K.length; j != null && ce < Ee; ) j = j[pe(K[ce++])];
    return ce && ce == Ee ? j : void 0;
  }
  function jo(j) {
    return en.call(j);
  }
  function Ho(j, K) {
    return j != null && K in Object(j);
  }
  function La(j, K, ce, Ee, Ne) {
    return j === K
      ? !0
      : j == null || K == null || (!pn(j) && !xn(K))
      ? j !== j && K !== K
      : fu(j, K, La, ce, Ee, Ne);
  }
  function fu(j, K, ce, Ee, Ne, Ie) {
    var xt = kt(j),
      Kt = kt(K),
      ln = f,
      Tn = f;
    xt || ((ln = Gr(j)), (ln = ln == u ? v : ln)),
      Kt || ((Tn = Gr(K)), (Tn = Tn == u ? v : Tn));
    var On = ln == v && !lt(j),
      wn = Tn == v && !lt(K),
      jn = ln == Tn;
    if (jn && !On)
      return (
        Ie || (Ie = new ds()),
        xt || Gi(j) ? Vi(j, K, ce, Ee, Ne, Ie) : Wo(j, K, ln, ce, Ee, Ne, Ie)
      );
    if (!(Ne & a)) {
      var br = On && Bt.call(j, "__wrapped__"),
        Pr = wn && Bt.call(K, "__wrapped__");
      if (br || Pr) {
        var Br = br ? j.value() : j,
          qi = Pr ? K.value() : K;
        return Ie || (Ie = new ds()), ce(Br, qi, Ee, Ne, Ie);
      }
    }
    return jn ? (Ie || (Ie = new ds()), qo(j, K, ce, Ee, Ne, Ie)) : !1;
  }
  function du(j, K, ce, Ee) {
    var Ne = ce.length,
      Ie = Ne,
      xt = !Ee;
    if (j == null) return !Ie;
    for (j = Object(j); Ne--; ) {
      var Kt = ce[Ne];
      if (xt && Kt[2] ? Kt[1] !== j[Kt[0]] : !(Kt[0] in j)) return !1;
    }
    for (; ++Ne < Ie; ) {
      Kt = ce[Ne];
      var ln = Kt[0],
        Tn = j[ln],
        On = Kt[1];
      if (xt && Kt[2]) {
        if (Tn === void 0 && !(ln in j)) return !1;
      } else {
        var wn = new ds();
        if (Ee) var jn = Ee(Tn, On, ln, j, K, wn);
        if (!(jn === void 0 ? La(On, Tn, Ee, s | a, wn) : jn)) return !1;
      }
    }
    return !0;
  }
  function zo(j) {
    if (!pn(j) || yu(j)) return !1;
    var K = tn(j) || lt(j) ? Tr : se;
    return K.test(q(j));
  }
  function Ba(j) {
    return xn(j) && Kn(j.length) && !!Q[en.call(j)];
  }
  function Mi(j) {
    return typeof j == "function"
      ? j
      : j == null
      ? fi
      : typeof j == "object"
      ? kt(j)
        ? Us(j[0], j[1])
        : pu(j)
      : X(j);
  }
  function hu(j) {
    if (!vu(j)) return qt(j);
    var K = [];
    for (var ce in Object(j))
      Bt.call(j, ce) && ce != "constructor" && K.push(ce);
    return K;
  }
  function pu(j) {
    var K = gu(j);
    return K.length == 1 && K[0][2]
      ? Un(K[0][0], K[0][1])
      : function (ce) {
          return ce === j || du(ce, j, K);
        };
  }
  function Us(j, K) {
    return Hs(j) && qn(K)
      ? Un(pe(j), K)
      : function (ce) {
          var Ee = $a(ce, j);
          return Ee === void 0 && Ee === K
            ? uc(ce, j)
            : La(K, Ee, void 0, s | a);
        };
  }
  function Vo(j) {
    return function (K) {
      return po(K, j);
    };
  }
  function kl(j) {
    if (typeof j == "string") return j;
    if (Sr(j)) return $n ? $n.call(j) : "";
    var K = j + "";
    return K == "0" && 1 / j == -o ? "-0" : K;
  }
  function mu(j, K, ce) {
    var Ee = -1,
      Ne = Ft,
      Ie = j.length,
      xt = !0,
      Kt = [],
      ln = Kt;
    if (ce) (xt = !1), (Ne = Nt);
    else if (Ie >= n) {
      var Tn = K ? null : Go(j);
      if (Tn) return jt(Tn);
      (xt = !1), (Ne = De), (ln = new fs());
    } else ln = K ? [] : Kt;
    e: for (; ++Ee < Ie; ) {
      var On = j[Ee],
        wn = K ? K(On) : On;
      if (((On = ce || On !== 0 ? On : 0), xt && wn === wn)) {
        for (var jn = ln.length; jn--; ) if (ln[jn] === wn) continue e;
        K && ln.push(wn), Kt.push(On);
      } else Ne(ln, wn, ce) || (ln !== Kt && ln.push(wn), Kt.push(On));
    }
    return Kt;
  }
  function Il(j) {
    return kt(j) ? j : re(j);
  }
  var Go =
    gt && 1 / jt(new gt([, -0]))[1] == o
      ? function (j) {
          return new gt(j);
        }
      : L1;
  function Vi(j, K, ce, Ee, Ne, Ie) {
    var xt = Ne & a,
      Kt = j.length,
      ln = K.length;
    if (Kt != ln && !(xt && ln > Kt)) return !1;
    var Tn = Ie.get(j);
    if (Tn && Ie.get(K)) return Tn == K;
    var On = -1,
      wn = !0,
      jn = Ne & s ? new fs() : void 0;
    for (Ie.set(j, K), Ie.set(K, j); ++On < Kt; ) {
      var br = j[On],
        Pr = K[On];
      if (Ee) var Br = xt ? Ee(Pr, br, On, K, j, Ie) : Ee(br, Pr, On, j, K, Ie);
      if (Br !== void 0) {
        if (Br) continue;
        wn = !1;
        break;
      }
      if (jn) {
        if (
          !Ot(K, function (qi, mo) {
            if (!jn.has(mo) && (br === qi || ce(br, qi, Ee, Ne, Ie)))
              return jn.add(mo);
          })
        ) {
          wn = !1;
          break;
        }
      } else if (!(br === Pr || ce(br, Pr, Ee, Ne, Ie))) {
        wn = !1;
        break;
      }
    }
    return Ie.delete(j), Ie.delete(K), wn;
  }
  function Wo(j, K, ce, Ee, Ne, Ie, xt) {
    switch (ce) {
      case N:
        if (j.byteLength != K.byteLength || j.byteOffset != K.byteOffset)
          return !1;
        (j = j.buffer), (K = K.buffer);
      case A:
        return !(j.byteLength != K.byteLength || !Ee(new Pt(j), new Pt(K)));
      case c:
      case d:
      case y:
        return Me(+j, +K);
      case p:
        return j.name == K.name && j.message == K.message;
      case S:
      case P:
        return j == K + "";
      case w:
        var Kt = Ke;
      case D:
        var ln = Ie & a;
        if ((Kt || (Kt = jt), j.size != K.size && !ln)) return !1;
        var Tn = xt.get(j);
        if (Tn) return Tn == K;
        (Ie |= s), xt.set(j, K);
        var On = Vi(Kt(j), Kt(K), Ee, Ne, Ie, xt);
        return xt.delete(j), On;
      case x:
        if (Vr) return Vr.call(j) == Vr.call(K);
    }
    return !1;
  }
  function qo(j, K, ce, Ee, Ne, Ie) {
    var xt = Ne & a,
      Kt = zs(j),
      ln = Kt.length,
      Tn = zs(K),
      On = Tn.length;
    if (ln != On && !xt) return !1;
    for (var wn = ln; wn--; ) {
      var jn = Kt[wn];
      if (!(xt ? jn in K : Bt.call(K, jn))) return !1;
    }
    var br = Ie.get(j);
    if (br && Ie.get(K)) return br == K;
    var Pr = !0;
    Ie.set(j, K), Ie.set(K, j);
    for (var Br = xt; ++wn < ln; ) {
      jn = Kt[wn];
      var qi = j[jn],
        mo = K[jn];
      if (Ee) var bu = xt ? Ee(mo, qi, jn, K, j, Ie) : Ee(qi, mo, jn, j, K, Ie);
      if (!(bu === void 0 ? qi === mo || ce(qi, mo, Ee, Ne, Ie) : bu)) {
        Pr = !1;
        break;
      }
      Br || (Br = jn == "constructor");
    }
    if (Pr && !Br) {
      var go = j.constructor,
        df = K.constructor;
      go != df &&
        "constructor" in j &&
        "constructor" in K &&
        !(
          typeof go == "function" &&
          go instanceof go &&
          typeof df == "function" &&
          df instanceof df
        ) &&
        (Pr = !1);
    }
    return Ie.delete(j), Ie.delete(K), Pr;
  }
  function hs(j, K) {
    var ce = j.__data__;
    return Fa(K) ? ce[typeof K == "string" ? "string" : "hash"] : ce.map;
  }
  function gu(j) {
    for (var K = zs(j), ce = K.length; ce--; ) {
      var Ee = K[ce],
        Ne = j[Ee];
      K[ce] = [Ee, Ne, qn(Ne)];
    }
    return K;
  }
  function Qr(j, K) {
    var ce = je(j, K);
    return zo(ce) ? ce : void 0;
  }
  var Gr = jo;
  ((Ye && Gr(new Ye(new ArrayBuffer(1))) != N) ||
    (xe && Gr(new xe()) != w) ||
    (nt && Gr(nt.resolve()) != E) ||
    (gt && Gr(new gt()) != D) ||
    (ht && Gr(new ht()) != _)) &&
    (Gr = function (j) {
      var K = en.call(j),
        ce = K == v ? j.constructor : void 0,
        Ee = ce ? q(ce) : void 0;
      if (Ee)
        switch (Ee) {
          case rn:
            return N;
          case ot:
            return w;
          case pt:
            return E;
          case zt:
            return D;
          case Zt:
            return _;
        }
      return K;
    });
  function ps(j, K, ce) {
    K = Hs(K, j) ? [K] : Il(K);
    for (var Ee, Ne = -1, xt = K.length; ++Ne < xt; ) {
      var Ie = pe(K[Ne]);
      if (!(Ee = j != null && ce(j, Ie))) break;
      j = j[Ie];
    }
    if (Ee) return Ee;
    var xt = j ? j.length : 0;
    return !!xt && Kn(xt) && js(Ie, xt) && (kt(j) || St(j));
  }
  function js(j, K) {
    return (
      (K = K ?? l),
      !!K &&
        (typeof j == "number" || Y.test(j)) &&
        j > -1 &&
        j % 1 == 0 &&
        j < K
    );
  }
  function Hs(j, K) {
    if (kt(j)) return !1;
    var ce = typeof j;
    return ce == "number" ||
      ce == "symbol" ||
      ce == "boolean" ||
      j == null ||
      Sr(j)
      ? !0
      : V.test(j) || !R.test(j) || (K != null && j in Object(K));
  }
  function Fa(j) {
    var K = typeof j;
    return K == "string" || K == "number" || K == "symbol" || K == "boolean"
      ? j !== "__proto__"
      : j === null;
  }
  function yu(j) {
    return !!Yt && Yt in j;
  }
  function vu(j) {
    var K = j && j.constructor,
      ce = (typeof K == "function" && K.prototype) || Dt;
    return j === ce;
  }
  function qn(j) {
    return j === j && !pn(j);
  }
  function Un(j, K) {
    return function (ce) {
      return ce == null ? !1 : ce[j] === K && (K !== void 0 || j in Object(ce));
    };
  }
  var re = ve(function (j) {
    j = Wi(j);
    var K = [];
    return (
      oe.test(j) && K.push(""),
      j.replace(le, function (ce, Ee, Ne, Ie) {
        K.push(Ne ? Ie.replace(z, "$1") : Ee || ce);
      }),
      K
    );
  });
  function pe(j) {
    if (typeof j == "string" || Sr(j)) return j;
    var K = j + "";
    return K == "0" && 1 / j == -o ? "-0" : K;
  }
  function q(j) {
    if (j != null) {
      try {
        return sr.call(j);
      } catch {}
      try {
        return j + "";
      } catch {}
    }
    return "";
  }
  function ie(j, K) {
    return j && j.length ? mu(j, Mi(K)) : [];
  }
  function ve(j, K) {
    if (typeof j != "function" || (K && typeof K != "function"))
      throw new TypeError(r);
    var ce = function () {
      var Ee = arguments,
        Ne = K ? K.apply(this, Ee) : Ee[0],
        Ie = ce.cache;
      if (Ie.has(Ne)) return Ie.get(Ne);
      var xt = j.apply(this, Ee);
      return (ce.cache = Ie.set(Ne, xt)), xt;
    };
    return (ce.cache = new (ve.Cache || xi)()), ce;
  }
  ve.Cache = xi;
  function Me(j, K) {
    return j === K || (j !== j && K !== K);
  }
  function St(j) {
    return (
      Et(j) &&
      Bt.call(j, "callee") &&
      (!fn.call(j, "callee") || en.call(j) == u)
    );
  }
  var kt = Array.isArray;
  function _t(j) {
    return j != null && Kn(j.length) && !tn(j);
  }
  function Et(j) {
    return xn(j) && _t(j);
  }
  function tn(j) {
    var K = pn(j) ? en.call(j) : "";
    return K == m || K == g;
  }
  function Kn(j) {
    return typeof j == "number" && j > -1 && j % 1 == 0 && j <= l;
  }
  function pn(j) {
    var K = typeof j;
    return !!j && (K == "object" || K == "function");
  }
  function xn(j) {
    return !!j && typeof j == "object";
  }
  function Sr(j) {
    return typeof j == "symbol" || (xn(j) && en.call(j) == x);
  }
  var Gi = Rt ? $e(Rt) : Ba;
  function Wi(j) {
    return j == null ? "" : kl(j);
  }
  function $a(j, K, ce) {
    var Ee = j == null ? void 0 : po(j, K);
    return Ee === void 0 ? ce : Ee;
  }
  function uc(j, K) {
    return j != null && ps(j, K, Ho);
  }
  function zs(j) {
    return _t(j) ? ho(j) : hu(j);
  }
  function fi(j) {
    return j;
  }
  function L1() {}
  function X(j) {
    return Hs(j) ? Re(pe(j)) : Vo(j);
  }
  t.exports = ie;
})(q5, q5.exports);
var kwe = q5.exports;
const Iwe = oa(kwe);
var yt;
(function (t) {
  (t.AlphaWallet = "isAlphaWallet"),
    (t.ApexWallet = "isApexWallet"),
    (t.AToken = "isAToken"),
    (t.BifrostWallet = "isBifrost"),
    (t.Binance = "bbcSignTx"),
    (t.Bitpie = "isBitpie"),
    (t.BlockWallet = "isBlockWallet"),
    (t.Coinbase = "isToshi"),
    (t.CoinbaseExtension = "isCoinbaseWallet"),
    (t.Detected = "request"),
    (t.Dcent = "isDcentWallet"),
    (t.Exodus = "isExodus"),
    (t.Frontier = "isFrontier"),
    (t.Frame = "isFrame"),
    (t.HuobiWallet = "isHbWallet"),
    (t.HyperPay = "isHyperPay"),
    (t.ImToken = "isImToken"),
    (t.InfinityWallet = "isInfinityWallet"),
    (t.Liquality = "isLiquality"),
    (t.MeetOne = "wallet"),
    (t.MetaMask = "isMetaMask"),
    (t.MyKey = "isMYKEY"),
    (t.OwnBit = "isOwnbit"),
    (t.Status = "isStatus"),
    (t.Trust = "isTrust"),
    (t.TokenPocket = "isTokenPocket"),
    (t.TP = "isTp"),
    (t.WalletIo = "isWalletIO"),
    (t.XDEFI = "isXDEFI"),
    (t.OneInch = "isOneInchIOSWallet"),
    (t.Tokenary = "isTokenary"),
    (t.Tally = "isTally"),
    (t.BraveWallet = "isBraveWallet"),
    (t.Rabby = "isRabby"),
    (t.MathWallet = "isMathWallet"),
    (t.GameStop = "isGamestop"),
    (t.Bitget = "isBitKeep"),
    (t.Sequence = "isSequence"),
    (t.Core = "isAvalanche"),
    (t.Opera = "isOpera"),
    (t.Bitski = "isBitski"),
    (t.Enkrypt = "isEnkrypt"),
    (t.Phantom = "isPhantom"),
    (t.OKXWallet = "isOkxWallet"),
    (t.Zeal = "isZeal"),
    (t.Zerion = "isZerion"),
    (t.Rainbow = "isRainbow"),
    (t.SafePal = "isSafePal"),
    (t.DeFiWallet = "isDeficonnectProvider"),
    (t.Safeheron = "isSafeheron"),
    (t.Talisman = "isTalisman"),
    (t.OneKey = "isOneKey"),
    (t.Fordefi = "isFordefi"),
    (t.Coin98Wallet = "isCoin98"),
    (t.SubWallet = "isSubWallet"),
    (t.Kayros = "isKayros"),
    (t.FoxWallet = "isFoxWallet");
})(yt || (yt = {}));
var Oa;
(function (t) {
  (t.Binance = "https://www.bnbchain.org/ru/blog/binance-extension-wallet/"),
    (t.Bitget = "https://web3.bitget.com/en/wallet-download"),
    (t.Coinbase = "https://www.coinbase.com/wallet/downloads"),
    (t.MetaMask = "https://metamask.io/download/"),
    (t.OKXWallet = "https://okx.com/download"),
    (t.Phantom = "https://phantom.app/ul/v1/connect"),
    (t.Talisman = "https://www.talisman.xyz/"),
    (t.Trust = "https://link.trustwallet.com"),
    (t.OneKey = "https://onekey.so/download/"),
    (t.RoninWallet = "https://wallet.skymavis.com/"),
    (t.Coin98Wallet = "https://coin98.com/wallet/"),
    (t.SubWallet = "https://www.subwallet.app/"),
    (t.Kayros = "https://www.kayros.games/wallet/"),
    (t.XDEFI = "https://xdefi.io/"),
    (t.FoxWallet = "https://foxwallet.com/download");
})(Oa || (Oa = {}));
var Xt;
(function (t) {
  (t.AlphaWallet = "AlphaWallet"),
    (t.ApexWallet = "Apex Wallet"),
    (t.AToken = "AToken"),
    (t.BifrostWallet = "Bifrost Wallet"),
    (t.Binance = "Binance Smart Wallet"),
    (t.Bitpie = "Bitpie"),
    (t.Bitski = "Bitski"),
    (t.BlockWallet = "BlockWallet"),
    (t.Brave = "Brave Wallet"),
    (t.Coinbase = "Coinbase Wallet"),
    (t.Dcent = "D'CENT"),
    (t.Detected = "Detected Wallet"),
    (t.Exodus = "Exodus"),
    (t.Frame = "Frame"),
    (t.Frontier = "Frontier"),
    (t.HuobiWallet = "Huobi Wallet"),
    (t.HyperPay = "HyperPay"),
    (t.ImToken = "imToken"),
    (t.InfinityWallet = "Infinity Wallet"),
    (t.Liquality = "Liquality"),
    (t.MeetOne = "MeetOne"),
    (t.MetaMask = "MetaMask"),
    (t.MyKey = "MyKey"),
    (t.Opera = "Opera Wallet"),
    (t.OwnBit = "OwnBit"),
    (t.Status = "Status Wallet"),
    (t.Trust = "Trust Wallet"),
    (t.TokenPocket = "TokenPocket"),
    (t.TP = "TP Wallet"),
    (t.WalletIo = "Wallet.io"),
    (t.XDEFI = "XDEFI Wallet"),
    (t.OneInch = "1inch Wallet"),
    (t.Tokenary = "Tokenary Wallet"),
    (t.Tally = "Taho"),
    (t.Rabby = "Rabby Wallet"),
    (t.MathWallet = "MathWallet"),
    (t.GameStop = "GameStop Wallet"),
    (t.Bitget = "Bitget Wallet"),
    (t.Sequence = "Sequence"),
    (t.Core = "Core"),
    (t.Enkrypt = "Enkrypt"),
    (t.Zeal = "Zeal"),
    (t.Phantom = "Phantom"),
    (t.OKXWallet = "OKX Wallet"),
    (t.Zerion = "Zerion"),
    (t.Rainbow = "Rainbow"),
    (t.SafePal = "SafePal"),
    (t.DeFiWallet = "DeFi Wallet"),
    (t.Safeheron = "Safeheron"),
    (t.Talisman = "Talisman"),
    (t.OneKey = "OneKey"),
    (t.Fordefi = "Fordefi"),
    (t.RoninWallet = "Ronin Wallet"),
    (t.Coin98Wallet = "Coin98 Wallet"),
    (t.SubWallet = "SubWallet"),
    (t.Kayros = "Kayros"),
    (t.FoxWallet = "FoxWallet");
})(Xt || (Xt = {}));
var It;
(function (t) {
  (t.Ethereum = "ethereum"),
    (t.Binance = "BinanceChain"),
    (t.Tally = "tally"),
    (t.Web3 = "web3"),
    (t.Arbitrum = "arbitrum"),
    (t.XFI = "xfi"),
    (t.GameStop = "gamestop"),
    (t.Bitget = "bitkeep"),
    (t.Avalanche = "avalanche"),
    (t.Bitski = "Bitski"),
    (t.Enkrypt = "enkrypt"),
    (t.Zeal = "zeal"),
    (t.Phantom = "phantom"),
    (t.OKXWallet = "okxwallet"),
    (t.Trust = "trustwallet"),
    (t.Frontier = "frontier"),
    (t.DeFiConnectProvider = "deficonnectProvider"),
    (t.Safeheron = "safeheron"),
    (t.Talisman = "talismanEth"),
    (t.OneKey = "$onekey"),
    (t.RoninWallet = "ronin"),
    (t.Coin98Wallet = "coin98"),
    (t.SubWallet = "SubWallet"),
    (t.Kayros = "kayros"),
    (t.FoxWallet = "foxwallet");
})(It || (It = {}));
const ts = null;
function Sl(t, e) {
  return async () => ({
    provider:
      window.ethereum.providers && Array.isArray(window.ethereum.providers)
        ? Owe(t, e)
        : window.ethereum,
  });
}
function Owe(t, e) {
  return window.ethereum.providers.find((n) =>
    e ? !!n[t] && !IG(t, n) : !!n[t]
  );
}
function IG(t, e) {
  return Object.values(yt)
    .filter((r) => r !== t && r !== yt.Detected)
    .some((r) => !!e[r]);
}
const Pwe = {
    label: Xt.MetaMask,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t[yt.MetaMask] && !IG(yt.MetaMask, t),
    getIcon: async () =>
      (await qe(() => import("./metamask-18a6d592.js"), [])).default,
    getInterface: Sl(yt.MetaMask, !0),
    platforms: ["all"],
    externalUrl: Oa.MetaMask,
  },
  Nwe = {
    label: Xt.InfinityWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.InfinityWallet],
    getIcon: async () =>
      (await qe(() => import("./infinitywallet-98962d06.js"), [])).default,
    getInterface: Sl(yt.InfinityWallet),
    platforms: ["desktop"],
  },
  Dwe = {
    label: Xt.Exodus,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Exodus],
    getIcon: async () =>
      (await qe(() => import("./exodus-49cf29d1.js"), [])).default,
    getInterface: Sl(yt.Exodus),
    platforms: ["all"],
  },
  Rwe = {
    label: Xt.Frontier,
    injectedNamespace: It.Frontier,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t.ethereum && !!t.ethereum[yt.Frontier],
    getIcon: async () =>
      (await qe(() => import("./frontier-a13ff526.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.frontier.ethereum) }),
    platforms: ["all"],
  },
  Mwe = {
    label: Xt.Brave,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.BraveWallet],
    getIcon: async () =>
      (await qe(() => import("./brave-dbe43c38.js"), [])).default,
    getInterface: Sl(yt.BraveWallet),
    platforms: ["all"],
  },
  Lwe = {
    label: Xt.Binance,
    injectedNamespace: It.Binance,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Binance],
    getIcon: async () =>
      (await qe(() => import("./binance-af66b9ec.js"), [])).default,
    getInterface: async () => {
      let t = { ...window.BinanceChain };
      window.BinanceChain = t;
      const e = window.BinanceChain.on.bind(window.BinanceChain);
      window.BinanceChain.on = (r, i) => {
        r === "chainChanged"
          ? e(r, (s) => {
              i(`0x${parseInt(s).toString(16)}`);
            })
          : e(r, i);
      };
      const n = hr(window.BinanceChain, {
        eth_chainId: ({ baseRequest: r }) =>
          r({ method: "eth_chainId" }).then(
            (i) => `0x${parseInt(i).toString(16)}`
          ),
        eth_selectAccounts: ts,
        wallet_switchEthereumChain: ts,
      });
      return (n.removeListener = (r, i) => {}), { provider: n };
    },
    platforms: ["desktop"],
    externalUrl: Oa.Binance,
  },
  Bwe = {
    label: Xt.Coinbase,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) =>
      (!!t && !!t[yt.Coinbase]) || (!!t && !!t[yt.CoinbaseExtension]),
    getIcon: async () =>
      (await qe(() => import("./coinbase-41f9b41e.js"), [])).default,
    getInterface: async () => {
      const { provider: t } = await Sl(yt.CoinbaseExtension)(),
        e = t.on.bind(t);
      return (
        (t.on = (n, r) => {
          n === "chainChanged"
            ? e(n, (i) => {
                r(`0x${parseInt(i).toString(16)}`);
              })
            : e(n, r);
        }),
        { provider: t }
      );
    },
    platforms: ["all"],
    externalUrl: Oa.Coinbase,
  },
  Fwe = {
    label: Xt.Detected,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Detected],
    getIcon: async () =>
      (await qe(() => import("./detected-5d7e3074.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["all"],
  },
  $we = {
    label: Xt.Trust,
    injectedNamespace: It.Trust,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Trust],
    getIcon: async () =>
      (await qe(() => import("./trust-5f68fe85.js"), [])).default,
    getInterface: async () => {
      const t = window.hasOwnProperty(It.Ethereum);
      let e;
      return (
        t && window[It.Ethereum].isTrust
          ? (e = window[It.Ethereum])
          : (e = window[It.Trust]),
        { provider: e }
      );
    },
    platforms: ["all"],
    externalUrl: Oa.Trust,
  },
  Uwe = {
    label: Xt.Opera,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Opera],
    getIcon: async () =>
      (await qe(() => import("./opera-1138f84d.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        eth_requestAccounts: async ({ baseRequest: t }) =>
          t({ method: "eth_accounts" }),
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["all"],
  },
  jwe = {
    label: Xt.Status,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Status],
    getIcon: async () =>
      (await qe(() => import("./status-d4a015f8.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  Hwe = {
    label: Xt.AlphaWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.AlphaWallet],
    getIcon: async () =>
      (await qe(() => import("./alphawallet-222e9b85.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["mobile"],
  },
  zwe = {
    label: Xt.ApexWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.ApexWallet],
    getIcon: async () =>
      (await qe(() => import("./apexwallet-26646b1d.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  Vwe = {
    label: Xt.AToken,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.AToken],
    getIcon: async () =>
      (await qe(() => import("./atoken-5ee95569.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  Gwe = {
    label: Xt.BifrostWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.BifrostWallet],
    getIcon: async () =>
      (await qe(() => import("./bifrostwallet-712a19ce.js"), [])).default,
    getInterface: Sl(yt.BifrostWallet),
    platforms: ["all"],
  },
  Wwe = {
    label: Xt.Bitpie,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: () => !!window.Bitpie,
    getIcon: async () =>
      (await qe(() => import("./bitpie-d6bc063e.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["mobile"],
  },
  qwe = {
    label: Xt.BlockWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.BlockWallet],
    getIcon: async () =>
      (await qe(() => import("./blockwallet-224dc3e7.js"), [])).default,
    getInterface: Sl(yt.BlockWallet),
    platforms: ["desktop"],
  },
  Kwe = {
    label: Xt.Frame,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Frame],
    getIcon: async () =>
      (await qe(() => import("./frame-c05fd086.js"), [])).default,
    getInterface: async () => {
      const t = window.ethereum;
      if (!t || !t.connected)
        throw new Error(
          "Frame App must be open with a hot wallet connected. If not installed first download the Frame App."
        );
      return { provider: t };
    },
    platforms: ["desktop"],
  },
  Xwe = {
    label: Xt.HuobiWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.HuobiWallet],
    getIcon: async () =>
      (await qe(() => import("./huobiwallet-630a31a8.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["mobile"],
  },
  Zwe = {
    label: Xt.HyperPay,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: () => !!window.hiWallet,
    getIcon: async () =>
      (await qe(() => import("./hyperpay-f3690ad6.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["mobile"],
  },
  Ywe = {
    label: Xt.ImToken,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.ImToken],
    getIcon: async () =>
      (await qe(() => import("./imtoken-4265b051.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, { eth_selectAccounts: ts }),
    }),
    platforms: ["mobile"],
  },
  Qwe = {
    label: Xt.Liquality,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Liquality],
    getIcon: async () =>
      (await qe(() => import("./liquality-fba27638.js"), [])).default,
    getInterface: async () => {
      const t = hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      });
      return (t.removeListener = (e, n) => {}), { provider: t };
    },
    platforms: ["desktop"],
  },
  Jwe = {
    label: Xt.MeetOne,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && t[yt.MeetOne] === "MEETONE",
    getIcon: async () =>
      (await qe(() => import("./meetone-d95f585f.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  e6e = {
    label: Xt.MyKey,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.MyKey],
    getIcon: async () =>
      (await qe(() => import("./mykey-c1b5b806.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  t6e = {
    label: Xt.OwnBit,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.OwnBit],
    getIcon: async () =>
      (await qe(() => import("./ownbit-e0c2b37c.js"), [])).default,
    getInterface: async () => {
      const t = hr(window.ethereum, {
        eth_chainId: ({ baseRequest: e }) =>
          e({ method: "eth_chainId" }).then(
            (n) => `0x${parseInt(n).toString(16)}`
          ),
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      });
      return (
        (t.removeListener = (e, n) => {}),
        (t.on = (e, n) => {}),
        { provider: t }
      );
    },
    platforms: ["mobile"],
  },
  n6e = {
    label: Xt.TokenPocket,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t[yt.TokenPocket] && !t[yt.TP],
    getIcon: async () =>
      (await qe(() => import("./tokenpocket-47af1e38.js"), [])).default,
    getInterface: Sl(yt.TokenPocket),
    platforms: ["all"],
  },
  r6e = {
    label: Xt.TP,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.TP],
    getIcon: async () =>
      (await qe(() => import("./tp-611fffd5.js"), [])).default,
    getInterface: async () => ({
      provider: hr(window.ethereum, {
        wallet_switchEthereumChain: ts,
        eth_selectAccounts: ts,
      }),
    }),
    platforms: ["mobile"],
  },
  i6e = {
    label: Xt.XDEFI,
    injectedNamespace: It.XFI,
    checkProviderIdentity: ({ provider: t }) =>
      t && t.ethereum && t.ethereum[yt.XDEFI],
    getIcon: async () =>
      (await qe(() => import("./xdefi-bfe73fb4.js"), [])).default,
    getInterface: async () => ({ provider: window.xfi && window.xfi.ethereum }),
    platforms: ["all"],
    externalUrl: Oa.XDEFI,
  },
  s6e = {
    label: Xt.OneInch,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.OneInch],
    getIcon: async () =>
      (await qe(() => import("./oneInch-30596bb6.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ethereum) }),
    platforms: ["mobile"],
  },
  a6e = {
    label: Xt.Tokenary,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Tokenary],
    getIcon: async () =>
      (await qe(() => import("./tokenary-6ec73b07.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ethereum) }),
    platforms: ["all"],
  },
  o6e = {
    label: Xt.Tally,
    injectedNamespace: It.Tally,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Tally],
    getIcon: async () =>
      (await qe(() => import("./tallywallet-7e74e87b.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.tally) }),
    platforms: ["desktop"],
  },
  l6e = {
    label: Xt.Zeal,
    injectedNamespace: It.Zeal,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Zeal],
    getIcon: async () =>
      (await qe(() => import("./zeal-801d5746.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.zeal) }),
    platforms: ["desktop"],
  },
  u6e = {
    label: Xt.Rabby,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Rabby],
    getIcon: async () =>
      (await qe(() => import("./rabby-0c80bc63.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ethereum) }),
    platforms: ["desktop"],
  },
  c6e = {
    label: Xt.MathWallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.MathWallet],
    getIcon: async () =>
      (await qe(() => import("./mathwallet-9686bb69.js"), [])).default,
    getInterface: Sl(yt.MathWallet),
    platforms: ["all"],
  },
  f6e = {
    label: Xt.GameStop,
    injectedNamespace: It.GameStop,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.GameStop],
    getIcon: async () =>
      (await qe(() => import("./gamestop-f7af96f8.js"), [])).default,
    getInterface: async () => {
      const t = hr(window.gamestop, {
        eth_chainId: ({ baseRequest: e }) =>
          e({ method: "eth_chainId" }).then(
            (n) => `0x${parseInt(n).toString(16)}`
          ),
        wallet_switchEthereumChain: ts,
      });
      return (
        (t.removeListener = (e, n) => {}),
        (t.on = (e, n) => {}),
        { provider: t }
      );
    },
    platforms: ["desktop"],
  },
  d6e = {
    label: Xt.Bitget,
    injectedNamespace: It.Bitget,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t.ethereum[yt.Bitget],
    getIcon: async () =>
      (await qe(() => import("./bitget-382820c7.js"), [])).default,
    getInterface: async () => ({
      provider: window.bitkeep && window.bitkeep.ethereum,
    }),
    platforms: ["all"],
    externalUrl: Oa.Bitget,
  },
  h6e = {
    label: Xt.Sequence,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Sequence],
    getIcon: async () =>
      (await qe(() => import("./sequence-03a89ec8.js"), [])).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["all"],
  },
  p6e = {
    label: Xt.Core,
    injectedNamespace: It.Avalanche,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Core],
    getIcon: async () =>
      (await qe(() => import("./core-608d5e6b.js"), [])).default,
    getInterface: Sl(yt.Core),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  m6e = {
    label: Xt.Bitski,
    injectedNamespace: It.Bitski,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t.getProvider && !!t.getProvider().isBitski,
    getIcon: async () =>
      (await qe(() => import("./bitski-e50f5480.js"), [])).default,
    getInterface: async () => ({
      provider:
        window.Bitski &&
        window.Bitski.getProvider &&
        window.Bitski.getProvider(),
    }),
    platforms: ["all"],
  },
  g6e = {
    label: Xt.Zerion,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Zerion],
    getIcon: async () =>
      (await qe(() => import("./zerion-079c181f.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ethereum) }),
    platforms: ["all"],
  },
  y6e = {
    label: Xt.Enkrypt,
    injectedNamespace: It.Enkrypt,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t.providers && !!t.providers.ethereum,
    getIcon: async () =>
      (await qe(() => import("./enkrypt-2a9c7712.js"), [])).default,
    getInterface: async () => {
      const t = window.enkrypt.providers.ethereum.on.bind(
        window.enkrypt.providers.ethereum
      );
      window.enkrypt.providers.ethereum.on = (n, r) => {
        n === "chainChanged"
          ? t(n, (i) => {
              r(`0x${parseInt(i).toString(16)}`);
            })
          : t(n, r);
      };
      const e = hr(window.enkrypt.providers.ethereum, {
        eth_chainId: ({ baseRequest: n }) =>
          n({ method: "eth_chainId" }).then(
            (r) => `0x${parseInt(r).toString(16)}`
          ),
      });
      return (e.removeListener = (n, r) => {}), { provider: e };
    },
    platforms: ["all"],
  },
  v6e = {
    label: Xt.Phantom,
    injectedNamespace: It.Phantom,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t.ethereum && !!t.ethereum[yt.Phantom],
    getIcon: async () =>
      (await qe(() => import("./phantom-472465bc.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.phantom.ethereum) }),
    platforms: ["all"],
    externalUrl: Oa.Phantom,
  },
  b6e = {
    label: Xt.SafePal,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.SafePal],
    getIcon: async () =>
      (await qe(() => import("./safepal-95ad8417.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ethereum) }),
    platforms: ["all"],
  },
  w6e = {
    label: Xt.Rainbow,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Rainbow],
    getIcon: async () =>
      (await qe(() => import("./rainbow-30b07276.js"), [])).default,
    getInterface: Sl(yt.Rainbow),
    platforms: ["all"],
  },
  _6e = {
    label: Xt.OKXWallet,
    injectedNamespace: It.OKXWallet,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.OKXWallet],
    getIcon: async () =>
      (await qe(() => import("./okxwallet-e459ad77.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.okxwallet) }),
    platforms: ["all"],
    externalUrl: Oa.OKXWallet,
  },
  E6e = {
    label: Xt.DeFiWallet,
    injectedNamespace: It.DeFiConnectProvider,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.DeFiWallet],
    getIcon: async () =>
      (await qe(() => import("./defiwallet-a34f8959.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.deficonnectProvider) }),
    platforms: ["all"],
  },
  x6e = {
    label: Xt.Safeheron,
    injectedNamespace: It.Safeheron,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Safeheron],
    getIcon: async () =>
      (await qe(() => import("./safeheron-1d7d4aab.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.safeheron) }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  T6e = {
    label: Xt.Talisman,
    injectedNamespace: It.Talisman,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Talisman],
    getIcon: async () =>
      (await qe(() => import("./talisman-648cb7f0.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.talismanEth) }),
    platforms: ["desktop"],
    externalUrl: Oa.Talisman,
  },
  S6e = {
    label: Xt.RoninWallet,
    injectedNamespace: It.RoninWallet,
    checkProviderIdentity: ({ provider: t }) => !!t,
    getIcon: async () =>
      (await qe(() => import("./roninwallet-a02fc8ec.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.ronin.provider) }),
    platforms: ["all"],
    externalUrl: Oa.RoninWallet,
  },
  A6e = {
    label: Xt.OneKey,
    injectedNamespace: It.OneKey,
    checkProviderIdentity: ({ provider: t }) =>
      !!t && !!t.ethereum && !!t.ethereum[yt.OneKey],
    getIcon: async () =>
      (await qe(() => import("./onekey-d2703259.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.$onekey.ethereum) }),
    platforms: ["all"],
    externalUrl: Oa.OneKey,
  },
  C6e = {
    label: Xt.Fordefi,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Fordefi],
    getIcon: async () =>
      (await qe(() => import("./fordefi-d9eaaba6.js"), [])).default,
    getInterface: Sl(yt.Fordefi, !0),
    platforms: ["desktop"],
  },
  k6e = {
    label: Xt.Coin98Wallet,
    injectedNamespace: It.Ethereum,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Coin98Wallet],
    getIcon: async () =>
      (await qe(() => import("./coin98wallet-ca7a9677.js"), [])).default,
    getInterface: async () => {
      const t = window.hasOwnProperty(It.Ethereum);
      let e;
      return (
        t && window[It.Ethereum].isCoin98
          ? (e = window[It.Ethereum])
          : (e = window[It.Coin98Wallet].provider),
        { provider: e }
      );
    },
    platforms: ["all"],
    externalUrl: Oa.Coin98Wallet,
  },
  I6e = {
    label: Xt.SubWallet,
    injectedNamespace: It.SubWallet,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.SubWallet],
    getIcon: async () =>
      (await qe(() => import("./subwallet-8bfc746e.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.SubWallet) }),
    platforms: ["all"],
    externalUrl: Oa.SubWallet,
  },
  O6e = {
    label: Xt.Kayros,
    injectedNamespace: It.Kayros,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.Kayros],
    getIcon: async () =>
      (await qe(() => import("./kayros-d6fa636b.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.kayros) }),
    platforms: ["desktop"],
  },
  P6e = {
    label: Xt.FoxWallet,
    injectedNamespace: It.FoxWallet,
    checkProviderIdentity: ({ provider: t }) => !!t && !!t[yt.FoxWallet],
    getIcon: async () =>
      (await qe(() => import("./foxwallet-d384c30e.js"), [])).default,
    getInterface: async () => ({ provider: hr(window.foxwallet) }),
    platforms: ["mobile"],
  },
  N6e = [
    l6e,
    Dwe,
    Rwe,
    Pwe,
    Gwe,
    Lwe,
    Bwe,
    Fwe,
    $we,
    Uwe,
    jwe,
    Hwe,
    zwe,
    Vwe,
    d6e,
    Wwe,
    qwe,
    Mwe,
    Kwe,
    Xwe,
    Zwe,
    Ywe,
    Qwe,
    Jwe,
    e6e,
    t6e,
    n6e,
    r6e,
    i6e,
    s6e,
    a6e,
    o6e,
    u6e,
    c6e,
    f6e,
    h6e,
    p6e,
    m6e,
    y6e,
    v6e,
    _6e,
    g6e,
    w6e,
    b6e,
    E6e,
    Nwe,
    x6e,
    T6e,
    A6e,
    C6e,
    S6e,
    k6e,
    I6e,
    O6e,
    P6e,
  ],
  D6e = ae.object({
    label: ae.string().required(),
    getIcon: ae.function().arity(0).required(),
    getInterface: ae.function().maxArity(1).required(),
    injectedNamespace: ae.string().required(),
    checkProviderIdentity: ae.function().arity(1).required(),
    platforms: ae.array().items(ae.string()),
    externalUrl: ae.string(),
  }),
  R6e = ae.array().items(D6e),
  M6e = ae
    .object()
    .pattern(
      /\w+/,
      ae.any().allow(ae.boolean(), ae.array().items(ae.string()))
    ),
  L6e = ae.object({
    custom: R6e,
    filter: M6e,
    displayUnavailable: [ae.boolean(), ae.array().items(ae.string())],
    walletUnavailableMessage: ae.function(),
    sort: ae.function(),
    externalUrl: ae.string(),
  }),
  B6e = (t) => Ri(L6e, t),
  F6e = ({ label: t, externalUrl: e }) =>
    e
      ? `Please <a href="${e}" target="_blank">install or switch to</a> ${t} to continue`
      : `Please install or enable ${t} to continue`,
  $6e = (t, e, n) => {
    var r;
    return t
      ? e({ provider: t, device: n })
        ? !0
        : !!(
            !((r = t.providers) === null || r === void 0) &&
            r.some((i) => e({ provider: i, device: n }))
          )
      : !1;
  };
function U6e(t) {
  if (typeof window > "u") return () => null;
  if (t) {
    const e = B6e(t);
    if (e && e.error) throw e.error;
  }
  return (e) => {
    const { device: n } = e,
      {
        custom: r = [],
        filter: i = {},
        displayUnavailable: s,
        sort: a,
        walletUnavailableMessage: o,
      } = t || {},
      u = Iwe([...r, ...N6e], ({ label: f }) => f).reduce((f, c) => {
        const {
            label: d,
            platforms: p,
            injectedNamespace: m,
            checkProviderIdentity: g,
          } = c,
          w = i[d],
          y = w === !1,
          v = window[m],
          E = $6e(v, g, n);
        let S = !1;
        Array.isArray(w) &&
          (w.includes(n.type) || w.includes(n.os.name)) &&
          (S = !0),
          w === "unavailable" && !E && (S = !0);
        const D =
          !p.includes("all") && !p.includes(n.type) && !p.includes(n.os.name);
        return (
          !y &&
            !S &&
            !D &&
            (E ||
              s === !0 ||
              (Array.isArray(s) && s.length && s.includes(c.label))) &&
            f.push(
              (s === !0 ||
                (Array.isArray(s) && s.length && s.includes(c.label))) &&
                !E
                ? {
                    ...c,
                    getInterface: async () => {
                      throw new Error(o ? o(c) : F6e(c));
                    },
                  }
                : c
            ),
          f
        );
      }, []);
    if (u.length) {
      const f = u.length > 1,
        c = u
          .filter((d) => {
            const { label: p } = d;
            return !(p === Xt.Detected && f);
          })
          .map(({ label: d, getIcon: p, getInterface: m }) => ({
            label: d,
            getIcon: p,
            getInterface: m,
          }))
          .sort((d, p) => (d.label < p.label ? -1 : d.label > p.label ? 1 : 0));
      return a ? a(c) : c;
    }
    return [];
  };
}
const j6e = ae.object({
    handleUri: ae.func().optional(),
    version: ae
      .number()
      .optional()
      .custom((t, e) => {
        if (t === 1)
          console.warn(
            "Version 1 of WalletConnect has been fully deprecated. This version of @web3-onboard/walletconnect only supports version 2"
          );
        else if (t !== 2 && t !== void 0)
          return e.error("any.invalid", {
            message:
              "Invalid version number. This version of @web3-onboard/walletconnect only supports version 2",
          });
        return t;
      }, "Custom version validation"),
    projectId: ae.string().messages({
      "any.required":
        "WalletConnect version 2 requires a projectId. Please visit https://cloud.walletconnect.com to get one.",
    }),
    dappUrl: ae
      .string()
      .optional()
      .custom(
        (t, e) =>
          t ||
          e.message({
            message:
              "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection.",
            type: "any.custom",
          }),
        "Custom dappUrl validation"
      ),
    requiredChains: ae.array().items(ae.number()).optional(),
    optionalChains: ae.array().items(ae.number()).optional(),
    qrModalOptions: ae.object().optional(),
    additionalRequiredMethods: ae.array().items(ae.string()).optional(),
    additionalOptionalMethods: ae.array().items(ae.string()).optional(),
  }),
  H6e = (t, e) => {
    const n = t.validate(e);
    return n.error ? n : null;
  },
  z6e = (t) => H6e(j6e, t);
var XT = { exports: {} },
  b0 = typeof Reflect == "object" ? Reflect : null,
  rM =
    b0 && typeof b0.apply == "function"
      ? b0.apply
      : function (e, n, r) {
          return Function.prototype.apply.call(e, n, r);
        },
  pb;
b0 && typeof b0.ownKeys == "function"
  ? (pb = b0.ownKeys)
  : Object.getOwnPropertySymbols
  ? (pb = function (e) {
      return Object.getOwnPropertyNames(e).concat(
        Object.getOwnPropertySymbols(e)
      );
    })
  : (pb = function (e) {
      return Object.getOwnPropertyNames(e);
    });
function V6e(t) {
  console && console.warn && console.warn(t);
}
var OG =
  Number.isNaN ||
  function (e) {
    return e !== e;
  };
function Er() {
  Er.init.call(this);
}
XT.exports = Er;
XT.exports.once = K6e;
Er.EventEmitter = Er;
Er.prototype._events = void 0;
Er.prototype._eventsCount = 0;
Er.prototype._maxListeners = void 0;
var iM = 10;
function c6(t) {
  if (typeof t != "function")
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' +
        typeof t
    );
}
Object.defineProperty(Er, "defaultMaxListeners", {
  enumerable: !0,
  get: function () {
    return iM;
  },
  set: function (t) {
    if (typeof t != "number" || t < 0 || OG(t))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          t +
          "."
      );
    iM = t;
  },
});
Er.init = function () {
  (this._events === void 0 ||
    this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0);
};
Er.prototype.setMaxListeners = function (e) {
  if (typeof e != "number" || e < 0 || OG(e))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' +
        e +
        "."
    );
  return (this._maxListeners = e), this;
};
function PG(t) {
  return t._maxListeners === void 0 ? Er.defaultMaxListeners : t._maxListeners;
}
Er.prototype.getMaxListeners = function () {
  return PG(this);
};
Er.prototype.emit = function (e) {
  for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
  var i = e === "error",
    s = this._events;
  if (s !== void 0) i = i && s.error === void 0;
  else if (!i) return !1;
  if (i) {
    var a;
    if ((n.length > 0 && (a = n[0]), a instanceof Error)) throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw ((o.context = a), o);
  }
  var l = s[e];
  if (l === void 0) return !1;
  if (typeof l == "function") rM(l, this, n);
  else
    for (var u = l.length, f = LG(l, u), r = 0; r < u; ++r) rM(f[r], this, n);
  return !0;
};
function NG(t, e, n, r) {
  var i, s, a;
  if (
    (c6(n),
    (s = t._events),
    s === void 0
      ? ((s = t._events = Object.create(null)), (t._eventsCount = 0))
      : (s.newListener !== void 0 &&
          (t.emit("newListener", e, n.listener ? n.listener : n),
          (s = t._events)),
        (a = s[e])),
    a === void 0)
  )
    (a = s[e] = n), ++t._eventsCount;
  else if (
    (typeof a == "function"
      ? (a = s[e] = r ? [n, a] : [a, n])
      : r
      ? a.unshift(n)
      : a.push(n),
    (i = PG(t)),
    i > 0 && a.length > i && !a.warned)
  ) {
    a.warned = !0;
    var o = new Error(
      "Possible EventEmitter memory leak detected. " +
        a.length +
        " " +
        String(e) +
        " listeners added. Use emitter.setMaxListeners() to increase limit"
    );
    (o.name = "MaxListenersExceededWarning"),
      (o.emitter = t),
      (o.type = e),
      (o.count = a.length),
      V6e(o);
  }
  return t;
}
Er.prototype.addListener = function (e, n) {
  return NG(this, e, n, !1);
};
Er.prototype.on = Er.prototype.addListener;
Er.prototype.prependListener = function (e, n) {
  return NG(this, e, n, !0);
};
function G6e() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    );
}
function DG(t, e, n) {
  var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n },
    i = G6e.bind(r);
  return (i.listener = n), (r.wrapFn = i), i;
}
Er.prototype.once = function (e, n) {
  return c6(n), this.on(e, DG(this, e, n)), this;
};
Er.prototype.prependOnceListener = function (e, n) {
  return c6(n), this.prependListener(e, DG(this, e, n)), this;
};
Er.prototype.removeListener = function (e, n) {
  var r, i, s, a, o;
  if ((c6(n), (i = this._events), i === void 0)) return this;
  if (((r = i[e]), r === void 0)) return this;
  if (r === n || r.listener === n)
    --this._eventsCount === 0
      ? (this._events = Object.create(null))
      : (delete i[e],
        i.removeListener && this.emit("removeListener", e, r.listener || n));
  else if (typeof r != "function") {
    for (s = -1, a = r.length - 1; a >= 0; a--)
      if (r[a] === n || r[a].listener === n) {
        (o = r[a].listener), (s = a);
        break;
      }
    if (s < 0) return this;
    s === 0 ? r.shift() : W6e(r, s),
      r.length === 1 && (i[e] = r[0]),
      i.removeListener !== void 0 && this.emit("removeListener", e, o || n);
  }
  return this;
};
Er.prototype.off = Er.prototype.removeListener;
Er.prototype.removeAllListeners = function (e) {
  var n, r, i;
  if (((r = this._events), r === void 0)) return this;
  if (r.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : r[e] !== void 0 &&
          (--this._eventsCount === 0
            ? (this._events = Object.create(null))
            : delete r[e]),
      this
    );
  if (arguments.length === 0) {
    var s = Object.keys(r),
      a;
    for (i = 0; i < s.length; ++i)
      (a = s[i]), a !== "removeListener" && this.removeAllListeners(a);
    return (
      this.removeAllListeners("removeListener"),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    );
  }
  if (((n = r[e]), typeof n == "function")) this.removeListener(e, n);
  else if (n !== void 0)
    for (i = n.length - 1; i >= 0; i--) this.removeListener(e, n[i]);
  return this;
};
function RG(t, e, n) {
  var r = t._events;
  if (r === void 0) return [];
  var i = r[e];
  return i === void 0
    ? []
    : typeof i == "function"
    ? n
      ? [i.listener || i]
      : [i]
    : n
    ? q6e(i)
    : LG(i, i.length);
}
Er.prototype.listeners = function (e) {
  return RG(this, e, !0);
};
Er.prototype.rawListeners = function (e) {
  return RG(this, e, !1);
};
Er.listenerCount = function (t, e) {
  return typeof t.listenerCount == "function"
    ? t.listenerCount(e)
    : MG.call(t, e);
};
Er.prototype.listenerCount = MG;
function MG(t) {
  var e = this._events;
  if (e !== void 0) {
    var n = e[t];
    if (typeof n == "function") return 1;
    if (n !== void 0) return n.length;
  }
  return 0;
}
Er.prototype.eventNames = function () {
  return this._eventsCount > 0 ? pb(this._events) : [];
};
function LG(t, e) {
  for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];
  return n;
}
function W6e(t, e) {
  for (; e + 1 < t.length; e++) t[e] = t[e + 1];
  t.pop();
}
function q6e(t) {
  for (var e = new Array(t.length), n = 0; n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function K6e(t, e) {
  return new Promise(function (n, r) {
    function i(a) {
      t.removeListener(e, s), r(a);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i),
        n([].slice.call(arguments));
    }
    BG(t, e, s, { once: !0 }), e !== "error" && X6e(t, i, { once: !0 });
  });
}
function X6e(t, e, n) {
  typeof t.on == "function" && BG(t, "error", e, n);
}
function BG(t, e, n, r) {
  if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      r.once && t.removeEventListener(e, i), n(s);
    });
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' +
        typeof t
    );
}
var Fo = XT.exports;
const ZT = oa(Fo);
var YT = {},
  f6 = {},
  _n = {},
  FG = {};
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(o, l) {
    var u = (o >>> 16) & 65535,
      f = o & 65535,
      c = (l >>> 16) & 65535,
      d = l & 65535;
    return (f * d + (((u * d + f * c) << 16) >>> 0)) | 0;
  }
  t.mul = Math.imul || e;
  function n(o, l) {
    return (o + l) | 0;
  }
  t.add = n;
  function r(o, l) {
    return (o - l) | 0;
  }
  t.sub = r;
  function i(o, l) {
    return (o << l) | (o >>> (32 - l));
  }
  t.rotl = i;
  function s(o, l) {
    return (o << (32 - l)) | (o >>> l);
  }
  t.rotr = s;
  function a(o) {
    return typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  }
  (t.isInteger = Number.isInteger || a),
    (t.MAX_SAFE_INTEGER = 9007199254740991),
    (t.isSafeInteger = function (o) {
      return (
        t.isInteger(o) && o >= -t.MAX_SAFE_INTEGER && o <= t.MAX_SAFE_INTEGER
      );
    });
})(FG);
Object.defineProperty(_n, "__esModule", { value: !0 });
var $G = FG;
function Z6e(t, e) {
  return e === void 0 && (e = 0), (((t[e + 0] << 8) | t[e + 1]) << 16) >> 16;
}
_n.readInt16BE = Z6e;
function Y6e(t, e) {
  return e === void 0 && (e = 0), ((t[e + 0] << 8) | t[e + 1]) >>> 0;
}
_n.readUint16BE = Y6e;
function Q6e(t, e) {
  return e === void 0 && (e = 0), (((t[e + 1] << 8) | t[e]) << 16) >> 16;
}
_n.readInt16LE = Q6e;
function J6e(t, e) {
  return e === void 0 && (e = 0), ((t[e + 1] << 8) | t[e]) >>> 0;
}
_n.readUint16LE = J6e;
function UG(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(2)),
    n === void 0 && (n = 0),
    (e[n + 0] = t >>> 8),
    (e[n + 1] = t >>> 0),
    e
  );
}
_n.writeUint16BE = UG;
_n.writeInt16BE = UG;
function jG(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(2)),
    n === void 0 && (n = 0),
    (e[n + 0] = t >>> 0),
    (e[n + 1] = t >>> 8),
    e
  );
}
_n.writeUint16LE = jG;
_n.writeInt16LE = jG;
function Ix(t, e) {
  return (
    e === void 0 && (e = 0),
    (t[e] << 24) | (t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]
  );
}
_n.readInt32BE = Ix;
function Ox(t, e) {
  return (
    e === void 0 && (e = 0),
    ((t[e] << 24) | (t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]) >>> 0
  );
}
_n.readUint32BE = Ox;
function Px(t, e) {
  return (
    e === void 0 && (e = 0),
    (t[e + 3] << 24) | (t[e + 2] << 16) | (t[e + 1] << 8) | t[e]
  );
}
_n.readInt32LE = Px;
function Nx(t, e) {
  return (
    e === void 0 && (e = 0),
    ((t[e + 3] << 24) | (t[e + 2] << 16) | (t[e + 1] << 8) | t[e]) >>> 0
  );
}
_n.readUint32LE = Nx;
function K5(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(4)),
    n === void 0 && (n = 0),
    (e[n + 0] = t >>> 24),
    (e[n + 1] = t >>> 16),
    (e[n + 2] = t >>> 8),
    (e[n + 3] = t >>> 0),
    e
  );
}
_n.writeUint32BE = K5;
_n.writeInt32BE = K5;
function X5(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(4)),
    n === void 0 && (n = 0),
    (e[n + 0] = t >>> 0),
    (e[n + 1] = t >>> 8),
    (e[n + 2] = t >>> 16),
    (e[n + 3] = t >>> 24),
    e
  );
}
_n.writeUint32LE = X5;
_n.writeInt32LE = X5;
function e3e(t, e) {
  e === void 0 && (e = 0);
  var n = Ix(t, e),
    r = Ix(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
_n.readInt64BE = e3e;
function t3e(t, e) {
  e === void 0 && (e = 0);
  var n = Ox(t, e),
    r = Ox(t, e + 4);
  return n * 4294967296 + r;
}
_n.readUint64BE = t3e;
function n3e(t, e) {
  e === void 0 && (e = 0);
  var n = Px(t, e),
    r = Px(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
_n.readInt64LE = n3e;
function r3e(t, e) {
  e === void 0 && (e = 0);
  var n = Nx(t, e),
    r = Nx(t, e + 4);
  return r * 4294967296 + n;
}
_n.readUint64LE = r3e;
function HG(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(8)),
    n === void 0 && (n = 0),
    K5((t / 4294967296) >>> 0, e, n),
    K5(t >>> 0, e, n + 4),
    e
  );
}
_n.writeUint64BE = HG;
_n.writeInt64BE = HG;
function zG(t, e, n) {
  return (
    e === void 0 && (e = new Uint8Array(8)),
    n === void 0 && (n = 0),
    X5(t >>> 0, e, n),
    X5((t / 4294967296) >>> 0, e, n + 4),
    e
  );
}
_n.writeUint64LE = zG;
_n.writeInt64LE = zG;
function i3e(t, e, n) {
  if ((n === void 0 && (n = 0), t % 8 !== 0))
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - n)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = t / 8 + n - 1; s >= n; s--)
    (r += e[s] * i), (i *= 256);
  return r;
}
_n.readUintBE = i3e;
function s3e(t, e, n) {
  if ((n === void 0 && (n = 0), t % 8 !== 0))
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - n)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = n; s < n + t / 8; s++) (r += e[s] * i), (i *= 256);
  return r;
}
_n.readUintLE = s3e;
function a3e(t, e, n, r) {
  if (
    (n === void 0 && (n = new Uint8Array(t / 8)),
    r === void 0 && (r = 0),
    t % 8 !== 0)
  )
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!$G.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + r - 1; s >= r; s--)
    (n[s] = (e / i) & 255), (i *= 256);
  return n;
}
_n.writeUintBE = a3e;
function o3e(t, e, n, r) {
  if (
    (n === void 0 && (n = new Uint8Array(t / 8)),
    r === void 0 && (r = 0),
    t % 8 !== 0)
  )
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!$G.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = r; s < r + t / 8; s++) (n[s] = (e / i) & 255), (i *= 256);
  return n;
}
_n.writeUintLE = o3e;
function l3e(t, e) {
  e === void 0 && (e = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.getFloat32(e);
}
_n.readFloat32BE = l3e;
function u3e(t, e) {
  e === void 0 && (e = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.getFloat32(e, !0);
}
_n.readFloat32LE = u3e;
function c3e(t, e) {
  e === void 0 && (e = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.getFloat64(e);
}
_n.readFloat64BE = c3e;
function f3e(t, e) {
  e === void 0 && (e = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.getFloat64(e, !0);
}
_n.readFloat64LE = f3e;
function d3e(t, e, n) {
  e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.setFloat32(n, t), e;
}
_n.writeFloat32BE = d3e;
function h3e(t, e, n) {
  e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.setFloat32(n, t, !0), e;
}
_n.writeFloat32LE = h3e;
function p3e(t, e, n) {
  e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.setFloat64(n, t), e;
}
_n.writeFloat64BE = p3e;
function m3e(t, e, n) {
  e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.setFloat64(n, t, !0), e;
}
_n.writeFloat64LE = m3e;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
function g3e(t) {
  for (var e = 0; e < t.length; e++) t[e] = 0;
  return t;
}
$o.wipe = g3e;
Object.defineProperty(f6, "__esModule", { value: !0 });
var Zs = _n,
  Dx = $o,
  y3e = 20;
function v3e(t, e, n) {
  for (
    var r = 1634760805,
      i = 857760878,
      s = 2036477234,
      a = 1797285236,
      o = (n[3] << 24) | (n[2] << 16) | (n[1] << 8) | n[0],
      l = (n[7] << 24) | (n[6] << 16) | (n[5] << 8) | n[4],
      u = (n[11] << 24) | (n[10] << 16) | (n[9] << 8) | n[8],
      f = (n[15] << 24) | (n[14] << 16) | (n[13] << 8) | n[12],
      c = (n[19] << 24) | (n[18] << 16) | (n[17] << 8) | n[16],
      d = (n[23] << 24) | (n[22] << 16) | (n[21] << 8) | n[20],
      p = (n[27] << 24) | (n[26] << 16) | (n[25] << 8) | n[24],
      m = (n[31] << 24) | (n[30] << 16) | (n[29] << 8) | n[28],
      g = (e[3] << 24) | (e[2] << 16) | (e[1] << 8) | e[0],
      w = (e[7] << 24) | (e[6] << 16) | (e[5] << 8) | e[4],
      y = (e[11] << 24) | (e[10] << 16) | (e[9] << 8) | e[8],
      v = (e[15] << 24) | (e[14] << 16) | (e[13] << 8) | e[12],
      E = r,
      S = i,
      D = s,
      P = a,
      x = o,
      _ = l,
      A = u,
      N = f,
      M = c,
      T = d,
      O = p,
      I = m,
      k = g,
      L = w,
      U = y,
      $ = v,
      B = 0;
    B < y3e;
    B += 2
  )
    (E = (E + x) | 0),
      (k ^= E),
      (k = (k >>> (32 - 16)) | (k << 16)),
      (M = (M + k) | 0),
      (x ^= M),
      (x = (x >>> (32 - 12)) | (x << 12)),
      (S = (S + _) | 0),
      (L ^= S),
      (L = (L >>> (32 - 16)) | (L << 16)),
      (T = (T + L) | 0),
      (_ ^= T),
      (_ = (_ >>> (32 - 12)) | (_ << 12)),
      (D = (D + A) | 0),
      (U ^= D),
      (U = (U >>> (32 - 16)) | (U << 16)),
      (O = (O + U) | 0),
      (A ^= O),
      (A = (A >>> (32 - 12)) | (A << 12)),
      (P = (P + N) | 0),
      ($ ^= P),
      ($ = ($ >>> (32 - 16)) | ($ << 16)),
      (I = (I + $) | 0),
      (N ^= I),
      (N = (N >>> (32 - 12)) | (N << 12)),
      (D = (D + A) | 0),
      (U ^= D),
      (U = (U >>> (32 - 8)) | (U << 8)),
      (O = (O + U) | 0),
      (A ^= O),
      (A = (A >>> (32 - 7)) | (A << 7)),
      (P = (P + N) | 0),
      ($ ^= P),
      ($ = ($ >>> (32 - 8)) | ($ << 8)),
      (I = (I + $) | 0),
      (N ^= I),
      (N = (N >>> (32 - 7)) | (N << 7)),
      (S = (S + _) | 0),
      (L ^= S),
      (L = (L >>> (32 - 8)) | (L << 8)),
      (T = (T + L) | 0),
      (_ ^= T),
      (_ = (_ >>> (32 - 7)) | (_ << 7)),
      (E = (E + x) | 0),
      (k ^= E),
      (k = (k >>> (32 - 8)) | (k << 8)),
      (M = (M + k) | 0),
      (x ^= M),
      (x = (x >>> (32 - 7)) | (x << 7)),
      (E = (E + _) | 0),
      ($ ^= E),
      ($ = ($ >>> (32 - 16)) | ($ << 16)),
      (O = (O + $) | 0),
      (_ ^= O),
      (_ = (_ >>> (32 - 12)) | (_ << 12)),
      (S = (S + A) | 0),
      (k ^= S),
      (k = (k >>> (32 - 16)) | (k << 16)),
      (I = (I + k) | 0),
      (A ^= I),
      (A = (A >>> (32 - 12)) | (A << 12)),
      (D = (D + N) | 0),
      (L ^= D),
      (L = (L >>> (32 - 16)) | (L << 16)),
      (M = (M + L) | 0),
      (N ^= M),
      (N = (N >>> (32 - 12)) | (N << 12)),
      (P = (P + x) | 0),
      (U ^= P),
      (U = (U >>> (32 - 16)) | (U << 16)),
      (T = (T + U) | 0),
      (x ^= T),
      (x = (x >>> (32 - 12)) | (x << 12)),
      (D = (D + N) | 0),
      (L ^= D),
      (L = (L >>> (32 - 8)) | (L << 8)),
      (M = (M + L) | 0),
      (N ^= M),
      (N = (N >>> (32 - 7)) | (N << 7)),
      (P = (P + x) | 0),
      (U ^= P),
      (U = (U >>> (32 - 8)) | (U << 8)),
      (T = (T + U) | 0),
      (x ^= T),
      (x = (x >>> (32 - 7)) | (x << 7)),
      (S = (S + A) | 0),
      (k ^= S),
      (k = (k >>> (32 - 8)) | (k << 8)),
      (I = (I + k) | 0),
      (A ^= I),
      (A = (A >>> (32 - 7)) | (A << 7)),
      (E = (E + _) | 0),
      ($ ^= E),
      ($ = ($ >>> (32 - 8)) | ($ << 8)),
      (O = (O + $) | 0),
      (_ ^= O),
      (_ = (_ >>> (32 - 7)) | (_ << 7));
  Zs.writeUint32LE((E + r) | 0, t, 0),
    Zs.writeUint32LE((S + i) | 0, t, 4),
    Zs.writeUint32LE((D + s) | 0, t, 8),
    Zs.writeUint32LE((P + a) | 0, t, 12),
    Zs.writeUint32LE((x + o) | 0, t, 16),
    Zs.writeUint32LE((_ + l) | 0, t, 20),
    Zs.writeUint32LE((A + u) | 0, t, 24),
    Zs.writeUint32LE((N + f) | 0, t, 28),
    Zs.writeUint32LE((M + c) | 0, t, 32),
    Zs.writeUint32LE((T + d) | 0, t, 36),
    Zs.writeUint32LE((O + p) | 0, t, 40),
    Zs.writeUint32LE((I + m) | 0, t, 44),
    Zs.writeUint32LE((k + g) | 0, t, 48),
    Zs.writeUint32LE((L + w) | 0, t, 52),
    Zs.writeUint32LE((U + y) | 0, t, 56),
    Zs.writeUint32LE(($ + v) | 0, t, 60);
}
function VG(t, e, n, r, i) {
  if ((i === void 0 && (i = 0), t.length !== 32))
    throw new Error("ChaCha: key size must be 32 bytes");
  if (r.length < n.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, a;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    (s = new Uint8Array(16)), (a = s.length - e.length), s.set(e, a);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    (s = e), (a = i);
  }
  for (var o = new Uint8Array(64), l = 0; l < n.length; l += 64) {
    v3e(o, s, t);
    for (var u = l; u < l + 64 && u < n.length; u++) r[u] = n[u] ^ o[u - l];
    w3e(s, 0, a);
  }
  return Dx.wipe(o), i === 0 && Dx.wipe(s), r;
}
f6.streamXOR = VG;
function b3e(t, e, n, r) {
  return r === void 0 && (r = 0), Dx.wipe(n), VG(t, e, n, n, r);
}
f6.stream = b3e;
function w3e(t, e, n) {
  for (var r = 1; n--; )
    (r = (r + (t[e] & 255)) | 0), (t[e] = r & 255), (r >>>= 8), e++;
  if (r > 0) throw new Error("ChaCha: counter overflow");
}
var GG = {},
  Sd = {};
Object.defineProperty(Sd, "__esModule", { value: !0 });
function _3e(t, e, n) {
  return (~(t - 1) & e) | ((t - 1) & n);
}
Sd.select = _3e;
function E3e(t, e) {
  return (((t | 0) - (e | 0) - 1) >>> 31) & 1;
}
Sd.lessOrEqual = E3e;
function WG(t, e) {
  if (t.length !== e.length) return 0;
  for (var n = 0, r = 0; r < t.length; r++) n |= t[r] ^ e[r];
  return 1 & ((n - 1) >>> 8);
}
Sd.compare = WG;
function x3e(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : WG(t, e) !== 0;
}
Sd.equal = x3e;
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Sd,
    n = $o;
  t.DIGEST_LENGTH = 16;
  var r = (function () {
    function a(o) {
      (this.digestLength = t.DIGEST_LENGTH),
        (this._buffer = new Uint8Array(16)),
        (this._r = new Uint16Array(10)),
        (this._h = new Uint16Array(10)),
        (this._pad = new Uint16Array(8)),
        (this._leftover = 0),
        (this._fin = 0),
        (this._finished = !1);
      var l = o[0] | (o[1] << 8);
      this._r[0] = l & 8191;
      var u = o[2] | (o[3] << 8);
      this._r[1] = ((l >>> 13) | (u << 3)) & 8191;
      var f = o[4] | (o[5] << 8);
      this._r[2] = ((u >>> 10) | (f << 6)) & 7939;
      var c = o[6] | (o[7] << 8);
      this._r[3] = ((f >>> 7) | (c << 9)) & 8191;
      var d = o[8] | (o[9] << 8);
      (this._r[4] = ((c >>> 4) | (d << 12)) & 255),
        (this._r[5] = (d >>> 1) & 8190);
      var p = o[10] | (o[11] << 8);
      this._r[6] = ((d >>> 14) | (p << 2)) & 8191;
      var m = o[12] | (o[13] << 8);
      this._r[7] = ((p >>> 11) | (m << 5)) & 8065;
      var g = o[14] | (o[15] << 8);
      (this._r[8] = ((m >>> 8) | (g << 8)) & 8191),
        (this._r[9] = (g >>> 5) & 127),
        (this._pad[0] = o[16] | (o[17] << 8)),
        (this._pad[1] = o[18] | (o[19] << 8)),
        (this._pad[2] = o[20] | (o[21] << 8)),
        (this._pad[3] = o[22] | (o[23] << 8)),
        (this._pad[4] = o[24] | (o[25] << 8)),
        (this._pad[5] = o[26] | (o[27] << 8)),
        (this._pad[6] = o[28] | (o[29] << 8)),
        (this._pad[7] = o[30] | (o[31] << 8));
    }
    return (
      (a.prototype._blocks = function (o, l, u) {
        for (
          var f = this._fin ? 0 : 2048,
            c = this._h[0],
            d = this._h[1],
            p = this._h[2],
            m = this._h[3],
            g = this._h[4],
            w = this._h[5],
            y = this._h[6],
            v = this._h[7],
            E = this._h[8],
            S = this._h[9],
            D = this._r[0],
            P = this._r[1],
            x = this._r[2],
            _ = this._r[3],
            A = this._r[4],
            N = this._r[5],
            M = this._r[6],
            T = this._r[7],
            O = this._r[8],
            I = this._r[9];
          u >= 16;

        ) {
          var k = o[l + 0] | (o[l + 1] << 8);
          c += k & 8191;
          var L = o[l + 2] | (o[l + 3] << 8);
          d += ((k >>> 13) | (L << 3)) & 8191;
          var U = o[l + 4] | (o[l + 5] << 8);
          p += ((L >>> 10) | (U << 6)) & 8191;
          var $ = o[l + 6] | (o[l + 7] << 8);
          m += ((U >>> 7) | ($ << 9)) & 8191;
          var B = o[l + 8] | (o[l + 9] << 8);
          (g += (($ >>> 4) | (B << 12)) & 8191), (w += (B >>> 1) & 8191);
          var R = o[l + 10] | (o[l + 11] << 8);
          y += ((B >>> 14) | (R << 2)) & 8191;
          var V = o[l + 12] | (o[l + 13] << 8);
          v += ((R >>> 11) | (V << 5)) & 8191;
          var oe = o[l + 14] | (o[l + 15] << 8);
          (E += ((V >>> 8) | (oe << 8)) & 8191), (S += (oe >>> 5) | f);
          var le = 0,
            fe = le;
          (fe += c * D),
            (fe += d * (5 * I)),
            (fe += p * (5 * O)),
            (fe += m * (5 * T)),
            (fe += g * (5 * M)),
            (le = fe >>> 13),
            (fe &= 8191),
            (fe += w * (5 * N)),
            (fe += y * (5 * A)),
            (fe += v * (5 * _)),
            (fe += E * (5 * x)),
            (fe += S * (5 * P)),
            (le += fe >>> 13),
            (fe &= 8191);
          var z = le;
          (z += c * P),
            (z += d * D),
            (z += p * (5 * I)),
            (z += m * (5 * O)),
            (z += g * (5 * T)),
            (le = z >>> 13),
            (z &= 8191),
            (z += w * (5 * M)),
            (z += y * (5 * N)),
            (z += v * (5 * A)),
            (z += E * (5 * _)),
            (z += S * (5 * x)),
            (le += z >>> 13),
            (z &= 8191);
          var se = le;
          (se += c * x),
            (se += d * P),
            (se += p * D),
            (se += m * (5 * I)),
            (se += g * (5 * O)),
            (le = se >>> 13),
            (se &= 8191),
            (se += w * (5 * T)),
            (se += y * (5 * M)),
            (se += v * (5 * N)),
            (se += E * (5 * A)),
            (se += S * (5 * _)),
            (le += se >>> 13),
            (se &= 8191);
          var Y = le;
          (Y += c * _),
            (Y += d * x),
            (Y += p * P),
            (Y += m * D),
            (Y += g * (5 * I)),
            (le = Y >>> 13),
            (Y &= 8191),
            (Y += w * (5 * O)),
            (Y += y * (5 * T)),
            (Y += v * (5 * M)),
            (Y += E * (5 * N)),
            (Y += S * (5 * A)),
            (le += Y >>> 13),
            (Y &= 8191);
          var Q = le;
          (Q += c * A),
            (Q += d * _),
            (Q += p * x),
            (Q += m * P),
            (Q += g * D),
            (le = Q >>> 13),
            (Q &= 8191),
            (Q += w * (5 * I)),
            (Q += y * (5 * O)),
            (Q += v * (5 * T)),
            (Q += E * (5 * M)),
            (Q += S * (5 * N)),
            (le += Q >>> 13),
            (Q &= 8191);
          var ee = le;
          (ee += c * N),
            (ee += d * A),
            (ee += p * _),
            (ee += m * x),
            (ee += g * P),
            (le = ee >>> 13),
            (ee &= 8191),
            (ee += w * D),
            (ee += y * (5 * I)),
            (ee += v * (5 * O)),
            (ee += E * (5 * T)),
            (ee += S * (5 * M)),
            (le += ee >>> 13),
            (ee &= 8191);
          var F = le;
          (F += c * M),
            (F += d * N),
            (F += p * A),
            (F += m * _),
            (F += g * x),
            (le = F >>> 13),
            (F &= 8191),
            (F += w * P),
            (F += y * D),
            (F += v * (5 * I)),
            (F += E * (5 * O)),
            (F += S * (5 * T)),
            (le += F >>> 13),
            (F &= 8191);
          var te = le;
          (te += c * T),
            (te += d * M),
            (te += p * N),
            (te += m * A),
            (te += g * _),
            (le = te >>> 13),
            (te &= 8191),
            (te += w * x),
            (te += y * P),
            (te += v * D),
            (te += E * (5 * I)),
            (te += S * (5 * O)),
            (le += te >>> 13),
            (te &= 8191);
          var he = le;
          (he += c * O),
            (he += d * T),
            (he += p * M),
            (he += m * N),
            (he += g * A),
            (le = he >>> 13),
            (he &= 8191),
            (he += w * _),
            (he += y * x),
            (he += v * P),
            (he += E * D),
            (he += S * (5 * I)),
            (le += he >>> 13),
            (he &= 8191);
          var Te = le;
          (Te += c * I),
            (Te += d * O),
            (Te += p * T),
            (Te += m * M),
            (Te += g * N),
            (le = Te >>> 13),
            (Te &= 8191),
            (Te += w * A),
            (Te += y * _),
            (Te += v * x),
            (Te += E * P),
            (Te += S * D),
            (le += Te >>> 13),
            (Te &= 8191),
            (le = ((le << 2) + le) | 0),
            (le = (le + fe) | 0),
            (fe = le & 8191),
            (le = le >>> 13),
            (z += le),
            (c = fe),
            (d = z),
            (p = se),
            (m = Y),
            (g = Q),
            (w = ee),
            (y = F),
            (v = te),
            (E = he),
            (S = Te),
            (l += 16),
            (u -= 16);
        }
        (this._h[0] = c),
          (this._h[1] = d),
          (this._h[2] = p),
          (this._h[3] = m),
          (this._h[4] = g),
          (this._h[5] = w),
          (this._h[6] = y),
          (this._h[7] = v),
          (this._h[8] = E),
          (this._h[9] = S);
      }),
      (a.prototype.finish = function (o, l) {
        l === void 0 && (l = 0);
        var u = new Uint16Array(10),
          f,
          c,
          d,
          p;
        if (this._leftover) {
          for (p = this._leftover, this._buffer[p++] = 1; p < 16; p++)
            this._buffer[p] = 0;
          (this._fin = 1), this._blocks(this._buffer, 0, 16);
        }
        for (f = this._h[1] >>> 13, this._h[1] &= 8191, p = 2; p < 10; p++)
          (this._h[p] += f), (f = this._h[p] >>> 13), (this._h[p] &= 8191);
        for (
          this._h[0] += f * 5,
            f = this._h[0] >>> 13,
            this._h[0] &= 8191,
            this._h[1] += f,
            f = this._h[1] >>> 13,
            this._h[1] &= 8191,
            this._h[2] += f,
            u[0] = this._h[0] + 5,
            f = u[0] >>> 13,
            u[0] &= 8191,
            p = 1;
          p < 10;
          p++
        )
          (u[p] = this._h[p] + f), (f = u[p] >>> 13), (u[p] &= 8191);
        for (u[9] -= 8192, c = (f ^ 1) - 1, p = 0; p < 10; p++) u[p] &= c;
        for (c = ~c, p = 0; p < 10; p++) this._h[p] = (this._h[p] & c) | u[p];
        for (
          this._h[0] = (this._h[0] | (this._h[1] << 13)) & 65535,
            this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 65535,
            this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 65535,
            this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 65535,
            this._h[4] =
              ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) &
              65535,
            this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 65535,
            this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 65535,
            this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 65535,
            d = this._h[0] + this._pad[0],
            this._h[0] = d & 65535,
            p = 1;
          p < 8;
          p++
        )
          (d = (((this._h[p] + this._pad[p]) | 0) + (d >>> 16)) | 0),
            (this._h[p] = d & 65535);
        return (
          (o[l + 0] = this._h[0] >>> 0),
          (o[l + 1] = this._h[0] >>> 8),
          (o[l + 2] = this._h[1] >>> 0),
          (o[l + 3] = this._h[1] >>> 8),
          (o[l + 4] = this._h[2] >>> 0),
          (o[l + 5] = this._h[2] >>> 8),
          (o[l + 6] = this._h[3] >>> 0),
          (o[l + 7] = this._h[3] >>> 8),
          (o[l + 8] = this._h[4] >>> 0),
          (o[l + 9] = this._h[4] >>> 8),
          (o[l + 10] = this._h[5] >>> 0),
          (o[l + 11] = this._h[5] >>> 8),
          (o[l + 12] = this._h[6] >>> 0),
          (o[l + 13] = this._h[6] >>> 8),
          (o[l + 14] = this._h[7] >>> 0),
          (o[l + 15] = this._h[7] >>> 8),
          (this._finished = !0),
          this
        );
      }),
      (a.prototype.update = function (o) {
        var l = 0,
          u = o.length,
          f;
        if (this._leftover) {
          (f = 16 - this._leftover), f > u && (f = u);
          for (var c = 0; c < f; c++)
            this._buffer[this._leftover + c] = o[l + c];
          if (((u -= f), (l += f), (this._leftover += f), this._leftover < 16))
            return this;
          this._blocks(this._buffer, 0, 16), (this._leftover = 0);
        }
        if (
          (u >= 16 &&
            ((f = u - (u % 16)), this._blocks(o, l, f), (l += f), (u -= f)),
          u)
        ) {
          for (var c = 0; c < u; c++)
            this._buffer[this._leftover + c] = o[l + c];
          this._leftover += u;
        }
        return this;
      }),
      (a.prototype.digest = function () {
        if (this._finished) throw new Error("Poly1305 was finished");
        var o = new Uint8Array(16);
        return this.finish(o), o;
      }),
      (a.prototype.clean = function () {
        return (
          n.wipe(this._buffer),
          n.wipe(this._r),
          n.wipe(this._h),
          n.wipe(this._pad),
          (this._leftover = 0),
          (this._fin = 0),
          (this._finished = !0),
          this
        );
      }),
      a
    );
  })();
  t.Poly1305 = r;
  function i(a, o) {
    var l = new r(a);
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.oneTimeAuth = i;
  function s(a, o) {
    return a.length !== t.DIGEST_LENGTH || o.length !== t.DIGEST_LENGTH
      ? !1
      : e.equal(a, o);
  }
  t.equal = s;
})(GG);
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = f6,
    n = GG,
    r = $o,
    i = _n,
    s = Sd;
  (t.KEY_LENGTH = 32), (t.NONCE_LENGTH = 12), (t.TAG_LENGTH = 16);
  var a = new Uint8Array(16),
    o = (function () {
      function l(u) {
        if (
          ((this.nonceLength = t.NONCE_LENGTH),
          (this.tagLength = t.TAG_LENGTH),
          u.length !== t.KEY_LENGTH)
        )
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(u);
      }
      return (
        (l.prototype.seal = function (u, f, c, d) {
          if (u.length > 16)
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          var p = new Uint8Array(16);
          p.set(u, p.length - u.length);
          var m = new Uint8Array(32);
          e.stream(this._key, p, m, 4);
          var g = f.length + this.tagLength,
            w;
          if (d) {
            if (d.length !== g)
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            w = d;
          } else w = new Uint8Array(g);
          return (
            e.streamXOR(this._key, p, f, w, 4),
            this._authenticate(
              w.subarray(w.length - this.tagLength, w.length),
              m,
              w.subarray(0, w.length - this.tagLength),
              c
            ),
            r.wipe(p),
            w
          );
        }),
        (l.prototype.open = function (u, f, c, d) {
          if (u.length > 16)
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          if (f.length < this.tagLength) return null;
          var p = new Uint8Array(16);
          p.set(u, p.length - u.length);
          var m = new Uint8Array(32);
          e.stream(this._key, p, m, 4);
          var g = new Uint8Array(this.tagLength);
          if (
            (this._authenticate(
              g,
              m,
              f.subarray(0, f.length - this.tagLength),
              c
            ),
            !s.equal(g, f.subarray(f.length - this.tagLength, f.length)))
          )
            return null;
          var w = f.length - this.tagLength,
            y;
          if (d) {
            if (d.length !== w)
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            y = d;
          } else y = new Uint8Array(w);
          return (
            e.streamXOR(
              this._key,
              p,
              f.subarray(0, f.length - this.tagLength),
              y,
              4
            ),
            r.wipe(p),
            y
          );
        }),
        (l.prototype.clean = function () {
          return r.wipe(this._key), this;
        }),
        (l.prototype._authenticate = function (u, f, c, d) {
          var p = new n.Poly1305(f);
          d &&
            (p.update(d),
            d.length % 16 > 0 && p.update(a.subarray(d.length % 16))),
            p.update(c),
            c.length % 16 > 0 && p.update(a.subarray(c.length % 16));
          var m = new Uint8Array(8);
          d && i.writeUint64LE(d.length, m),
            p.update(m),
            i.writeUint64LE(c.length, m),
            p.update(m);
          for (var g = p.digest(), w = 0; w < g.length; w++) u[w] = g[w];
          p.clean(), r.wipe(g), r.wipe(m);
        }),
        l
      );
    })();
  t.ChaCha20Poly1305 = o;
})(YT);
var qG = {},
  jy = {},
  QT = {};
Object.defineProperty(QT, "__esModule", { value: !0 });
function T3e(t) {
  return (
    typeof t.saveState < "u" &&
    typeof t.restoreState < "u" &&
    typeof t.cleanSavedState < "u"
  );
}
QT.isSerializableHash = T3e;
Object.defineProperty(jy, "__esModule", { value: !0 });
var Su = QT,
  S3e = Sd,
  A3e = $o,
  KG = (function () {
    function t(e, n) {
      (this._finished = !1),
        (this._inner = new e()),
        (this._outer = new e()),
        (this.blockSize = this._outer.blockSize),
        (this.digestLength = this._outer.digestLength);
      var r = new Uint8Array(this.blockSize);
      n.length > this.blockSize
        ? this._inner.update(n).finish(r).clean()
        : r.set(n);
      for (var i = 0; i < r.length; i++) r[i] ^= 54;
      this._inner.update(r);
      for (var i = 0; i < r.length; i++) r[i] ^= 106;
      this._outer.update(r),
        Su.isSerializableHash(this._inner) &&
          Su.isSerializableHash(this._outer) &&
          ((this._innerKeyedState = this._inner.saveState()),
          (this._outerKeyedState = this._outer.saveState())),
        A3e.wipe(r);
    }
    return (
      (t.prototype.reset = function () {
        if (
          !Su.isSerializableHash(this._inner) ||
          !Su.isSerializableHash(this._outer)
        )
          throw new Error(
            "hmac: can't reset() because hash doesn't implement restoreState()"
          );
        return (
          this._inner.restoreState(this._innerKeyedState),
          this._outer.restoreState(this._outerKeyedState),
          (this._finished = !1),
          this
        );
      }),
      (t.prototype.clean = function () {
        Su.isSerializableHash(this._inner) &&
          this._inner.cleanSavedState(this._innerKeyedState),
          Su.isSerializableHash(this._outer) &&
            this._outer.cleanSavedState(this._outerKeyedState),
          this._inner.clean(),
          this._outer.clean();
      }),
      (t.prototype.update = function (e) {
        return this._inner.update(e), this;
      }),
      (t.prototype.finish = function (e) {
        return this._finished
          ? (this._outer.finish(e), this)
          : (this._inner.finish(e),
            this._outer.update(e.subarray(0, this.digestLength)).finish(e),
            (this._finished = !0),
            this);
      }),
      (t.prototype.digest = function () {
        var e = new Uint8Array(this.digestLength);
        return this.finish(e), e;
      }),
      (t.prototype.saveState = function () {
        if (!Su.isSerializableHash(this._inner))
          throw new Error(
            "hmac: can't saveState() because hash doesn't implement it"
          );
        return this._inner.saveState();
      }),
      (t.prototype.restoreState = function (e) {
        if (
          !Su.isSerializableHash(this._inner) ||
          !Su.isSerializableHash(this._outer)
        )
          throw new Error(
            "hmac: can't restoreState() because hash doesn't implement it"
          );
        return (
          this._inner.restoreState(e),
          this._outer.restoreState(this._outerKeyedState),
          (this._finished = !1),
          this
        );
      }),
      (t.prototype.cleanSavedState = function (e) {
        if (!Su.isSerializableHash(this._inner))
          throw new Error(
            "hmac: can't cleanSavedState() because hash doesn't implement it"
          );
        this._inner.cleanSavedState(e);
      }),
      t
    );
  })();
jy.HMAC = KG;
function C3e(t, e, n) {
  var r = new KG(t, e);
  r.update(n);
  var i = r.digest();
  return r.clean(), i;
}
jy.hmac = C3e;
jy.equal = S3e.equal;
Object.defineProperty(qG, "__esModule", { value: !0 });
var sM = jy,
  aM = $o,
  k3e = (function () {
    function t(e, n, r, i) {
      r === void 0 && (r = new Uint8Array(0)),
        (this._counter = new Uint8Array(1)),
        (this._hash = e),
        (this._info = i);
      var s = sM.hmac(this._hash, r, n);
      (this._hmac = new sM.HMAC(e, s)),
        (this._buffer = new Uint8Array(this._hmac.digestLength)),
        (this._bufpos = this._buffer.length);
    }
    return (
      (t.prototype._fillBuffer = function () {
        this._counter[0]++;
        var e = this._counter[0];
        if (e === 0) throw new Error("hkdf: cannot expand more");
        this._hmac.reset(),
          e > 1 && this._hmac.update(this._buffer),
          this._info && this._hmac.update(this._info),
          this._hmac.update(this._counter),
          this._hmac.finish(this._buffer),
          (this._bufpos = 0);
      }),
      (t.prototype.expand = function (e) {
        for (var n = new Uint8Array(e), r = 0; r < n.length; r++)
          this._bufpos === this._buffer.length && this._fillBuffer(),
            (n[r] = this._buffer[this._bufpos++]);
        return n;
      }),
      (t.prototype.clean = function () {
        this._hmac.clean(),
          aM.wipe(this._buffer),
          aM.wipe(this._counter),
          (this._bufpos = 0);
      }),
      t
    );
  })(),
  I3e = (qG.HKDF = k3e),
  A1 = {},
  d6 = {},
  h6 = {};
Object.defineProperty(h6, "__esModule", { value: !0 });
h6.BrowserRandomSource = void 0;
const oM = 65536;
class O3e {
  constructor() {
    (this.isAvailable = !1), (this.isInstantiated = !1);
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e &&
      e.getRandomValues !== void 0 &&
      ((this._crypto = e), (this.isAvailable = !0), (this.isInstantiated = !0));
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const n = new Uint8Array(e);
    for (let r = 0; r < n.length; r += oM)
      this._crypto.getRandomValues(
        n.subarray(r, r + Math.min(n.length - r, oM))
      );
    return n;
  }
}
h6.BrowserRandomSource = O3e;
function P3e(t) {
  throw new Error(
    'Could not dynamically require "' +
      t +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  );
}
var p6 = {};
Object.defineProperty(p6, "__esModule", { value: !0 });
p6.NodeRandomSource = void 0;
const N3e = $o;
class D3e {
  constructor() {
    if (
      ((this.isAvailable = !1), (this.isInstantiated = !1), typeof P3e < "u")
    ) {
      const e = pj;
      e &&
        e.randomBytes &&
        ((this._crypto = e),
        (this.isAvailable = !0),
        (this.isInstantiated = !0));
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let n = this._crypto.randomBytes(e);
    if (n.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const r = new Uint8Array(e);
    for (let i = 0; i < r.length; i++) r[i] = n[i];
    return (0, N3e.wipe)(n), r;
  }
}
p6.NodeRandomSource = D3e;
Object.defineProperty(d6, "__esModule", { value: !0 });
d6.SystemRandomSource = void 0;
const R3e = h6,
  M3e = p6;
class L3e {
  constructor() {
    if (
      ((this.isAvailable = !1),
      (this.name = ""),
      (this._source = new R3e.BrowserRandomSource()),
      this._source.isAvailable)
    ) {
      (this.isAvailable = !0), (this.name = "Browser");
      return;
    }
    if (
      ((this._source = new M3e.NodeRandomSource()), this._source.isAvailable)
    ) {
      (this.isAvailable = !0), (this.name = "Node");
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
d6.SystemRandomSource = L3e;
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.randomStringForEntropy =
      t.randomString =
      t.randomUint32 =
      t.randomBytes =
      t.defaultRandomSource =
        void 0);
  const e = d6,
    n = _n,
    r = $o;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(u, f = t.defaultRandomSource) {
    return f.randomBytes(u);
  }
  t.randomBytes = i;
  function s(u = t.defaultRandomSource) {
    const f = i(4, u),
      c = (0, n.readUint32LE)(f);
    return (0, r.wipe)(f), c;
  }
  t.randomUint32 = s;
  const a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function o(u, f = a, c = t.defaultRandomSource) {
    if (f.length < 2) throw new Error("randomString charset is too short");
    if (f.length > 256) throw new Error("randomString charset is too long");
    let d = "";
    const p = f.length,
      m = 256 - (256 % p);
    for (; u > 0; ) {
      const g = i(Math.ceil((u * 256) / m), c);
      for (let w = 0; w < g.length && u > 0; w++) {
        const y = g[w];
        y < m && ((d += f.charAt(y % p)), u--);
      }
      (0, r.wipe)(g);
    }
    return d;
  }
  t.randomString = o;
  function l(u, f = a, c = t.defaultRandomSource) {
    const d = Math.ceil(u / (Math.log(f.length) / Math.LN2));
    return o(d, f, c);
  }
  t.randomStringForEntropy = l;
})(A1);
var m6 = {};
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = _n,
    n = $o;
  (t.DIGEST_LENGTH = 32), (t.BLOCK_SIZE = 64);
  var r = (function () {
    function o() {
      (this.digestLength = t.DIGEST_LENGTH),
        (this.blockSize = t.BLOCK_SIZE),
        (this._state = new Int32Array(8)),
        (this._temp = new Int32Array(64)),
        (this._buffer = new Uint8Array(128)),
        (this._bufferLength = 0),
        (this._bytesHashed = 0),
        (this._finished = !1),
        this.reset();
    }
    return (
      (o.prototype._initState = function () {
        (this._state[0] = 1779033703),
          (this._state[1] = 3144134277),
          (this._state[2] = 1013904242),
          (this._state[3] = 2773480762),
          (this._state[4] = 1359893119),
          (this._state[5] = 2600822924),
          (this._state[6] = 528734635),
          (this._state[7] = 1541459225);
      }),
      (o.prototype.reset = function () {
        return (
          this._initState(),
          (this._bufferLength = 0),
          (this._bytesHashed = 0),
          (this._finished = !1),
          this
        );
      }),
      (o.prototype.clean = function () {
        n.wipe(this._buffer), n.wipe(this._temp), this.reset();
      }),
      (o.prototype.update = function (l, u) {
        if ((u === void 0 && (u = l.length), this._finished))
          throw new Error("SHA256: can't update because hash was finished.");
        var f = 0;
        if (((this._bytesHashed += u), this._bufferLength > 0)) {
          for (; this._bufferLength < this.blockSize && u > 0; )
            (this._buffer[this._bufferLength++] = l[f++]), u--;
          this._bufferLength === this.blockSize &&
            (s(this._temp, this._state, this._buffer, 0, this.blockSize),
            (this._bufferLength = 0));
        }
        for (
          u >= this.blockSize &&
          ((f = s(this._temp, this._state, l, f, u)), (u %= this.blockSize));
          u > 0;

        )
          (this._buffer[this._bufferLength++] = l[f++]), u--;
        return this;
      }),
      (o.prototype.finish = function (l) {
        if (!this._finished) {
          var u = this._bytesHashed,
            f = this._bufferLength,
            c = (u / 536870912) | 0,
            d = u << 3,
            p = u % 64 < 56 ? 64 : 128;
          this._buffer[f] = 128;
          for (var m = f + 1; m < p - 8; m++) this._buffer[m] = 0;
          e.writeUint32BE(c, this._buffer, p - 8),
            e.writeUint32BE(d, this._buffer, p - 4),
            s(this._temp, this._state, this._buffer, 0, p),
            (this._finished = !0);
        }
        for (var m = 0; m < this.digestLength / 4; m++)
          e.writeUint32BE(this._state[m], l, m * 4);
        return this;
      }),
      (o.prototype.digest = function () {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }),
      (o.prototype.saveState = function () {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer:
            this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed,
        };
      }),
      (o.prototype.restoreState = function (l) {
        return (
          this._state.set(l.state),
          (this._bufferLength = l.bufferLength),
          l.buffer && this._buffer.set(l.buffer),
          (this._bytesHashed = l.bytesHashed),
          (this._finished = !1),
          this
        );
      }),
      (o.prototype.cleanSavedState = function (l) {
        n.wipe(l.state),
          l.buffer && n.wipe(l.buffer),
          (l.bufferLength = 0),
          (l.bytesHashed = 0);
      }),
      o
    );
  })();
  t.SHA256 = r;
  var i = new Int32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]);
  function s(o, l, u, f, c) {
    for (; c >= 64; ) {
      for (
        var d = l[0],
          p = l[1],
          m = l[2],
          g = l[3],
          w = l[4],
          y = l[5],
          v = l[6],
          E = l[7],
          S = 0;
        S < 16;
        S++
      ) {
        var D = f + S * 4;
        o[S] = e.readUint32BE(u, D);
      }
      for (var S = 16; S < 64; S++) {
        var P = o[S - 2],
          x =
            ((P >>> 17) | (P << (32 - 17))) ^
            ((P >>> 19) | (P << (32 - 19))) ^
            (P >>> 10);
        P = o[S - 15];
        var _ =
          ((P >>> 7) | (P << (32 - 7))) ^
          ((P >>> 18) | (P << (32 - 18))) ^
          (P >>> 3);
        o[S] = ((x + o[S - 7]) | 0) + ((_ + o[S - 16]) | 0);
      }
      for (var S = 0; S < 64; S++) {
        var x =
            ((((((w >>> 6) | (w << 26)) ^
              ((w >>> 11) | (w << 21)) ^
              ((w >>> 25) | (w << 7))) +
              ((w & y) ^ (~w & v))) |
              0) +
              ((E + ((i[S] + o[S]) | 0)) | 0)) |
            0,
          _ =
            ((((d >>> 2) | (d << (32 - 2))) ^
              ((d >>> 13) | (d << (32 - 13))) ^
              ((d >>> 22) | (d << (32 - 22)))) +
              ((d & p) ^ (d & m) ^ (p & m))) |
            0;
        (E = v),
          (v = y),
          (y = w),
          (w = (g + x) | 0),
          (g = m),
          (m = p),
          (p = d),
          (d = (x + _) | 0);
      }
      (l[0] += d),
        (l[1] += p),
        (l[2] += m),
        (l[3] += g),
        (l[4] += w),
        (l[5] += y),
        (l[6] += v),
        (l[7] += E),
        (f += 64),
        (c -= 64);
    }
    return f;
  }
  function a(o) {
    var l = new r();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(m6);
var JT = {};
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.sharedKey =
      t.generateKeyPair =
      t.generateKeyPairFromSeed =
      t.scalarMultBase =
      t.scalarMult =
      t.SHARED_KEY_LENGTH =
      t.SECRET_KEY_LENGTH =
      t.PUBLIC_KEY_LENGTH =
        void 0);
  const e = A1,
    n = $o;
  (t.PUBLIC_KEY_LENGTH = 32),
    (t.SECRET_KEY_LENGTH = 32),
    (t.SHARED_KEY_LENGTH = 32);
  function r(S) {
    const D = new Float64Array(16);
    if (S) for (let P = 0; P < S.length; P++) D[P] = S[P];
    return D;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = r([56129, 1]);
  function a(S) {
    let D = 1;
    for (let P = 0; P < 16; P++) {
      let x = S[P] + D + 65535;
      (D = Math.floor(x / 65536)), (S[P] = x - D * 65536);
    }
    S[0] += D - 1 + 37 * (D - 1);
  }
  function o(S, D, P) {
    const x = ~(P - 1);
    for (let _ = 0; _ < 16; _++) {
      const A = x & (S[_] ^ D[_]);
      (S[_] ^= A), (D[_] ^= A);
    }
  }
  function l(S, D) {
    const P = r(),
      x = r();
    for (let _ = 0; _ < 16; _++) x[_] = D[_];
    a(x), a(x), a(x);
    for (let _ = 0; _ < 2; _++) {
      P[0] = x[0] - 65517;
      for (let N = 1; N < 15; N++)
        (P[N] = x[N] - 65535 - ((P[N - 1] >> 16) & 1)), (P[N - 1] &= 65535);
      P[15] = x[15] - 32767 - ((P[14] >> 16) & 1);
      const A = (P[15] >> 16) & 1;
      (P[14] &= 65535), o(x, P, 1 - A);
    }
    for (let _ = 0; _ < 16; _++)
      (S[2 * _] = x[_] & 255), (S[2 * _ + 1] = x[_] >> 8);
  }
  function u(S, D) {
    for (let P = 0; P < 16; P++) S[P] = D[2 * P] + (D[2 * P + 1] << 8);
    S[15] &= 32767;
  }
  function f(S, D, P) {
    for (let x = 0; x < 16; x++) S[x] = D[x] + P[x];
  }
  function c(S, D, P) {
    for (let x = 0; x < 16; x++) S[x] = D[x] - P[x];
  }
  function d(S, D, P) {
    let x,
      _,
      A = 0,
      N = 0,
      M = 0,
      T = 0,
      O = 0,
      I = 0,
      k = 0,
      L = 0,
      U = 0,
      $ = 0,
      B = 0,
      R = 0,
      V = 0,
      oe = 0,
      le = 0,
      fe = 0,
      z = 0,
      se = 0,
      Y = 0,
      Q = 0,
      ee = 0,
      F = 0,
      te = 0,
      he = 0,
      Te = 0,
      Ce = 0,
      ke = 0,
      at = 0,
      Rt = 0,
      Ft = 0,
      Nt = 0,
      Ot = P[0],
      et = P[1],
      st = P[2],
      vt = P[3],
      Re = P[4],
      me = P[5],
      $e = P[6],
      De = P[7],
      je = P[8],
      lt = P[9],
      Ke = P[10],
      tt = P[11],
      jt = P[12],
      ct = P[13],
      rt = P[14],
      Dt = P[15];
    (x = D[0]),
      (A += x * Ot),
      (N += x * et),
      (M += x * st),
      (T += x * vt),
      (O += x * Re),
      (I += x * me),
      (k += x * $e),
      (L += x * De),
      (U += x * je),
      ($ += x * lt),
      (B += x * Ke),
      (R += x * tt),
      (V += x * jt),
      (oe += x * ct),
      (le += x * rt),
      (fe += x * Dt),
      (x = D[1]),
      (N += x * Ot),
      (M += x * et),
      (T += x * st),
      (O += x * vt),
      (I += x * Re),
      (k += x * me),
      (L += x * $e),
      (U += x * De),
      ($ += x * je),
      (B += x * lt),
      (R += x * Ke),
      (V += x * tt),
      (oe += x * jt),
      (le += x * ct),
      (fe += x * rt),
      (z += x * Dt),
      (x = D[2]),
      (M += x * Ot),
      (T += x * et),
      (O += x * st),
      (I += x * vt),
      (k += x * Re),
      (L += x * me),
      (U += x * $e),
      ($ += x * De),
      (B += x * je),
      (R += x * lt),
      (V += x * Ke),
      (oe += x * tt),
      (le += x * jt),
      (fe += x * ct),
      (z += x * rt),
      (se += x * Dt),
      (x = D[3]),
      (T += x * Ot),
      (O += x * et),
      (I += x * st),
      (k += x * vt),
      (L += x * Re),
      (U += x * me),
      ($ += x * $e),
      (B += x * De),
      (R += x * je),
      (V += x * lt),
      (oe += x * Ke),
      (le += x * tt),
      (fe += x * jt),
      (z += x * ct),
      (se += x * rt),
      (Y += x * Dt),
      (x = D[4]),
      (O += x * Ot),
      (I += x * et),
      (k += x * st),
      (L += x * vt),
      (U += x * Re),
      ($ += x * me),
      (B += x * $e),
      (R += x * De),
      (V += x * je),
      (oe += x * lt),
      (le += x * Ke),
      (fe += x * tt),
      (z += x * jt),
      (se += x * ct),
      (Y += x * rt),
      (Q += x * Dt),
      (x = D[5]),
      (I += x * Ot),
      (k += x * et),
      (L += x * st),
      (U += x * vt),
      ($ += x * Re),
      (B += x * me),
      (R += x * $e),
      (V += x * De),
      (oe += x * je),
      (le += x * lt),
      (fe += x * Ke),
      (z += x * tt),
      (se += x * jt),
      (Y += x * ct),
      (Q += x * rt),
      (ee += x * Dt),
      (x = D[6]),
      (k += x * Ot),
      (L += x * et),
      (U += x * st),
      ($ += x * vt),
      (B += x * Re),
      (R += x * me),
      (V += x * $e),
      (oe += x * De),
      (le += x * je),
      (fe += x * lt),
      (z += x * Ke),
      (se += x * tt),
      (Y += x * jt),
      (Q += x * ct),
      (ee += x * rt),
      (F += x * Dt),
      (x = D[7]),
      (L += x * Ot),
      (U += x * et),
      ($ += x * st),
      (B += x * vt),
      (R += x * Re),
      (V += x * me),
      (oe += x * $e),
      (le += x * De),
      (fe += x * je),
      (z += x * lt),
      (se += x * Ke),
      (Y += x * tt),
      (Q += x * jt),
      (ee += x * ct),
      (F += x * rt),
      (te += x * Dt),
      (x = D[8]),
      (U += x * Ot),
      ($ += x * et),
      (B += x * st),
      (R += x * vt),
      (V += x * Re),
      (oe += x * me),
      (le += x * $e),
      (fe += x * De),
      (z += x * je),
      (se += x * lt),
      (Y += x * Ke),
      (Q += x * tt),
      (ee += x * jt),
      (F += x * ct),
      (te += x * rt),
      (he += x * Dt),
      (x = D[9]),
      ($ += x * Ot),
      (B += x * et),
      (R += x * st),
      (V += x * vt),
      (oe += x * Re),
      (le += x * me),
      (fe += x * $e),
      (z += x * De),
      (se += x * je),
      (Y += x * lt),
      (Q += x * Ke),
      (ee += x * tt),
      (F += x * jt),
      (te += x * ct),
      (he += x * rt),
      (Te += x * Dt),
      (x = D[10]),
      (B += x * Ot),
      (R += x * et),
      (V += x * st),
      (oe += x * vt),
      (le += x * Re),
      (fe += x * me),
      (z += x * $e),
      (se += x * De),
      (Y += x * je),
      (Q += x * lt),
      (ee += x * Ke),
      (F += x * tt),
      (te += x * jt),
      (he += x * ct),
      (Te += x * rt),
      (Ce += x * Dt),
      (x = D[11]),
      (R += x * Ot),
      (V += x * et),
      (oe += x * st),
      (le += x * vt),
      (fe += x * Re),
      (z += x * me),
      (se += x * $e),
      (Y += x * De),
      (Q += x * je),
      (ee += x * lt),
      (F += x * Ke),
      (te += x * tt),
      (he += x * jt),
      (Te += x * ct),
      (Ce += x * rt),
      (ke += x * Dt),
      (x = D[12]),
      (V += x * Ot),
      (oe += x * et),
      (le += x * st),
      (fe += x * vt),
      (z += x * Re),
      (se += x * me),
      (Y += x * $e),
      (Q += x * De),
      (ee += x * je),
      (F += x * lt),
      (te += x * Ke),
      (he += x * tt),
      (Te += x * jt),
      (Ce += x * ct),
      (ke += x * rt),
      (at += x * Dt),
      (x = D[13]),
      (oe += x * Ot),
      (le += x * et),
      (fe += x * st),
      (z += x * vt),
      (se += x * Re),
      (Y += x * me),
      (Q += x * $e),
      (ee += x * De),
      (F += x * je),
      (te += x * lt),
      (he += x * Ke),
      (Te += x * tt),
      (Ce += x * jt),
      (ke += x * ct),
      (at += x * rt),
      (Rt += x * Dt),
      (x = D[14]),
      (le += x * Ot),
      (fe += x * et),
      (z += x * st),
      (se += x * vt),
      (Y += x * Re),
      (Q += x * me),
      (ee += x * $e),
      (F += x * De),
      (te += x * je),
      (he += x * lt),
      (Te += x * Ke),
      (Ce += x * tt),
      (ke += x * jt),
      (at += x * ct),
      (Rt += x * rt),
      (Ft += x * Dt),
      (x = D[15]),
      (fe += x * Ot),
      (z += x * et),
      (se += x * st),
      (Y += x * vt),
      (Q += x * Re),
      (ee += x * me),
      (F += x * $e),
      (te += x * De),
      (he += x * je),
      (Te += x * lt),
      (Ce += x * Ke),
      (ke += x * tt),
      (at += x * jt),
      (Rt += x * ct),
      (Ft += x * rt),
      (Nt += x * Dt),
      (A += 38 * z),
      (N += 38 * se),
      (M += 38 * Y),
      (T += 38 * Q),
      (O += 38 * ee),
      (I += 38 * F),
      (k += 38 * te),
      (L += 38 * he),
      (U += 38 * Te),
      ($ += 38 * Ce),
      (B += 38 * ke),
      (R += 38 * at),
      (V += 38 * Rt),
      (oe += 38 * Ft),
      (le += 38 * Nt),
      (_ = 1),
      (x = A + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (A = x - _ * 65536),
      (x = N + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (N = x - _ * 65536),
      (x = M + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (M = x - _ * 65536),
      (x = T + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (T = x - _ * 65536),
      (x = O + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (O = x - _ * 65536),
      (x = I + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (I = x - _ * 65536),
      (x = k + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (k = x - _ * 65536),
      (x = L + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (L = x - _ * 65536),
      (x = U + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (U = x - _ * 65536),
      (x = $ + _ + 65535),
      (_ = Math.floor(x / 65536)),
      ($ = x - _ * 65536),
      (x = B + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (B = x - _ * 65536),
      (x = R + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (R = x - _ * 65536),
      (x = V + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (V = x - _ * 65536),
      (x = oe + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (oe = x - _ * 65536),
      (x = le + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (le = x - _ * 65536),
      (x = fe + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (fe = x - _ * 65536),
      (A += _ - 1 + 37 * (_ - 1)),
      (_ = 1),
      (x = A + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (A = x - _ * 65536),
      (x = N + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (N = x - _ * 65536),
      (x = M + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (M = x - _ * 65536),
      (x = T + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (T = x - _ * 65536),
      (x = O + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (O = x - _ * 65536),
      (x = I + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (I = x - _ * 65536),
      (x = k + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (k = x - _ * 65536),
      (x = L + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (L = x - _ * 65536),
      (x = U + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (U = x - _ * 65536),
      (x = $ + _ + 65535),
      (_ = Math.floor(x / 65536)),
      ($ = x - _ * 65536),
      (x = B + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (B = x - _ * 65536),
      (x = R + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (R = x - _ * 65536),
      (x = V + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (V = x - _ * 65536),
      (x = oe + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (oe = x - _ * 65536),
      (x = le + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (le = x - _ * 65536),
      (x = fe + _ + 65535),
      (_ = Math.floor(x / 65536)),
      (fe = x - _ * 65536),
      (A += _ - 1 + 37 * (_ - 1)),
      (S[0] = A),
      (S[1] = N),
      (S[2] = M),
      (S[3] = T),
      (S[4] = O),
      (S[5] = I),
      (S[6] = k),
      (S[7] = L),
      (S[8] = U),
      (S[9] = $),
      (S[10] = B),
      (S[11] = R),
      (S[12] = V),
      (S[13] = oe),
      (S[14] = le),
      (S[15] = fe);
  }
  function p(S, D) {
    d(S, D, D);
  }
  function m(S, D) {
    const P = r();
    for (let x = 0; x < 16; x++) P[x] = D[x];
    for (let x = 253; x >= 0; x--) p(P, P), x !== 2 && x !== 4 && d(P, P, D);
    for (let x = 0; x < 16; x++) S[x] = P[x];
  }
  function g(S, D) {
    const P = new Uint8Array(32),
      x = new Float64Array(80),
      _ = r(),
      A = r(),
      N = r(),
      M = r(),
      T = r(),
      O = r();
    for (let U = 0; U < 31; U++) P[U] = S[U];
    (P[31] = (S[31] & 127) | 64), (P[0] &= 248), u(x, D);
    for (let U = 0; U < 16; U++) A[U] = x[U];
    _[0] = M[0] = 1;
    for (let U = 254; U >= 0; --U) {
      const $ = (P[U >>> 3] >>> (U & 7)) & 1;
      o(_, A, $),
        o(N, M, $),
        f(T, _, N),
        c(_, _, N),
        f(N, A, M),
        c(A, A, M),
        p(M, T),
        p(O, _),
        d(_, N, _),
        d(N, A, T),
        f(T, _, N),
        c(_, _, N),
        p(A, _),
        c(N, M, O),
        d(_, N, s),
        f(_, _, M),
        d(N, N, _),
        d(_, M, O),
        d(M, A, x),
        p(A, T),
        o(_, A, $),
        o(N, M, $);
    }
    for (let U = 0; U < 16; U++)
      (x[U + 16] = _[U]),
        (x[U + 32] = N[U]),
        (x[U + 48] = A[U]),
        (x[U + 64] = M[U]);
    const I = x.subarray(32),
      k = x.subarray(16);
    m(I, I), d(k, k, I);
    const L = new Uint8Array(32);
    return l(L, k), L;
  }
  t.scalarMult = g;
  function w(S) {
    return g(S, i);
  }
  t.scalarMultBase = w;
  function y(S) {
    if (S.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const D = new Uint8Array(S);
    return { publicKey: w(D), secretKey: D };
  }
  t.generateKeyPairFromSeed = y;
  function v(S) {
    const D = (0, e.randomBytes)(32, S),
      P = y(D);
    return (0, n.wipe)(D), P;
  }
  t.generateKeyPair = v;
  function E(S, D, P = !1) {
    if (S.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (D.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const x = g(S, D);
    if (P) {
      let _ = 0;
      for (let A = 0; A < x.length; A++) _ |= x[A];
      if (_ === 0) throw new Error("X25519: invalid shared key");
    }
    return x;
  }
  t.sharedKey = E;
})(JT);
function eS(t) {
  return globalThis.Buffer != null
    ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    : t;
}
function XG(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? eS(globalThis.Buffer.allocUnsafe(t))
    : new Uint8Array(t);
}
function Rx(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const n = XG(e);
  let r = 0;
  for (const i of t) n.set(i, r), (r += i.length);
  return eS(n);
}
function B3e(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      a = s.charCodeAt(0);
    if (n[a] !== 255) throw new TypeError(s + " is ambiguous");
    n[a] = i;
  }
  var o = t.length,
    l = t.charAt(0),
    u = Math.log(o) / Math.log(256),
    f = Math.log(256) / Math.log(o);
  function c(m) {
    if (
      (m instanceof Uint8Array ||
        (ArrayBuffer.isView(m)
          ? (m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength))
          : Array.isArray(m) && (m = Uint8Array.from(m))),
      !(m instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0) return "";
    for (var g = 0, w = 0, y = 0, v = m.length; y !== v && m[y] === 0; )
      y++, g++;
    for (var E = ((v - y) * f + 1) >>> 0, S = new Uint8Array(E); y !== v; ) {
      for (
        var D = m[y], P = 0, x = E - 1;
        (D !== 0 || P < w) && x !== -1;
        x--, P++
      )
        (D += (256 * S[x]) >>> 0), (S[x] = D % o >>> 0), (D = (D / o) >>> 0);
      if (D !== 0) throw new Error("Non-zero carry");
      (w = P), y++;
    }
    for (var _ = E - w; _ !== E && S[_] === 0; ) _++;
    for (var A = l.repeat(g); _ < E; ++_) A += t.charAt(S[_]);
    return A;
  }
  function d(m) {
    if (typeof m != "string") throw new TypeError("Expected String");
    if (m.length === 0) return new Uint8Array();
    var g = 0;
    if (m[g] !== " ") {
      for (var w = 0, y = 0; m[g] === l; ) w++, g++;
      for (
        var v = ((m.length - g) * u + 1) >>> 0, E = new Uint8Array(v);
        m[g];

      ) {
        var S = n[m.charCodeAt(g)];
        if (S === 255) return;
        for (var D = 0, P = v - 1; (S !== 0 || D < y) && P !== -1; P--, D++)
          (S += (o * E[P]) >>> 0),
            (E[P] = S % 256 >>> 0),
            (S = (S / 256) >>> 0);
        if (S !== 0) throw new Error("Non-zero carry");
        (y = D), g++;
      }
      if (m[g] !== " ") {
        for (var x = v - y; x !== v && E[x] === 0; ) x++;
        for (var _ = new Uint8Array(w + (v - x)), A = w; x !== v; )
          _[A++] = E[x++];
        return _;
      }
    }
  }
  function p(m) {
    var g = d(m);
    if (g) return g;
    throw new Error(`Non-${e} character`);
  }
  return { encode: c, decodeUnsafe: d, decode: p };
}
var F3e = B3e,
  $3e = F3e;
const U3e = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  j3e = (t) => new TextEncoder().encode(t),
  H3e = (t) => new TextDecoder().decode(t);
class z3e {
  constructor(e, n, r) {
    (this.name = e), (this.prefix = n), (this.baseEncode = r);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class V3e {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ZG(this, e);
  }
}
class G3e {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ZG(this, e);
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n];
    if (r) return r.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const ZG = (t, e) =>
  new G3e({
    ...(t.decoders || { [t.prefix]: t }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class W3e {
  constructor(e, n, r, i) {
    (this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new z3e(e, n, r)),
      (this.decoder = new V3e(e, n, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const g6 = ({ name: t, prefix: e, encode: n, decode: r }) =>
    new W3e(t, e, n, r),
  Hy = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = $3e(n, e);
    return g6({ prefix: t, name: e, encode: r, decode: (s) => U3e(i(s)) });
  },
  q3e = (t, e, n, r) => {
    const i = {};
    for (let f = 0; f < e.length; ++f) i[e[f]] = f;
    let s = t.length;
    for (; t[s - 1] === "="; ) --s;
    const a = new Uint8Array(((s * n) / 8) | 0);
    let o = 0,
      l = 0,
      u = 0;
    for (let f = 0; f < s; ++f) {
      const c = i[t[f]];
      if (c === void 0) throw new SyntaxError(`Non-${r} character`);
      (l = (l << n) | c),
        (o += n),
        o >= 8 && ((o -= 8), (a[u++] = 255 & (l >> o)));
    }
    if (o >= n || 255 & (l << (8 - o)))
      throw new SyntaxError("Unexpected end of data");
    return a;
  },
  K3e = (t, e, n) => {
    const r = e[e.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      a = 0,
      o = 0;
    for (let l = 0; l < t.length; ++l)
      for (o = (o << 8) | t[l], a += 8; a > n; )
        (a -= n), (s += e[i & (o >> a)]);
    if ((a && (s += e[i & (o << (n - a))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  Bs = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    g6({
      prefix: e,
      name: t,
      encode(i) {
        return K3e(i, r, n);
      },
      decode(i) {
        return q3e(i, r, n, t);
      },
    }),
  X3e = g6({
    prefix: "\0",
    name: "identity",
    encode: (t) => H3e(t),
    decode: (t) => j3e(t),
  }),
  Z3e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, identity: X3e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Y3e = Bs({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
  Q3e = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: Y3e }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  J3e = Bs({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3,
  }),
  e_e = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: J3e }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  t_e = Hy({ prefix: "9", name: "base10", alphabet: "0123456789" }),
  n_e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base10: t_e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  r_e = Bs({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  i_e = Bs({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  }),
  s_e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base16: r_e, base16upper: i_e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  a_e = Bs({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  o_e = Bs({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  l_e = Bs({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  u_e = Bs({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  c_e = Bs({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  f_e = Bs({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  d_e = Bs({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  h_e = Bs({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  p_e = Bs({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  }),
  m_e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: a_e,
        base32hex: c_e,
        base32hexpad: d_e,
        base32hexpadupper: h_e,
        base32hexupper: f_e,
        base32pad: l_e,
        base32padupper: u_e,
        base32upper: o_e,
        base32z: p_e,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  g_e = Hy({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  y_e = Hy({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  }),
  v_e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base36: g_e, base36upper: y_e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  b_e = Hy({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  w_e = Hy({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  }),
  __e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: b_e, base58flickr: w_e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  E_e = Bs({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  x_e = Bs({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  T_e = Bs({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  S_e = Bs({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  }),
  A_e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base64: E_e,
        base64pad: x_e,
        base64url: T_e,
        base64urlpad: S_e,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  YG = Array.from(
    "🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"
  ),
  C_e = YG.reduce((t, e, n) => ((t[n] = e), t), []),
  k_e = YG.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), []);
function I_e(t) {
  return t.reduce((e, n) => ((e += C_e[n]), e), "");
}
function O_e(t) {
  const e = [];
  for (const n of t) {
    const r = k_e[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const P_e = g6({
    prefix: "🚀",
    name: "base256emoji",
    encode: I_e,
    decode: O_e,
  }),
  N_e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base256emoji: P_e },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
new TextEncoder();
new TextDecoder();
const lM = {
  ...Z3e,
  ...Q3e,
  ...e_e,
  ...n_e,
  ...s_e,
  ...m_e,
  ...v_e,
  ...__e,
  ...A_e,
  ...N_e,
};
function QG(t, e, n, r) {
  return {
    name: t,
    prefix: e,
    encoder: { name: t, prefix: e, encode: n },
    decoder: { decode: r },
  };
}
const uM = QG(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  A8 = QG(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = XG(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return e;
    }
  ),
  JG = {
    utf8: uM,
    "utf-8": uM,
    hex: lM.base16,
    latin1: A8,
    ascii: A8,
    binary: A8,
    ...lM,
  };
function eo(t, e = "utf8") {
  const n = JG[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? eS(globalThis.Buffer.from(t, "utf-8"))
    : n.decoder.decode(`${n.prefix}${t}`);
}
function Pa(t, e = "utf8") {
  const n = JG[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
        "utf8"
      )
    : n.encoder.encode(t).substring(1);
}
var cM =
    (globalThis && globalThis.__spreadArray) ||
    function (t, e, n) {
      if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)
          (s || !(r in e)) &&
            (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
      return t.concat(s || Array.prototype.slice.call(e));
    },
  D_e = (function () {
    function t(e, n, r) {
      (this.name = e),
        (this.version = n),
        (this.os = r),
        (this.type = "browser");
    }
    return t;
  })(),
  R_e = (function () {
    function t(e) {
      (this.version = e),
        (this.type = "node"),
        (this.name = "node"),
        (this.os = process.platform);
    }
    return t;
  })(),
  M_e = (function () {
    function t(e, n, r, i) {
      (this.name = e),
        (this.version = n),
        (this.os = r),
        (this.bot = i),
        (this.type = "bot-device");
    }
    return t;
  })(),
  L_e = (function () {
    function t() {
      (this.type = "bot"),
        (this.bot = !0),
        (this.name = "bot"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  B_e = (function () {
    function t() {
      (this.type = "react-native"),
        (this.name = "react-native"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  F_e =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  $_e =
    /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  fM = 3,
  U_e = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      "pie",
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
    ],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", F_e],
  ],
  dM = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/],
  ];
function j_e(t) {
  return t
    ? hM(t)
    : typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    ? new B_e()
    : typeof navigator < "u"
    ? hM(navigator.userAgent)
    : V_e();
}
function H_e(t) {
  return (
    t !== "" &&
    U_e.reduce(function (e, n) {
      var r = n[0],
        i = n[1];
      if (e) return e;
      var s = i.exec(t);
      return !!s && [r, s];
    }, !1)
  );
}
function hM(t) {
  var e = H_e(t);
  if (!e) return null;
  var n = e[0],
    r = e[1];
  if (n === "searchbot") return new L_e();
  var i = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
  i
    ? i.length < fM && (i = cM(cM([], i, !0), G_e(fM - i.length), !0))
    : (i = []);
  var s = i.join("."),
    a = z_e(t),
    o = $_e.exec(t);
  return o && o[1] ? new M_e(n, s, a, o[1]) : new D_e(n, s, a);
}
function z_e(t) {
  for (var e = 0, n = dM.length; e < n; e++) {
    var r = dM[e],
      i = r[0],
      s = r[1],
      a = s.exec(t);
    if (a) return i;
  }
  return null;
}
function V_e() {
  var t = typeof process < "u" && process.version;
  return t ? new R_e(process.version.slice(1)) : null;
}
function G_e(t) {
  for (var e = [], n = 0; n < t; n++) e.push("0");
  return e;
}
var Vt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var Mx =
  function (t, e) {
    return (
      (Mx =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (n, r) {
            n.__proto__ = r;
          }) ||
        function (n, r) {
          for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
        }),
      Mx(t, e)
    );
  };
function W_e(t, e) {
  Mx(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
var Lx = function () {
  return (
    (Lx =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    Lx.apply(this, arguments)
  );
};
function q_e(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
}
function K_e(t, e, n, r) {
  var i = arguments.length,
    s =
      i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
    a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, n, s) : a(e, n)) || s);
  return i > 3 && s && Object.defineProperty(e, n, s), s;
}
function X_e(t, e) {
  return function (n, r) {
    e(n, r, t);
  };
}
function Z_e(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function Y_e(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(f) {
      try {
        u(r.next(f));
      } catch (c) {
        a(c);
      }
    }
    function l(f) {
      try {
        u(r.throw(f));
      } catch (c) {
        a(c);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(o, l);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function Q_e(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    a;
  return (
    (a = { next: o(0), throw: o(1), return: o(2) }),
    typeof Symbol == "function" &&
      (a[Symbol.iterator] = function () {
        return this;
      }),
    a
  );
  function o(u) {
    return function (f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              u[0] & 2
                ? i.return
                : u[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, u[1])).done)
        )
          return s;
        switch (((i = 0), s && (u = [u[0] & 2, s.value]), u[0])) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, (i = u[1]), (u = [0]);
            continue;
          case 7:
            (u = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((s = n.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || (u[1] > s[0] && u[1] < s[3]))) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = u);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (f) {
        (u = [6, f]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function J_e(t, e, n, r) {
  r === void 0 && (r = n), (t[r] = e[n]);
}
function e8e(t, e) {
  for (var n in t) n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Bx(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    n = e && t[e],
    r = 0;
  if (n) return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return (
          t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function eW(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n) return t;
  var r = n.call(t),
    i,
    s = [],
    a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}
function t8e() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(eW(arguments[e]));
  return t;
}
function n8e() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], a = 0, o = s.length; a < o; a++, i++)
      r[i] = s[a];
  return r;
}
function ay(t) {
  return this instanceof ay ? ((this.v = t), this) : new ay(t);
}
function r8e(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []),
    i,
    s = [];
  return (
    (i = {}),
    a("next"),
    a("throw"),
    a("return"),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function a(d) {
    r[d] &&
      (i[d] = function (p) {
        return new Promise(function (m, g) {
          s.push([d, p, m, g]) > 1 || o(d, p);
        });
      });
  }
  function o(d, p) {
    try {
      l(r[d](p));
    } catch (m) {
      c(s[0][3], m);
    }
  }
  function l(d) {
    d.value instanceof ay
      ? Promise.resolve(d.value.v).then(u, f)
      : c(s[0][2], d);
  }
  function u(d) {
    o("next", d);
  }
  function f(d) {
    o("throw", d);
  }
  function c(d, p) {
    d(p), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function i8e(t) {
  var e, n;
  return (
    (e = {}),
    r("next"),
    r("throw", function (i) {
      throw i;
    }),
    r("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function r(i, s) {
    e[i] = t[i]
      ? function (a) {
          return (n = !n)
            ? { value: ay(t[i](a)), done: i === "return" }
            : s
            ? s(a)
            : a;
        }
      : s;
  }
}
function s8e(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    n;
  return e
    ? e.call(t)
    : ((t = typeof Bx == "function" ? Bx(t) : t[Symbol.iterator]()),
      (n = {}),
      r("next"),
      r("throw"),
      r("return"),
      (n[Symbol.asyncIterator] = function () {
        return this;
      }),
      n);
  function r(s) {
    n[s] =
      t[s] &&
      function (a) {
        return new Promise(function (o, l) {
          (a = t[s](a)), i(o, l, a.done, a.value);
        });
      };
  }
  function i(s, a, o, l) {
    Promise.resolve(l).then(function (u) {
      s({ value: u, done: o });
    }, a);
  }
}
function a8e(t, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(t, "raw", { value: e })
      : (t.raw = e),
    t
  );
}
function o8e(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null)
    for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return (e.default = t), e;
}
function l8e(t) {
  return t && t.__esModule ? t : { default: t };
}
function u8e(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function c8e(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const f8e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return Lx;
        },
        __asyncDelegator: i8e,
        __asyncGenerator: r8e,
        __asyncValues: s8e,
        __await: ay,
        __awaiter: Y_e,
        __classPrivateFieldGet: u8e,
        __classPrivateFieldSet: c8e,
        __createBinding: J_e,
        __decorate: K_e,
        __exportStar: e8e,
        __extends: W_e,
        __generator: Q_e,
        __importDefault: l8e,
        __importStar: o8e,
        __makeTemplateObject: a8e,
        __metadata: Z_e,
        __param: X_e,
        __read: eW,
        __rest: q_e,
        __spread: t8e,
        __spreadArrays: n8e,
        __values: Bx,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  oc = w9(f8e);
var C8 = {},
  vm = {},
  pM;
function d8e() {
  if (pM) return vm;
  (pM = 1),
    Object.defineProperty(vm, "__esModule", { value: !0 }),
    (vm.delay = void 0);
  function t(e) {
    return new Promise((n) => {
      setTimeout(() => {
        n(!0);
      }, e);
    });
  }
  return (vm.delay = t), vm;
}
var Ld = {},
  k8 = {},
  Bd = {},
  mM;
function h8e() {
  return (
    mM ||
      ((mM = 1),
      Object.defineProperty(Bd, "__esModule", { value: !0 }),
      (Bd.ONE_THOUSAND = Bd.ONE_HUNDRED = void 0),
      (Bd.ONE_HUNDRED = 100),
      (Bd.ONE_THOUSAND = 1e3)),
    Bd
  );
}
var I8 = {},
  gM;
function p8e() {
  return (
    gM ||
      ((gM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ONE_YEAR =
            t.FOUR_WEEKS =
            t.THREE_WEEKS =
            t.TWO_WEEKS =
            t.ONE_WEEK =
            t.THIRTY_DAYS =
            t.SEVEN_DAYS =
            t.FIVE_DAYS =
            t.THREE_DAYS =
            t.ONE_DAY =
            t.TWENTY_FOUR_HOURS =
            t.TWELVE_HOURS =
            t.SIX_HOURS =
            t.THREE_HOURS =
            t.ONE_HOUR =
            t.SIXTY_MINUTES =
            t.THIRTY_MINUTES =
            t.TEN_MINUTES =
            t.FIVE_MINUTES =
            t.ONE_MINUTE =
            t.SIXTY_SECONDS =
            t.THIRTY_SECONDS =
            t.TEN_SECONDS =
            t.FIVE_SECONDS =
            t.ONE_SECOND =
              void 0),
          (t.ONE_SECOND = 1),
          (t.FIVE_SECONDS = 5),
          (t.TEN_SECONDS = 10),
          (t.THIRTY_SECONDS = 30),
          (t.SIXTY_SECONDS = 60),
          (t.ONE_MINUTE = t.SIXTY_SECONDS),
          (t.FIVE_MINUTES = t.ONE_MINUTE * 5),
          (t.TEN_MINUTES = t.ONE_MINUTE * 10),
          (t.THIRTY_MINUTES = t.ONE_MINUTE * 30),
          (t.SIXTY_MINUTES = t.ONE_MINUTE * 60),
          (t.ONE_HOUR = t.SIXTY_MINUTES),
          (t.THREE_HOURS = t.ONE_HOUR * 3),
          (t.SIX_HOURS = t.ONE_HOUR * 6),
          (t.TWELVE_HOURS = t.ONE_HOUR * 12),
          (t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24),
          (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
          (t.THREE_DAYS = t.ONE_DAY * 3),
          (t.FIVE_DAYS = t.ONE_DAY * 5),
          (t.SEVEN_DAYS = t.ONE_DAY * 7),
          (t.THIRTY_DAYS = t.ONE_DAY * 30),
          (t.ONE_WEEK = t.SEVEN_DAYS),
          (t.TWO_WEEKS = t.ONE_WEEK * 2),
          (t.THREE_WEEKS = t.ONE_WEEK * 3),
          (t.FOUR_WEEKS = t.ONE_WEEK * 4),
          (t.ONE_YEAR = t.ONE_DAY * 365);
      })(I8)),
    I8
  );
}
var yM;
function tW() {
  return (
    yM ||
      ((yM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = oc;
        e.__exportStar(h8e(), t), e.__exportStar(p8e(), t);
      })(k8)),
    k8
  );
}
var vM;
function m8e() {
  if (vM) return Ld;
  (vM = 1),
    Object.defineProperty(Ld, "__esModule", { value: !0 }),
    (Ld.fromMiliseconds = Ld.toMiliseconds = void 0);
  const t = tW();
  function e(r) {
    return r * t.ONE_THOUSAND;
  }
  Ld.toMiliseconds = e;
  function n(r) {
    return Math.floor(r / t.ONE_THOUSAND);
  }
  return (Ld.fromMiliseconds = n), Ld;
}
var bM;
function g8e() {
  return (
    bM ||
      ((bM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = oc;
        e.__exportStar(d8e(), t), e.__exportStar(m8e(), t);
      })(C8)),
    C8
  );
}
var wp = {},
  wM;
function y8e() {
  if (wM) return wp;
  (wM = 1),
    Object.defineProperty(wp, "__esModule", { value: !0 }),
    (wp.Watch = void 0);
  class t {
    constructor() {
      this.timestamps = new Map();
    }
    start(n) {
      if (this.timestamps.has(n))
        throw new Error(`Watch already started for label: ${n}`);
      this.timestamps.set(n, { started: Date.now() });
    }
    stop(n) {
      const r = this.get(n);
      if (typeof r.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${n}`);
      const i = Date.now() - r.started;
      this.timestamps.set(n, { started: r.started, elapsed: i });
    }
    get(n) {
      const r = this.timestamps.get(n);
      if (typeof r > "u") throw new Error(`No timestamp found for label: ${n}`);
      return r;
    }
    elapsed(n) {
      const r = this.get(n);
      return r.elapsed || Date.now() - r.started;
    }
  }
  return (wp.Watch = t), (wp.default = t), wp;
}
var O8 = {},
  bm = {},
  _M;
function v8e() {
  if (_M) return bm;
  (_M = 1),
    Object.defineProperty(bm, "__esModule", { value: !0 }),
    (bm.IWatch = void 0);
  class t {}
  return (bm.IWatch = t), bm;
}
var EM;
function b8e() {
  return (
    EM ||
      ((EM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          oc.__exportStar(v8e(), t);
      })(O8)),
    O8
  );
}
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = oc;
  e.__exportStar(g8e(), t),
    e.__exportStar(y8e(), t),
    e.__exportStar(b8e(), t),
    e.__exportStar(tW(), t);
})(Vt);
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.getLocalStorage =
  Nr.getLocalStorageOrThrow =
  Nr.getCrypto =
  Nr.getCryptoOrThrow =
  rW =
  Nr.getLocation =
  Nr.getLocationOrThrow =
  tS =
  Nr.getNavigator =
  Nr.getNavigatorOrThrow =
  nW =
  Nr.getDocument =
  Nr.getDocumentOrThrow =
  Nr.getFromWindowOrThrow =
  Nr.getFromWindow =
    void 0;
function Uh(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Nr.getFromWindow = Uh;
function C1(t) {
  const e = Uh(t);
  if (!e) throw new Error(`${t} is not defined in Window`);
  return e;
}
Nr.getFromWindowOrThrow = C1;
function w8e() {
  return C1("document");
}
Nr.getDocumentOrThrow = w8e;
function _8e() {
  return Uh("document");
}
var nW = (Nr.getDocument = _8e);
function E8e() {
  return C1("navigator");
}
Nr.getNavigatorOrThrow = E8e;
function x8e() {
  return Uh("navigator");
}
var tS = (Nr.getNavigator = x8e);
function T8e() {
  return C1("location");
}
Nr.getLocationOrThrow = T8e;
function S8e() {
  return Uh("location");
}
var rW = (Nr.getLocation = S8e);
function A8e() {
  return C1("crypto");
}
Nr.getCryptoOrThrow = A8e;
function C8e() {
  return Uh("crypto");
}
Nr.getCrypto = C8e;
function k8e() {
  return C1("localStorage");
}
Nr.getLocalStorageOrThrow = k8e;
function I8e() {
  return Uh("localStorage");
}
Nr.getLocalStorage = I8e;
var nS = {};
Object.defineProperty(nS, "__esModule", { value: !0 });
var iW = (nS.getWindowMetadata = void 0);
const xM = Nr;
function O8e() {
  let t, e;
  try {
    (t = xM.getDocumentOrThrow()), (e = xM.getLocationOrThrow());
  } catch {
    return null;
  }
  function n() {
    const c = t.getElementsByTagName("link"),
      d = [];
    for (let p = 0; p < c.length; p++) {
      const m = c[p],
        g = m.getAttribute("rel");
      if (g && g.toLowerCase().indexOf("icon") > -1) {
        const w = m.getAttribute("href");
        if (w)
          if (
            w.toLowerCase().indexOf("https:") === -1 &&
            w.toLowerCase().indexOf("http:") === -1 &&
            w.indexOf("//") !== 0
          ) {
            let y = e.protocol + "//" + e.host;
            if (w.indexOf("/") === 0) y += w;
            else {
              const v = e.pathname.split("/");
              v.pop();
              const E = v.join("/");
              y += E + "/" + w;
            }
            d.push(y);
          } else if (w.indexOf("//") === 0) {
            const y = e.protocol + w;
            d.push(y);
          } else d.push(w);
      }
    }
    return d;
  }
  function r(...c) {
    const d = t.getElementsByTagName("meta");
    for (let p = 0; p < d.length; p++) {
      const m = d[p],
        g = ["itemprop", "property", "name"]
          .map((w) => m.getAttribute(w))
          .filter((w) => (w ? c.includes(w) : !1));
      if (g.length && g) {
        const w = m.getAttribute("content");
        if (w) return w;
      }
    }
    return "";
  }
  function i() {
    let c = r("name", "og:site_name", "og:title", "twitter:title");
    return c || (c = t.title), c;
  }
  function s() {
    return r(
      "description",
      "og:description",
      "twitter:description",
      "keywords"
    );
  }
  const a = i(),
    o = s(),
    l = e.origin,
    u = n();
  return { description: o, url: l, icons: u, name: a };
}
iW = nS.getWindowMetadata = O8e;
var oy = {},
  P8e = (t) =>
    encodeURIComponent(t).replace(
      /[!'()*]/g,
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
    ),
  sW = "%[a-f0-9]{2}",
  TM = new RegExp("(" + sW + ")|([^%]+?)", "gi"),
  SM = new RegExp("(" + sW + ")+", "gi");
function Fx(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {}
  if (t.length === 1) return t;
  e = e || 1;
  var n = t.slice(0, e),
    r = t.slice(e);
  return Array.prototype.concat.call([], Fx(n), Fx(r));
}
function N8e(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(TM) || [], n = 1; n < e.length; n++)
      (t = Fx(e, n).join("")), (e = t.match(TM) || []);
    return t;
  }
}
function D8e(t) {
  for (var e = { "%FE%FF": "��", "%FF%FE": "��" }, n = SM.exec(t); n; ) {
    try {
      e[n[0]] = decodeURIComponent(n[0]);
    } catch {
      var r = N8e(n[0]);
      r !== n[0] && (e[n[0]] = r);
    }
    n = SM.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var a = i[s];
    t = t.replace(new RegExp(a, "g"), e[a]);
  }
  return t;
}
var R8e = function (t) {
    if (typeof t != "string")
      throw new TypeError(
        "Expected `encodedURI` to be of type `string`, got `" + typeof t + "`"
      );
    try {
      return (t = t.replace(/\+/g, " ")), decodeURIComponent(t);
    } catch {
      return D8e(t);
    }
  },
  M8e = (t, e) => {
    if (!(typeof t == "string" && typeof e == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
    if (e === "") return [t];
    const n = t.indexOf(e);
    return n === -1 ? [t] : [t.slice(0, n), t.slice(n + e.length)];
  },
  L8e = function (t, e) {
    for (
      var n = {}, r = Object.keys(t), i = Array.isArray(e), s = 0;
      s < r.length;
      s++
    ) {
      var a = r[s],
        o = t[a];
      (i ? e.indexOf(a) !== -1 : e(a, o, t)) && (n[a] = o);
    }
    return n;
  };
(function (t) {
  const e = P8e,
    n = R8e,
    r = M8e,
    i = L8e,
    s = (v) => v == null,
    a = Symbol("encodeFragmentIdentifier");
  function o(v) {
    switch (v.arrayFormat) {
      case "index":
        return (E) => (S, D) => {
          const P = S.length;
          return D === void 0 ||
            (v.skipNull && D === null) ||
            (v.skipEmptyString && D === "")
            ? S
            : D === null
            ? [...S, [f(E, v), "[", P, "]"].join("")]
            : [...S, [f(E, v), "[", f(P, v), "]=", f(D, v)].join("")];
        };
      case "bracket":
        return (E) => (S, D) =>
          D === void 0 ||
          (v.skipNull && D === null) ||
          (v.skipEmptyString && D === "")
            ? S
            : D === null
            ? [...S, [f(E, v), "[]"].join("")]
            : [...S, [f(E, v), "[]=", f(D, v)].join("")];
      case "colon-list-separator":
        return (E) => (S, D) =>
          D === void 0 ||
          (v.skipNull && D === null) ||
          (v.skipEmptyString && D === "")
            ? S
            : D === null
            ? [...S, [f(E, v), ":list="].join("")]
            : [...S, [f(E, v), ":list=", f(D, v)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const E = v.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (S) => (D, P) =>
          P === void 0 ||
          (v.skipNull && P === null) ||
          (v.skipEmptyString && P === "")
            ? D
            : ((P = P === null ? "" : P),
              D.length === 0
                ? [[f(S, v), E, f(P, v)].join("")]
                : [[D, f(P, v)].join(v.arrayFormatSeparator)]);
      }
      default:
        return (E) => (S, D) =>
          D === void 0 ||
          (v.skipNull && D === null) ||
          (v.skipEmptyString && D === "")
            ? S
            : D === null
            ? [...S, f(E, v)]
            : [...S, [f(E, v), "=", f(D, v)].join("")];
    }
  }
  function l(v) {
    let E;
    switch (v.arrayFormat) {
      case "index":
        return (S, D, P) => {
          if (
            ((E = /\[(\d*)\]$/.exec(S)), (S = S.replace(/\[\d*\]$/, "")), !E)
          ) {
            P[S] = D;
            return;
          }
          P[S] === void 0 && (P[S] = {}), (P[S][E[1]] = D);
        };
      case "bracket":
        return (S, D, P) => {
          if (((E = /(\[\])$/.exec(S)), (S = S.replace(/\[\]$/, "")), !E)) {
            P[S] = D;
            return;
          }
          if (P[S] === void 0) {
            P[S] = [D];
            return;
          }
          P[S] = [].concat(P[S], D);
        };
      case "colon-list-separator":
        return (S, D, P) => {
          if (((E = /(:list)$/.exec(S)), (S = S.replace(/:list$/, "")), !E)) {
            P[S] = D;
            return;
          }
          if (P[S] === void 0) {
            P[S] = [D];
            return;
          }
          P[S] = [].concat(P[S], D);
        };
      case "comma":
      case "separator":
        return (S, D, P) => {
          const x = typeof D == "string" && D.includes(v.arrayFormatSeparator),
            _ =
              typeof D == "string" &&
              !x &&
              c(D, v).includes(v.arrayFormatSeparator);
          D = _ ? c(D, v) : D;
          const A =
            x || _
              ? D.split(v.arrayFormatSeparator).map((N) => c(N, v))
              : D === null
              ? D
              : c(D, v);
          P[S] = A;
        };
      case "bracket-separator":
        return (S, D, P) => {
          const x = /(\[\])$/.test(S);
          if (((S = S.replace(/\[\]$/, "")), !x)) {
            P[S] = D && c(D, v);
            return;
          }
          const _ =
            D === null
              ? []
              : D.split(v.arrayFormatSeparator).map((A) => c(A, v));
          if (P[S] === void 0) {
            P[S] = _;
            return;
          }
          P[S] = [].concat(P[S], _);
        };
      default:
        return (S, D, P) => {
          if (P[S] === void 0) {
            P[S] = D;
            return;
          }
          P[S] = [].concat(P[S], D);
        };
    }
  }
  function u(v) {
    if (typeof v != "string" || v.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function f(v, E) {
    return E.encode ? (E.strict ? e(v) : encodeURIComponent(v)) : v;
  }
  function c(v, E) {
    return E.decode ? n(v) : v;
  }
  function d(v) {
    return Array.isArray(v)
      ? v.sort()
      : typeof v == "object"
      ? d(Object.keys(v))
          .sort((E, S) => Number(E) - Number(S))
          .map((E) => v[E])
      : v;
  }
  function p(v) {
    const E = v.indexOf("#");
    return E !== -1 && (v = v.slice(0, E)), v;
  }
  function m(v) {
    let E = "";
    const S = v.indexOf("#");
    return S !== -1 && (E = v.slice(S)), E;
  }
  function g(v) {
    v = p(v);
    const E = v.indexOf("?");
    return E === -1 ? "" : v.slice(E + 1);
  }
  function w(v, E) {
    return (
      E.parseNumbers &&
      !Number.isNaN(Number(v)) &&
      typeof v == "string" &&
      v.trim() !== ""
        ? (v = Number(v))
        : E.parseBooleans &&
          v !== null &&
          (v.toLowerCase() === "true" || v.toLowerCase() === "false") &&
          (v = v.toLowerCase() === "true"),
      v
    );
  }
  function y(v, E) {
    (E = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      E
    )),
      u(E.arrayFormatSeparator);
    const S = l(E),
      D = Object.create(null);
    if (typeof v != "string" || ((v = v.trim().replace(/^[?#&]/, "")), !v))
      return D;
    for (const P of v.split("&")) {
      if (P === "") continue;
      let [x, _] = r(E.decode ? P.replace(/\+/g, " ") : P, "=");
      (_ =
        _ === void 0
          ? null
          : ["comma", "separator", "bracket-separator"].includes(E.arrayFormat)
          ? _
          : c(_, E)),
        S(c(x, E), _, D);
    }
    for (const P of Object.keys(D)) {
      const x = D[P];
      if (typeof x == "object" && x !== null)
        for (const _ of Object.keys(x)) x[_] = w(x[_], E);
      else D[P] = w(x, E);
    }
    return E.sort === !1
      ? D
      : (E.sort === !0
          ? Object.keys(D).sort()
          : Object.keys(D).sort(E.sort)
        ).reduce((P, x) => {
          const _ = D[x];
          return (
            _ && typeof _ == "object" && !Array.isArray(_)
              ? (P[x] = d(_))
              : (P[x] = _),
            P
          );
        }, Object.create(null));
  }
  (t.extract = g),
    (t.parse = y),
    (t.stringify = (v, E) => {
      if (!v) return "";
      (E = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        E
      )),
        u(E.arrayFormatSeparator);
      const S = (_) =>
          (E.skipNull && s(v[_])) || (E.skipEmptyString && v[_] === ""),
        D = o(E),
        P = {};
      for (const _ of Object.keys(v)) S(_) || (P[_] = v[_]);
      const x = Object.keys(P);
      return (
        E.sort !== !1 && x.sort(E.sort),
        x
          .map((_) => {
            const A = v[_];
            return A === void 0
              ? ""
              : A === null
              ? f(_, E)
              : Array.isArray(A)
              ? A.length === 0 && E.arrayFormat === "bracket-separator"
                ? f(_, E) + "[]"
                : A.reduce(D(_), []).join("&")
              : f(_, E) + "=" + f(A, E);
          })
          .filter((_) => _.length > 0)
          .join("&")
      );
    }),
    (t.parseUrl = (v, E) => {
      E = Object.assign({ decode: !0 }, E);
      const [S, D] = r(v, "#");
      return Object.assign(
        { url: S.split("?")[0] || "", query: y(g(v), E) },
        E && E.parseFragmentIdentifier && D
          ? { fragmentIdentifier: c(D, E) }
          : {}
      );
    }),
    (t.stringifyUrl = (v, E) => {
      E = Object.assign({ encode: !0, strict: !0, [a]: !0 }, E);
      const S = p(v.url).split("?")[0] || "",
        D = t.extract(v.url),
        P = t.parse(D, { sort: !1 }),
        x = Object.assign(P, v.query);
      let _ = t.stringify(x, E);
      _ && (_ = `?${_}`);
      let A = m(v.url);
      return (
        v.fragmentIdentifier &&
          (A = `#${E[a] ? f(v.fragmentIdentifier, E) : v.fragmentIdentifier}`),
        `${S}${_}${A}`
      );
    }),
    (t.pick = (v, E, S) => {
      S = Object.assign({ parseFragmentIdentifier: !0, [a]: !1 }, S);
      const { url: D, query: P, fragmentIdentifier: x } = t.parseUrl(v, S);
      return t.stringifyUrl(
        { url: D, query: i(P, E), fragmentIdentifier: x },
        S
      );
    }),
    (t.exclude = (v, E, S) => {
      const D = Array.isArray(E) ? (P) => !E.includes(P) : (P, x) => !E(P, x);
      return t.pick(v, D, S);
    });
})(oy);
const B8e = {
    waku: {
      publish: "waku_publish",
      batchPublish: "waku_batchPublish",
      subscribe: "waku_subscribe",
      batchSubscribe: "waku_batchSubscribe",
      subscription: "waku_subscription",
      unsubscribe: "waku_unsubscribe",
      batchUnsubscribe: "waku_batchUnsubscribe",
    },
    irn: {
      publish: "irn_publish",
      batchPublish: "irn_batchPublish",
      subscribe: "irn_subscribe",
      batchSubscribe: "irn_batchSubscribe",
      subscription: "irn_subscription",
      unsubscribe: "irn_unsubscribe",
      batchUnsubscribe: "irn_batchUnsubscribe",
    },
    iridium: {
      publish: "iridium_publish",
      batchPublish: "iridium_batchPublish",
      subscribe: "iridium_subscribe",
      batchSubscribe: "iridium_batchSubscribe",
      subscription: "iridium_subscription",
      unsubscribe: "iridium_unsubscribe",
      batchUnsubscribe: "iridium_batchUnsubscribe",
    },
  },
  F8e = ":";
function $8e(t) {
  const [e, n] = t.split(F8e);
  return { namespace: e, reference: n };
}
function U8e(t, e = []) {
  const n = [];
  return (
    Object.keys(t).forEach((r) => {
      if (e.length && !e.includes(r)) return;
      const i = t[r];
      n.push(...i.accounts);
    }),
    n
  );
}
function aW(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
const oW = "base10",
  Ca = "base16",
  $x = "base64pad",
  rS = "utf8",
  lW = 0,
  jh = 1,
  j8e = 0,
  AM = 1,
  Ux = 12,
  iS = 32;
function H8e() {
  const t = JT.generateKeyPair();
  return { privateKey: Pa(t.secretKey, Ca), publicKey: Pa(t.publicKey, Ca) };
}
function jx() {
  const t = A1.randomBytes(iS);
  return Pa(t, Ca);
}
function z8e(t, e) {
  const n = JT.sharedKey(eo(t, Ca), eo(e, Ca), !0),
    r = new I3e(m6.SHA256, n).expand(iS);
  return Pa(r, Ca);
}
function V8e(t) {
  const e = m6.hash(eo(t, Ca));
  return Pa(e, Ca);
}
function w0(t) {
  const e = m6.hash(eo(t, rS));
  return Pa(e, Ca);
}
function G8e(t) {
  return eo(`${t}`, oW);
}
function zy(t) {
  return Number(Pa(t, oW));
}
function W8e(t) {
  const e = G8e(typeof t.type < "u" ? t.type : lW);
  if (zy(e) === jh && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const n = typeof t.senderPublicKey < "u" ? eo(t.senderPublicKey, Ca) : void 0,
    r = typeof t.iv < "u" ? eo(t.iv, Ca) : A1.randomBytes(Ux),
    i = new YT.ChaCha20Poly1305(eo(t.symKey, Ca)).seal(r, eo(t.message, rS));
  return K8e({ type: e, sealed: i, iv: r, senderPublicKey: n });
}
function q8e(t) {
  const e = new YT.ChaCha20Poly1305(eo(t.symKey, Ca)),
    { sealed: n, iv: r } = Z5(t.encoded),
    i = e.open(r, n);
  if (i === null) throw new Error("Failed to decrypt");
  return Pa(i, rS);
}
function K8e(t) {
  if (zy(t.type) === jh) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return Pa(Rx([t.type, t.senderPublicKey, t.iv, t.sealed]), $x);
  }
  return Pa(Rx([t.type, t.iv, t.sealed]), $x);
}
function Z5(t) {
  const e = eo(t, $x),
    n = e.slice(j8e, AM),
    r = AM;
  if (zy(n) === jh) {
    const o = r + iS,
      l = o + Ux,
      u = e.slice(r, o),
      f = e.slice(o, l),
      c = e.slice(l);
    return { type: n, sealed: c, iv: f, senderPublicKey: u };
  }
  const i = r + Ux,
    s = e.slice(r, i),
    a = e.slice(i);
  return { type: n, sealed: a, iv: s };
}
function X8e(t, e) {
  const n = Z5(t);
  return uW({
    type: zy(n.type),
    senderPublicKey:
      typeof n.senderPublicKey < "u" ? Pa(n.senderPublicKey, Ca) : void 0,
    receiverPublicKey: e?.receiverPublicKey,
  });
}
function uW(t) {
  const e = t?.type || lW;
  if (e === jh) {
    if (typeof t?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof t?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return {
    type: e,
    senderPublicKey: t?.senderPublicKey,
    receiverPublicKey: t?.receiverPublicKey,
  };
}
function CM(t) {
  return (
    t.type === jh &&
    typeof t.senderPublicKey == "string" &&
    typeof t.receiverPublicKey == "string"
  );
}
var Z8e = Object.defineProperty,
  kM = Object.getOwnPropertySymbols,
  Y8e = Object.prototype.hasOwnProperty,
  Q8e = Object.prototype.propertyIsEnumerable,
  IM = (t, e, n) =>
    e in t
      ? Z8e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  OM = (t, e) => {
    for (var n in e || (e = {})) Y8e.call(e, n) && IM(t, n, e[n]);
    if (kM) for (var n of kM(e)) Q8e.call(e, n) && IM(t, n, e[n]);
    return t;
  };
const J8e = "ReactNative",
  No = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown",
  },
  e4e = "js";
function sS() {
  return (
    typeof process < "u" &&
    typeof process.versions < "u" &&
    typeof process.versions.node < "u"
  );
}
function k1() {
  return !nW() && !!tS() && navigator.product === J8e;
}
function I1() {
  return !sS() && !!tS();
}
function Vy() {
  return k1()
    ? No.reactNative
    : sS()
    ? No.node
    : I1()
    ? No.browser
    : No.unknown;
}
function t4e() {
  var t;
  try {
    return k1() &&
      typeof global < "u" &&
      typeof (global == null ? void 0 : global.Application) < "u"
      ? (t = global.Application) == null
        ? void 0
        : t.applicationId
      : void 0;
  } catch {
    return;
  }
}
function n4e(t, e) {
  let n = oy.parse(t);
  return (n = OM(OM({}, n), e)), (t = oy.stringify(n)), t;
}
function r4e() {
  return iW() || { name: "", description: "", url: "", icons: [""] };
}
function i4e() {
  if (
    Vy() === No.reactNative &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u"
  ) {
    const { OS: n, Version: r } = global.Platform;
    return [n, r].join("-");
  }
  const t = j_e();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser"
    ? [e, t.name, t.version].join("-")
    : [e, t.version].join("-");
}
function s4e() {
  var t;
  const e = Vy();
  return e === No.browser
    ? [e, ((t = rW()) == null ? void 0 : t.host) || "unknown"].join(":")
    : e;
}
function a4e(t, e, n) {
  const r = i4e(),
    i = s4e();
  return [[t, e].join("-"), [e4e, n].join("-"), r, i].join("/");
}
function o4e({
  protocol: t,
  version: e,
  relayUrl: n,
  sdkVersion: r,
  auth: i,
  projectId: s,
  useOnCloseEvent: a,
  bundleId: o,
}) {
  const l = n.split("?"),
    u = a4e(t, e, r),
    f = {
      auth: i,
      ua: u,
      projectId: s,
      useOnCloseEvent: a || void 0,
      origin: o || void 0,
    },
    c = n4e(l[1] || "", f);
  return l[0] + "?" + c;
}
function ih(t, e) {
  return t.filter((n) => e.includes(n)).length === t.length;
}
function cW(t) {
  return Object.fromEntries(t.entries());
}
function fW(t) {
  return new Map(Object.entries(t));
}
function Pp(t = Vt.FIVE_MINUTES, e) {
  const n = Vt.toMiliseconds(t || Vt.FIVE_MINUTES);
  let r, i, s;
  return {
    resolve: (a) => {
      s && r && (clearTimeout(s), r(a));
    },
    reject: (a) => {
      s && i && (clearTimeout(s), i(a));
    },
    done: () =>
      new Promise((a, o) => {
        (s = setTimeout(() => {
          o(new Error(e));
        }, n)),
          (r = a),
          (i = o);
      }),
  };
}
function ly(t, e, n) {
  return new Promise(async (r, i) => {
    const s = setTimeout(() => i(new Error(n)), e);
    try {
      const a = await t;
      r(a);
    } catch (a) {
      i(a);
    }
    clearTimeout(s);
  });
}
function dW(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function l4e(t) {
  return dW("topic", t);
}
function u4e(t) {
  return dW("id", t);
}
function hW(t) {
  const [e, n] = t.split(":"),
    r = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n == "string") r.topic = n;
  else if (e === "id" && Number.isInteger(Number(n))) r.id = Number(n);
  else
    throw new Error(
      `Invalid target, expected id:number or topic:string, got ${e}:${n}`
    );
  return r;
}
function ql(t, e) {
  return Vt.fromMiliseconds((e || Date.now()) + Vt.toMiliseconds(t));
}
function Rf(t) {
  return Date.now() >= Vt.toMiliseconds(t);
}
function Bi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function P8(t = [], e = []) {
  return [...new Set([...t, ...e])];
}
async function c4e({ id: t, topic: e, wcDeepLink: n }) {
  try {
    if (!n) return;
    let i = (typeof n == "string" ? JSON.parse(n) : n)?.href;
    if (typeof i != "string") return;
    i.endsWith("/") && (i = i.slice(0, -1));
    const s = `${i}/wc?requestId=${t}&sessionTopic=${e}`,
      a = Vy();
    a === No.browser
      ? s.startsWith("https://")
        ? window.open(s, "_blank", "noreferrer noopener")
        : window.open(s, "_self", "noreferrer noopener")
      : a === No.reactNative &&
        typeof (global == null ? void 0 : global.Linking) < "u" &&
        (await global.Linking.openURL(s));
  } catch (r) {
    console.error(r);
  }
}
async function f4e(t, e) {
  try {
    return (await t.getItem(e)) || (I1() ? localStorage.getItem(e) : void 0);
  } catch (n) {
    console.error(n);
  }
}
const d4e = "irn";
function Hx(t) {
  return t?.relay || { protocol: d4e };
}
function mb(t) {
  const e = B8e[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var h4e = Object.defineProperty,
  PM = Object.getOwnPropertySymbols,
  p4e = Object.prototype.hasOwnProperty,
  m4e = Object.prototype.propertyIsEnumerable,
  NM = (t, e, n) =>
    e in t
      ? h4e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  g4e = (t, e) => {
    for (var n in e || (e = {})) p4e.call(e, n) && NM(t, n, e[n]);
    if (PM) for (var n of PM(e)) m4e.call(e, n) && NM(t, n, e[n]);
    return t;
  };
function y4e(t, e = "-") {
  const n = {},
    r = "relay" + e;
  return (
    Object.keys(t).forEach((i) => {
      if (i.startsWith(r)) {
        const s = i.replace(r, ""),
          a = t[i];
        n[s] = a;
      }
    }),
    n
  );
}
function DM(t) {
  (t = t.includes("wc://") ? t.replace("wc://", "") : t),
    (t = t.includes("wc:") ? t.replace("wc:", "") : t);
  const e = t.indexOf(":"),
    n = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
    r = t.substring(0, e),
    i = t.substring(e + 1, n).split("@"),
    s = typeof n < "u" ? t.substring(n) : "",
    a = oy.parse(s);
  return {
    protocol: r,
    topic: v4e(i[0]),
    version: parseInt(i[1], 10),
    symKey: a.symKey,
    relay: y4e(a),
  };
}
function v4e(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function b4e(t, e = "-") {
  const n = "relay",
    r = {};
  return (
    Object.keys(t).forEach((i) => {
      const s = n + e + i;
      t[i] && (r[s] = t[i]);
    }),
    r
  );
}
function w4e(t) {
  return (
    `${t.protocol}:${t.topic}@${t.version}?` +
    oy.stringify(g4e({ symKey: t.symKey }, b4e(t.relay)))
  );
}
function O1(t) {
  const e = [];
  return (
    t.forEach((n) => {
      const [r, i] = n.split(":");
      e.push(`${r}:${i}`);
    }),
    e
  );
}
function _4e(t) {
  const e = [];
  return (
    Object.values(t).forEach((n) => {
      e.push(...O1(n.accounts));
    }),
    e
  );
}
function E4e(t, e) {
  const n = [];
  return (
    Object.values(t).forEach((r) => {
      O1(r.accounts).includes(e) && n.push(...r.methods);
    }),
    n
  );
}
function x4e(t, e) {
  const n = [];
  return (
    Object.values(t).forEach((r) => {
      O1(r.accounts).includes(e) && n.push(...r.events);
    }),
    n
  );
}
function T4e(t, e) {
  const n = gb(t, e);
  if (n) throw new Error(n.message);
  const r = {};
  for (const [i, s] of Object.entries(t))
    r[i] = {
      methods: s.methods,
      events: s.events,
      chains: s.accounts.map((a) => `${a.split(":")[0]}:${a.split(":")[1]}`),
    };
  return r;
}
function aS(t) {
  return t.includes(":");
}
function qm(t) {
  return aS(t) ? t.split(":")[0] : t;
}
const S4e = {
    INVALID_METHOD: { message: "Invalid method.", code: 1001 },
    INVALID_EVENT: { message: "Invalid event.", code: 1002 },
    INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 },
    INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005,
    },
    UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
    UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003,
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004,
    },
    USER_REJECTED: { message: "User rejected.", code: 5e3 },
    USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 },
    USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 },
    USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 },
    UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
    UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
    UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
    UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104,
    },
    USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3,
    },
    WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 },
  },
  A4e = {
    NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
    NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
    RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
    RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
    MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
    EXPIRED: { message: "Expired.", code: 6 },
    UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
    MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9,
    },
  };
function ut(t, e) {
  const { message: n, code: r } = A4e[t];
  return { message: e ? `${n} ${e}` : n, code: r };
}
function ki(t, e) {
  const { message: n, code: r } = S4e[t];
  return { message: e ? `${n} ${e}` : n, code: r };
}
function tc(t, e) {
  return Array.isArray(t) ? (typeof e < "u" && t.length ? t.every(e) : !0) : !1;
}
function _0(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function ba(t) {
  return typeof t > "u";
}
function Es(t, e) {
  return e && ba(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function oS(t, e) {
  return e && ba(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function C4e(t, e) {
  const { requiredNamespaces: n } = e,
    r = Object.keys(t.namespaces),
    i = Object.keys(n);
  let s = !0;
  return ih(i, r)
    ? (r.forEach((a) => {
        const { accounts: o, methods: l, events: u } = t.namespaces[a],
          f = O1(o),
          c = n[a];
        (!ih(aW(a, c), f) || !ih(c.methods, l) || !ih(c.events, u)) && (s = !1);
      }),
      s)
    : !1;
}
function Y5(t) {
  return Es(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function k4e(t) {
  if (Es(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n = e[0] + ":" + e[1];
      return !!e[2] && Y5(n);
    }
  }
  return !1;
}
function I4e(t) {
  if (Es(t, !1))
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function O4e(t) {
  var e;
  return (e = t?.proposer) == null ? void 0 : e.publicKey;
}
function P4e(t) {
  return t?.topic;
}
function N4e(t, e) {
  let n = null;
  return (
    Es(t?.publicKey, !1) ||
      (n = ut(
        "MISSING_OR_INVALID",
        `${e} controller public key should be a string`
      )),
    n
  );
}
function RM(t) {
  let e = !0;
  return tc(t) ? t.length && (e = t.every((n) => Es(n, !1))) : (e = !1), e;
}
function D4e(t, e, n) {
  let r = null;
  return (
    tc(e) && e.length
      ? e.forEach((i) => {
          r ||
            Y5(i) ||
            (r = ki(
              "UNSUPPORTED_CHAINS",
              `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`
            ));
        })
      : Y5(t) ||
        (r = ki(
          "UNSUPPORTED_CHAINS",
          `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
        )),
    r
  );
}
function R4e(t, e, n) {
  let r = null;
  return (
    Object.entries(t).forEach(([i, s]) => {
      if (r) return;
      const a = D4e(i, aW(i, s), `${e} ${n}`);
      a && (r = a);
    }),
    r
  );
}
function M4e(t, e) {
  let n = null;
  return (
    tc(t)
      ? t.forEach((r) => {
          n ||
            k4e(r) ||
            (n = ki(
              "UNSUPPORTED_ACCOUNTS",
              `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`
            ));
        })
      : (n = ki(
          "UNSUPPORTED_ACCOUNTS",
          `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
        )),
    n
  );
}
function L4e(t, e) {
  let n = null;
  return (
    Object.values(t).forEach((r) => {
      if (n) return;
      const i = M4e(r?.accounts, `${e} namespace`);
      i && (n = i);
    }),
    n
  );
}
function B4e(t, e) {
  let n = null;
  return (
    RM(t?.methods)
      ? RM(t?.events) ||
        (n = ki(
          "UNSUPPORTED_EVENTS",
          `${e}, events should be an array of strings or empty array for no events`
        ))
      : (n = ki(
          "UNSUPPORTED_METHODS",
          `${e}, methods should be an array of strings or empty array for no methods`
        )),
    n
  );
}
function pW(t, e) {
  let n = null;
  return (
    Object.values(t).forEach((r) => {
      if (n) return;
      const i = B4e(r, `${e}, namespace`);
      i && (n = i);
    }),
    n
  );
}
function F4e(t, e, n) {
  let r = null;
  if (t && _0(t)) {
    const i = pW(t, e);
    i && (r = i);
    const s = R4e(t, e, n);
    s && (r = s);
  } else
    r = ut("MISSING_OR_INVALID", `${e}, ${n} should be an object with data`);
  return r;
}
function gb(t, e) {
  let n = null;
  if (t && _0(t)) {
    const r = pW(t, e);
    r && (n = r);
    const i = L4e(t, e);
    i && (n = i);
  } else
    n = ut(
      "MISSING_OR_INVALID",
      `${e}, namespaces should be an object with data`
    );
  return n;
}
function mW(t) {
  return Es(t.protocol, !0);
}
function $4e(t, e) {
  let n = !1;
  return (
    e && !t
      ? (n = !0)
      : t &&
        tc(t) &&
        t.length &&
        t.forEach((r) => {
          n = mW(r);
        }),
    n
  );
}
function U4e(t) {
  return typeof t == "number";
}
function Ka(t) {
  return typeof t < "u" && typeof t !== null;
}
function j4e(t) {
  return !(
    !t ||
    typeof t != "object" ||
    !t.code ||
    !oS(t.code, !1) ||
    !t.message ||
    !Es(t.message, !1)
  );
}
function H4e(t) {
  return !(ba(t) || !Es(t.method, !1));
}
function z4e(t) {
  return !(
    ba(t) ||
    (ba(t.result) && ba(t.error)) ||
    !oS(t.id, !1) ||
    !Es(t.jsonrpc, !1)
  );
}
function V4e(t) {
  return !(ba(t) || !Es(t.name, !1));
}
function MM(t, e) {
  return !(!Y5(e) || !_4e(t).includes(e));
}
function G4e(t, e, n) {
  return Es(n, !1) ? E4e(t, e).includes(n) : !1;
}
function W4e(t, e, n) {
  return Es(n, !1) ? x4e(t, e).includes(n) : !1;
}
function LM(t, e, n) {
  let r = null;
  const i = q4e(t),
    s = K4e(e),
    a = Object.keys(i),
    o = Object.keys(s),
    l = BM(Object.keys(t)),
    u = BM(Object.keys(e)),
    f = l.filter((c) => !u.includes(c));
  return (
    f.length &&
      (r = ut(
        "NON_CONFORMING_NAMESPACES",
        `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${f.toString()}
      Received: ${Object.keys(e).toString()}`
      )),
    ih(a, o) ||
      (r = ut(
        "NON_CONFORMING_NAMESPACES",
        `${n} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`
      )),
    Object.keys(e).forEach((c) => {
      if (!c.includes(":") || r) return;
      const d = O1(e[c].accounts);
      d.includes(c) ||
        (r = ut(
          "NON_CONFORMING_NAMESPACES",
          `${n} namespaces accounts don't satisfy namespace accounts for ${c}
        Required: ${c}
        Approved: ${d.toString()}`
        ));
    }),
    a.forEach((c) => {
      r ||
        (ih(i[c].methods, s[c].methods)
          ? ih(i[c].events, s[c].events) ||
            (r = ut(
              "NON_CONFORMING_NAMESPACES",
              `${n} namespaces events don't satisfy namespace events for ${c}`
            ))
          : (r = ut(
              "NON_CONFORMING_NAMESPACES",
              `${n} namespaces methods don't satisfy namespace methods for ${c}`
            )));
    }),
    r
  );
}
function q4e(t) {
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      var r;
      n.includes(":")
        ? (e[n] = t[n])
        : (r = t[n].chains) == null ||
          r.forEach((i) => {
            e[i] = { methods: t[n].methods, events: t[n].events };
          });
    }),
    e
  );
}
function BM(t) {
  return [...new Set(t.map((e) => (e.includes(":") ? e.split(":")[0] : e)))];
}
function K4e(t) {
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      n.includes(":")
        ? (e[n] = t[n])
        : O1(t[n].accounts)?.forEach((i) => {
            e[i] = {
              accounts: t[n].accounts.filter((s) => s.includes(`${i}:`)),
              methods: t[n].methods,
              events: t[n].events,
            };
          });
    }),
    e
  );
}
function X4e(t, e) {
  return oS(t, !1) && t <= e.max && t >= e.min;
}
function FM() {
  const t = Vy();
  return new Promise((e) => {
    switch (t) {
      case No.browser:
        e(Z4e());
        break;
      case No.reactNative:
        e(Y4e());
        break;
      case No.node:
        e(Q4e());
        break;
      default:
        e(!0);
    }
  });
}
function Z4e() {
  return I1() && navigator?.onLine;
}
async function Y4e() {
  return k1() && typeof global < "u" && global != null && global.NetInfo
    ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected
    : !0;
}
function Q4e() {
  return !0;
}
function J4e(t) {
  switch (Vy()) {
    case No.browser:
      eEe(t);
      break;
    case No.reactNative:
      tEe(t);
      break;
  }
}
function eEe(t) {
  !k1() &&
    I1() &&
    (window.addEventListener("online", () => t(!0)),
    window.addEventListener("offline", () => t(!1)));
}
function tEe(t) {
  k1() &&
    typeof global < "u" &&
    global != null &&
    global.NetInfo &&
    global?.NetInfo.addEventListener((e) => t(e?.isConnected));
}
const N8 = {};
let _v = class {
  static get(e) {
    return N8[e];
  }
  static set(e, n) {
    N8[e] = n;
  }
  static delete(e) {
    delete N8[e];
  }
};
const nEe =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  rEe =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  iEe = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function sEe(t, e) {
  if (
    t === "__proto__" ||
    (t === "constructor" && e && typeof e == "object" && "prototype" in e)
  ) {
    aEe(t);
    return;
  }
  return e;
}
function aEe(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function Ev(t, e = {}) {
  if (typeof t != "string") return t;
  const n = t.trim();
  if (t[0] === '"' && t.at(-1) === '"' && !t.includes("\\"))
    return n.slice(1, -1);
  if (n.length <= 9) {
    const r = n.toLowerCase();
    if (r === "true") return !0;
    if (r === "false") return !1;
    if (r === "undefined") return;
    if (r === "null") return null;
    if (r === "nan") return Number.NaN;
    if (r === "infinity") return Number.POSITIVE_INFINITY;
    if (r === "-infinity") return Number.NEGATIVE_INFINITY;
  }
  if (!iEe.test(t)) {
    if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (nEe.test(t) || rEe.test(t)) {
      if (e.strict) throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, sEe);
    }
    return JSON.parse(t);
  } catch (r) {
    if (e.strict) throw r;
    return t;
  }
}
function oEe(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function vs(t, ...e) {
  try {
    return oEe(t(...e));
  } catch (n) {
    return Promise.reject(n);
  }
}
function lEe(t) {
  const e = typeof t;
  return t === null || (e !== "object" && e !== "function");
}
function uEe(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function yb(t) {
  if (lEe(t)) return String(t);
  if (uEe(t) || Array.isArray(t)) return JSON.stringify(t);
  if (typeof t.toJSON == "function") return yb(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function gW() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const zx = "base64:";
function cEe(t) {
  if (typeof t == "string") return t;
  gW();
  const e = Buffer.from(t).toString("base64");
  return zx + e;
}
function fEe(t) {
  return typeof t != "string" || !t.startsWith(zx)
    ? t
    : (gW(), Buffer.from(t.slice(zx.length), "base64"));
}
function qa(t) {
  return t
    ? t
        .split("?")[0]
        .replace(/[/\\]/g, ":")
        .replace(/:+/g, ":")
        .replace(/^:|:$/g, "")
    : "";
}
function dEe(...t) {
  return qa(t.join(":"));
}
function xv(t) {
  return (t = qa(t)), t ? t + ":" : "";
}
const hEe = "memory",
  pEe = () => {
    const t = new Map();
    return {
      name: hEe,
      options: {},
      hasItem(e) {
        return t.has(e);
      },
      getItem(e) {
        return t.get(e) ?? null;
      },
      getItemRaw(e) {
        return t.get(e) ?? null;
      },
      setItem(e, n) {
        t.set(e, n);
      },
      setItemRaw(e, n) {
        t.set(e, n);
      },
      removeItem(e) {
        t.delete(e);
      },
      getKeys() {
        return Array.from(t.keys());
      },
      clear() {
        t.clear();
      },
      dispose() {
        t.clear();
      },
    };
  };
function mEe(t = {}) {
  const e = {
      mounts: { "": t.driver || pEe() },
      mountpoints: [""],
      watching: !1,
      watchListeners: [],
      unwatch: {},
    },
    n = (u) => {
      for (const f of e.mountpoints)
        if (u.startsWith(f))
          return {
            base: f,
            relativeKey: u.slice(f.length),
            driver: e.mounts[f],
          };
      return { base: "", relativeKey: u, driver: e.mounts[""] };
    },
    r = (u, f) =>
      e.mountpoints
        .filter((c) => c.startsWith(u) || (f && u.startsWith(c)))
        .map((c) => ({
          relativeBase: u.length > c.length ? u.slice(c.length) : void 0,
          mountpoint: c,
          driver: e.mounts[c],
        })),
    i = (u, f) => {
      if (e.watching) {
        f = qa(f);
        for (const c of e.watchListeners) c(u, f);
      }
    },
    s = async () => {
      if (!e.watching) {
        e.watching = !0;
        for (const u in e.mounts) e.unwatch[u] = await $M(e.mounts[u], i, u);
      }
    },
    a = async () => {
      if (e.watching) {
        for (const u in e.unwatch) await e.unwatch[u]();
        (e.unwatch = {}), (e.watching = !1);
      }
    },
    o = (u, f, c) => {
      const d = new Map(),
        p = (m) => {
          let g = d.get(m.base);
          return (
            g ||
              ((g = { driver: m.driver, base: m.base, items: [] }),
              d.set(m.base, g)),
            g
          );
        };
      for (const m of u) {
        const g = typeof m == "string",
          w = qa(g ? m : m.key),
          y = g ? void 0 : m.value,
          v = g || !m.options ? f : { ...f, ...m.options },
          E = n(w);
        p(E).items.push({
          key: w,
          value: y,
          relativeKey: E.relativeKey,
          options: v,
        });
      }
      return Promise.all([...d.values()].map((m) => c(m))).then((m) =>
        m.flat()
      );
    },
    l = {
      hasItem(u, f = {}) {
        u = qa(u);
        const { relativeKey: c, driver: d } = n(u);
        return vs(d.hasItem, c, f);
      },
      getItem(u, f = {}) {
        u = qa(u);
        const { relativeKey: c, driver: d } = n(u);
        return vs(d.getItem, c, f).then((p) => Ev(p));
      },
      getItems(u, f) {
        return o(u, f, (c) =>
          c.driver.getItems
            ? vs(
                c.driver.getItems,
                c.items.map((d) => ({
                  key: d.relativeKey,
                  options: d.options,
                })),
                f
              ).then((d) =>
                d.map((p) => ({ key: dEe(c.base, p.key), value: Ev(p.value) }))
              )
            : Promise.all(
                c.items.map((d) =>
                  vs(c.driver.getItem, d.relativeKey, d.options).then((p) => ({
                    key: d.key,
                    value: Ev(p),
                  }))
                )
              )
        );
      },
      getItemRaw(u, f = {}) {
        u = qa(u);
        const { relativeKey: c, driver: d } = n(u);
        return d.getItemRaw
          ? vs(d.getItemRaw, c, f)
          : vs(d.getItem, c, f).then((p) => fEe(p));
      },
      async setItem(u, f, c = {}) {
        if (f === void 0) return l.removeItem(u);
        u = qa(u);
        const { relativeKey: d, driver: p } = n(u);
        p.setItem &&
          (await vs(p.setItem, d, yb(f), c), p.watch || i("update", u));
      },
      async setItems(u, f) {
        await o(u, f, async (c) => {
          c.driver.setItems &&
            (await vs(
              c.driver.setItems,
              c.items.map((d) => ({
                key: d.relativeKey,
                value: yb(d.value),
                options: d.options,
              })),
              f
            )),
            c.driver.setItem &&
              (await Promise.all(
                c.items.map((d) =>
                  vs(c.driver.setItem, d.relativeKey, yb(d.value), d.options)
                )
              ));
        });
      },
      async setItemRaw(u, f, c = {}) {
        if (f === void 0) return l.removeItem(u, c);
        u = qa(u);
        const { relativeKey: d, driver: p } = n(u);
        if (p.setItemRaw) await vs(p.setItemRaw, d, f, c);
        else if (p.setItem) await vs(p.setItem, d, cEe(f), c);
        else return;
        p.watch || i("update", u);
      },
      async removeItem(u, f = {}) {
        typeof f == "boolean" && (f = { removeMeta: f }), (u = qa(u));
        const { relativeKey: c, driver: d } = n(u);
        d.removeItem &&
          (await vs(d.removeItem, c, f),
          (f.removeMeta || f.removeMata) &&
            (await vs(d.removeItem, c + "$", f)),
          d.watch || i("remove", u));
      },
      async getMeta(u, f = {}) {
        typeof f == "boolean" && (f = { nativeOnly: f }), (u = qa(u));
        const { relativeKey: c, driver: d } = n(u),
          p = Object.create(null);
        if (
          (d.getMeta && Object.assign(p, await vs(d.getMeta, c, f)),
          !f.nativeOnly)
        ) {
          const m = await vs(d.getItem, c + "$", f).then((g) => Ev(g));
          m &&
            typeof m == "object" &&
            (typeof m.atime == "string" && (m.atime = new Date(m.atime)),
            typeof m.mtime == "string" && (m.mtime = new Date(m.mtime)),
            Object.assign(p, m));
        }
        return p;
      },
      setMeta(u, f, c = {}) {
        return this.setItem(u + "$", f, c);
      },
      removeMeta(u, f = {}) {
        return this.removeItem(u + "$", f);
      },
      async getKeys(u, f = {}) {
        u = xv(u);
        const c = r(u, !0);
        let d = [];
        const p = [];
        for (const m of c) {
          const w = (await vs(m.driver.getKeys, m.relativeBase, f))
            .map((y) => m.mountpoint + qa(y))
            .filter((y) => !d.some((v) => y.startsWith(v)));
          p.push(...w),
            (d = [
              m.mountpoint,
              ...d.filter((y) => !y.startsWith(m.mountpoint)),
            ]);
        }
        return u
          ? p.filter((m) => m.startsWith(u) && !m.endsWith("$"))
          : p.filter((m) => !m.endsWith("$"));
      },
      async clear(u, f = {}) {
        (u = xv(u)),
          await Promise.all(
            r(u, !1).map(async (c) => {
              if (c.driver.clear) return vs(c.driver.clear, c.relativeBase, f);
              if (c.driver.removeItem) {
                const d = await c.driver.getKeys(c.relativeBase || "", f);
                return Promise.all(d.map((p) => c.driver.removeItem(p, f)));
              }
            })
          );
      },
      async dispose() {
        await Promise.all(Object.values(e.mounts).map((u) => UM(u)));
      },
      async watch(u) {
        return (
          await s(),
          e.watchListeners.push(u),
          async () => {
            (e.watchListeners = e.watchListeners.filter((f) => f !== u)),
              e.watchListeners.length === 0 && (await a());
          }
        );
      },
      async unwatch() {
        (e.watchListeners = []), await a();
      },
      mount(u, f) {
        if (((u = xv(u)), u && e.mounts[u]))
          throw new Error(`already mounted at ${u}`);
        return (
          u &&
            (e.mountpoints.push(u),
            e.mountpoints.sort((c, d) => d.length - c.length)),
          (e.mounts[u] = f),
          e.watching &&
            Promise.resolve($M(f, i, u))
              .then((c) => {
                e.unwatch[u] = c;
              })
              .catch(console.error),
          l
        );
      },
      async unmount(u, f = !0) {
        (u = xv(u)),
          !(!u || !e.mounts[u]) &&
            (e.watching &&
              u in e.unwatch &&
              (e.unwatch[u](), delete e.unwatch[u]),
            f && (await UM(e.mounts[u])),
            (e.mountpoints = e.mountpoints.filter((c) => c !== u)),
            delete e.mounts[u]);
      },
      getMount(u = "") {
        u = qa(u) + ":";
        const f = n(u);
        return { driver: f.driver, base: f.base };
      },
      getMounts(u = "", f = {}) {
        return (
          (u = qa(u)),
          r(u, f.parents).map((d) => ({ driver: d.driver, base: d.mountpoint }))
        );
      },
    };
  return l;
}
function $M(t, e, n) {
  return t.watch ? t.watch((r, i) => e(r, n + i)) : () => {};
}
async function UM(t) {
  typeof t.dispose == "function" && (await vs(t.dispose));
}
function Hh(t) {
  return new Promise((e, n) => {
    (t.oncomplete = t.onsuccess = () => e(t.result)),
      (t.onabort = t.onerror = () => n(t.error));
  });
}
function yW(t, e) {
  const n = indexedDB.open(t);
  n.onupgradeneeded = () => n.result.createObjectStore(e);
  const r = Hh(n);
  return (i, s) => r.then((a) => s(a.transaction(e, i).objectStore(e)));
}
let D8;
function Gy() {
  return D8 || (D8 = yW("keyval-store", "keyval")), D8;
}
function jM(t, e = Gy()) {
  return e("readonly", (n) => Hh(n.get(t)));
}
function gEe(t, e, n = Gy()) {
  return n("readwrite", (r) => (r.put(e, t), Hh(r.transaction)));
}
function yEe(t, e = Gy()) {
  return e("readwrite", (n) => (n.delete(t), Hh(n.transaction)));
}
function vEe(t = Gy()) {
  return t("readwrite", (e) => (e.clear(), Hh(e.transaction)));
}
function bEe(t, e) {
  return (
    (t.openCursor().onsuccess = function () {
      this.result && (e(this.result), this.result.continue());
    }),
    Hh(t.transaction)
  );
}
function wEe(t = Gy()) {
  return t("readonly", (e) => {
    if (e.getAllKeys) return Hh(e.getAllKeys());
    const n = [];
    return bEe(e, (r) => n.push(r.key)).then(() => n);
  });
}
const _Ee = (t) =>
    JSON.stringify(t, (e, n) =>
      typeof n == "bigint" ? n.toString() + "n" : n
    ),
  EEe = (t) => {
    const e =
        /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      n = t.replace(e, '$1"$2n"$3');
    return JSON.parse(n, (r, i) =>
      typeof i == "string" && i.match(/^\d+n$/)
        ? BigInt(i.substring(0, i.length - 1))
        : i
    );
  };
function Wy(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return EEe(t);
  } catch {
    return t;
  }
}
function kh(t) {
  return typeof t == "string" ? t : _Ee(t) || "";
}
const xEe = "idb-keyval";
var TEe = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "",
    n = (i) => e + i;
  let r;
  return (
    t.dbName && t.storeName && (r = yW(t.dbName, t.storeName)),
    {
      name: xEe,
      options: t,
      async hasItem(i) {
        return !(typeof (await jM(n(i), r)) > "u");
      },
      async getItem(i) {
        return (await jM(n(i), r)) ?? null;
      },
      setItem(i, s) {
        return gEe(n(i), s, r);
      },
      removeItem(i) {
        return yEe(n(i), r);
      },
      getKeys() {
        return wEe(r);
      },
      clear() {
        return vEe(r);
      },
    }
  );
};
const SEe = "WALLET_CONNECT_V2_INDEXED_DB",
  AEe = "keyvaluestorage";
let CEe = class {
  constructor() {
    this.indexedDb = mEe({ driver: TEe({ dbName: SEe, storeName: AEe }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(
      (e) => [e.key, e.value]
    );
  }
  async getItem(e) {
    const n = await this.indexedDb.getItem(e);
    if (n !== null) return n;
  }
  async setItem(e, n) {
    await this.indexedDb.setItem(e, kh(n));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var R8 =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {},
  vb = { exports: {} };
(function () {
  let t;
  function e() {}
  (t = e),
    (t.prototype.getItem = function (n) {
      return this.hasOwnProperty(n) ? String(this[n]) : null;
    }),
    (t.prototype.setItem = function (n, r) {
      this[n] = String(r);
    }),
    (t.prototype.removeItem = function (n) {
      delete this[n];
    }),
    (t.prototype.clear = function () {
      const n = this;
      Object.keys(n).forEach(function (r) {
        (n[r] = void 0), delete n[r];
      });
    }),
    (t.prototype.key = function (n) {
      return (n = n || 0), Object.keys(this)[n];
    }),
    t.prototype.__defineGetter__("length", function () {
      return Object.keys(this).length;
    }),
    typeof R8 < "u" && R8.localStorage
      ? (vb.exports = R8.localStorage)
      : typeof window < "u" && window.localStorage
      ? (vb.exports = window.localStorage)
      : (vb.exports = new e());
})();
function kEe(t) {
  var e;
  return [t[0], Wy((e = t[1]) != null ? e : "")];
}
class IEe {
  constructor() {
    this.localStorage = vb.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(kEe);
  }
  async getItem(e) {
    const n = this.localStorage.getItem(e);
    if (n !== null) return Wy(n);
  }
  async setItem(e, n) {
    this.localStorage.setItem(e, kh(n));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
}
const OEe = "wc_storage_version",
  HM = 1,
  PEe = async (t, e, n) => {
    const r = OEe,
      i = await e.getItem(r);
    if (i && i >= HM) {
      n(e);
      return;
    }
    const s = await t.getKeys();
    if (!s.length) {
      n(e);
      return;
    }
    const a = [];
    for (; s.length; ) {
      const o = s.shift();
      if (!o) continue;
      const l = o.toLowerCase();
      if (
        l.includes("wc@") ||
        l.includes("walletconnect") ||
        l.includes("wc_") ||
        l.includes("wallet_connect")
      ) {
        const u = await t.getItem(o);
        await e.setItem(o, u), a.push(o);
      }
    }
    await e.setItem(r, HM), n(e), NEe(t, a);
  },
  NEe = async (t, e) => {
    e.length &&
      e.forEach(async (n) => {
        await t.removeItem(n);
      });
  };
let DEe = class {
  constructor() {
    (this.initialized = !1),
      (this.setInitialized = (n) => {
        (this.storage = n), (this.initialized = !0);
      });
    const e = new IEe();
    this.storage = e;
    try {
      const n = new CEe();
      PEe(e, n, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, n) {
    return await this.initialize(), this.storage.setItem(e, n);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized ||
      (await new Promise((e) => {
        const n = setInterval(() => {
          this.initialized && (clearInterval(n), e());
        }, 20);
      }));
  }
};
var P1 = {},
  wm = {},
  M8 = {},
  _m = {};
let zh = class {};
const REe = Object.freeze(
    Object.defineProperty(
      { __proto__: null, IEvents: zh },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  MEe = w9(REe);
var zM;
function LEe() {
  if (zM) return _m;
  (zM = 1),
    Object.defineProperty(_m, "__esModule", { value: !0 }),
    (_m.IHeartBeat = void 0);
  const t = MEe;
  class e extends t.IEvents {
    constructor(r) {
      super();
    }
  }
  return (_m.IHeartBeat = e), _m;
}
var VM;
function vW() {
  return (
    VM ||
      ((VM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          oc.__exportStar(LEe(), t);
      })(M8)),
    M8
  );
}
var L8 = {},
  Fd = {},
  GM;
function BEe() {
  if (GM) return Fd;
  (GM = 1),
    Object.defineProperty(Fd, "__esModule", { value: !0 }),
    (Fd.HEARTBEAT_EVENTS = Fd.HEARTBEAT_INTERVAL = void 0);
  const t = Vt;
  return (
    (Fd.HEARTBEAT_INTERVAL = t.FIVE_SECONDS),
    (Fd.HEARTBEAT_EVENTS = { pulse: "heartbeat_pulse" }),
    Fd
  );
}
var WM;
function bW() {
  return (
    WM ||
      ((WM = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          oc.__exportStar(BEe(), t);
      })(L8)),
    L8
  );
}
var qM;
function FEe() {
  if (qM) return wm;
  (qM = 1),
    Object.defineProperty(wm, "__esModule", { value: !0 }),
    (wm.HeartBeat = void 0);
  const t = oc,
    e = Fo,
    n = Vt,
    r = vW(),
    i = bW();
  class s extends r.IHeartBeat {
    constructor(o) {
      super(o),
        (this.events = new e.EventEmitter()),
        (this.interval = i.HEARTBEAT_INTERVAL),
        (this.interval = o?.interval || i.HEARTBEAT_INTERVAL);
    }
    static init(o) {
      return t.__awaiter(this, void 0, void 0, function* () {
        const l = new s(o);
        return yield l.init(), l;
      });
    }
    init() {
      return t.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(o, l) {
      this.events.on(o, l);
    }
    once(o, l) {
      this.events.once(o, l);
    }
    off(o, l) {
      this.events.off(o, l);
    }
    removeListener(o, l) {
      this.events.removeListener(o, l);
    }
    initialize() {
      return t.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(
          () => this.pulse(),
          n.toMiliseconds(this.interval)
        );
      });
    }
    pulse() {
      this.events.emit(i.HEARTBEAT_EVENTS.pulse);
    }
  }
  return (wm.HeartBeat = s), wm;
}
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = oc;
  e.__exportStar(FEe(), t), e.__exportStar(vW(), t), e.__exportStar(bW(), t);
})(P1);
var Qn = {},
  B8,
  KM;
function $Ee() {
  if (KM) return B8;
  KM = 1;
  function t(n) {
    try {
      return JSON.stringify(n);
    } catch {
      return '"[Circular]"';
    }
  }
  B8 = e;
  function e(n, r, i) {
    var s = (i && i.stringify) || t,
      a = 1;
    if (typeof n == "object" && n !== null) {
      var o = r.length + a;
      if (o === 1) return n;
      var l = new Array(o);
      l[0] = s(n);
      for (var u = 1; u < o; u++) l[u] = s(r[u]);
      return l.join(" ");
    }
    if (typeof n != "string") return n;
    var f = r.length;
    if (f === 0) return n;
    for (
      var c = "", d = 1 - a, p = -1, m = (n && n.length) || 0, g = 0;
      g < m;

    ) {
      if (n.charCodeAt(g) === 37 && g + 1 < m) {
        switch (((p = p > -1 ? p : 0), n.charCodeAt(g + 1))) {
          case 100:
          case 102:
            if (d >= f || r[d] == null) break;
            p < g && (c += n.slice(p, g)),
              (c += Number(r[d])),
              (p = g + 2),
              g++;
            break;
          case 105:
            if (d >= f || r[d] == null) break;
            p < g && (c += n.slice(p, g)),
              (c += Math.floor(Number(r[d]))),
              (p = g + 2),
              g++;
            break;
          case 79:
          case 111:
          case 106:
            if (d >= f || r[d] === void 0) break;
            p < g && (c += n.slice(p, g));
            var w = typeof r[d];
            if (w === "string") {
              (c += "'" + r[d] + "'"), (p = g + 2), g++;
              break;
            }
            if (w === "function") {
              (c += r[d].name || "<anonymous>"), (p = g + 2), g++;
              break;
            }
            (c += s(r[d])), (p = g + 2), g++;
            break;
          case 115:
            if (d >= f) break;
            p < g && (c += n.slice(p, g)),
              (c += String(r[d])),
              (p = g + 2),
              g++;
            break;
          case 37:
            p < g && (c += n.slice(p, g)), (c += "%"), (p = g + 2), g++, d--;
            break;
        }
        ++d;
      }
      ++g;
    }
    return p === -1 ? n : (p < m && (c += n.slice(p)), c);
  }
  return B8;
}
var F8, XM;
function UEe() {
  if (XM) return F8;
  XM = 1;
  const t = $Ee();
  F8 = i;
  const e = D().console || {},
    n = {
      mapHttpRequest: m,
      mapHttpResponse: m,
      wrapRequestSerializer: g,
      wrapResponseSerializer: g,
      wrapErrorSerializer: g,
      req: m,
      res: m,
      err: d,
    };
  function r(P, x) {
    return Array.isArray(P)
      ? P.filter(function (A) {
          return A !== "!stdSerializers.err";
        })
      : P === !0
      ? Object.keys(x)
      : !1;
  }
  function i(P) {
    (P = P || {}), (P.browser = P.browser || {});
    const x = P.browser.transmit;
    if (x && typeof x.send != "function")
      throw Error("pino: transmit option must have a send function");
    const _ = P.browser.write || e;
    P.browser.write && (P.browser.asObject = !0);
    const A = P.serializers || {},
      N = r(P.browser.serialize, A);
    let M = P.browser.serialize;
    Array.isArray(P.browser.serialize) &&
      P.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
      (M = !1);
    const T = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof _ == "function" &&
      (_.error = _.fatal = _.warn = _.info = _.debug = _.trace = _),
      P.enabled === !1 && (P.level = "silent");
    const O = P.level || "info",
      I = Object.create(_);
    I.log || (I.log = w),
      Object.defineProperty(I, "levelVal", { get: L }),
      Object.defineProperty(I, "level", { get: U, set: $ });
    const k = {
      transmit: x,
      serialize: N,
      asObject: P.browser.asObject,
      levels: T,
      timestamp: p(P),
    };
    (I.levels = i.levels),
      (I.level = O),
      (I.setMaxListeners =
        I.getMaxListeners =
        I.emit =
        I.addListener =
        I.on =
        I.prependListener =
        I.once =
        I.prependOnceListener =
        I.removeListener =
        I.removeAllListeners =
        I.listeners =
        I.listenerCount =
        I.eventNames =
        I.write =
        I.flush =
          w),
      (I.serializers = A),
      (I._serialize = N),
      (I._stdErrSerialize = M),
      (I.child = B),
      x && (I._logEvent = c());
    function L() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function U() {
      return this._level;
    }
    function $(R) {
      if (R !== "silent" && !this.levels.values[R])
        throw Error("unknown level " + R);
      (this._level = R),
        s(k, I, "error", "log"),
        s(k, I, "fatal", "error"),
        s(k, I, "warn", "error"),
        s(k, I, "info", "log"),
        s(k, I, "debug", "log"),
        s(k, I, "trace", "log");
    }
    function B(R, V) {
      if (!R) throw new Error("missing bindings for child Pino");
      (V = V || {}), N && R.serializers && (V.serializers = R.serializers);
      const oe = V.serializers;
      if (N && oe) {
        var le = Object.assign({}, A, oe),
          fe = P.browser.serialize === !0 ? Object.keys(le) : N;
        delete R.serializers, l([R], fe, le, this._stdErrSerialize);
      }
      function z(se) {
        (this._childLevel = (se._childLevel | 0) + 1),
          (this.error = u(se, R, "error")),
          (this.fatal = u(se, R, "fatal")),
          (this.warn = u(se, R, "warn")),
          (this.info = u(se, R, "info")),
          (this.debug = u(se, R, "debug")),
          (this.trace = u(se, R, "trace")),
          le && ((this.serializers = le), (this._serialize = fe)),
          x && (this._logEvent = c([].concat(se._logEvent.bindings, R)));
      }
      return (z.prototype = this), new z(this);
    }
    return I;
  }
  (i.levels = {
    values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal",
    },
  }),
    (i.stdSerializers = n),
    (i.stdTimeFunctions = Object.assign(
      {},
      { nullTime: y, epochTime: v, unixTime: E, isoTime: S }
    ));
  function s(P, x, _, A) {
    const N = Object.getPrototypeOf(x);
    (x[_] =
      x.levelVal > x.levels.values[_] ? w : N[_] ? N[_] : e[_] || e[A] || w),
      a(P, x, _);
  }
  function a(P, x, _) {
    (!P.transmit && x[_] === w) ||
      (x[_] = (function (A) {
        return function () {
          const M = P.timestamp(),
            T = new Array(arguments.length),
            O =
              Object.getPrototypeOf && Object.getPrototypeOf(this) === e
                ? e
                : this;
          for (var I = 0; I < T.length; I++) T[I] = arguments[I];
          if (
            (P.serialize &&
              !P.asObject &&
              l(T, this._serialize, this.serializers, this._stdErrSerialize),
            P.asObject ? A.call(O, o(this, _, T, M)) : A.apply(O, T),
            P.transmit)
          ) {
            const k = P.transmit.level || x.level,
              L = i.levels.values[k],
              U = i.levels.values[_];
            if (U < L) return;
            f(
              this,
              {
                ts: M,
                methodLevel: _,
                methodValue: U,
                transmitLevel: k,
                transmitValue: i.levels.values[P.transmit.level || x.level],
                send: P.transmit.send,
                val: x.levelVal,
              },
              T
            );
          }
        };
      })(x[_]));
  }
  function o(P, x, _, A) {
    P._serialize && l(_, P._serialize, P.serializers, P._stdErrSerialize);
    const N = _.slice();
    let M = N[0];
    const T = {};
    A && (T.time = A), (T.level = i.levels.values[x]);
    let O = (P._childLevel | 0) + 1;
    if ((O < 1 && (O = 1), M !== null && typeof M == "object")) {
      for (; O-- && typeof N[0] == "object"; ) Object.assign(T, N.shift());
      M = N.length ? t(N.shift(), N) : void 0;
    } else typeof M == "string" && (M = t(N.shift(), N));
    return M !== void 0 && (T.msg = M), T;
  }
  function l(P, x, _, A) {
    for (const N in P)
      if (A && P[N] instanceof Error) P[N] = i.stdSerializers.err(P[N]);
      else if (typeof P[N] == "object" && !Array.isArray(P[N]))
        for (const M in P[N])
          x && x.indexOf(M) > -1 && M in _ && (P[N][M] = _[M](P[N][M]));
  }
  function u(P, x, _) {
    return function () {
      const A = new Array(1 + arguments.length);
      A[0] = x;
      for (var N = 1; N < A.length; N++) A[N] = arguments[N - 1];
      return P[_].apply(this, A);
    };
  }
  function f(P, x, _) {
    const A = x.send,
      N = x.ts,
      M = x.methodLevel,
      T = x.methodValue,
      O = x.val,
      I = P._logEvent.bindings;
    l(
      _,
      P._serialize || Object.keys(P.serializers),
      P.serializers,
      P._stdErrSerialize === void 0 ? !0 : P._stdErrSerialize
    ),
      (P._logEvent.ts = N),
      (P._logEvent.messages = _.filter(function (k) {
        return I.indexOf(k) === -1;
      })),
      (P._logEvent.level.label = M),
      (P._logEvent.level.value = T),
      A(M, P._logEvent, O),
      (P._logEvent = c(I));
  }
  function c(P) {
    return {
      ts: 0,
      messages: [],
      bindings: P || [],
      level: { label: "", value: 0 },
    };
  }
  function d(P) {
    const x = { type: P.constructor.name, msg: P.message, stack: P.stack };
    for (const _ in P) x[_] === void 0 && (x[_] = P[_]);
    return x;
  }
  function p(P) {
    return typeof P.timestamp == "function"
      ? P.timestamp
      : P.timestamp === !1
      ? y
      : v;
  }
  function m() {
    return {};
  }
  function g(P) {
    return P;
  }
  function w() {}
  function y() {
    return !1;
  }
  function v() {
    return Date.now();
  }
  function E() {
    return Math.round(Date.now() / 1e3);
  }
  function S() {
    return new Date(Date.now()).toISOString();
  }
  function D() {
    function P(x) {
      return typeof x < "u" && x;
    }
    try {
      return (
        typeof globalThis < "u" ||
          Object.defineProperty(Object.prototype, "globalThis", {
            get: function () {
              return (
                delete Object.prototype.globalThis, (this.globalThis = this)
              );
            },
            configurable: !0,
          }),
        globalThis
      );
    } catch {
      return P(self) || P(window) || P(this) || {};
    }
  }
  return F8;
}
var $d = {},
  ZM;
function wW() {
  return (
    ZM ||
      ((ZM = 1),
      Object.defineProperty($d, "__esModule", { value: !0 }),
      ($d.PINO_CUSTOM_CONTEXT_KEY = $d.PINO_LOGGER_DEFAULTS = void 0),
      ($d.PINO_LOGGER_DEFAULTS = { level: "info" }),
      ($d.PINO_CUSTOM_CONTEXT_KEY = "custom_context")),
    $d
  );
}
var ha = {},
  YM;
function jEe() {
  if (YM) return ha;
  (YM = 1),
    Object.defineProperty(ha, "__esModule", { value: !0 }),
    (ha.generateChildLogger =
      ha.formatChildLoggerContext =
      ha.getLoggerContext =
      ha.setBrowserLoggerContext =
      ha.getBrowserLoggerContext =
      ha.getDefaultLoggerOptions =
        void 0);
  const t = wW();
  function e(o) {
    return Object.assign(Object.assign({}, o), {
      level: o?.level || t.PINO_LOGGER_DEFAULTS.level,
    });
  }
  ha.getDefaultLoggerOptions = e;
  function n(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    return o[l] || "";
  }
  ha.getBrowserLoggerContext = n;
  function r(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    return (o[u] = l), o;
  }
  ha.setBrowserLoggerContext = r;
  function i(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    let u = "";
    return (
      typeof o.bindings > "u"
        ? (u = n(o, l))
        : (u = o.bindings().context || ""),
      u
    );
  }
  ha.getLoggerContext = i;
  function s(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const f = i(o, u);
    return f.trim() ? `${f}/${l}` : l;
  }
  ha.formatChildLoggerContext = s;
  function a(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const f = s(o, l, u),
      c = o.child({ context: f });
    return r(c, f, u);
  }
  return (ha.generateChildLogger = a), ha;
}
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), (t.pino = void 0);
  const e = oc,
    n = e.__importDefault(UEe());
  Object.defineProperty(t, "pino", {
    enumerable: !0,
    get: function () {
      return n.default;
    },
  }),
    e.__exportStar(wW(), t),
    e.__exportStar(jEe(), t);
})(Qn);
let HEe = class extends zh {
    constructor(e) {
      super(), (this.opts = e), (this.protocol = "wc"), (this.version = 2);
    }
  },
  zEe = class extends zh {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n), (this.records = new Map());
    }
  },
  VEe = class {
    constructor(e, n) {
      (this.logger = e), (this.core = n);
    }
  },
  GEe = class extends zh {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n);
    }
  },
  WEe = class extends zh {
    constructor(e) {
      super();
    }
  },
  qEe = class {
    constructor(e, n, r, i) {
      (this.core = e), (this.logger = n), (this.name = r);
    }
  },
  KEe = class extends zh {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n);
    }
  },
  XEe = class extends zh {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n);
    }
  },
  ZEe = class {
    constructor(e, n) {
      (this.projectId = e), (this.logger = n);
    }
  },
  YEe = class {
    constructor(e) {
      (this.opts = e), (this.protocol = "wc"), (this.version = 2);
    }
  },
  QEe = class {
    constructor(e) {
      this.client = e;
    }
  };
var lS = {},
  _W = {};
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = _n,
    n = $o;
  (t.DIGEST_LENGTH = 64), (t.BLOCK_SIZE = 128);
  var r = (function () {
    function o() {
      (this.digestLength = t.DIGEST_LENGTH),
        (this.blockSize = t.BLOCK_SIZE),
        (this._stateHi = new Int32Array(8)),
        (this._stateLo = new Int32Array(8)),
        (this._tempHi = new Int32Array(16)),
        (this._tempLo = new Int32Array(16)),
        (this._buffer = new Uint8Array(256)),
        (this._bufferLength = 0),
        (this._bytesHashed = 0),
        (this._finished = !1),
        this.reset();
    }
    return (
      (o.prototype._initState = function () {
        (this._stateHi[0] = 1779033703),
          (this._stateHi[1] = 3144134277),
          (this._stateHi[2] = 1013904242),
          (this._stateHi[3] = 2773480762),
          (this._stateHi[4] = 1359893119),
          (this._stateHi[5] = 2600822924),
          (this._stateHi[6] = 528734635),
          (this._stateHi[7] = 1541459225),
          (this._stateLo[0] = 4089235720),
          (this._stateLo[1] = 2227873595),
          (this._stateLo[2] = 4271175723),
          (this._stateLo[3] = 1595750129),
          (this._stateLo[4] = 2917565137),
          (this._stateLo[5] = 725511199),
          (this._stateLo[6] = 4215389547),
          (this._stateLo[7] = 327033209);
      }),
      (o.prototype.reset = function () {
        return (
          this._initState(),
          (this._bufferLength = 0),
          (this._bytesHashed = 0),
          (this._finished = !1),
          this
        );
      }),
      (o.prototype.clean = function () {
        n.wipe(this._buffer),
          n.wipe(this._tempHi),
          n.wipe(this._tempLo),
          this.reset();
      }),
      (o.prototype.update = function (l, u) {
        if ((u === void 0 && (u = l.length), this._finished))
          throw new Error("SHA512: can't update because hash was finished.");
        var f = 0;
        if (((this._bytesHashed += u), this._bufferLength > 0)) {
          for (; this._bufferLength < t.BLOCK_SIZE && u > 0; )
            (this._buffer[this._bufferLength++] = l[f++]), u--;
          this._bufferLength === this.blockSize &&
            (s(
              this._tempHi,
              this._tempLo,
              this._stateHi,
              this._stateLo,
              this._buffer,
              0,
              this.blockSize
            ),
            (this._bufferLength = 0));
        }
        for (
          u >= this.blockSize &&
          ((f = s(
            this._tempHi,
            this._tempLo,
            this._stateHi,
            this._stateLo,
            l,
            f,
            u
          )),
          (u %= this.blockSize));
          u > 0;

        )
          (this._buffer[this._bufferLength++] = l[f++]), u--;
        return this;
      }),
      (o.prototype.finish = function (l) {
        if (!this._finished) {
          var u = this._bytesHashed,
            f = this._bufferLength,
            c = (u / 536870912) | 0,
            d = u << 3,
            p = u % 128 < 112 ? 128 : 256;
          this._buffer[f] = 128;
          for (var m = f + 1; m < p - 8; m++) this._buffer[m] = 0;
          e.writeUint32BE(c, this._buffer, p - 8),
            e.writeUint32BE(d, this._buffer, p - 4),
            s(
              this._tempHi,
              this._tempLo,
              this._stateHi,
              this._stateLo,
              this._buffer,
              0,
              p
            ),
            (this._finished = !0);
        }
        for (var m = 0; m < this.digestLength / 8; m++)
          e.writeUint32BE(this._stateHi[m], l, m * 8),
            e.writeUint32BE(this._stateLo[m], l, m * 8 + 4);
        return this;
      }),
      (o.prototype.digest = function () {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }),
      (o.prototype.saveState = function () {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer:
            this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed,
        };
      }),
      (o.prototype.restoreState = function (l) {
        return (
          this._stateHi.set(l.stateHi),
          this._stateLo.set(l.stateLo),
          (this._bufferLength = l.bufferLength),
          l.buffer && this._buffer.set(l.buffer),
          (this._bytesHashed = l.bytesHashed),
          (this._finished = !1),
          this
        );
      }),
      (o.prototype.cleanSavedState = function (l) {
        n.wipe(l.stateHi),
          n.wipe(l.stateLo),
          l.buffer && n.wipe(l.buffer),
          (l.bufferLength = 0),
          (l.bytesHashed = 0);
      }),
      o
    );
  })();
  t.SHA512 = r;
  var i = new Int32Array([
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ]);
  function s(o, l, u, f, c, d, p) {
    for (
      var m = u[0],
        g = u[1],
        w = u[2],
        y = u[3],
        v = u[4],
        E = u[5],
        S = u[6],
        D = u[7],
        P = f[0],
        x = f[1],
        _ = f[2],
        A = f[3],
        N = f[4],
        M = f[5],
        T = f[6],
        O = f[7],
        I,
        k,
        L,
        U,
        $,
        B,
        R,
        V;
      p >= 128;

    ) {
      for (var oe = 0; oe < 16; oe++) {
        var le = 8 * oe + d;
        (o[oe] = e.readUint32BE(c, le)), (l[oe] = e.readUint32BE(c, le + 4));
      }
      for (var oe = 0; oe < 80; oe++) {
        var fe = m,
          z = g,
          se = w,
          Y = y,
          Q = v,
          ee = E,
          F = S,
          te = D,
          he = P,
          Te = x,
          Ce = _,
          ke = A,
          at = N,
          Rt = M,
          Ft = T,
          Nt = O;
        if (
          ((I = D),
          (k = O),
          ($ = k & 65535),
          (B = k >>> 16),
          (R = I & 65535),
          (V = I >>> 16),
          (I =
            ((v >>> 14) | (N << (32 - 14))) ^
            ((v >>> 18) | (N << (32 - 18))) ^
            ((N >>> (41 - 32)) | (v << (32 - (41 - 32))))),
          (k =
            ((N >>> 14) | (v << (32 - 14))) ^
            ((N >>> 18) | (v << (32 - 18))) ^
            ((v >>> (41 - 32)) | (N << (32 - (41 - 32))))),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (I = (v & E) ^ (~v & S)),
          (k = (N & M) ^ (~N & T)),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (I = i[oe * 2]),
          (k = i[oe * 2 + 1]),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (I = o[oe % 16]),
          (k = l[oe % 16]),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (B += $ >>> 16),
          (R += B >>> 16),
          (V += R >>> 16),
          (L = (R & 65535) | (V << 16)),
          (U = ($ & 65535) | (B << 16)),
          (I = L),
          (k = U),
          ($ = k & 65535),
          (B = k >>> 16),
          (R = I & 65535),
          (V = I >>> 16),
          (I =
            ((m >>> 28) | (P << (32 - 28))) ^
            ((P >>> (34 - 32)) | (m << (32 - (34 - 32)))) ^
            ((P >>> (39 - 32)) | (m << (32 - (39 - 32))))),
          (k =
            ((P >>> 28) | (m << (32 - 28))) ^
            ((m >>> (34 - 32)) | (P << (32 - (34 - 32)))) ^
            ((m >>> (39 - 32)) | (P << (32 - (39 - 32))))),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (I = (m & g) ^ (m & w) ^ (g & w)),
          (k = (P & x) ^ (P & _) ^ (x & _)),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (B += $ >>> 16),
          (R += B >>> 16),
          (V += R >>> 16),
          (te = (R & 65535) | (V << 16)),
          (Nt = ($ & 65535) | (B << 16)),
          (I = Y),
          (k = ke),
          ($ = k & 65535),
          (B = k >>> 16),
          (R = I & 65535),
          (V = I >>> 16),
          (I = L),
          (k = U),
          ($ += k & 65535),
          (B += k >>> 16),
          (R += I & 65535),
          (V += I >>> 16),
          (B += $ >>> 16),
          (R += B >>> 16),
          (V += R >>> 16),
          (Y = (R & 65535) | (V << 16)),
          (ke = ($ & 65535) | (B << 16)),
          (g = fe),
          (w = z),
          (y = se),
          (v = Y),
          (E = Q),
          (S = ee),
          (D = F),
          (m = te),
          (x = he),
          (_ = Te),
          (A = Ce),
          (N = ke),
          (M = at),
          (T = Rt),
          (O = Ft),
          (P = Nt),
          oe % 16 === 15)
        )
          for (var le = 0; le < 16; le++)
            (I = o[le]),
              (k = l[le]),
              ($ = k & 65535),
              (B = k >>> 16),
              (R = I & 65535),
              (V = I >>> 16),
              (I = o[(le + 9) % 16]),
              (k = l[(le + 9) % 16]),
              ($ += k & 65535),
              (B += k >>> 16),
              (R += I & 65535),
              (V += I >>> 16),
              (L = o[(le + 1) % 16]),
              (U = l[(le + 1) % 16]),
              (I =
                ((L >>> 1) | (U << (32 - 1))) ^
                ((L >>> 8) | (U << (32 - 8))) ^
                (L >>> 7)),
              (k =
                ((U >>> 1) | (L << (32 - 1))) ^
                ((U >>> 8) | (L << (32 - 8))) ^
                ((U >>> 7) | (L << (32 - 7)))),
              ($ += k & 65535),
              (B += k >>> 16),
              (R += I & 65535),
              (V += I >>> 16),
              (L = o[(le + 14) % 16]),
              (U = l[(le + 14) % 16]),
              (I =
                ((L >>> 19) | (U << (32 - 19))) ^
                ((U >>> (61 - 32)) | (L << (32 - (61 - 32)))) ^
                (L >>> 6)),
              (k =
                ((U >>> 19) | (L << (32 - 19))) ^
                ((L >>> (61 - 32)) | (U << (32 - (61 - 32)))) ^
                ((U >>> 6) | (L << (32 - 6)))),
              ($ += k & 65535),
              (B += k >>> 16),
              (R += I & 65535),
              (V += I >>> 16),
              (B += $ >>> 16),
              (R += B >>> 16),
              (V += R >>> 16),
              (o[le] = (R & 65535) | (V << 16)),
              (l[le] = ($ & 65535) | (B << 16));
      }
      (I = m),
        (k = P),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[0]),
        (k = f[0]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[0] = m = (R & 65535) | (V << 16)),
        (f[0] = P = ($ & 65535) | (B << 16)),
        (I = g),
        (k = x),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[1]),
        (k = f[1]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[1] = g = (R & 65535) | (V << 16)),
        (f[1] = x = ($ & 65535) | (B << 16)),
        (I = w),
        (k = _),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[2]),
        (k = f[2]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[2] = w = (R & 65535) | (V << 16)),
        (f[2] = _ = ($ & 65535) | (B << 16)),
        (I = y),
        (k = A),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[3]),
        (k = f[3]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[3] = y = (R & 65535) | (V << 16)),
        (f[3] = A = ($ & 65535) | (B << 16)),
        (I = v),
        (k = N),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[4]),
        (k = f[4]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[4] = v = (R & 65535) | (V << 16)),
        (f[4] = N = ($ & 65535) | (B << 16)),
        (I = E),
        (k = M),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[5]),
        (k = f[5]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[5] = E = (R & 65535) | (V << 16)),
        (f[5] = M = ($ & 65535) | (B << 16)),
        (I = S),
        (k = T),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[6]),
        (k = f[6]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[6] = S = (R & 65535) | (V << 16)),
        (f[6] = T = ($ & 65535) | (B << 16)),
        (I = D),
        (k = O),
        ($ = k & 65535),
        (B = k >>> 16),
        (R = I & 65535),
        (V = I >>> 16),
        (I = u[7]),
        (k = f[7]),
        ($ += k & 65535),
        (B += k >>> 16),
        (R += I & 65535),
        (V += I >>> 16),
        (B += $ >>> 16),
        (R += B >>> 16),
        (V += R >>> 16),
        (u[7] = D = (R & 65535) | (V << 16)),
        (f[7] = O = ($ & 65535) | (B << 16)),
        (d += 128),
        (p -= 128);
    }
    return d;
  }
  function a(o) {
    var l = new r();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(_W);
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.convertSecretKeyToX25519 =
      t.convertPublicKeyToX25519 =
      t.verify =
      t.sign =
      t.extractPublicKeyFromSecretKey =
      t.generateKeyPair =
      t.generateKeyPairFromSeed =
      t.SEED_LENGTH =
      t.SECRET_KEY_LENGTH =
      t.PUBLIC_KEY_LENGTH =
      t.SIGNATURE_LENGTH =
        void 0);
  const e = A1,
    n = _W,
    r = $o;
  (t.SIGNATURE_LENGTH = 64),
    (t.PUBLIC_KEY_LENGTH = 32),
    (t.SECRET_KEY_LENGTH = 64),
    (t.SEED_LENGTH = 32);
  function i(Y) {
    const Q = new Float64Array(16);
    if (Y) for (let ee = 0; ee < Y.length; ee++) Q[ee] = Y[ee];
    return Q;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const a = i(),
    o = i([1]),
    l = i([
      30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505,
      36039, 65139, 11119, 27886, 20995,
    ]),
    u = i([
      61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010,
      6542, 64743, 22239, 55772, 9222,
    ]),
    f = i([
      54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982,
      57905, 49316, 21502, 52590, 14035, 8553,
    ]),
    c = i([
      26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
      26214, 26214, 26214, 26214, 26214, 26214,
    ]),
    d = i([
      41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153,
      11085, 57099, 20417, 9344, 11139,
    ]);
  function p(Y, Q) {
    for (let ee = 0; ee < 16; ee++) Y[ee] = Q[ee] | 0;
  }
  function m(Y) {
    let Q = 1;
    for (let ee = 0; ee < 16; ee++) {
      let F = Y[ee] + Q + 65535;
      (Q = Math.floor(F / 65536)), (Y[ee] = F - Q * 65536);
    }
    Y[0] += Q - 1 + 37 * (Q - 1);
  }
  function g(Y, Q, ee) {
    const F = ~(ee - 1);
    for (let te = 0; te < 16; te++) {
      const he = F & (Y[te] ^ Q[te]);
      (Y[te] ^= he), (Q[te] ^= he);
    }
  }
  function w(Y, Q) {
    const ee = i(),
      F = i();
    for (let te = 0; te < 16; te++) F[te] = Q[te];
    m(F), m(F), m(F);
    for (let te = 0; te < 2; te++) {
      ee[0] = F[0] - 65517;
      for (let Te = 1; Te < 15; Te++)
        (ee[Te] = F[Te] - 65535 - ((ee[Te - 1] >> 16) & 1)),
          (ee[Te - 1] &= 65535);
      ee[15] = F[15] - 32767 - ((ee[14] >> 16) & 1);
      const he = (ee[15] >> 16) & 1;
      (ee[14] &= 65535), g(F, ee, 1 - he);
    }
    for (let te = 0; te < 16; te++)
      (Y[2 * te] = F[te] & 255), (Y[2 * te + 1] = F[te] >> 8);
  }
  function y(Y, Q) {
    let ee = 0;
    for (let F = 0; F < 32; F++) ee |= Y[F] ^ Q[F];
    return (1 & ((ee - 1) >>> 8)) - 1;
  }
  function v(Y, Q) {
    const ee = new Uint8Array(32),
      F = new Uint8Array(32);
    return w(ee, Y), w(F, Q), y(ee, F);
  }
  function E(Y) {
    const Q = new Uint8Array(32);
    return w(Q, Y), Q[0] & 1;
  }
  function S(Y, Q) {
    for (let ee = 0; ee < 16; ee++) Y[ee] = Q[2 * ee] + (Q[2 * ee + 1] << 8);
    Y[15] &= 32767;
  }
  function D(Y, Q, ee) {
    for (let F = 0; F < 16; F++) Y[F] = Q[F] + ee[F];
  }
  function P(Y, Q, ee) {
    for (let F = 0; F < 16; F++) Y[F] = Q[F] - ee[F];
  }
  function x(Y, Q, ee) {
    let F,
      te,
      he = 0,
      Te = 0,
      Ce = 0,
      ke = 0,
      at = 0,
      Rt = 0,
      Ft = 0,
      Nt = 0,
      Ot = 0,
      et = 0,
      st = 0,
      vt = 0,
      Re = 0,
      me = 0,
      $e = 0,
      De = 0,
      je = 0,
      lt = 0,
      Ke = 0,
      tt = 0,
      jt = 0,
      ct = 0,
      rt = 0,
      Dt = 0,
      Ht = 0,
      Yt = 0,
      sr = 0,
      Bt = 0,
      en = 0,
      Tr = 0,
      on = 0,
      Pt = ee[0],
      fn = ee[1],
      Wt = ee[2],
      qt = ee[3],
      Ye = ee[4],
      xe = ee[5],
      nt = ee[6],
      gt = ee[7],
      ht = ee[8],
      wt = ee[9],
      rn = ee[10],
      ot = ee[11],
      pt = ee[12],
      zt = ee[13],
      Zt = ee[14],
      $t = ee[15];
    (F = Q[0]),
      (he += F * Pt),
      (Te += F * fn),
      (Ce += F * Wt),
      (ke += F * qt),
      (at += F * Ye),
      (Rt += F * xe),
      (Ft += F * nt),
      (Nt += F * gt),
      (Ot += F * ht),
      (et += F * wt),
      (st += F * rn),
      (vt += F * ot),
      (Re += F * pt),
      (me += F * zt),
      ($e += F * Zt),
      (De += F * $t),
      (F = Q[1]),
      (Te += F * Pt),
      (Ce += F * fn),
      (ke += F * Wt),
      (at += F * qt),
      (Rt += F * Ye),
      (Ft += F * xe),
      (Nt += F * nt),
      (Ot += F * gt),
      (et += F * ht),
      (st += F * wt),
      (vt += F * rn),
      (Re += F * ot),
      (me += F * pt),
      ($e += F * zt),
      (De += F * Zt),
      (je += F * $t),
      (F = Q[2]),
      (Ce += F * Pt),
      (ke += F * fn),
      (at += F * Wt),
      (Rt += F * qt),
      (Ft += F * Ye),
      (Nt += F * xe),
      (Ot += F * nt),
      (et += F * gt),
      (st += F * ht),
      (vt += F * wt),
      (Re += F * rn),
      (me += F * ot),
      ($e += F * pt),
      (De += F * zt),
      (je += F * Zt),
      (lt += F * $t),
      (F = Q[3]),
      (ke += F * Pt),
      (at += F * fn),
      (Rt += F * Wt),
      (Ft += F * qt),
      (Nt += F * Ye),
      (Ot += F * xe),
      (et += F * nt),
      (st += F * gt),
      (vt += F * ht),
      (Re += F * wt),
      (me += F * rn),
      ($e += F * ot),
      (De += F * pt),
      (je += F * zt),
      (lt += F * Zt),
      (Ke += F * $t),
      (F = Q[4]),
      (at += F * Pt),
      (Rt += F * fn),
      (Ft += F * Wt),
      (Nt += F * qt),
      (Ot += F * Ye),
      (et += F * xe),
      (st += F * nt),
      (vt += F * gt),
      (Re += F * ht),
      (me += F * wt),
      ($e += F * rn),
      (De += F * ot),
      (je += F * pt),
      (lt += F * zt),
      (Ke += F * Zt),
      (tt += F * $t),
      (F = Q[5]),
      (Rt += F * Pt),
      (Ft += F * fn),
      (Nt += F * Wt),
      (Ot += F * qt),
      (et += F * Ye),
      (st += F * xe),
      (vt += F * nt),
      (Re += F * gt),
      (me += F * ht),
      ($e += F * wt),
      (De += F * rn),
      (je += F * ot),
      (lt += F * pt),
      (Ke += F * zt),
      (tt += F * Zt),
      (jt += F * $t),
      (F = Q[6]),
      (Ft += F * Pt),
      (Nt += F * fn),
      (Ot += F * Wt),
      (et += F * qt),
      (st += F * Ye),
      (vt += F * xe),
      (Re += F * nt),
      (me += F * gt),
      ($e += F * ht),
      (De += F * wt),
      (je += F * rn),
      (lt += F * ot),
      (Ke += F * pt),
      (tt += F * zt),
      (jt += F * Zt),
      (ct += F * $t),
      (F = Q[7]),
      (Nt += F * Pt),
      (Ot += F * fn),
      (et += F * Wt),
      (st += F * qt),
      (vt += F * Ye),
      (Re += F * xe),
      (me += F * nt),
      ($e += F * gt),
      (De += F * ht),
      (je += F * wt),
      (lt += F * rn),
      (Ke += F * ot),
      (tt += F * pt),
      (jt += F * zt),
      (ct += F * Zt),
      (rt += F * $t),
      (F = Q[8]),
      (Ot += F * Pt),
      (et += F * fn),
      (st += F * Wt),
      (vt += F * qt),
      (Re += F * Ye),
      (me += F * xe),
      ($e += F * nt),
      (De += F * gt),
      (je += F * ht),
      (lt += F * wt),
      (Ke += F * rn),
      (tt += F * ot),
      (jt += F * pt),
      (ct += F * zt),
      (rt += F * Zt),
      (Dt += F * $t),
      (F = Q[9]),
      (et += F * Pt),
      (st += F * fn),
      (vt += F * Wt),
      (Re += F * qt),
      (me += F * Ye),
      ($e += F * xe),
      (De += F * nt),
      (je += F * gt),
      (lt += F * ht),
      (Ke += F * wt),
      (tt += F * rn),
      (jt += F * ot),
      (ct += F * pt),
      (rt += F * zt),
      (Dt += F * Zt),
      (Ht += F * $t),
      (F = Q[10]),
      (st += F * Pt),
      (vt += F * fn),
      (Re += F * Wt),
      (me += F * qt),
      ($e += F * Ye),
      (De += F * xe),
      (je += F * nt),
      (lt += F * gt),
      (Ke += F * ht),
      (tt += F * wt),
      (jt += F * rn),
      (ct += F * ot),
      (rt += F * pt),
      (Dt += F * zt),
      (Ht += F * Zt),
      (Yt += F * $t),
      (F = Q[11]),
      (vt += F * Pt),
      (Re += F * fn),
      (me += F * Wt),
      ($e += F * qt),
      (De += F * Ye),
      (je += F * xe),
      (lt += F * nt),
      (Ke += F * gt),
      (tt += F * ht),
      (jt += F * wt),
      (ct += F * rn),
      (rt += F * ot),
      (Dt += F * pt),
      (Ht += F * zt),
      (Yt += F * Zt),
      (sr += F * $t),
      (F = Q[12]),
      (Re += F * Pt),
      (me += F * fn),
      ($e += F * Wt),
      (De += F * qt),
      (je += F * Ye),
      (lt += F * xe),
      (Ke += F * nt),
      (tt += F * gt),
      (jt += F * ht),
      (ct += F * wt),
      (rt += F * rn),
      (Dt += F * ot),
      (Ht += F * pt),
      (Yt += F * zt),
      (sr += F * Zt),
      (Bt += F * $t),
      (F = Q[13]),
      (me += F * Pt),
      ($e += F * fn),
      (De += F * Wt),
      (je += F * qt),
      (lt += F * Ye),
      (Ke += F * xe),
      (tt += F * nt),
      (jt += F * gt),
      (ct += F * ht),
      (rt += F * wt),
      (Dt += F * rn),
      (Ht += F * ot),
      (Yt += F * pt),
      (sr += F * zt),
      (Bt += F * Zt),
      (en += F * $t),
      (F = Q[14]),
      ($e += F * Pt),
      (De += F * fn),
      (je += F * Wt),
      (lt += F * qt),
      (Ke += F * Ye),
      (tt += F * xe),
      (jt += F * nt),
      (ct += F * gt),
      (rt += F * ht),
      (Dt += F * wt),
      (Ht += F * rn),
      (Yt += F * ot),
      (sr += F * pt),
      (Bt += F * zt),
      (en += F * Zt),
      (Tr += F * $t),
      (F = Q[15]),
      (De += F * Pt),
      (je += F * fn),
      (lt += F * Wt),
      (Ke += F * qt),
      (tt += F * Ye),
      (jt += F * xe),
      (ct += F * nt),
      (rt += F * gt),
      (Dt += F * ht),
      (Ht += F * wt),
      (Yt += F * rn),
      (sr += F * ot),
      (Bt += F * pt),
      (en += F * zt),
      (Tr += F * Zt),
      (on += F * $t),
      (he += 38 * je),
      (Te += 38 * lt),
      (Ce += 38 * Ke),
      (ke += 38 * tt),
      (at += 38 * jt),
      (Rt += 38 * ct),
      (Ft += 38 * rt),
      (Nt += 38 * Dt),
      (Ot += 38 * Ht),
      (et += 38 * Yt),
      (st += 38 * sr),
      (vt += 38 * Bt),
      (Re += 38 * en),
      (me += 38 * Tr),
      ($e += 38 * on),
      (te = 1),
      (F = he + te + 65535),
      (te = Math.floor(F / 65536)),
      (he = F - te * 65536),
      (F = Te + te + 65535),
      (te = Math.floor(F / 65536)),
      (Te = F - te * 65536),
      (F = Ce + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ce = F - te * 65536),
      (F = ke + te + 65535),
      (te = Math.floor(F / 65536)),
      (ke = F - te * 65536),
      (F = at + te + 65535),
      (te = Math.floor(F / 65536)),
      (at = F - te * 65536),
      (F = Rt + te + 65535),
      (te = Math.floor(F / 65536)),
      (Rt = F - te * 65536),
      (F = Ft + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ft = F - te * 65536),
      (F = Nt + te + 65535),
      (te = Math.floor(F / 65536)),
      (Nt = F - te * 65536),
      (F = Ot + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ot = F - te * 65536),
      (F = et + te + 65535),
      (te = Math.floor(F / 65536)),
      (et = F - te * 65536),
      (F = st + te + 65535),
      (te = Math.floor(F / 65536)),
      (st = F - te * 65536),
      (F = vt + te + 65535),
      (te = Math.floor(F / 65536)),
      (vt = F - te * 65536),
      (F = Re + te + 65535),
      (te = Math.floor(F / 65536)),
      (Re = F - te * 65536),
      (F = me + te + 65535),
      (te = Math.floor(F / 65536)),
      (me = F - te * 65536),
      (F = $e + te + 65535),
      (te = Math.floor(F / 65536)),
      ($e = F - te * 65536),
      (F = De + te + 65535),
      (te = Math.floor(F / 65536)),
      (De = F - te * 65536),
      (he += te - 1 + 37 * (te - 1)),
      (te = 1),
      (F = he + te + 65535),
      (te = Math.floor(F / 65536)),
      (he = F - te * 65536),
      (F = Te + te + 65535),
      (te = Math.floor(F / 65536)),
      (Te = F - te * 65536),
      (F = Ce + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ce = F - te * 65536),
      (F = ke + te + 65535),
      (te = Math.floor(F / 65536)),
      (ke = F - te * 65536),
      (F = at + te + 65535),
      (te = Math.floor(F / 65536)),
      (at = F - te * 65536),
      (F = Rt + te + 65535),
      (te = Math.floor(F / 65536)),
      (Rt = F - te * 65536),
      (F = Ft + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ft = F - te * 65536),
      (F = Nt + te + 65535),
      (te = Math.floor(F / 65536)),
      (Nt = F - te * 65536),
      (F = Ot + te + 65535),
      (te = Math.floor(F / 65536)),
      (Ot = F - te * 65536),
      (F = et + te + 65535),
      (te = Math.floor(F / 65536)),
      (et = F - te * 65536),
      (F = st + te + 65535),
      (te = Math.floor(F / 65536)),
      (st = F - te * 65536),
      (F = vt + te + 65535),
      (te = Math.floor(F / 65536)),
      (vt = F - te * 65536),
      (F = Re + te + 65535),
      (te = Math.floor(F / 65536)),
      (Re = F - te * 65536),
      (F = me + te + 65535),
      (te = Math.floor(F / 65536)),
      (me = F - te * 65536),
      (F = $e + te + 65535),
      (te = Math.floor(F / 65536)),
      ($e = F - te * 65536),
      (F = De + te + 65535),
      (te = Math.floor(F / 65536)),
      (De = F - te * 65536),
      (he += te - 1 + 37 * (te - 1)),
      (Y[0] = he),
      (Y[1] = Te),
      (Y[2] = Ce),
      (Y[3] = ke),
      (Y[4] = at),
      (Y[5] = Rt),
      (Y[6] = Ft),
      (Y[7] = Nt),
      (Y[8] = Ot),
      (Y[9] = et),
      (Y[10] = st),
      (Y[11] = vt),
      (Y[12] = Re),
      (Y[13] = me),
      (Y[14] = $e),
      (Y[15] = De);
  }
  function _(Y, Q) {
    x(Y, Q, Q);
  }
  function A(Y, Q) {
    const ee = i();
    let F;
    for (F = 0; F < 16; F++) ee[F] = Q[F];
    for (F = 253; F >= 0; F--) _(ee, ee), F !== 2 && F !== 4 && x(ee, ee, Q);
    for (F = 0; F < 16; F++) Y[F] = ee[F];
  }
  function N(Y, Q) {
    const ee = i();
    let F;
    for (F = 0; F < 16; F++) ee[F] = Q[F];
    for (F = 250; F >= 0; F--) _(ee, ee), F !== 1 && x(ee, ee, Q);
    for (F = 0; F < 16; F++) Y[F] = ee[F];
  }
  function M(Y, Q) {
    const ee = i(),
      F = i(),
      te = i(),
      he = i(),
      Te = i(),
      Ce = i(),
      ke = i(),
      at = i(),
      Rt = i();
    P(ee, Y[1], Y[0]),
      P(Rt, Q[1], Q[0]),
      x(ee, ee, Rt),
      D(F, Y[0], Y[1]),
      D(Rt, Q[0], Q[1]),
      x(F, F, Rt),
      x(te, Y[3], Q[3]),
      x(te, te, u),
      x(he, Y[2], Q[2]),
      D(he, he, he),
      P(Te, F, ee),
      P(Ce, he, te),
      D(ke, he, te),
      D(at, F, ee),
      x(Y[0], Te, Ce),
      x(Y[1], at, ke),
      x(Y[2], ke, Ce),
      x(Y[3], Te, at);
  }
  function T(Y, Q, ee) {
    for (let F = 0; F < 4; F++) g(Y[F], Q[F], ee);
  }
  function O(Y, Q) {
    const ee = i(),
      F = i(),
      te = i();
    A(te, Q[2]),
      x(ee, Q[0], te),
      x(F, Q[1], te),
      w(Y, F),
      (Y[31] ^= E(ee) << 7);
  }
  function I(Y, Q, ee) {
    p(Y[0], a), p(Y[1], o), p(Y[2], o), p(Y[3], a);
    for (let F = 255; F >= 0; --F) {
      const te = (ee[(F / 8) | 0] >> (F & 7)) & 1;
      T(Y, Q, te), M(Q, Y), M(Y, Y), T(Y, Q, te);
    }
  }
  function k(Y, Q) {
    const ee = [i(), i(), i(), i()];
    p(ee[0], f), p(ee[1], c), p(ee[2], o), x(ee[3], f, c), I(Y, ee, Q);
  }
  function L(Y) {
    if (Y.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const Q = (0, n.hash)(Y);
    (Q[0] &= 248), (Q[31] &= 127), (Q[31] |= 64);
    const ee = new Uint8Array(32),
      F = [i(), i(), i(), i()];
    k(F, Q), O(ee, F);
    const te = new Uint8Array(64);
    return te.set(Y), te.set(ee, 32), { publicKey: ee, secretKey: te };
  }
  t.generateKeyPairFromSeed = L;
  function U(Y) {
    const Q = (0, e.randomBytes)(32, Y),
      ee = L(Q);
    return (0, r.wipe)(Q), ee;
  }
  t.generateKeyPair = U;
  function $(Y) {
    if (Y.length !== t.SECRET_KEY_LENGTH)
      throw new Error(
        `ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`
      );
    return new Uint8Array(Y.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = $;
  const B = new Float64Array([
    237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
  ]);
  function R(Y, Q) {
    let ee, F, te, he;
    for (F = 63; F >= 32; --F) {
      for (ee = 0, te = F - 32, he = F - 12; te < he; ++te)
        (Q[te] += ee - 16 * Q[F] * B[te - (F - 32)]),
          (ee = Math.floor((Q[te] + 128) / 256)),
          (Q[te] -= ee * 256);
      (Q[te] += ee), (Q[F] = 0);
    }
    for (ee = 0, te = 0; te < 32; te++)
      (Q[te] += ee - (Q[31] >> 4) * B[te]), (ee = Q[te] >> 8), (Q[te] &= 255);
    for (te = 0; te < 32; te++) Q[te] -= ee * B[te];
    for (F = 0; F < 32; F++) (Q[F + 1] += Q[F] >> 8), (Y[F] = Q[F] & 255);
  }
  function V(Y) {
    const Q = new Float64Array(64);
    for (let ee = 0; ee < 64; ee++) Q[ee] = Y[ee];
    for (let ee = 0; ee < 64; ee++) Y[ee] = 0;
    R(Y, Q);
  }
  function oe(Y, Q) {
    const ee = new Float64Array(64),
      F = [i(), i(), i(), i()],
      te = (0, n.hash)(Y.subarray(0, 32));
    (te[0] &= 248), (te[31] &= 127), (te[31] |= 64);
    const he = new Uint8Array(64);
    he.set(te.subarray(32), 32);
    const Te = new n.SHA512();
    Te.update(he.subarray(32)), Te.update(Q);
    const Ce = Te.digest();
    Te.clean(),
      V(Ce),
      k(F, Ce),
      O(he, F),
      Te.reset(),
      Te.update(he.subarray(0, 32)),
      Te.update(Y.subarray(32)),
      Te.update(Q);
    const ke = Te.digest();
    V(ke);
    for (let at = 0; at < 32; at++) ee[at] = Ce[at];
    for (let at = 0; at < 32; at++)
      for (let Rt = 0; Rt < 32; Rt++) ee[at + Rt] += ke[at] * te[Rt];
    return R(he.subarray(32), ee), he;
  }
  t.sign = oe;
  function le(Y, Q) {
    const ee = i(),
      F = i(),
      te = i(),
      he = i(),
      Te = i(),
      Ce = i(),
      ke = i();
    return (
      p(Y[2], o),
      S(Y[1], Q),
      _(te, Y[1]),
      x(he, te, l),
      P(te, te, Y[2]),
      D(he, Y[2], he),
      _(Te, he),
      _(Ce, Te),
      x(ke, Ce, Te),
      x(ee, ke, te),
      x(ee, ee, he),
      N(ee, ee),
      x(ee, ee, te),
      x(ee, ee, he),
      x(ee, ee, he),
      x(Y[0], ee, he),
      _(F, Y[0]),
      x(F, F, he),
      v(F, te) && x(Y[0], Y[0], d),
      _(F, Y[0]),
      x(F, F, he),
      v(F, te)
        ? -1
        : (E(Y[0]) === Q[31] >> 7 && P(Y[0], a, Y[0]), x(Y[3], Y[0], Y[1]), 0)
    );
  }
  function fe(Y, Q, ee) {
    const F = new Uint8Array(32),
      te = [i(), i(), i(), i()],
      he = [i(), i(), i(), i()];
    if (ee.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (le(he, Y)) return !1;
    const Te = new n.SHA512();
    Te.update(ee.subarray(0, 32)), Te.update(Y), Te.update(Q);
    const Ce = Te.digest();
    return (
      V(Ce),
      I(te, he, Ce),
      k(he, ee.subarray(32)),
      M(te, he),
      O(F, te),
      !y(ee, F)
    );
  }
  t.verify = fe;
  function z(Y) {
    let Q = [i(), i(), i(), i()];
    if (le(Q, Y)) throw new Error("Ed25519: invalid public key");
    let ee = i(),
      F = i(),
      te = Q[1];
    D(ee, o, te), P(F, o, te), A(F, F), x(ee, ee, F);
    let he = new Uint8Array(32);
    return w(he, ee), he;
  }
  t.convertPublicKeyToX25519 = z;
  function se(Y) {
    const Q = (0, n.hash)(Y.subarray(0, 32));
    (Q[0] &= 248), (Q[31] &= 127), (Q[31] |= 64);
    const ee = new Uint8Array(Q.subarray(0, 32));
    return (0, r.wipe)(Q), ee;
  }
  t.convertSecretKeyToX25519 = se;
})(lS);
const JEe = "EdDSA",
  exe = "JWT",
  EW = ".",
  xW = "base64url",
  txe = "utf8",
  nxe = "utf8",
  rxe = ":",
  ixe = "did",
  sxe = "key",
  QM = "base58btc",
  axe = "z",
  oxe = "K36",
  lxe = 32;
function Q5(t) {
  return Pa(eo(kh(t), txe), xW);
}
function TW(t) {
  const e = eo(oxe, QM),
    n = axe + Pa(Rx([e, t]), QM);
  return [ixe, sxe, n].join(rxe);
}
function uxe(t) {
  return Pa(t, xW);
}
function cxe(t) {
  return eo([Q5(t.header), Q5(t.payload)].join(EW), nxe);
}
function fxe(t) {
  return [Q5(t.header), Q5(t.payload), uxe(t.signature)].join(EW);
}
function JM(t = A1.randomBytes(lxe)) {
  return lS.generateKeyPairFromSeed(t);
}
async function dxe(t, e, n, r, i = Vt.fromMiliseconds(Date.now())) {
  const s = { alg: JEe, typ: exe },
    a = TW(r.publicKey),
    o = i + n,
    l = { iss: a, sub: t, aud: e, iat: i, exp: o },
    u = cxe({ header: s, payload: l }),
    f = lS.sign(r.secretKey, u);
  return fxe({ header: s, payload: l, signature: f });
}
const hxe = "PARSE_ERROR",
  pxe = "INVALID_REQUEST",
  mxe = "METHOD_NOT_FOUND",
  gxe = "INVALID_PARAMS",
  SW = "INTERNAL_ERROR",
  uS = "SERVER_ERROR",
  yxe = [-32700, -32600, -32601, -32602, -32603],
  fg = {
    [hxe]: { code: -32700, message: "Parse error" },
    [pxe]: { code: -32600, message: "Invalid Request" },
    [mxe]: { code: -32601, message: "Method not found" },
    [gxe]: { code: -32602, message: "Invalid params" },
    [SW]: { code: -32603, message: "Internal error" },
    [uS]: { code: -32e3, message: "Server error" },
  },
  AW = uS;
function vxe(t) {
  return yxe.includes(t);
}
function eL(t) {
  return Object.keys(fg).includes(t) ? fg[t] : fg[AW];
}
function bxe(t) {
  const e = Object.values(fg).find((n) => n.code === t);
  return e || fg[AW];
}
function CW(t, e, n) {
  return t.message.includes("getaddrinfo ENOTFOUND") ||
    t.message.includes("connect ECONNREFUSED")
    ? new Error(`Unavailable ${n} RPC url at ${e}`)
    : t;
}
var kW = {},
  wc = {},
  tL;
function wxe() {
  if (tL) return wc;
  (tL = 1),
    Object.defineProperty(wc, "__esModule", { value: !0 }),
    (wc.isBrowserCryptoAvailable =
      wc.getSubtleCrypto =
      wc.getBrowerCrypto =
        void 0);
  function t() {
    return Ur?.crypto || Ur?.msCrypto || {};
  }
  wc.getBrowerCrypto = t;
  function e() {
    const r = t();
    return r.subtle || r.webkitSubtle;
  }
  wc.getSubtleCrypto = e;
  function n() {
    return !!t() && !!e();
  }
  return (wc.isBrowserCryptoAvailable = n), wc;
}
var _c = {},
  nL;
function _xe() {
  if (nL) return _c;
  (nL = 1),
    Object.defineProperty(_c, "__esModule", { value: !0 }),
    (_c.isBrowser = _c.isNode = _c.isReactNative = void 0);
  function t() {
    return (
      typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    );
  }
  _c.isReactNative = t;
  function e() {
    return (
      typeof process < "u" &&
      typeof process.versions < "u" &&
      typeof process.versions.node < "u"
    );
  }
  _c.isNode = e;
  function n() {
    return !t() && !e();
  }
  return (_c.isBrowser = n), _c;
}
(function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = oc;
  e.__exportStar(wxe(), t), e.__exportStar(_xe(), t);
})(kW);
function cS(t = 3) {
  const e = Date.now() * Math.pow(10, t),
    n = Math.floor(Math.random() * Math.pow(10, t));
  return e + n;
}
function IW(t = 6) {
  return BigInt(cS(t));
}
function E0(t, e, n) {
  return { id: n || cS(), jsonrpc: "2.0", method: t, params: e };
}
function fS(t, e) {
  return { id: t, jsonrpc: "2.0", result: e };
}
function y6(t, e, n) {
  return { id: t, jsonrpc: "2.0", error: Exe(e, n) };
}
function Exe(t, e) {
  return typeof t > "u"
    ? eL(SW)
    : (typeof t == "string" &&
        (t = Object.assign(Object.assign({}, eL(uS)), { message: t })),
      typeof e < "u" && (t.data = e),
      vxe(t.code) && (t = bxe(t.code)),
      t);
}
class xxe {}
class Txe extends xxe {
  constructor() {
    super();
  }
}
class Sxe extends Txe {
  constructor(e) {
    super();
  }
}
const Axe = "^https?:",
  Cxe = "^wss?:";
function kxe(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length)) return e[0];
}
function OW(t, e) {
  const n = kxe(t);
  return typeof n > "u" ? !1 : new RegExp(e).test(n);
}
function rL(t) {
  return OW(t, Axe);
}
function iL(t) {
  return OW(t, Cxe);
}
function Ixe(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function PW(t) {
  return (
    typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0"
  );
}
function dS(t) {
  return PW(t) && "method" in t;
}
function v6(t) {
  return PW(t) && (Ic(t) || Kl(t));
}
function Ic(t) {
  return "result" in t;
}
function Kl(t) {
  return "error" in t;
}
class cf extends Sxe {
  constructor(e) {
    super(e),
      (this.events = new Fo.EventEmitter()),
      (this.hasRegisteredEventListeners = !1),
      (this.connection = this.setConnection(e)),
      this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async request(e, n) {
    return this.requestStrict(
      E0(e.method, e.params || [], e.id || IW().toString()),
      n
    );
  }
  async requestStrict(e, n) {
    return new Promise(async (r, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          i(s);
        }
      this.events.on(`${e.id}`, (s) => {
        Kl(s) ? i(s.error) : r(s.result);
      });
      try {
        await this.connection.send(e, n);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e),
      v6(e)
        ? this.events.emit(`${e.id}`, e)
        : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e &&
      e.code === 3e3 &&
      this.events.emit(
        "error",
        new Error(
          `WebSocket connection closed abnormally with code: ${e.code} ${
            e.reason ? `(${e.reason})` : ""
          }`
        )
      ),
      this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    (this.connection === e && this.connection.connected) ||
      (this.connection.connected && this.close(),
      typeof e == "string" &&
        (await this.connection.open(e), (e = this.connection)),
      (this.connection = this.setConnection(e)),
      await this.connection.open(),
      this.registerEventListeners(),
      this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners ||
      (this.connection.on("payload", (e) => this.onPayload(e)),
      this.connection.on("close", (e) => this.onClose(e)),
      this.connection.on("error", (e) => this.events.emit("error", e)),
      this.connection.on("register_error", (e) => this.onClose()),
      (this.hasRegisteredEventListeners = !0));
  }
}
const Oxe = () =>
    typeof WebSocket < "u"
      ? WebSocket
      : typeof global < "u" && typeof global.WebSocket < "u"
      ? global.WebSocket
      : typeof window < "u" && typeof window.WebSocket < "u"
      ? window.WebSocket
      : typeof self < "u" && typeof self.WebSocket < "u"
      ? self.WebSocket
      : require("ws"),
  Pxe = () =>
    typeof WebSocket < "u" ||
    (typeof global < "u" && typeof global.WebSocket < "u") ||
    (typeof window < "u" && typeof window.WebSocket < "u") ||
    (typeof self < "u" && typeof self.WebSocket < "u"),
  sL = (t) => t.split("?")[0],
  aL = 10,
  Nxe = Oxe();
let Dxe = class {
  constructor(e) {
    if (
      ((this.url = e),
      (this.events = new Fo.EventEmitter()),
      (this.registering = !1),
      !iL(e))
    )
      throw new Error(
        `Provided URL is not compatible with WebSocket connection: ${e}`
      );
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, n) => {
      if (typeof this.socket > "u") {
        n(new Error("Connection already closed"));
        return;
      }
      (this.socket.onclose = (r) => {
        this.onClose(r), e();
      }),
        this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(kh(e));
    } catch (n) {
      this.onError(e.id, n);
    }
  }
  register(e = this.url) {
    if (!iL(e))
      throw new Error(
        `Provided URL is not compatible with WebSocket connection: ${e}`
      );
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (
        (this.events.listenerCount("register_error") >= n ||
          this.events.listenerCount("open") >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once("register_error", (s) => {
            this.resetMaxListeners(), i(s);
          }),
            this.events.once("open", () => {
              if ((this.resetMaxListeners(), typeof this.socket > "u"))
                return i(
                  new Error("WebSocket connection is missing or invalid")
                );
              r(this.socket);
            });
        })
      );
    }
    return (
      (this.url = e),
      (this.registering = !0),
      new Promise((n, r) => {
        const i = new URLSearchParams(e).get("origin"),
          s = kW.isReactNative()
            ? { headers: { origin: i } }
            : { rejectUnauthorized: !Ixe(e) },
          a = new Nxe(e, [], s);
        Pxe()
          ? (a.onerror = (o) => {
              const l = o;
              r(this.emitError(l.error));
            })
          : a.on("error", (o) => {
              r(this.emitError(o));
            }),
          (a.onopen = () => {
            this.onOpen(a), n(a);
          });
      })
    );
  }
  onOpen(e) {
    (e.onmessage = (n) => this.onPayload(n)),
      (e.onclose = (n) => this.onClose(n)),
      (this.socket = e),
      (this.registering = !1),
      this.events.emit("open");
  }
  onClose(e) {
    (this.socket = void 0),
      (this.registering = !1),
      this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const n = typeof e.data == "string" ? Wy(e.data) : e.data;
    this.events.emit("payload", n);
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = y6(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, n = this.url) {
    return CW(e, sL(n), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > aL && this.events.setMaxListeners(aL);
  }
  emitError(e) {
    const n = this.parseError(
      new Error(
        e?.message || `WebSocket connection failed for host: ${sL(this.url)}`
      )
    );
    return this.events.emit("register_error", n), n;
  }
};
var J5 = { exports: {} };
J5.exports;
(function (t, e) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 1,
    s = 2,
    a = 9007199254740991,
    o = "[object Arguments]",
    l = "[object Array]",
    u = "[object AsyncFunction]",
    f = "[object Boolean]",
    c = "[object Date]",
    d = "[object Error]",
    p = "[object Function]",
    m = "[object GeneratorFunction]",
    g = "[object Map]",
    w = "[object Number]",
    y = "[object Null]",
    v = "[object Object]",
    E = "[object Promise]",
    S = "[object Proxy]",
    D = "[object RegExp]",
    P = "[object Set]",
    x = "[object String]",
    _ = "[object Symbol]",
    A = "[object Undefined]",
    N = "[object WeakMap]",
    M = "[object ArrayBuffer]",
    T = "[object DataView]",
    O = "[object Float32Array]",
    I = "[object Float64Array]",
    k = "[object Int8Array]",
    L = "[object Int16Array]",
    U = "[object Int32Array]",
    $ = "[object Uint8Array]",
    B = "[object Uint8ClampedArray]",
    R = "[object Uint16Array]",
    V = "[object Uint32Array]",
    oe = /[\\^$.*+?()[\]{}|]/g,
    le = /^\[object .+?Constructor\]$/,
    fe = /^(?:0|[1-9]\d*)$/,
    z = {};
  (z[O] = z[I] = z[k] = z[L] = z[U] = z[$] = z[B] = z[R] = z[V] = !0),
    (z[o] =
      z[l] =
      z[M] =
      z[f] =
      z[T] =
      z[c] =
      z[d] =
      z[p] =
      z[g] =
      z[w] =
      z[v] =
      z[D] =
      z[P] =
      z[x] =
      z[N] =
        !1);
  var se = typeof Ur == "object" && Ur && Ur.Object === Object && Ur,
    Y = typeof self == "object" && self && self.Object === Object && self,
    Q = se || Y || Function("return this")(),
    ee = e && !e.nodeType && e,
    F = ee && !0 && t && !t.nodeType && t,
    te = F && F.exports === ee,
    he = te && se.process,
    Te = (function () {
      try {
        return he && he.binding && he.binding("util");
      } catch {}
    })(),
    Ce = Te && Te.isTypedArray;
  function ke(re, pe) {
    for (
      var q = -1, ie = re == null ? 0 : re.length, ve = 0, Me = [];
      ++q < ie;

    ) {
      var St = re[q];
      pe(St, q, re) && (Me[ve++] = St);
    }
    return Me;
  }
  function at(re, pe) {
    for (var q = -1, ie = pe.length, ve = re.length; ++q < ie; )
      re[ve + q] = pe[q];
    return re;
  }
  function Rt(re, pe) {
    for (var q = -1, ie = re == null ? 0 : re.length; ++q < ie; )
      if (pe(re[q], q, re)) return !0;
    return !1;
  }
  function Ft(re, pe) {
    for (var q = -1, ie = Array(re); ++q < re; ) ie[q] = pe(q);
    return ie;
  }
  function Nt(re) {
    return function (pe) {
      return re(pe);
    };
  }
  function Ot(re, pe) {
    return re.has(pe);
  }
  function et(re, pe) {
    return re?.[pe];
  }
  function st(re) {
    var pe = -1,
      q = Array(re.size);
    return (
      re.forEach(function (ie, ve) {
        q[++pe] = [ve, ie];
      }),
      q
    );
  }
  function vt(re, pe) {
    return function (q) {
      return re(pe(q));
    };
  }
  function Re(re) {
    var pe = -1,
      q = Array(re.size);
    return (
      re.forEach(function (ie) {
        q[++pe] = ie;
      }),
      q
    );
  }
  var me = Array.prototype,
    $e = Function.prototype,
    De = Object.prototype,
    je = Q["__core-js_shared__"],
    lt = $e.toString,
    Ke = De.hasOwnProperty,
    tt = (function () {
      var re = /[^.]+$/.exec((je && je.keys && je.keys.IE_PROTO) || "");
      return re ? "Symbol(src)_1." + re : "";
    })(),
    jt = De.toString,
    ct = RegExp(
      "^" +
        lt
          .call(Ke)
          .replace(oe, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    rt = te ? Q.Buffer : void 0,
    Dt = Q.Symbol,
    Ht = Q.Uint8Array,
    Yt = De.propertyIsEnumerable,
    sr = me.splice,
    Bt = Dt ? Dt.toStringTag : void 0,
    en = Object.getOwnPropertySymbols,
    Tr = rt ? rt.isBuffer : void 0,
    on = vt(Object.keys, Object),
    Pt = Mi(Q, "DataView"),
    fn = Mi(Q, "Map"),
    Wt = Mi(Q, "Promise"),
    qt = Mi(Q, "Set"),
    Ye = Mi(Q, "WeakMap"),
    xe = Mi(Object, "create"),
    nt = Vi(Pt),
    gt = Vi(fn),
    ht = Vi(Wt),
    wt = Vi(qt),
    rn = Vi(Ye),
    ot = Dt ? Dt.prototype : void 0,
    pt = ot ? ot.valueOf : void 0;
  function zt(re) {
    var pe = -1,
      q = re == null ? 0 : re.length;
    for (this.clear(); ++pe < q; ) {
      var ie = re[pe];
      this.set(ie[0], ie[1]);
    }
  }
  function Zt() {
    (this.__data__ = xe ? xe(null) : {}), (this.size = 0);
  }
  function $t(re) {
    var pe = this.has(re) && delete this.__data__[re];
    return (this.size -= pe ? 1 : 0), pe;
  }
  function Vr(re) {
    var pe = this.__data__;
    if (xe) {
      var q = pe[re];
      return q === r ? void 0 : q;
    }
    return Ke.call(pe, re) ? pe[re] : void 0;
  }
  function $n(re) {
    var pe = this.__data__;
    return xe ? pe[re] !== void 0 : Ke.call(pe, re);
  }
  function En(re, pe) {
    var q = this.__data__;
    return (
      (this.size += this.has(re) ? 0 : 1),
      (q[re] = xe && pe === void 0 ? r : pe),
      this
    );
  }
  (zt.prototype.clear = Zt),
    (zt.prototype.delete = $t),
    (zt.prototype.get = Vr),
    (zt.prototype.has = $n),
    (zt.prototype.set = En);
  function In(re) {
    var pe = -1,
      q = re == null ? 0 : re.length;
    for (this.clear(); ++pe < q; ) {
      var ie = re[pe];
      this.set(ie[0], ie[1]);
    }
  }
  function as() {
    (this.__data__ = []), (this.size = 0);
  }
  function os(re) {
    var pe = this.__data__,
      q = $s(pe, re);
    if (q < 0) return !1;
    var ie = pe.length - 1;
    return q == ie ? pe.pop() : sr.call(pe, q, 1), --this.size, !0;
  }
  function ls(re) {
    var pe = this.__data__,
      q = $s(pe, re);
    return q < 0 ? void 0 : pe[q][1];
  }
  function us(re) {
    return $s(this.__data__, re) > -1;
  }
  function Or(re, pe) {
    var q = this.__data__,
      ie = $s(q, re);
    return ie < 0 ? (++this.size, q.push([re, pe])) : (q[ie][1] = pe), this;
  }
  (In.prototype.clear = as),
    (In.prototype.delete = os),
    (In.prototype.get = ls),
    (In.prototype.has = us),
    (In.prototype.set = Or);
  function ar(re) {
    var pe = -1,
      q = re == null ? 0 : re.length;
    for (this.clear(); ++pe < q; ) {
      var ie = re[pe];
      this.set(ie[0], ie[1]);
    }
  }
  function cs() {
    (this.size = 0),
      (this.__data__ = {
        hash: new zt(),
        map: new (fn || In)(),
        string: new zt(),
      });
  }
  function lo(re) {
    var pe = Ba(this, re).delete(re);
    return (this.size -= pe ? 1 : 0), pe;
  }
  function zi(re) {
    return Ba(this, re).get(re);
  }
  function la(re) {
    return Ba(this, re).has(re);
  }
  function xi(re, pe) {
    var q = Ba(this, re),
      ie = q.size;
    return q.set(re, pe), (this.size += q.size == ie ? 0 : 1), this;
  }
  (ar.prototype.clear = cs),
    (ar.prototype.delete = lo),
    (ar.prototype.get = zi),
    (ar.prototype.has = la),
    (ar.prototype.set = xi);
  function ci(re) {
    var pe = -1,
      q = re == null ? 0 : re.length;
    for (this.__data__ = new ar(); ++pe < q; ) this.add(re[pe]);
  }
  function ua(re) {
    return this.__data__.set(re, r), this;
  }
  function Ra(re) {
    return this.__data__.has(re);
  }
  (ci.prototype.add = ci.prototype.push = ua), (ci.prototype.has = Ra);
  function pr(re) {
    var pe = (this.__data__ = new In(re));
    this.size = pe.size;
  }
  function uo() {
    (this.__data__ = new In()), (this.size = 0);
  }
  function fs(re) {
    var pe = this.__data__,
      q = pe.delete(re);
    return (this.size = pe.size), q;
  }
  function co(re) {
    return this.__data__.get(re);
  }
  function lc(re) {
    return this.__data__.has(re);
  }
  function ds(re, pe) {
    var q = this.__data__;
    if (q instanceof In) {
      var ie = q.__data__;
      if (!fn || ie.length < n - 1)
        return ie.push([re, pe]), (this.size = ++q.size), this;
      q = this.__data__ = new ar(ie);
    }
    return q.set(re, pe), (this.size = q.size), this;
  }
  (pr.prototype.clear = uo),
    (pr.prototype.delete = fs),
    (pr.prototype.get = co),
    (pr.prototype.has = lc),
    (pr.prototype.set = ds);
  function cu(re, pe) {
    var q = hs(re),
      ie = !q && qo(re),
      ve = !q && !ie && Qr(re),
      Me = !q && !ie && !ve && yu(re),
      St = q || ie || ve || Me,
      kt = St ? Ft(re.length, String) : [],
      _t = kt.length;
    for (var Et in re)
      (pe || Ke.call(re, Et)) &&
        !(
          St &&
          (Et == "length" ||
            (ve && (Et == "offset" || Et == "parent")) ||
            (Me &&
              (Et == "buffer" || Et == "byteLength" || Et == "byteOffset")) ||
            Vo(Et, _t))
        ) &&
        kt.push(Et);
    return kt;
  }
  function $s(re, pe) {
    for (var q = re.length; q--; ) if (Wo(re[q][0], pe)) return q;
    return -1;
  }
  function Al(re, pe, q) {
    var ie = pe(re);
    return hs(re) ? ie : at(ie, q(re));
  }
  function fo(re) {
    return re == null
      ? re === void 0
        ? A
        : y
      : Bt && Bt in Object(re)
      ? hu(re)
      : Go(re);
  }
  function Cl(re) {
    return Fa(re) && fo(re) == o;
  }
  function ho(re, pe, q, ie, ve) {
    return re === pe
      ? !0
      : re == null || pe == null || (!Fa(re) && !Fa(pe))
      ? re !== re && pe !== pe
      : Ma(re, pe, q, ie, ho, ve);
  }
  function Ma(re, pe, q, ie, ve, Me) {
    var St = hs(re),
      kt = hs(pe),
      _t = St ? l : Us(re),
      Et = kt ? l : Us(pe);
    (_t = _t == o ? v : _t), (Et = Et == o ? v : Et);
    var tn = _t == v,
      Kn = Et == v,
      pn = _t == Et;
    if (pn && Qr(re)) {
      if (!Qr(pe)) return !1;
      (St = !0), (tn = !1);
    }
    if (pn && !tn)
      return (
        Me || (Me = new pr()),
        St || yu(re) ? La(re, pe, q, ie, ve, Me) : fu(re, pe, _t, q, ie, ve, Me)
      );
    if (!(q & i)) {
      var xn = tn && Ke.call(re, "__wrapped__"),
        Sr = Kn && Ke.call(pe, "__wrapped__");
      if (xn || Sr) {
        var Gi = xn ? re.value() : re,
          Wi = Sr ? pe.value() : pe;
        return Me || (Me = new pr()), ve(Gi, Wi, q, ie, Me);
      }
    }
    return pn ? (Me || (Me = new pr()), du(re, pe, q, ie, ve, Me)) : !1;
  }
  function po(re) {
    if (!Hs(re) || mu(re)) return !1;
    var pe = ps(re) ? ct : le;
    return pe.test(Vi(re));
  }
  function jo(re) {
    return Fa(re) && js(re.length) && !!z[fo(re)];
  }
  function Ho(re) {
    if (!Il(re)) return on(re);
    var pe = [];
    for (var q in Object(re))
      Ke.call(re, q) && q != "constructor" && pe.push(q);
    return pe;
  }
  function La(re, pe, q, ie, ve, Me) {
    var St = q & i,
      kt = re.length,
      _t = pe.length;
    if (kt != _t && !(St && _t > kt)) return !1;
    var Et = Me.get(re);
    if (Et && Me.get(pe)) return Et == pe;
    var tn = -1,
      Kn = !0,
      pn = q & s ? new ci() : void 0;
    for (Me.set(re, pe), Me.set(pe, re); ++tn < kt; ) {
      var xn = re[tn],
        Sr = pe[tn];
      if (ie)
        var Gi = St ? ie(Sr, xn, tn, pe, re, Me) : ie(xn, Sr, tn, re, pe, Me);
      if (Gi !== void 0) {
        if (Gi) continue;
        Kn = !1;
        break;
      }
      if (pn) {
        if (
          !Rt(pe, function (Wi, $a) {
            if (!Ot(pn, $a) && (xn === Wi || ve(xn, Wi, q, ie, Me)))
              return pn.push($a);
          })
        ) {
          Kn = !1;
          break;
        }
      } else if (!(xn === Sr || ve(xn, Sr, q, ie, Me))) {
        Kn = !1;
        break;
      }
    }
    return Me.delete(re), Me.delete(pe), Kn;
  }
  function fu(re, pe, q, ie, ve, Me, St) {
    switch (q) {
      case T:
        if (re.byteLength != pe.byteLength || re.byteOffset != pe.byteOffset)
          return !1;
        (re = re.buffer), (pe = pe.buffer);
      case M:
        return !(re.byteLength != pe.byteLength || !Me(new Ht(re), new Ht(pe)));
      case f:
      case c:
      case w:
        return Wo(+re, +pe);
      case d:
        return re.name == pe.name && re.message == pe.message;
      case D:
      case x:
        return re == pe + "";
      case g:
        var kt = st;
      case P:
        var _t = ie & i;
        if ((kt || (kt = Re), re.size != pe.size && !_t)) return !1;
        var Et = St.get(re);
        if (Et) return Et == pe;
        (ie |= s), St.set(re, pe);
        var tn = La(kt(re), kt(pe), ie, ve, Me, St);
        return St.delete(re), tn;
      case _:
        if (pt) return pt.call(re) == pt.call(pe);
    }
    return !1;
  }
  function du(re, pe, q, ie, ve, Me) {
    var St = q & i,
      kt = zo(re),
      _t = kt.length,
      Et = zo(pe),
      tn = Et.length;
    if (_t != tn && !St) return !1;
    for (var Kn = _t; Kn--; ) {
      var pn = kt[Kn];
      if (!(St ? pn in pe : Ke.call(pe, pn))) return !1;
    }
    var xn = Me.get(re);
    if (xn && Me.get(pe)) return xn == pe;
    var Sr = !0;
    Me.set(re, pe), Me.set(pe, re);
    for (var Gi = St; ++Kn < _t; ) {
      pn = kt[Kn];
      var Wi = re[pn],
        $a = pe[pn];
      if (ie)
        var uc = St ? ie($a, Wi, pn, pe, re, Me) : ie(Wi, $a, pn, re, pe, Me);
      if (!(uc === void 0 ? Wi === $a || ve(Wi, $a, q, ie, Me) : uc)) {
        Sr = !1;
        break;
      }
      Gi || (Gi = pn == "constructor");
    }
    if (Sr && !Gi) {
      var zs = re.constructor,
        fi = pe.constructor;
      zs != fi &&
        "constructor" in re &&
        "constructor" in pe &&
        !(
          typeof zs == "function" &&
          zs instanceof zs &&
          typeof fi == "function" &&
          fi instanceof fi
        ) &&
        (Sr = !1);
    }
    return Me.delete(re), Me.delete(pe), Sr;
  }
  function zo(re) {
    return Al(re, vu, pu);
  }
  function Ba(re, pe) {
    var q = re.__data__;
    return kl(pe) ? q[typeof pe == "string" ? "string" : "hash"] : q.map;
  }
  function Mi(re, pe) {
    var q = et(re, pe);
    return po(q) ? q : void 0;
  }
  function hu(re) {
    var pe = Ke.call(re, Bt),
      q = re[Bt];
    try {
      re[Bt] = void 0;
      var ie = !0;
    } catch {}
    var ve = jt.call(re);
    return ie && (pe ? (re[Bt] = q) : delete re[Bt]), ve;
  }
  var pu = en
      ? function (re) {
          return re == null
            ? []
            : ((re = Object(re)),
              ke(en(re), function (pe) {
                return Yt.call(re, pe);
              }));
        }
      : qn,
    Us = fo;
  ((Pt && Us(new Pt(new ArrayBuffer(1))) != T) ||
    (fn && Us(new fn()) != g) ||
    (Wt && Us(Wt.resolve()) != E) ||
    (qt && Us(new qt()) != P) ||
    (Ye && Us(new Ye()) != N)) &&
    (Us = function (re) {
      var pe = fo(re),
        q = pe == v ? re.constructor : void 0,
        ie = q ? Vi(q) : "";
      if (ie)
        switch (ie) {
          case nt:
            return T;
          case gt:
            return g;
          case ht:
            return E;
          case wt:
            return P;
          case rn:
            return N;
        }
      return pe;
    });
  function Vo(re, pe) {
    return (
      (pe = pe ?? a),
      !!pe &&
        (typeof re == "number" || fe.test(re)) &&
        re > -1 &&
        re % 1 == 0 &&
        re < pe
    );
  }
  function kl(re) {
    var pe = typeof re;
    return pe == "string" || pe == "number" || pe == "symbol" || pe == "boolean"
      ? re !== "__proto__"
      : re === null;
  }
  function mu(re) {
    return !!tt && tt in re;
  }
  function Il(re) {
    var pe = re && re.constructor,
      q = (typeof pe == "function" && pe.prototype) || De;
    return re === q;
  }
  function Go(re) {
    return jt.call(re);
  }
  function Vi(re) {
    if (re != null) {
      try {
        return lt.call(re);
      } catch {}
      try {
        return re + "";
      } catch {}
    }
    return "";
  }
  function Wo(re, pe) {
    return re === pe || (re !== re && pe !== pe);
  }
  var qo = Cl(
      (function () {
        return arguments;
      })()
    )
      ? Cl
      : function (re) {
          return Fa(re) && Ke.call(re, "callee") && !Yt.call(re, "callee");
        },
    hs = Array.isArray;
  function gu(re) {
    return re != null && js(re.length) && !ps(re);
  }
  var Qr = Tr || Un;
  function Gr(re, pe) {
    return ho(re, pe);
  }
  function ps(re) {
    if (!Hs(re)) return !1;
    var pe = fo(re);
    return pe == p || pe == m || pe == u || pe == S;
  }
  function js(re) {
    return typeof re == "number" && re > -1 && re % 1 == 0 && re <= a;
  }
  function Hs(re) {
    var pe = typeof re;
    return re != null && (pe == "object" || pe == "function");
  }
  function Fa(re) {
    return re != null && typeof re == "object";
  }
  var yu = Ce ? Nt(Ce) : jo;
  function vu(re) {
    return gu(re) ? cu(re) : Ho(re);
  }
  function qn() {
    return [];
  }
  function Un() {
    return !1;
  }
  t.exports = Gr;
})(J5, J5.exports);
var Rxe = J5.exports;
const Mxe = oa(Rxe);
function Lxe(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      a = s.charCodeAt(0);
    if (n[a] !== 255) throw new TypeError(s + " is ambiguous");
    n[a] = i;
  }
  var o = t.length,
    l = t.charAt(0),
    u = Math.log(o) / Math.log(256),
    f = Math.log(256) / Math.log(o);
  function c(m) {
    if (
      (m instanceof Uint8Array ||
        (ArrayBuffer.isView(m)
          ? (m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength))
          : Array.isArray(m) && (m = Uint8Array.from(m))),
      !(m instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0) return "";
    for (var g = 0, w = 0, y = 0, v = m.length; y !== v && m[y] === 0; )
      y++, g++;
    for (var E = ((v - y) * f + 1) >>> 0, S = new Uint8Array(E); y !== v; ) {
      for (
        var D = m[y], P = 0, x = E - 1;
        (D !== 0 || P < w) && x !== -1;
        x--, P++
      )
        (D += (256 * S[x]) >>> 0), (S[x] = D % o >>> 0), (D = (D / o) >>> 0);
      if (D !== 0) throw new Error("Non-zero carry");
      (w = P), y++;
    }
    for (var _ = E - w; _ !== E && S[_] === 0; ) _++;
    for (var A = l.repeat(g); _ < E; ++_) A += t.charAt(S[_]);
    return A;
  }
  function d(m) {
    if (typeof m != "string") throw new TypeError("Expected String");
    if (m.length === 0) return new Uint8Array();
    var g = 0;
    if (m[g] !== " ") {
      for (var w = 0, y = 0; m[g] === l; ) w++, g++;
      for (
        var v = ((m.length - g) * u + 1) >>> 0, E = new Uint8Array(v);
        m[g];

      ) {
        var S = n[m.charCodeAt(g)];
        if (S === 255) return;
        for (var D = 0, P = v - 1; (S !== 0 || D < y) && P !== -1; P--, D++)
          (S += (o * E[P]) >>> 0),
            (E[P] = S % 256 >>> 0),
            (S = (S / 256) >>> 0);
        if (S !== 0) throw new Error("Non-zero carry");
        (y = D), g++;
      }
      if (m[g] !== " ") {
        for (var x = v - y; x !== v && E[x] === 0; ) x++;
        for (var _ = new Uint8Array(w + (v - x)), A = w; x !== v; )
          _[A++] = E[x++];
        return _;
      }
    }
  }
  function p(m) {
    var g = d(m);
    if (g) return g;
    throw new Error(`Non-${e} character`);
  }
  return { encode: c, decodeUnsafe: d, decode: p };
}
var Bxe = Lxe,
  Fxe = Bxe;
const NW = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  $xe = (t) => new TextEncoder().encode(t),
  Uxe = (t) => new TextDecoder().decode(t);
class jxe {
  constructor(e, n, r) {
    (this.name = e), (this.prefix = n), (this.baseEncode = r);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Hxe {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return DW(this, e);
  }
}
let zxe = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return DW(this, e);
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n];
    if (r) return r.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
};
const DW = (t, e) =>
  new zxe({
    ...(t.decoders || { [t.prefix]: t }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class Vxe {
  constructor(e, n, r, i) {
    (this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new jxe(e, n, r)),
      (this.decoder = new Hxe(e, n, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const b6 = ({ name: t, prefix: e, encode: n, decode: r }) =>
    new Vxe(t, e, n, r),
  qy = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = Fxe(n, e);
    return b6({ prefix: t, name: e, encode: r, decode: (s) => NW(i(s)) });
  },
  Gxe = (t, e, n, r) => {
    const i = {};
    for (let f = 0; f < e.length; ++f) i[e[f]] = f;
    let s = t.length;
    for (; t[s - 1] === "="; ) --s;
    const a = new Uint8Array(((s * n) / 8) | 0);
    let o = 0,
      l = 0,
      u = 0;
    for (let f = 0; f < s; ++f) {
      const c = i[t[f]];
      if (c === void 0) throw new SyntaxError(`Non-${r} character`);
      (l = (l << n) | c),
        (o += n),
        o >= 8 && ((o -= 8), (a[u++] = 255 & (l >> o)));
    }
    if (o >= n || 255 & (l << (8 - o)))
      throw new SyntaxError("Unexpected end of data");
    return a;
  },
  Wxe = (t, e, n) => {
    const r = e[e.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      a = 0,
      o = 0;
    for (let l = 0; l < t.length; ++l)
      for (o = (o << 8) | t[l], a += 8; a > n; )
        (a -= n), (s += e[i & (o >> a)]);
    if ((a && (s += e[i & (o << (n - a))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  Fs = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    b6({
      prefix: e,
      name: t,
      encode(i) {
        return Wxe(i, r, n);
      },
      decode(i) {
        return Gxe(i, r, n, t);
      },
    }),
  qxe = b6({
    prefix: "\0",
    name: "identity",
    encode: (t) => Uxe(t),
    decode: (t) => $xe(t),
  });
var Kxe = Object.freeze({ __proto__: null, identity: qxe });
const Xxe = Fs({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Zxe = Object.freeze({ __proto__: null, base2: Xxe });
const Yxe = Fs({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3,
});
var Qxe = Object.freeze({ __proto__: null, base8: Yxe });
const Jxe = qy({ prefix: "9", name: "base10", alphabet: "0123456789" });
var e9e = Object.freeze({ __proto__: null, base10: Jxe });
const t9e = Fs({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  n9e = Fs({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  });
var r9e = Object.freeze({ __proto__: null, base16: t9e, base16upper: n9e });
const i9e = Fs({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  s9e = Fs({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  a9e = Fs({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  o9e = Fs({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  l9e = Fs({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  u9e = Fs({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  c9e = Fs({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  f9e = Fs({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  d9e = Fs({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  });
var h9e = Object.freeze({
  __proto__: null,
  base32: i9e,
  base32upper: s9e,
  base32pad: a9e,
  base32padupper: o9e,
  base32hex: l9e,
  base32hexupper: u9e,
  base32hexpad: c9e,
  base32hexpadupper: f9e,
  base32z: d9e,
});
const p9e = qy({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  m9e = qy({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  });
var g9e = Object.freeze({ __proto__: null, base36: p9e, base36upper: m9e });
const y9e = qy({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  v9e = qy({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  });
var b9e = Object.freeze({ __proto__: null, base58btc: y9e, base58flickr: v9e });
const w9e = Fs({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  _9e = Fs({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  E9e = Fs({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  x9e = Fs({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  });
var T9e = Object.freeze({
  __proto__: null,
  base64: w9e,
  base64pad: _9e,
  base64url: E9e,
  base64urlpad: x9e,
});
const RW = Array.from(
    "🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"
  ),
  S9e = RW.reduce((t, e, n) => ((t[n] = e), t), []),
  A9e = RW.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), []);
function C9e(t) {
  return t.reduce((e, n) => ((e += S9e[n]), e), "");
}
function k9e(t) {
  const e = [];
  for (const n of t) {
    const r = A9e[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const I9e = b6({
  prefix: "🚀",
  name: "base256emoji",
  encode: C9e,
  decode: k9e,
});
var O9e = Object.freeze({ __proto__: null, base256emoji: I9e }),
  P9e = MW,
  oL = 128,
  N9e = 127,
  D9e = ~N9e,
  R9e = Math.pow(2, 31);
function MW(t, e, n) {
  (e = e || []), (n = n || 0);
  for (var r = n; t >= R9e; ) (e[n++] = (t & 255) | oL), (t /= 128);
  for (; t & D9e; ) (e[n++] = (t & 255) | oL), (t >>>= 7);
  return (e[n] = t | 0), (MW.bytes = n - r + 1), e;
}
var M9e = Vx,
  L9e = 128,
  lL = 127;
function Vx(t, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    a,
    o = t.length;
  do {
    if (s >= o)
      throw ((Vx.bytes = 0), new RangeError("Could not decode varint"));
    (a = t[s++]),
      (n += i < 28 ? (a & lL) << i : (a & lL) * Math.pow(2, i)),
      (i += 7);
  } while (a >= L9e);
  return (Vx.bytes = s - r), n;
}
var B9e = Math.pow(2, 7),
  F9e = Math.pow(2, 14),
  $9e = Math.pow(2, 21),
  U9e = Math.pow(2, 28),
  j9e = Math.pow(2, 35),
  H9e = Math.pow(2, 42),
  z9e = Math.pow(2, 49),
  V9e = Math.pow(2, 56),
  G9e = Math.pow(2, 63),
  W9e = function (t) {
    return t < B9e
      ? 1
      : t < F9e
      ? 2
      : t < $9e
      ? 3
      : t < U9e
      ? 4
      : t < j9e
      ? 5
      : t < H9e
      ? 6
      : t < z9e
      ? 7
      : t < V9e
      ? 8
      : t < G9e
      ? 9
      : 10;
  },
  q9e = { encode: P9e, decode: M9e, encodingLength: W9e },
  LW = q9e;
const uL = (t, e, n = 0) => (LW.encode(t, e, n), e),
  cL = (t) => LW.encodingLength(t),
  Gx = (t, e) => {
    const n = e.byteLength,
      r = cL(t),
      i = r + cL(n),
      s = new Uint8Array(i + n);
    return uL(t, s, 0), uL(n, s, r), s.set(e, i), new K9e(t, n, e, s);
  };
class K9e {
  constructor(e, n, r, i) {
    (this.code = e), (this.size = n), (this.digest = r), (this.bytes = i);
  }
}
const BW = ({ name: t, code: e, encode: n }) => new X9e(t, e, n);
class X9e {
  constructor(e, n, r) {
    (this.name = e), (this.code = n), (this.encode = r);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e);
      return n instanceof Uint8Array
        ? Gx(this.code, n)
        : n.then((r) => Gx(this.code, r));
    } else throw Error("Unknown type, must be binary type");
  }
}
const FW = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)),
  Z9e = BW({ name: "sha2-256", code: 18, encode: FW("SHA-256") }),
  Y9e = BW({ name: "sha2-512", code: 19, encode: FW("SHA-512") });
var Q9e = Object.freeze({ __proto__: null, sha256: Z9e, sha512: Y9e });
const $W = 0,
  J9e = "identity",
  UW = NW,
  e7e = (t) => Gx($W, UW(t)),
  t7e = { code: $W, name: J9e, encode: UW, digest: e7e };
var n7e = Object.freeze({ __proto__: null, identity: t7e });
new TextEncoder(), new TextDecoder();
const fL = {
  ...Kxe,
  ...Zxe,
  ...Qxe,
  ...e9e,
  ...r9e,
  ...h9e,
  ...g9e,
  ...b9e,
  ...T9e,
  ...O9e,
};
({ ...Q9e, ...n7e });
function jW(t) {
  return globalThis.Buffer != null
    ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    : t;
}
function r7e(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? jW(globalThis.Buffer.allocUnsafe(t))
    : new Uint8Array(t);
}
function HW(t, e, n, r) {
  return {
    name: t,
    prefix: e,
    encoder: { name: t, prefix: e, encode: n },
    decoder: { decode: r },
  };
}
const dL = HW(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  $8 = HW(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = r7e(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return e;
    }
  ),
  i7e = {
    utf8: dL,
    "utf-8": dL,
    hex: fL.base16,
    latin1: $8,
    ascii: $8,
    binary: $8,
    ...fL,
  };
function s7e(t, e = "utf8") {
  const n = i7e[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? jW(globalThis.Buffer.from(t, "utf-8"))
    : n.decoder.decode(`${n.prefix}${t}`);
}
const zW = "wc",
  a7e = 2,
  hS = "core",
  hd = `${zW}@2:${hS}:`,
  o7e = { name: hS, logger: "error" },
  l7e = { database: ":memory:" },
  u7e = "crypto",
  hL = "client_ed25519_seed",
  c7e = Vt.ONE_DAY,
  f7e = "keychain",
  d7e = "0.3",
  h7e = "messages",
  p7e = "0.3",
  m7e = Vt.SIX_HOURS,
  g7e = "publisher",
  VW = "irn",
  y7e = "error",
  GW = "wss://relay.walletconnect.com",
  pL = "wss://relay.walletconnect.org",
  v7e = "relayer",
  ta = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish",
  },
  b7e = "_subscription",
  Ec = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error",
  },
  w7e = Vt.ONE_SECOND,
  _7e = "2.10.6",
  E7e = 1e4,
  x7e = "0.3",
  T7e = "WALLETCONNECT_CLIENT_ID",
  Vl = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed",
  },
  S7e = "subscription",
  A7e = "0.3",
  C7e = Vt.FIVE_SECONDS * 1e3,
  k7e = "pairing",
  I7e = "0.3",
  Em = {
    wc_pairingDelete: {
      req: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1e3 },
      res: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1001 },
    },
    wc_pairingPing: {
      req: { ttl: Vt.THIRTY_SECONDS, prompt: !1, tag: 1002 },
      res: { ttl: Vt.THIRTY_SECONDS, prompt: !1, tag: 1003 },
    },
    unregistered_method: {
      req: { ttl: Vt.ONE_DAY, prompt: !1, tag: 0 },
      res: { ttl: Vt.ONE_DAY, prompt: !1, tag: 0 },
    },
  },
  Km = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping",
  },
  Au = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync",
  },
  O7e = "history",
  P7e = "0.3",
  N7e = "expirer",
  sl = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync",
  },
  D7e = "0.3",
  U8 = "verify-api",
  Qp = "https://verify.walletconnect.com",
  Wx = "https://verify.walletconnect.org",
  R7e = [Qp, Wx];
class M7e {
  constructor(e, n) {
    (this.core = e),
      (this.logger = n),
      (this.keychain = new Map()),
      (this.name = f7e),
      (this.version = d7e),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.init = async () => {
        if (!this.initialized) {
          const r = await this.getKeyChain();
          typeof r < "u" && (this.keychain = r), (this.initialized = !0);
        }
      }),
      (this.has = (r) => (this.isInitialized(), this.keychain.has(r))),
      (this.set = async (r, i) => {
        this.isInitialized(), this.keychain.set(r, i), await this.persist();
      }),
      (this.get = (r) => {
        this.isInitialized();
        const i = this.keychain.get(r);
        if (typeof i > "u") {
          const { message: s } = ut("NO_MATCHING_KEY", `${this.name}: ${r}`);
          throw new Error(s);
        }
        return i;
      }),
      (this.del = async (r) => {
        this.isInitialized(), this.keychain.delete(r), await this.persist();
      }),
      (this.core = e),
      (this.logger = Qn.generateChildLogger(n, this.name));
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, cW(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? fW(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class L7e {
  constructor(e, n, r) {
    (this.core = e),
      (this.logger = n),
      (this.name = u7e),
      (this.initialized = !1),
      (this.init = async () => {
        this.initialized ||
          (await this.keychain.init(), (this.initialized = !0));
      }),
      (this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i))),
      (this.getClientId = async () => {
        this.isInitialized();
        const i = await this.getClientSeed(),
          s = JM(i);
        return TW(s.publicKey);
      }),
      (this.generateKeyPair = () => {
        this.isInitialized();
        const i = H8e();
        return this.setPrivateKey(i.publicKey, i.privateKey);
      }),
      (this.signJWT = async (i) => {
        this.isInitialized();
        const s = await this.getClientSeed(),
          a = JM(s),
          o = jx();
        return await dxe(o, i, c7e, a);
      }),
      (this.generateSharedKey = (i, s, a) => {
        this.isInitialized();
        const o = this.getPrivateKey(i),
          l = z8e(o, s);
        return this.setSymKey(l, a);
      }),
      (this.setSymKey = async (i, s) => {
        this.isInitialized();
        const a = s || V8e(i);
        return await this.keychain.set(a, i), a;
      }),
      (this.deleteKeyPair = async (i) => {
        this.isInitialized(), await this.keychain.del(i);
      }),
      (this.deleteSymKey = async (i) => {
        this.isInitialized(), await this.keychain.del(i);
      }),
      (this.encode = async (i, s, a) => {
        this.isInitialized();
        const o = uW(a),
          l = kh(s);
        if (CM(o)) {
          const d = o.senderPublicKey,
            p = o.receiverPublicKey;
          i = await this.generateSharedKey(d, p);
        }
        const u = this.getSymKey(i),
          { type: f, senderPublicKey: c } = o;
        return W8e({ type: f, symKey: u, message: l, senderPublicKey: c });
      }),
      (this.decode = async (i, s, a) => {
        this.isInitialized();
        const o = X8e(s, a);
        if (CM(o)) {
          const l = o.receiverPublicKey,
            u = o.senderPublicKey;
          i = await this.generateSharedKey(l, u);
        }
        try {
          const l = this.getSymKey(i),
            u = q8e({ symKey: l, encoded: s });
          return Wy(u);
        } catch (l) {
          this.logger.error(
            `Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`
          ),
            this.logger.error(l);
        }
      }),
      (this.getPayloadType = (i) => {
        const s = Z5(i);
        return zy(s.type);
      }),
      (this.getPayloadSenderPublicKey = (i) => {
        const s = Z5(i);
        return s.senderPublicKey ? Pa(s.senderPublicKey, Ca) : void 0;
      }),
      (this.core = e),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.keychain = r || new M7e(this.core, this.logger));
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, n) {
    return await this.keychain.set(e, n), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(hL);
    } catch {
      (e = jx()), await this.keychain.set(hL, e);
    }
    return s7e(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class B7e extends VEe {
  constructor(e, n) {
    super(e, n),
      (this.logger = e),
      (this.core = n),
      (this.messages = new Map()),
      (this.name = h7e),
      (this.version = p7e),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.init = async () => {
        if (!this.initialized) {
          this.logger.trace("Initialized");
          try {
            const r = await this.getRelayerMessages();
            typeof r < "u" && (this.messages = r),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                size: this.messages.size,
              });
          } catch (r) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(r);
          } finally {
            this.initialized = !0;
          }
        }
      }),
      (this.set = async (r, i) => {
        this.isInitialized();
        const s = w0(i);
        let a = this.messages.get(r);
        return (
          typeof a > "u" && (a = {}),
          typeof a[s] < "u" ||
            ((a[s] = i), this.messages.set(r, a), await this.persist()),
          s
        );
      }),
      (this.get = (r) => {
        this.isInitialized();
        let i = this.messages.get(r);
        return typeof i > "u" && (i = {}), i;
      }),
      (this.has = (r, i) => {
        this.isInitialized();
        const s = this.get(r),
          a = w0(i);
        return typeof s[a] < "u";
      }),
      (this.del = async (r) => {
        this.isInitialized(), this.messages.delete(r), await this.persist();
      }),
      (this.logger = Qn.generateChildLogger(e, this.name)),
      (this.core = n);
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, cW(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? fW(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class F7e extends GEe {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      (this.events = new Fo.EventEmitter()),
      (this.name = g7e),
      (this.queue = new Map()),
      (this.publishTimeout = Vt.toMiliseconds(Vt.TEN_SECONDS)),
      (this.needsTransportRestart = !1),
      (this.publish = async (r, i, s) => {
        var a;
        this.logger.debug("Publishing Payload"),
          this.logger.trace({
            type: "method",
            method: "publish",
            params: { topic: r, message: i, opts: s },
          });
        try {
          const o = s?.ttl || m7e,
            l = Hx(s),
            u = s?.prompt || !1,
            f = s?.tag || 0,
            c = s?.id || IW().toString(),
            d = {
              topic: r,
              message: i,
              opts: { ttl: o, relay: l, prompt: u, tag: f, id: c },
            },
            p = setTimeout(() => this.queue.set(c, d), this.publishTimeout);
          try {
            await await ly(
              this.rpcPublish(r, i, o, l, u, f, c),
              this.publishTimeout,
              "Failed to publish payload, please try again."
            ),
              this.removeRequestFromQueue(c),
              this.relayer.events.emit(ta.publish, d);
          } catch (m) {
            if (
              (this.logger.debug("Publishing Payload stalled"),
              (this.needsTransportRestart = !0),
              (a = s?.internal) != null && a.throwOnFailedPublish)
            )
              throw (this.removeRequestFromQueue(c), m);
            return;
          } finally {
            clearTimeout(p);
          }
          this.logger.debug("Successfully Published Payload"),
            this.logger.trace({
              type: "method",
              method: "publish",
              params: { topic: r, message: i, opts: s },
            });
        } catch (o) {
          throw (
            (this.logger.debug("Failed to Publish Payload"),
            this.logger.error(o),
            o)
          );
        }
      }),
      (this.on = (r, i) => {
        this.events.on(r, i);
      }),
      (this.once = (r, i) => {
        this.events.once(r, i);
      }),
      (this.off = (r, i) => {
        this.events.off(r, i);
      }),
      (this.removeListener = (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.relayer = e),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      this.registerEventListeners();
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  rpcPublish(e, n, r, i, s, a, o) {
    var l, u, f, c;
    const d = {
      method: mb(i.protocol).publish,
      params: { topic: e, message: n, ttl: r, prompt: s, tag: a },
      id: o,
    };
    return (
      ba((l = d.params) == null ? void 0 : l.prompt) &&
        ((u = d.params) == null || delete u.prompt),
      ba((f = d.params) == null ? void 0 : f.tag) &&
        ((c = d.params) == null || delete c.tag),
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "message", direction: "outgoing", request: d }),
      this.relayer.request(d)
    );
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: n, message: r, opts: i } = e;
      await this.publish(n, r, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(P1.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        (this.needsTransportRestart = !1),
          this.relayer.events.emit(ta.connection_stalled);
        return;
      }
      this.checkQueue();
    }),
      this.relayer.on(ta.message_ack, (e) => {
        this.removeRequestFromQueue(e.id.toString());
      });
  }
}
class $7e {
  constructor() {
    (this.map = new Map()),
      (this.set = (e, n) => {
        const r = this.get(e);
        this.exists(e, n) || this.map.set(e, [...r, n]);
      }),
      (this.get = (e) => this.map.get(e) || []),
      (this.exists = (e, n) => this.get(e).includes(n)),
      (this.delete = (e, n) => {
        if (typeof n > "u") {
          this.map.delete(e);
          return;
        }
        if (!this.map.has(e)) return;
        const r = this.get(e);
        if (!this.exists(e, n)) return;
        const i = r.filter((s) => s !== n);
        if (!i.length) {
          this.map.delete(e);
          return;
        }
        this.map.set(e, i);
      }),
      (this.clear = () => {
        this.map.clear();
      });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var U7e = Object.defineProperty,
  j7e = Object.defineProperties,
  H7e = Object.getOwnPropertyDescriptors,
  mL = Object.getOwnPropertySymbols,
  z7e = Object.prototype.hasOwnProperty,
  V7e = Object.prototype.propertyIsEnumerable,
  gL = (t, e, n) =>
    e in t
      ? U7e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  xm = (t, e) => {
    for (var n in e || (e = {})) z7e.call(e, n) && gL(t, n, e[n]);
    if (mL) for (var n of mL(e)) V7e.call(e, n) && gL(t, n, e[n]);
    return t;
  },
  j8 = (t, e) => j7e(t, H7e(e));
class G7e extends KEe {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      (this.subscriptions = new Map()),
      (this.topicMap = new $7e()),
      (this.events = new Fo.EventEmitter()),
      (this.name = S7e),
      (this.version = A7e),
      (this.pending = new Map()),
      (this.cached = []),
      (this.initialized = !1),
      (this.pendingSubscriptionWatchLabel = "pending_sub_watch_label"),
      (this.pollingInterval = 20),
      (this.storagePrefix = hd),
      (this.subscribeTimeout = 1e4),
      (this.restartInProgress = !1),
      (this.batchSubscribeTopicsLimit = 500),
      (this.init = async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          this.registerEventListeners(),
          (this.clientId = await this.relayer.core.crypto.getClientId()));
      }),
      (this.subscribe = async (r, i) => {
        await this.restartToComplete(),
          this.isInitialized(),
          this.logger.debug("Subscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "subscribe",
            params: { topic: r, opts: i },
          });
        try {
          const s = Hx(i),
            a = { topic: r, relay: s };
          this.pending.set(r, a);
          const o = await this.rpcSubscribe(r, s);
          return (
            this.onSubscribe(o, a),
            this.logger.debug("Successfully Subscribed Topic"),
            this.logger.trace({
              type: "method",
              method: "subscribe",
              params: { topic: r, opts: i },
            }),
            o
          );
        } catch (s) {
          throw (
            (this.logger.debug("Failed to Subscribe Topic"),
            this.logger.error(s),
            s)
          );
        }
      }),
      (this.unsubscribe = async (r, i) => {
        await this.restartToComplete(),
          this.isInitialized(),
          typeof i?.id < "u"
            ? await this.unsubscribeById(r, i.id, i)
            : await this.unsubscribeByTopic(r, i);
      }),
      (this.isSubscribed = async (r) =>
        this.topics.includes(r)
          ? !0
          : await new Promise((i, s) => {
              const a = new Vt.Watch();
              a.start(this.pendingSubscriptionWatchLabel);
              const o = setInterval(() => {
                !this.pending.has(r) &&
                  this.topics.includes(r) &&
                  (clearInterval(o),
                  a.stop(this.pendingSubscriptionWatchLabel),
                  i(!0)),
                  a.elapsed(this.pendingSubscriptionWatchLabel) >= C7e &&
                    (clearInterval(o),
                    a.stop(this.pendingSubscriptionWatchLabel),
                    s(new Error("Subscription resolution timeout")));
              }, this.pollingInterval);
            }).catch(() => !1)),
      (this.on = (r, i) => {
        this.events.on(r, i);
      }),
      (this.once = (r, i) => {
        this.events.once(r, i);
      }),
      (this.off = (r, i) => {
        this.events.off(r, i);
      }),
      (this.removeListener = (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.restart = async () => {
        (this.restartInProgress = !0),
          await this.restore(),
          await this.reset(),
          (this.restartInProgress = !1);
      }),
      (this.relayer = e),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.clientId = "");
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.relayer.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, n) {
    let r = !1;
    try {
      r = this.getSubscription(e).topic === n;
    } catch {}
    return r;
  }
  onEnable() {
    (this.cached = []), (this.initialized = !0);
  }
  onDisable() {
    (this.cached = this.values),
      this.subscriptions.clear(),
      this.topicMap.clear();
  }
  async unsubscribeByTopic(e, n) {
    const r = this.topicMap.get(e);
    await Promise.all(r.map(async (i) => await this.unsubscribeById(e, i, n)));
  }
  async unsubscribeById(e, n, r) {
    this.logger.debug("Unsubscribing Topic"),
      this.logger.trace({
        type: "method",
        method: "unsubscribe",
        params: { topic: e, id: n, opts: r },
      });
    try {
      const i = Hx(r);
      await this.rpcUnsubscribe(e, n, i);
      const s = ki("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, n, s),
        this.logger.debug("Successfully Unsubscribed Topic"),
        this.logger.trace({
          type: "method",
          method: "unsubscribe",
          params: { topic: e, id: n, opts: r },
        });
    } catch (i) {
      throw (
        (this.logger.debug("Failed to Unsubscribe Topic"),
        this.logger.error(i),
        i)
      );
    }
  }
  async rpcSubscribe(e, n) {
    const r = { method: mb(n.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    try {
      await await ly(this.relayer.request(r), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
        this.relayer.events.emit(ta.connection_stalled);
    }
    return w0(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const n = e[0].relay,
      r = {
        method: mb(n.protocol).batchSubscribe,
        params: { topics: e.map((i) => i.topic) },
      };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    try {
      return await await ly(this.relayer.request(r), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"),
        this.relayer.events.emit(ta.connection_stalled);
    }
  }
  rpcUnsubscribe(e, n, r) {
    const i = {
      method: mb(r.protocol).unsubscribe,
      params: { topic: e, id: n },
    };
    return (
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: i }),
      this.relayer.request(i)
    );
  }
  onSubscribe(e, n) {
    this.setSubscription(e, j8(xm({}, n), { id: e })),
      this.pending.delete(n.topic);
  }
  onBatchSubscribe(e) {
    e.length &&
      e.forEach((n) => {
        this.setSubscription(n.id, xm({}, n)), this.pending.delete(n.topic);
      });
  }
  async onUnsubscribe(e, n, r) {
    this.events.removeAllListeners(n),
      this.hasSubscription(n, e) && this.deleteSubscription(n, r),
      await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, n) {
    this.subscriptions.has(e) ||
      (this.logger.debug("Setting subscription"),
      this.logger.trace({
        type: "method",
        method: "setSubscription",
        id: e,
        subscription: n,
      }),
      this.addSubscription(e, n));
  }
  addSubscription(e, n) {
    this.subscriptions.set(e, xm({}, n)),
      this.topicMap.set(n.topic, e),
      this.events.emit(Vl.created, n);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"),
      this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const n = this.subscriptions.get(e);
    if (!n) {
      const { message: r } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return n;
  }
  deleteSubscription(e, n) {
    this.logger.debug("Deleting subscription"),
      this.logger.trace({
        type: "method",
        method: "deleteSubscription",
        id: e,
        reason: n,
      });
    const r = this.getSubscription(e);
    this.subscriptions.delete(e),
      this.topicMap.delete(r.topic, e),
      this.events.emit(Vl.deleted, j8(xm({}, r), { reason: n }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Vl.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let n = 0; n < e; n++) {
        const r = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(r);
      }
    }
    this.events.emit(Vl.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: n } = ut("RESTORE_WILL_OVERRIDE", this.name);
        throw (
          (this.logger.error(n),
          this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
          new Error(n))
        );
      }
      (this.cached = e),
        this.logger.debug(
          `Successfully Restored subscriptions for ${this.name}`
        ),
        this.logger.trace({
          type: "method",
          method: "restore",
          subscriptions: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
        this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const n = await this.rpcBatchSubscribe(e);
    tc(n) &&
      this.onBatchSubscribe(n.map((r, i) => j8(xm({}, e[i]), { id: r })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
    const e = [];
    this.pending.forEach((n) => {
      e.push(n);
    }),
      await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(P1.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }),
      this.relayer.on(ta.connect, async () => {
        await this.onConnect();
      }),
      this.relayer.on(ta.disconnect, () => {
        this.onDisconnect();
      }),
      this.events.on(Vl.created, async (e) => {
        const n = Vl.created;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          await this.persist();
      }),
      this.events.on(Vl.deleted, async (e) => {
        const n = Vl.deleted;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          await this.persist();
      });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress &&
      (await new Promise((e) => {
        const n = setInterval(() => {
          this.restartInProgress || (clearInterval(n), e());
        }, this.pollingInterval);
      }));
  }
}
var W7e = Object.defineProperty,
  yL = Object.getOwnPropertySymbols,
  q7e = Object.prototype.hasOwnProperty,
  K7e = Object.prototype.propertyIsEnumerable,
  vL = (t, e, n) =>
    e in t
      ? W7e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  X7e = (t, e) => {
    for (var n in e || (e = {})) q7e.call(e, n) && vL(t, n, e[n]);
    if (yL) for (var n of yL(e)) K7e.call(e, n) && vL(t, n, e[n]);
    return t;
  };
class Z7e extends WEe {
  constructor(e) {
    super(e),
      (this.protocol = "wc"),
      (this.version = 2),
      (this.events = new Fo.EventEmitter()),
      (this.name = v7e),
      (this.transportExplicitlyClosed = !1),
      (this.initialized = !1),
      (this.connectionAttemptInProgress = !1),
      (this.connectionStatusPollingInterval = 20),
      (this.staleConnectionErrors = ["socket hang up", "socket stalled"]),
      (this.hasExperiencedNetworkDisruption = !1),
      (this.request = async (n) => {
        this.logger.debug("Publishing Request Payload");
        try {
          return (
            await this.toEstablishConnection(), await this.provider.request(n)
          );
        } catch (r) {
          throw (
            (this.logger.debug("Failed to Publish Request"),
            this.logger.error(r),
            r)
          );
        }
      }),
      (this.onPayloadHandler = (n) => {
        this.onProviderPayload(n);
      }),
      (this.onConnectHandler = () => {
        this.events.emit(ta.connect);
      }),
      (this.onDisconnectHandler = () => {
        this.onProviderDisconnect();
      }),
      (this.onProviderErrorHandler = (n) => {
        this.logger.error(n),
          this.events.emit(ta.error, n),
          this.logger.info("Fatal socket error received, closing transport"),
          this.transportClose();
      }),
      (this.registerProviderListeners = () => {
        this.provider.on(Ec.payload, this.onPayloadHandler),
          this.provider.on(Ec.connect, this.onConnectHandler),
          this.provider.on(Ec.disconnect, this.onDisconnectHandler),
          this.provider.on(Ec.error, this.onProviderErrorHandler);
      }),
      (this.core = e.core),
      (this.logger =
        typeof e.logger < "u" && typeof e.logger != "string"
          ? Qn.generateChildLogger(e.logger, this.name)
          : Qn.pino(Qn.getDefaultLoggerOptions({ level: e.logger || y7e }))),
      (this.messages = new B7e(this.logger, e.core)),
      (this.subscriber = new G7e(this, this.logger)),
      (this.publisher = new F7e(this, this.logger)),
      (this.relayUrl = e?.relayUrl || GW),
      (this.projectId = e.projectId),
      (this.bundleId = t4e()),
      (this.provider = {});
  }
  async init() {
    this.logger.trace("Initialized"),
      this.registerEventListeners(),
      await this.createProvider(),
      await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(
        `Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pL}...`
      ),
        await this.restartTransport(pL);
    }
    (this.initialized = !0),
      setTimeout(async () => {
        this.subscriber.topics.length === 0 &&
          (this.logger.info(
            "No topics subscribed to after init, closing transport"
          ),
          await this.transportClose(),
          (this.transportExplicitlyClosed = !1));
      }, E7e);
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, n, r) {
    this.isInitialized(),
      await this.publisher.publish(e, n, r),
      await this.recordMessageEvent({
        topic: e,
        message: n,
        publishedAt: Date.now(),
      });
  }
  async subscribe(e, n) {
    var r;
    this.isInitialized();
    let i =
      ((r = this.subscriber.topicMap.get(e)) == null ? void 0 : r[0]) || "";
    if (i) return i;
    let s;
    const a = (o) => {
      o.topic === e && (this.subscriber.off(Vl.created, a), s());
    };
    return (
      await Promise.all([
        new Promise((o) => {
          (s = o), this.subscriber.on(Vl.created, a);
        }),
        new Promise(async (o) => {
          (i = await this.subscriber.subscribe(e, n)), o();
        }),
      ]),
      i
    );
  }
  async unsubscribe(e, n) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, n);
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async transportClose() {
    (this.transportExplicitlyClosed = !0),
      this.hasExperiencedNetworkDisruption && this.connected
        ? await ly(
            this.provider.disconnect(),
            1e3,
            "provider.disconnect()"
          ).catch(() => this.onProviderDisconnect())
        : this.connected && (await this.provider.disconnect());
  }
  async transportOpen(e) {
    if (
      ((this.transportExplicitlyClosed = !1),
      await this.confirmOnlineStateOrThrow(),
      !this.connectionAttemptInProgress)
    ) {
      e &&
        e !== this.relayUrl &&
        ((this.relayUrl = e),
        await this.transportClose(),
        await this.createProvider()),
        (this.connectionAttemptInProgress = !0);
      try {
        await Promise.all([
          new Promise((n) => {
            if (!this.initialized) return n();
            this.subscriber.once(Vl.resubscribed, () => {
              n();
            });
          }),
          new Promise(async (n, r) => {
            try {
              await ly(
                this.provider.connect(),
                1e4,
                `Socket stalled when trying to connect to ${this.relayUrl}`
              );
            } catch (i) {
              r(i);
              return;
            }
            n();
          }),
        ]);
      } catch (n) {
        this.logger.error(n);
        const r = n;
        if (!this.isConnectionStalled(r.message)) throw n;
        this.provider.events.emit(Ec.disconnect);
      } finally {
        (this.connectionAttemptInProgress = !1),
          (this.hasExperiencedNetworkDisruption = !1);
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(),
      !this.connectionAttemptInProgress &&
        ((this.relayUrl = e || this.relayUrl),
        await this.transportClose(),
        await this.createProvider(),
        await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!(await FM()))
      throw new Error(
        "No internet connection detected. Please restart your network and try again."
      );
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((n) => e.includes(n));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    (this.provider = new cf(
      new Dxe(
        o4e({
          sdkVersion: _7e,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e,
          useOnCloseEvent: !0,
          bundleId: this.bundleId,
        })
      )
    )),
      this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: n, message: r } = e;
    await this.messages.set(n, r);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: n, message: r } = e;
    if (!r || r.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${r}`), !0;
    if (!(await this.subscriber.isSubscribed(n)))
      return (
        this.logger.debug(`Ignoring message for non-subscribed topic ${n}`), !0
      );
    const i = this.messages.has(n, r);
    return i && this.logger.debug(`Ignoring duplicate message: ${r}`), i;
  }
  async onProviderPayload(e) {
    if (
      (this.logger.debug("Incoming Relay Payload"),
      this.logger.trace({ type: "payload", direction: "incoming", payload: e }),
      dS(e))
    ) {
      if (!e.method.endsWith(b7e)) return;
      const n = e.params,
        { topic: r, message: i, publishedAt: s } = n.data,
        a = { topic: r, message: i, publishedAt: s };
      this.logger.debug("Emitting Relayer Payload"),
        this.logger.trace(X7e({ type: "event", event: n.id }, a)),
        this.events.emit(n.id, a),
        await this.acknowledgePayload(e),
        await this.onMessageEvent(a);
    } else v6(e) && this.events.emit(ta.message_ack, e);
  }
  async onMessageEvent(e) {
    (await this.shouldIgnoreMessageEvent(e)) ||
      (this.events.emit(ta.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const n = fS(e.id, !0);
    await this.provider.connection.send(n);
  }
  unregisterProviderListeners() {
    this.provider.off(Ec.payload, this.onPayloadHandler),
      this.provider.off(Ec.connect, this.onConnectHandler),
      this.provider.off(Ec.disconnect, this.onDisconnectHandler),
      this.provider.off(Ec.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(ta.connection_stalled, () => {
      this.restartTransport().catch((n) => this.logger.error(n));
    });
    let e = await FM();
    J4e(async (n) => {
      this.initialized &&
        e !== n &&
        ((e = n),
        n
          ? await this.restartTransport().catch((r) => this.logger.error(r))
          : ((this.hasExperiencedNetworkDisruption = !0),
            await this.transportClose().catch((r) => this.logger.error(r))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(ta.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed ||
      (this.logger.info("attemptToReconnect called. Connecting..."),
      setTimeout(async () => {
        await this.restartTransport().catch((e) => this.logger.error(e));
      }, Vt.toMiliseconds(w7e)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const n = setInterval(() => {
            this.connected && (clearInterval(n), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var Y7e = Object.defineProperty,
  bL = Object.getOwnPropertySymbols,
  Q7e = Object.prototype.hasOwnProperty,
  J7e = Object.prototype.propertyIsEnumerable,
  wL = (t, e, n) =>
    e in t
      ? Y7e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  _L = (t, e) => {
    for (var n in e || (e = {})) Q7e.call(e, n) && wL(t, n, e[n]);
    if (bL) for (var n of bL(e)) J7e.call(e, n) && wL(t, n, e[n]);
    return t;
  };
class w6 extends qEe {
  constructor(e, n, r, i = hd, s = void 0) {
    super(e, n, r, i),
      (this.core = e),
      (this.logger = n),
      (this.name = r),
      (this.map = new Map()),
      (this.version = x7e),
      (this.cached = []),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.init = async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((a) => {
            this.getKey && a !== null && !ba(a)
              ? this.map.set(this.getKey(a), a)
              : O4e(a)
              ? this.map.set(a.id, a)
              : P4e(a) && this.map.set(a.topic, a);
          }),
          (this.cached = []),
          (this.initialized = !0));
      }),
      (this.set = async (a, o) => {
        this.isInitialized(),
          this.map.has(a)
            ? await this.update(a, o)
            : (this.logger.debug("Setting value"),
              this.logger.trace({
                type: "method",
                method: "set",
                key: a,
                value: o,
              }),
              this.map.set(a, o),
              await this.persist());
      }),
      (this.get = (a) => (
        this.isInitialized(),
        this.logger.debug("Getting value"),
        this.logger.trace({ type: "method", method: "get", key: a }),
        this.getData(a)
      )),
      (this.getAll = (a) => (
        this.isInitialized(),
        a
          ? this.values.filter((o) =>
              Object.keys(a).every((l) => Mxe(o[l], a[l]))
            )
          : this.values
      )),
      (this.update = async (a, o) => {
        this.isInitialized(),
          this.logger.debug("Updating value"),
          this.logger.trace({
            type: "method",
            method: "update",
            key: a,
            update: o,
          });
        const l = _L(_L({}, this.getData(a)), o);
        this.map.set(a, l), await this.persist();
      }),
      (this.delete = async (a, o) => {
        this.isInitialized(),
          this.map.has(a) &&
            (this.logger.debug("Deleting value"),
            this.logger.trace({
              type: "method",
              method: "delete",
              key: a,
              reason: o,
            }),
            this.map.delete(a),
            await this.persist());
      }),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.storagePrefix = i),
      (this.getKey = s);
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const n = this.map.get(e);
    if (!n) {
      const { message: r } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.error(r), new Error(r));
    }
    return n;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: n } = ut("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored value for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          value: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`),
        this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class eTe {
  constructor(e, n) {
    (this.core = e),
      (this.logger = n),
      (this.name = k7e),
      (this.version = I7e),
      (this.events = new ZT()),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.ignoredPayloadTypes = [jh]),
      (this.registeredMethods = []),
      (this.init = async () => {
        this.initialized ||
          (await this.pairings.init(),
          await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          (this.initialized = !0),
          this.logger.trace("Initialized"));
      }),
      (this.register = ({ methods: r }) => {
        this.isInitialized(),
          (this.registeredMethods = [
            ...new Set([...this.registeredMethods, ...r]),
          ]);
      }),
      (this.create = async () => {
        this.isInitialized();
        const r = jx(),
          i = await this.core.crypto.setSymKey(r),
          s = ql(Vt.FIVE_MINUTES),
          a = { protocol: VW },
          o = { topic: i, expiry: s, relay: a, active: !1 },
          l = w4e({
            protocol: this.core.protocol,
            version: this.core.version,
            topic: i,
            symKey: r,
            relay: a,
          });
        return (
          await this.pairings.set(i, o),
          await this.core.relayer.subscribe(i),
          this.core.expirer.set(i, s),
          { topic: i, uri: l }
        );
      }),
      (this.pair = async (r) => {
        this.isInitialized(), this.isValidPair(r);
        const { topic: i, symKey: s, relay: a } = DM(r.uri);
        let o;
        if (
          this.pairings.keys.includes(i) &&
          ((o = this.pairings.get(i)), o.active)
        )
          throw new Error(
            `Pairing already exists: ${i}. Please try again with a new connection URI.`
          );
        const l = ql(Vt.FIVE_MINUTES),
          u = { topic: i, relay: a, expiry: l, active: !1 };
        return (
          await this.pairings.set(i, u),
          this.core.expirer.set(i, l),
          r.activatePairing && (await this.activate({ topic: i })),
          this.events.emit(Km.create, u),
          this.core.crypto.keychain.has(i) ||
            (await this.core.crypto.setSymKey(s, i),
            await this.core.relayer.subscribe(i, { relay: a })),
          u
        );
      }),
      (this.activate = async ({ topic: r }) => {
        this.isInitialized();
        const i = ql(Vt.THIRTY_DAYS);
        await this.pairings.update(r, { active: !0, expiry: i }),
          this.core.expirer.set(r, i);
      }),
      (this.ping = async (r) => {
        this.isInitialized(), await this.isValidPing(r);
        const { topic: i } = r;
        if (this.pairings.keys.includes(i)) {
          const s = await this.sendRequest(i, "wc_pairingPing", {}),
            { done: a, resolve: o, reject: l } = Pp();
          this.events.once(Bi("pairing_ping", s), ({ error: u }) => {
            u ? l(u) : o();
          }),
            await a();
        }
      }),
      (this.updateExpiry = async ({ topic: r, expiry: i }) => {
        this.isInitialized(), await this.pairings.update(r, { expiry: i });
      }),
      (this.updateMetadata = async ({ topic: r, metadata: i }) => {
        this.isInitialized(),
          await this.pairings.update(r, { peerMetadata: i });
      }),
      (this.getPairings = () => (this.isInitialized(), this.pairings.values)),
      (this.disconnect = async (r) => {
        this.isInitialized(), await this.isValidDisconnect(r);
        const { topic: i } = r;
        this.pairings.keys.includes(i) &&
          (await this.sendRequest(
            i,
            "wc_pairingDelete",
            ki("USER_DISCONNECTED")
          ),
          await this.deletePairing(i));
      }),
      (this.sendRequest = async (r, i, s) => {
        const a = E0(i, s),
          o = await this.core.crypto.encode(r, a),
          l = Em[i].req;
        return (
          this.core.history.set(r, a), this.core.relayer.publish(r, o, l), a.id
        );
      }),
      (this.sendResult = async (r, i, s) => {
        const a = fS(r, s),
          o = await this.core.crypto.encode(i, a),
          l = await this.core.history.get(i, r),
          u = Em[l.request.method].res;
        await this.core.relayer.publish(i, o, u),
          await this.core.history.resolve(a);
      }),
      (this.sendError = async (r, i, s) => {
        const a = y6(r, s),
          o = await this.core.crypto.encode(i, a),
          l = await this.core.history.get(i, r),
          u = Em[l.request.method]
            ? Em[l.request.method].res
            : Em.unregistered_method.res;
        await this.core.relayer.publish(i, o, u),
          await this.core.history.resolve(a);
      }),
      (this.deletePairing = async (r, i) => {
        await this.core.relayer.unsubscribe(r),
          await Promise.all([
            this.pairings.delete(r, ki("USER_DISCONNECTED")),
            this.core.crypto.deleteSymKey(r),
            i ? Promise.resolve() : this.core.expirer.del(r),
          ]);
      }),
      (this.cleanup = async () => {
        const r = this.pairings.getAll().filter((i) => Rf(i.expiry));
        await Promise.all(r.map((i) => this.deletePairing(i.topic)));
      }),
      (this.onRelayEventRequest = (r) => {
        const { topic: i, payload: s } = r;
        switch (s.method) {
          case "wc_pairingPing":
            return this.onPairingPingRequest(i, s);
          case "wc_pairingDelete":
            return this.onPairingDeleteRequest(i, s);
          default:
            return this.onUnknownRpcMethodRequest(i, s);
        }
      }),
      (this.onRelayEventResponse = async (r) => {
        const { topic: i, payload: s } = r,
          a = (await this.core.history.get(i, s.id)).request.method;
        switch (a) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(i, s);
          default:
            return this.onUnknownRpcMethodResponse(a);
        }
      }),
      (this.onPairingPingRequest = async (r, i) => {
        const { id: s } = i;
        try {
          this.isValidPing({ topic: r }),
            await this.sendResult(s, r, !0),
            this.events.emit(Km.ping, { id: s, topic: r });
        } catch (a) {
          await this.sendError(s, r, a), this.logger.error(a);
        }
      }),
      (this.onPairingPingResponse = (r, i) => {
        const { id: s } = i;
        setTimeout(() => {
          Ic(i)
            ? this.events.emit(Bi("pairing_ping", s), {})
            : Kl(i) &&
              this.events.emit(Bi("pairing_ping", s), { error: i.error });
        }, 500);
      }),
      (this.onPairingDeleteRequest = async (r, i) => {
        const { id: s } = i;
        try {
          this.isValidDisconnect({ topic: r }),
            await this.deletePairing(r),
            this.events.emit(Km.delete, { id: s, topic: r });
        } catch (a) {
          await this.sendError(s, r, a), this.logger.error(a);
        }
      }),
      (this.onUnknownRpcMethodRequest = async (r, i) => {
        const { id: s, method: a } = i;
        try {
          if (this.registeredMethods.includes(a)) return;
          const o = ki("WC_METHOD_UNSUPPORTED", a);
          await this.sendError(s, r, o), this.logger.error(o);
        } catch (o) {
          await this.sendError(s, r, o), this.logger.error(o);
        }
      }),
      (this.onUnknownRpcMethodResponse = (r) => {
        this.registeredMethods.includes(r) ||
          this.logger.error(ki("WC_METHOD_UNSUPPORTED", r));
      }),
      (this.isValidPair = (r) => {
        var i;
        if (!Ka(r)) {
          const { message: a } = ut(
            "MISSING_OR_INVALID",
            `pair() params: ${r}`
          );
          throw new Error(a);
        }
        if (!I4e(r.uri)) {
          const { message: a } = ut(
            "MISSING_OR_INVALID",
            `pair() uri: ${r.uri}`
          );
          throw new Error(a);
        }
        const s = DM(r.uri);
        if (!((i = s?.relay) != null && i.protocol)) {
          const { message: a } = ut(
            "MISSING_OR_INVALID",
            "pair() uri#relay-protocol"
          );
          throw new Error(a);
        }
        if (!(s != null && s.symKey)) {
          const { message: a } = ut("MISSING_OR_INVALID", "pair() uri#symKey");
          throw new Error(a);
        }
      }),
      (this.isValidPing = async (r) => {
        if (!Ka(r)) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `ping() params: ${r}`
          );
          throw new Error(s);
        }
        const { topic: i } = r;
        await this.isValidPairingTopic(i);
      }),
      (this.isValidDisconnect = async (r) => {
        if (!Ka(r)) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `disconnect() params: ${r}`
          );
          throw new Error(s);
        }
        const { topic: i } = r;
        await this.isValidPairingTopic(i);
      }),
      (this.isValidPairingTopic = async (r) => {
        if (!Es(r, !1)) {
          const { message: i } = ut(
            "MISSING_OR_INVALID",
            `pairing topic should be a string: ${r}`
          );
          throw new Error(i);
        }
        if (!this.pairings.keys.includes(r)) {
          const { message: i } = ut(
            "NO_MATCHING_KEY",
            `pairing topic doesn't exist: ${r}`
          );
          throw new Error(i);
        }
        if (Rf(this.pairings.get(r).expiry)) {
          await this.deletePairing(r);
          const { message: i } = ut("EXPIRED", `pairing topic: ${r}`);
          throw new Error(i);
        }
      }),
      (this.core = e),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.pairings = new w6(
        this.core,
        this.logger,
        this.name,
        this.storagePrefix
      ));
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(ta.message, async (e) => {
      const { topic: n, message: r } = e;
      if (
        !this.pairings.keys.includes(n) ||
        this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))
      )
        return;
      const i = await this.core.crypto.decode(n, r);
      try {
        dS(i)
          ? (this.core.history.set(n, i),
            this.onRelayEventRequest({ topic: n, payload: i }))
          : v6(i) &&
            (await this.core.history.resolve(i),
            await this.onRelayEventResponse({ topic: n, payload: i }),
            this.core.history.delete(n, i.id));
      } catch (s) {
        this.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(sl.expired, async (e) => {
      const { topic: n } = hW(e.target);
      n &&
        this.pairings.keys.includes(n) &&
        (await this.deletePairing(n, !0),
        this.events.emit(Km.expire, { topic: n }));
    });
  }
}
class tTe extends zEe {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      (this.records = new Map()),
      (this.events = new Fo.EventEmitter()),
      (this.name = O7e),
      (this.version = P7e),
      (this.cached = []),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.init = async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((r) => this.records.set(r.id, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      (this.set = (r, i, s) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Setting JSON-RPC request history record"),
          this.logger.trace({
            type: "method",
            method: "set",
            topic: r,
            request: i,
            chainId: s,
          }),
          this.records.has(i.id))
        )
          return;
        const a = {
          id: i.id,
          topic: r,
          request: { method: i.method, params: i.params || null },
          chainId: s,
          expiry: ql(Vt.THIRTY_DAYS),
        };
        this.records.set(a.id, a), this.events.emit(Au.created, a);
      }),
      (this.resolve = async (r) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Updating JSON-RPC response history record"),
          this.logger.trace({ type: "method", method: "update", response: r }),
          !this.records.has(r.id))
        )
          return;
        const i = await this.getRecord(r.id);
        typeof i.response > "u" &&
          ((i.response = Kl(r) ? { error: r.error } : { result: r.result }),
          this.records.set(i.id, i),
          this.events.emit(Au.updated, i));
      }),
      (this.get = async (r, i) => (
        this.isInitialized(),
        this.logger.debug("Getting record"),
        this.logger.trace({ type: "method", method: "get", topic: r, id: i }),
        await this.getRecord(i)
      )),
      (this.delete = (r, i) => {
        this.isInitialized(),
          this.logger.debug("Deleting record"),
          this.logger.trace({ type: "method", method: "delete", id: i }),
          this.values.forEach((s) => {
            if (s.topic === r) {
              if (typeof i < "u" && s.id !== i) return;
              this.records.delete(s.id), this.events.emit(Au.deleted, s);
            }
          });
      }),
      (this.exists = async (r, i) => (
        this.isInitialized(),
        this.records.has(i) ? (await this.getRecord(i)).topic === r : !1
      )),
      (this.on = (r, i) => {
        this.events.on(r, i);
      }),
      (this.once = (r, i) => {
        this.events.once(r, i);
      }),
      (this.off = (r, i) => {
        this.events.off(r, i);
      }),
      (this.removeListener = (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.logger = Qn.generateChildLogger(n, this.name));
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return (
      this.values.forEach((n) => {
        if (typeof n.response < "u") return;
        const r = {
          topic: n.topic,
          request: E0(n.request.method, n.request.params, n.id),
          chainId: n.chainId,
        };
        return e.push(r);
      }),
      e
    );
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const n = this.records.get(e);
    if (!n) {
      const { message: r } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return n;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Au.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: n } = ut("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored records for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          records: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`),
        this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Au.created, (e) => {
      const n = Au.created;
      this.logger.info(`Emitting ${n}`),
        this.logger.debug({ type: "event", event: n, record: e }),
        this.persist();
    }),
      this.events.on(Au.updated, (e) => {
        const n = Au.updated;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, record: e }),
          this.persist();
      }),
      this.events.on(Au.deleted, (e) => {
        const n = Au.deleted;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, record: e }),
          this.persist();
      }),
      this.core.heartbeat.on(P1.HEARTBEAT_EVENTS.pulse, () => {
        this.cleanup();
      });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        Vt.toMiliseconds(e.expiry || 0) - Date.now() <= 0 &&
          (this.logger.info(`Deleting expired history log: ${e.id}`),
          this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class nTe extends XEe {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      (this.expirations = new Map()),
      (this.events = new Fo.EventEmitter()),
      (this.name = N7e),
      (this.version = D7e),
      (this.cached = []),
      (this.initialized = !1),
      (this.storagePrefix = hd),
      (this.init = async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((r) => this.expirations.set(r.target, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      (this.has = (r) => {
        try {
          const i = this.formatTarget(r);
          return typeof this.getExpiration(i) < "u";
        } catch {
          return !1;
        }
      }),
      (this.set = (r, i) => {
        this.isInitialized();
        const s = this.formatTarget(r),
          a = { target: s, expiry: i };
        this.expirations.set(s, a),
          this.checkExpiry(s, a),
          this.events.emit(sl.created, { target: s, expiration: a });
      }),
      (this.get = (r) => {
        this.isInitialized();
        const i = this.formatTarget(r);
        return this.getExpiration(i);
      }),
      (this.del = (r) => {
        if ((this.isInitialized(), this.has(r))) {
          const i = this.formatTarget(r),
            s = this.getExpiration(i);
          this.expirations.delete(i),
            this.events.emit(sl.deleted, { target: i, expiration: s });
        }
      }),
      (this.on = (r, i) => {
        this.events.on(r, i);
      }),
      (this.once = (r, i) => {
        this.events.once(r, i);
      }),
      (this.off = (r, i) => {
        this.events.off(r, i);
      }),
      (this.removeListener = (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.logger = Qn.generateChildLogger(n, this.name));
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return l4e(e);
    if (typeof e == "number") return u4e(e);
    const { message: n } = ut("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(n);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(sl.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: n } = ut("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored expirations for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          expirations: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`),
        this.logger.error(e);
    }
  }
  getExpiration(e) {
    const n = this.expirations.get(e);
    if (!n) {
      const { message: r } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.error(r), new Error(r));
    }
    return n;
  }
  checkExpiry(e, n) {
    const { expiry: r } = n;
    Vt.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, n);
  }
  expire(e, n) {
    this.expirations.delete(e),
      this.events.emit(sl.expired, { target: e, expiration: n });
  }
  checkExpirations() {
    this.core.relayer.connected &&
      this.expirations.forEach((e, n) => this.checkExpiry(n, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(P1.HEARTBEAT_EVENTS.pulse, () =>
      this.checkExpirations()
    ),
      this.events.on(sl.created, (e) => {
        const n = sl.created;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      }),
      this.events.on(sl.expired, (e) => {
        const n = sl.expired;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      }),
      this.events.on(sl.deleted, (e) => {
        const n = sl.deleted;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class rTe extends ZEe {
  constructor(e, n) {
    super(e, n),
      (this.projectId = e),
      (this.logger = n),
      (this.name = U8),
      (this.initialized = !1),
      (this.queue = []),
      (this.verifyDisabled = !1),
      (this.init = async (r) => {
        if (this.verifyDisabled || k1() || !I1()) return;
        const i = this.getVerifyUrl(r?.verifyUrl);
        this.verifyUrl !== i && this.removeIframe(), (this.verifyUrl = i);
        try {
          await this.createIframe();
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),
            this.logger.info(s);
        }
        if (!this.initialized) {
          this.removeIframe(), (this.verifyUrl = Wx);
          try {
            await this.createIframe();
          } catch (s) {
            this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),
              this.logger.info(s),
              (this.verifyDisabled = !0);
          }
        }
      }),
      (this.register = async (r) => {
        this.initialized
          ? this.sendPost(r.attestationId)
          : (this.addToQueue(r.attestationId), await this.init());
      }),
      (this.resolve = async (r) => {
        if (this.isDevEnv) return "";
        const i = this.getVerifyUrl(r?.verifyUrl);
        let s;
        try {
          s = await this.fetchAttestation(r.attestationId, i);
        } catch (a) {
          this.logger.info(
            `failed to resolve attestation: ${r.attestationId} from url: ${i}`
          ),
            this.logger.info(a),
            (s = await this.fetchAttestation(r.attestationId, Wx));
        }
        return s;
      }),
      (this.fetchAttestation = async (r, i) => {
        this.logger.info(`resolving attestation: ${r} from url: ${i}`);
        const s = this.startAbortTimer(Vt.ONE_SECOND * 2),
          a = await fetch(`${i}/attestation/${r}`, {
            signal: this.abortController.signal,
          });
        return clearTimeout(s), a.status === 200 ? await a.json() : void 0;
      }),
      (this.addToQueue = (r) => {
        this.queue.push(r);
      }),
      (this.processQueue = () => {
        this.queue.length !== 0 &&
          (this.queue.forEach((r) => this.sendPost(r)), (this.queue = []));
      }),
      (this.sendPost = (r) => {
        var i;
        try {
          if (!this.iframe) return;
          (i = this.iframe.contentWindow) == null || i.postMessage(r, "*"),
            this.logger.info(`postMessage sent: ${r} ${this.verifyUrl}`);
        } catch {}
      }),
      (this.createIframe = async () => {
        let r;
        const i = (s) => {
          s.data === "verify_ready" &&
            ((this.initialized = !0),
            this.processQueue(),
            window.removeEventListener("message", i),
            r());
        };
        await Promise.race([
          new Promise((s) => {
            if (document.getElementById(U8)) return s();
            window.addEventListener("message", i);
            const a = document.createElement("iframe");
            (a.id = U8),
              (a.src = `${this.verifyUrl}/${this.projectId}`),
              (a.style.display = "none"),
              document.body.append(a),
              (this.iframe = a),
              (r = s);
          }),
          new Promise((s, a) =>
            setTimeout(() => {
              window.removeEventListener("message", i),
                a("verify iframe load timeout");
            }, Vt.toMiliseconds(Vt.FIVE_SECONDS))
          ),
        ]);
      }),
      (this.removeIframe = () => {
        this.iframe &&
          (this.iframe.remove(),
          (this.iframe = void 0),
          (this.initialized = !1));
      }),
      (this.getVerifyUrl = (r) => {
        let i = r || Qp;
        return (
          R7e.includes(i) ||
            (this.logger.info(
              `verify url: ${i}, not included in trusted list, assigning default: ${Qp}`
            ),
            (i = Qp)),
          i
        );
      }),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.verifyUrl = Qp),
      (this.abortController = new AbortController()),
      (this.isDevEnv = sS() && {}.IS_VITEST);
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return (
      (this.abortController = new AbortController()),
      setTimeout(() => this.abortController.abort(), Vt.toMiliseconds(e))
    );
  }
}
var iTe = Object.defineProperty,
  EL = Object.getOwnPropertySymbols,
  sTe = Object.prototype.hasOwnProperty,
  aTe = Object.prototype.propertyIsEnumerable,
  xL = (t, e, n) =>
    e in t
      ? iTe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  TL = (t, e) => {
    for (var n in e || (e = {})) sTe.call(e, n) && xL(t, n, e[n]);
    if (EL) for (var n of EL(e)) aTe.call(e, n) && xL(t, n, e[n]);
    return t;
  };
class pS extends HEe {
  constructor(e) {
    super(e),
      (this.protocol = zW),
      (this.version = a7e),
      (this.name = hS),
      (this.events = new Fo.EventEmitter()),
      (this.initialized = !1),
      (this.on = (r, i) => this.events.on(r, i)),
      (this.once = (r, i) => this.events.once(r, i)),
      (this.off = (r, i) => this.events.off(r, i)),
      (this.removeListener = (r, i) => this.events.removeListener(r, i)),
      (this.projectId = e?.projectId),
      (this.relayUrl = e?.relayUrl || GW),
      (this.customStoragePrefix =
        e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "");
    const n =
      typeof e?.logger < "u" && typeof e?.logger != "string"
        ? e.logger
        : Qn.pino(
            Qn.getDefaultLoggerOptions({ level: e?.logger || o7e.logger })
          );
    (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.heartbeat = new P1.HeartBeat()),
      (this.crypto = new L7e(this, this.logger, e?.keychain)),
      (this.history = new tTe(this, this.logger)),
      (this.expirer = new nTe(this, this.logger)),
      (this.storage =
        e != null && e.storage
          ? e.storage
          : new DEe(TL(TL({}, l7e), e?.storageOptions))),
      (this.relayer = new Z7e({
        core: this,
        logger: this.logger,
        relayUrl: this.relayUrl,
        projectId: this.projectId,
      })),
      (this.pairing = new eTe(this, this.logger)),
      (this.verify = new rTe(this.projectId || "", this.logger));
  }
  static async init(e) {
    const n = new pS(e);
    await n.initialize();
    const r = await n.crypto.getClientId();
    return await n.storage.setItem(T7e, r), n;
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || (await this.initialize());
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(),
        await this.history.init(),
        await this.expirer.init(),
        await this.relayer.init(),
        await this.heartbeat.init(),
        await this.pairing.init(),
        (this.initialized = !0),
        this.logger.info("Core Initialization Success");
    } catch (e) {
      throw (
        (this.logger.warn(
          `Core Initialization Failure at epoch ${Date.now()}`,
          e
        ),
        this.logger.error(e.message),
        e)
      );
    }
  }
}
const oTe = pS,
  WW = "wc",
  qW = 2,
  KW = "client",
  mS = `${WW}@${qW}:${KW}:`,
  H8 = {
    name: KW,
    logger: "error",
    controller: !1,
    relayUrl: "wss://relay.walletconnect.com",
  },
  SL = "WALLETCONNECT_DEEPLINK_CHOICE",
  lTe = "proposal",
  XW = "Proposal expired",
  uTe = "session",
  Tv = Vt.SEVEN_DAYS,
  cTe = "engine",
  Tm = {
    wc_sessionPropose: {
      req: { ttl: Vt.FIVE_MINUTES, prompt: !0, tag: 1100 },
      res: { ttl: Vt.FIVE_MINUTES, prompt: !1, tag: 1101 },
    },
    wc_sessionSettle: {
      req: { ttl: Vt.FIVE_MINUTES, prompt: !1, tag: 1102 },
      res: { ttl: Vt.FIVE_MINUTES, prompt: !1, tag: 1103 },
    },
    wc_sessionUpdate: {
      req: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1104 },
      res: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1105 },
    },
    wc_sessionExtend: {
      req: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1106 },
      res: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1107 },
    },
    wc_sessionRequest: {
      req: { ttl: Vt.FIVE_MINUTES, prompt: !0, tag: 1108 },
      res: { ttl: Vt.FIVE_MINUTES, prompt: !1, tag: 1109 },
    },
    wc_sessionEvent: {
      req: { ttl: Vt.FIVE_MINUTES, prompt: !0, tag: 1110 },
      res: { ttl: Vt.FIVE_MINUTES, prompt: !1, tag: 1111 },
    },
    wc_sessionDelete: {
      req: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1112 },
      res: { ttl: Vt.ONE_DAY, prompt: !1, tag: 1113 },
    },
    wc_sessionPing: {
      req: { ttl: Vt.THIRTY_SECONDS, prompt: !1, tag: 1114 },
      res: { ttl: Vt.THIRTY_SECONDS, prompt: !1, tag: 1115 },
    },
  },
  z8 = { min: Vt.FIVE_MINUTES, max: Vt.SEVEN_DAYS },
  xc = { idle: "IDLE", active: "ACTIVE" },
  fTe = "request",
  dTe = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var hTe = Object.defineProperty,
  pTe = Object.defineProperties,
  mTe = Object.getOwnPropertyDescriptors,
  AL = Object.getOwnPropertySymbols,
  gTe = Object.prototype.hasOwnProperty,
  yTe = Object.prototype.propertyIsEnumerable,
  CL = (t, e, n) =>
    e in t
      ? hTe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Ga = (t, e) => {
    for (var n in e || (e = {})) gTe.call(e, n) && CL(t, n, e[n]);
    if (AL) for (var n of AL(e)) yTe.call(e, n) && CL(t, n, e[n]);
    return t;
  },
  Sm = (t, e) => pTe(t, mTe(e));
class vTe extends QEe {
  constructor(e) {
    super(e),
      (this.name = cTe),
      (this.events = new ZT()),
      (this.initialized = !1),
      (this.ignoredPayloadTypes = [jh]),
      (this.requestQueue = { state: xc.idle, queue: [] }),
      (this.sessionRequestQueue = { state: xc.idle, queue: [] }),
      (this.requestQueueDelay = Vt.ONE_SECOND),
      (this.init = async () => {
        this.initialized ||
          (await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          this.registerPairingEvents(),
          this.client.core.pairing.register({ methods: Object.keys(Tm) }),
          (this.initialized = !0),
          setTimeout(() => {
            (this.sessionRequestQueue.queue = this.getPendingSessionRequests()),
              this.processSessionRequestQueue();
          }, Vt.toMiliseconds(this.requestQueueDelay)));
      }),
      (this.connect = async (n) => {
        await this.isInitialized();
        const r = Sm(Ga({}, n), {
          requiredNamespaces: n.requiredNamespaces || {},
          optionalNamespaces: n.optionalNamespaces || {},
        });
        await this.isValidConnect(r);
        const {
          pairingTopic: i,
          requiredNamespaces: s,
          optionalNamespaces: a,
          sessionProperties: o,
          relays: l,
        } = r;
        let u = i,
          f,
          c = !1;
        if (
          (u && (c = this.client.core.pairing.pairings.get(u).active), !u || !c)
        ) {
          const { topic: E, uri: S } = await this.client.core.pairing.create();
          (u = E), (f = S);
        }
        const d = await this.client.core.crypto.generateKeyPair(),
          p = Ga(
            {
              requiredNamespaces: s,
              optionalNamespaces: a,
              relays: l ?? [{ protocol: VW }],
              proposer: { publicKey: d, metadata: this.client.metadata },
            },
            o && { sessionProperties: o }
          ),
          { reject: m, resolve: g, done: w } = Pp(Vt.FIVE_MINUTES, XW);
        if (
          (this.events.once(
            Bi("session_connect"),
            async ({ error: E, session: S }) => {
              if (E) m(E);
              else if (S) {
                S.self.publicKey = d;
                const D = Sm(Ga({}, S), {
                  requiredNamespaces: S.requiredNamespaces,
                  optionalNamespaces: S.optionalNamespaces,
                });
                await this.client.session.set(S.topic, D),
                  await this.setExpiry(S.topic, S.expiry),
                  u &&
                    (await this.client.core.pairing.updateMetadata({
                      topic: u,
                      metadata: S.peer.metadata,
                    })),
                  g(D);
              }
            }
          ),
          !u)
        ) {
          const { message: E } = ut(
            "NO_MATCHING_KEY",
            `connect() pairing topic: ${u}`
          );
          throw new Error(E);
        }
        const y = await this.sendRequest({
            topic: u,
            method: "wc_sessionPropose",
            params: p,
          }),
          v = ql(Vt.FIVE_MINUTES);
        return (
          await this.setProposal(y, Ga({ id: y, expiry: v }, p)),
          { uri: f, approval: w }
        );
      }),
      (this.pair = async (n) => (
        await this.isInitialized(), await this.client.core.pairing.pair(n)
      )),
      (this.approve = async (n) => {
        await this.isInitialized(), await this.isValidApprove(n);
        const {
            id: r,
            relayProtocol: i,
            namespaces: s,
            sessionProperties: a,
          } = n,
          o = this.client.proposal.get(r);
        let {
          pairingTopic: l,
          proposer: u,
          requiredNamespaces: f,
          optionalNamespaces: c,
        } = o;
        (l = l || ""), _0(f) || (f = T4e(s, "approve()"));
        const d = await this.client.core.crypto.generateKeyPair(),
          p = u.publicKey,
          m = await this.client.core.crypto.generateSharedKey(d, p);
        l &&
          r &&
          (await this.client.core.pairing.updateMetadata({
            topic: l,
            metadata: u.metadata,
          }),
          await this.sendResult({
            id: r,
            topic: l,
            result: { relay: { protocol: i ?? "irn" }, responderPublicKey: d },
          }),
          await this.client.proposal.delete(r, ki("USER_DISCONNECTED")),
          await this.client.core.pairing.activate({ topic: l }));
        const g = Ga(
          {
            relay: { protocol: i ?? "irn" },
            namespaces: s,
            requiredNamespaces: f,
            optionalNamespaces: c,
            pairingTopic: l,
            controller: { publicKey: d, metadata: this.client.metadata },
            expiry: ql(Tv),
          },
          a && { sessionProperties: a }
        );
        await this.client.core.relayer.subscribe(m),
          await this.sendRequest({
            topic: m,
            method: "wc_sessionSettle",
            params: g,
            throwOnFailedPublish: !0,
          });
        const w = Sm(Ga({}, g), {
          topic: m,
          pairingTopic: l,
          acknowledged: !1,
          self: g.controller,
          peer: { publicKey: u.publicKey, metadata: u.metadata },
          controller: d,
        });
        return (
          await this.client.session.set(m, w),
          await this.setExpiry(m, ql(Tv)),
          {
            topic: m,
            acknowledged: () =>
              new Promise((y) =>
                setTimeout(() => y(this.client.session.get(m)), 500)
              ),
          }
        );
      }),
      (this.reject = async (n) => {
        await this.isInitialized(), await this.isValidReject(n);
        const { id: r, reason: i } = n,
          { pairingTopic: s } = this.client.proposal.get(r);
        s &&
          (await this.sendError(r, s, i),
          await this.client.proposal.delete(r, ki("USER_DISCONNECTED")));
      }),
      (this.update = async (n) => {
        await this.isInitialized(), await this.isValidUpdate(n);
        const { topic: r, namespaces: i } = n,
          s = await this.sendRequest({
            topic: r,
            method: "wc_sessionUpdate",
            params: { namespaces: i },
          }),
          { done: a, resolve: o, reject: l } = Pp();
        return (
          this.events.once(Bi("session_update", s), ({ error: u }) => {
            u ? l(u) : o();
          }),
          await this.client.session.update(r, { namespaces: i }),
          { acknowledged: a }
        );
      }),
      (this.extend = async (n) => {
        await this.isInitialized(), await this.isValidExtend(n);
        const { topic: r } = n,
          i = await this.sendRequest({
            topic: r,
            method: "wc_sessionExtend",
            params: {},
          }),
          { done: s, resolve: a, reject: o } = Pp();
        return (
          this.events.once(Bi("session_extend", i), ({ error: l }) => {
            l ? o(l) : a();
          }),
          await this.setExpiry(r, ql(Tv)),
          { acknowledged: s }
        );
      }),
      (this.request = async (n) => {
        await this.isInitialized(), await this.isValidRequest(n);
        const { chainId: r, request: i, topic: s, expiry: a } = n,
          o = cS(),
          {
            done: l,
            resolve: u,
            reject: f,
          } = Pp(a, "Request expired. Please try again.");
        return (
          this.events.once(
            Bi("session_request", o),
            ({ error: c, result: d }) => {
              c ? f(c) : u(d);
            }
          ),
          await Promise.all([
            new Promise(async (c) => {
              await this.sendRequest({
                clientRpcId: o,
                topic: s,
                method: "wc_sessionRequest",
                params: { request: i, chainId: r },
                expiry: a,
                throwOnFailedPublish: !0,
              }).catch((d) => f(d)),
                this.client.events.emit("session_request_sent", {
                  topic: s,
                  request: i,
                  chainId: r,
                  id: o,
                }),
                c();
            }),
            new Promise(async (c) => {
              const d = await f4e(this.client.core.storage, SL);
              c4e({ id: o, topic: s, wcDeepLink: d }), c();
            }),
            l(),
          ]).then((c) => c[2])
        );
      }),
      (this.respond = async (n) => {
        await this.isInitialized(), await this.isValidRespond(n);
        const { topic: r, response: i } = n,
          { id: s } = i;
        Ic(i)
          ? await this.sendResult({
              id: s,
              topic: r,
              result: i.result,
              throwOnFailedPublish: !0,
            })
          : Kl(i) && (await this.sendError(s, r, i.error)),
          this.cleanupAfterResponse(n);
      }),
      (this.ping = async (n) => {
        await this.isInitialized(), await this.isValidPing(n);
        const { topic: r } = n;
        if (this.client.session.keys.includes(r)) {
          const i = await this.sendRequest({
              topic: r,
              method: "wc_sessionPing",
              params: {},
            }),
            { done: s, resolve: a, reject: o } = Pp();
          this.events.once(Bi("session_ping", i), ({ error: l }) => {
            l ? o(l) : a();
          }),
            await s();
        } else
          this.client.core.pairing.pairings.keys.includes(r) &&
            (await this.client.core.pairing.ping({ topic: r }));
      }),
      (this.emit = async (n) => {
        await this.isInitialized(), await this.isValidEmit(n);
        const { topic: r, event: i, chainId: s } = n;
        await this.sendRequest({
          topic: r,
          method: "wc_sessionEvent",
          params: { event: i, chainId: s },
        });
      }),
      (this.disconnect = async (n) => {
        await this.isInitialized(), await this.isValidDisconnect(n);
        const { topic: r } = n;
        this.client.session.keys.includes(r)
          ? (await this.sendRequest({
              topic: r,
              method: "wc_sessionDelete",
              params: ki("USER_DISCONNECTED"),
              throwOnFailedPublish: !0,
            }),
            await this.deleteSession(r))
          : await this.client.core.pairing.disconnect({ topic: r });
      }),
      (this.find = (n) => (
        this.isInitialized(),
        this.client.session.getAll().filter((r) => C4e(r, n))
      )),
      (this.getPendingSessionRequests = () => (
        this.isInitialized(), this.client.pendingRequest.getAll()
      )),
      (this.cleanupDuplicatePairings = async (n) => {
        if (n.pairingTopic)
          try {
            const r = this.client.core.pairing.pairings.get(n.pairingTopic),
              i = this.client.core.pairing.pairings.getAll().filter((s) => {
                var a, o;
                return (
                  ((a = s.peerMetadata) == null ? void 0 : a.url) &&
                  ((o = s.peerMetadata) == null ? void 0 : o.url) ===
                    n.peer.metadata.url &&
                  s.topic &&
                  s.topic !== r.topic
                );
              });
            if (i.length === 0) return;
            this.client.logger.info(
              `Cleaning up ${i.length} duplicate pairing(s)`
            ),
              await Promise.all(
                i.map((s) =>
                  this.client.core.pairing.disconnect({ topic: s.topic })
                )
              ),
              this.client.logger.info("Duplicate pairings clean up finished");
          } catch (r) {
            this.client.logger.error(r);
          }
      }),
      (this.deleteSession = async (n, r) => {
        const { self: i } = this.client.session.get(n);
        await this.client.core.relayer.unsubscribe(n),
          this.client.session.delete(n, ki("USER_DISCONNECTED")),
          this.client.core.crypto.keychain.has(i.publicKey) &&
            (await this.client.core.crypto.deleteKeyPair(i.publicKey)),
          this.client.core.crypto.keychain.has(n) &&
            (await this.client.core.crypto.deleteSymKey(n)),
          r || this.client.core.expirer.del(n),
          this.client.core.storage
            .removeItem(SL)
            .catch((s) => this.client.logger.warn(s));
      }),
      (this.deleteProposal = async (n, r) => {
        await Promise.all([
          this.client.proposal.delete(n, ki("USER_DISCONNECTED")),
          r ? Promise.resolve() : this.client.core.expirer.del(n),
        ]);
      }),
      (this.deletePendingSessionRequest = async (n, r, i = !1) => {
        await Promise.all([
          this.client.pendingRequest.delete(n, r),
          i ? Promise.resolve() : this.client.core.expirer.del(n),
        ]),
          (this.sessionRequestQueue.queue =
            this.sessionRequestQueue.queue.filter((s) => s.id !== n)),
          i && (this.sessionRequestQueue.state = xc.idle);
      }),
      (this.setExpiry = async (n, r) => {
        this.client.session.keys.includes(n) &&
          (await this.client.session.update(n, { expiry: r })),
          this.client.core.expirer.set(n, r);
      }),
      (this.setProposal = async (n, r) => {
        await this.client.proposal.set(n, r),
          this.client.core.expirer.set(n, r.expiry);
      }),
      (this.setPendingSessionRequest = async (n) => {
        const r = Tm.wc_sessionRequest.req.ttl,
          { id: i, topic: s, params: a, verifyContext: o } = n;
        await this.client.pendingRequest.set(i, {
          id: i,
          topic: s,
          params: a,
          verifyContext: o,
        }),
          r && this.client.core.expirer.set(i, ql(r));
      }),
      (this.sendRequest = async (n) => {
        const {
            topic: r,
            method: i,
            params: s,
            expiry: a,
            relayRpcId: o,
            clientRpcId: l,
            throwOnFailedPublish: u,
          } = n,
          f = E0(i, s, l);
        if (I1() && dTe.includes(i)) {
          const p = w0(JSON.stringify(f));
          this.client.core.verify.register({ attestationId: p });
        }
        const c = await this.client.core.crypto.encode(r, f),
          d = Tm[i].req;
        return (
          a && (d.ttl = a),
          o && (d.id = o),
          this.client.core.history.set(r, f),
          u
            ? ((d.internal = Sm(Ga({}, d.internal), {
                throwOnFailedPublish: !0,
              })),
              await this.client.core.relayer.publish(r, c, d))
            : this.client.core.relayer
                .publish(r, c, d)
                .catch((p) => this.client.logger.error(p)),
          f.id
        );
      }),
      (this.sendResult = async (n) => {
        const { id: r, topic: i, result: s, throwOnFailedPublish: a } = n,
          o = fS(r, s),
          l = await this.client.core.crypto.encode(i, o),
          u = await this.client.core.history.get(i, r),
          f = Tm[u.request.method].res;
        a
          ? ((f.internal = Sm(Ga({}, f.internal), {
              throwOnFailedPublish: !0,
            })),
            await this.client.core.relayer.publish(i, l, f))
          : this.client.core.relayer
              .publish(i, l, f)
              .catch((c) => this.client.logger.error(c)),
          await this.client.core.history.resolve(o);
      }),
      (this.sendError = async (n, r, i) => {
        const s = y6(n, i),
          a = await this.client.core.crypto.encode(r, s),
          o = await this.client.core.history.get(r, n),
          l = Tm[o.request.method].res;
        this.client.core.relayer.publish(r, a, l),
          await this.client.core.history.resolve(s);
      }),
      (this.cleanup = async () => {
        const n = [],
          r = [];
        this.client.session.getAll().forEach((i) => {
          Rf(i.expiry) && n.push(i.topic);
        }),
          this.client.proposal.getAll().forEach((i) => {
            Rf(i.expiry) && r.push(i.id);
          }),
          await Promise.all([
            ...n.map((i) => this.deleteSession(i)),
            ...r.map((i) => this.deleteProposal(i)),
          ]);
      }),
      (this.onRelayEventRequest = async (n) => {
        this.requestQueue.queue.push(n), await this.processRequestsQueue();
      }),
      (this.processRequestsQueue = async () => {
        if (this.requestQueue.state === xc.active) {
          this.client.logger.info("Request queue already active, skipping...");
          return;
        }
        for (
          this.client.logger.info(
            `Request queue starting with ${this.requestQueue.queue.length} requests`
          );
          this.requestQueue.queue.length > 0;

        ) {
          this.requestQueue.state = xc.active;
          const n = this.requestQueue.queue.shift();
          if (n)
            try {
              this.processRequest(n),
                await new Promise((r) => setTimeout(r, 300));
            } catch (r) {
              this.client.logger.warn(r);
            }
        }
        this.requestQueue.state = xc.idle;
      }),
      (this.processRequest = (n) => {
        const { topic: r, payload: i } = n,
          s = i.method;
        switch (s) {
          case "wc_sessionPropose":
            return this.onSessionProposeRequest(r, i);
          case "wc_sessionSettle":
            return this.onSessionSettleRequest(r, i);
          case "wc_sessionUpdate":
            return this.onSessionUpdateRequest(r, i);
          case "wc_sessionExtend":
            return this.onSessionExtendRequest(r, i);
          case "wc_sessionPing":
            return this.onSessionPingRequest(r, i);
          case "wc_sessionDelete":
            return this.onSessionDeleteRequest(r, i);
          case "wc_sessionRequest":
            return this.onSessionRequest(r, i);
          case "wc_sessionEvent":
            return this.onSessionEventRequest(r, i);
          default:
            return this.client.logger.info(`Unsupported request method ${s}`);
        }
      }),
      (this.onRelayEventResponse = async (n) => {
        const { topic: r, payload: i } = n,
          s = (await this.client.core.history.get(r, i.id)).request.method;
        switch (s) {
          case "wc_sessionPropose":
            return this.onSessionProposeResponse(r, i);
          case "wc_sessionSettle":
            return this.onSessionSettleResponse(r, i);
          case "wc_sessionUpdate":
            return this.onSessionUpdateResponse(r, i);
          case "wc_sessionExtend":
            return this.onSessionExtendResponse(r, i);
          case "wc_sessionPing":
            return this.onSessionPingResponse(r, i);
          case "wc_sessionRequest":
            return this.onSessionRequestResponse(r, i);
          default:
            return this.client.logger.info(`Unsupported response method ${s}`);
        }
      }),
      (this.onRelayEventUnknownPayload = (n) => {
        const { topic: r } = n,
          { message: i } = ut(
            "MISSING_OR_INVALID",
            `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`
          );
        throw new Error(i);
      }),
      (this.onSessionProposeRequest = async (n, r) => {
        const { params: i, id: s } = r;
        try {
          this.isValidConnect(Ga({}, r.params));
          const a = ql(Vt.FIVE_MINUTES),
            o = Ga({ id: s, pairingTopic: n, expiry: a }, i);
          await this.setProposal(s, o);
          const l = w0(JSON.stringify(r)),
            u = await this.getVerifyContext(l, o.proposer.metadata);
          this.client.events.emit("session_proposal", {
            id: s,
            params: o,
            verifyContext: u,
          });
        } catch (a) {
          await this.sendError(s, n, a), this.client.logger.error(a);
        }
      }),
      (this.onSessionProposeResponse = async (n, r) => {
        const { id: i } = r;
        if (Ic(r)) {
          const { result: s } = r;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            result: s,
          });
          const a = this.client.proposal.get(i);
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            proposal: a,
          });
          const o = a.proposer.publicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            selfPublicKey: o,
          });
          const l = s.responderPublicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            peerPublicKey: l,
          });
          const u = await this.client.core.crypto.generateSharedKey(o, l);
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            sessionTopic: u,
          });
          const f = await this.client.core.relayer.subscribe(u);
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            subscriptionId: f,
          }),
            await this.client.core.pairing.activate({ topic: n });
        } else
          Kl(r) &&
            (await this.client.proposal.delete(i, ki("USER_DISCONNECTED")),
            this.events.emit(Bi("session_connect"), { error: r.error }));
      }),
      (this.onSessionSettleRequest = async (n, r) => {
        const { id: i, params: s } = r;
        try {
          this.isValidSessionSettleRequest(s);
          const {
              relay: a,
              controller: o,
              expiry: l,
              namespaces: u,
              requiredNamespaces: f,
              optionalNamespaces: c,
              sessionProperties: d,
              pairingTopic: p,
            } = r.params,
            m = Ga(
              {
                topic: n,
                relay: a,
                expiry: l,
                namespaces: u,
                acknowledged: !0,
                pairingTopic: p,
                requiredNamespaces: f,
                optionalNamespaces: c,
                controller: o.publicKey,
                self: { publicKey: "", metadata: this.client.metadata },
                peer: { publicKey: o.publicKey, metadata: o.metadata },
              },
              d && { sessionProperties: d }
            );
          await this.sendResult({ id: r.id, topic: n, result: !0 }),
            this.events.emit(Bi("session_connect"), { session: m }),
            this.cleanupDuplicatePairings(m);
        } catch (a) {
          await this.sendError(i, n, a), this.client.logger.error(a);
        }
      }),
      (this.onSessionSettleResponse = async (n, r) => {
        const { id: i } = r;
        Ic(r)
          ? (await this.client.session.update(n, { acknowledged: !0 }),
            this.events.emit(Bi("session_approve", i), {}))
          : Kl(r) &&
            (await this.client.session.delete(n, ki("USER_DISCONNECTED")),
            this.events.emit(Bi("session_approve", i), { error: r.error }));
      }),
      (this.onSessionUpdateRequest = async (n, r) => {
        const { params: i, id: s } = r;
        try {
          const a = `${n}_session_update`,
            o = _v.get(a);
          if (o && this.isRequestOutOfSync(o, s)) {
            this.client.logger.info(`Discarding out of sync request - ${s}`);
            return;
          }
          this.isValidUpdate(Ga({ topic: n }, i)),
            await this.client.session.update(n, { namespaces: i.namespaces }),
            await this.sendResult({ id: s, topic: n, result: !0 }),
            this.client.events.emit("session_update", {
              id: s,
              topic: n,
              params: i,
            }),
            _v.set(a, s);
        } catch (a) {
          await this.sendError(s, n, a), this.client.logger.error(a);
        }
      }),
      (this.isRequestOutOfSync = (n, r) =>
        parseInt(r.toString().slice(0, -3)) <=
        parseInt(n.toString().slice(0, -3))),
      (this.onSessionUpdateResponse = (n, r) => {
        const { id: i } = r;
        Ic(r)
          ? this.events.emit(Bi("session_update", i), {})
          : Kl(r) &&
            this.events.emit(Bi("session_update", i), { error: r.error });
      }),
      (this.onSessionExtendRequest = async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidExtend({ topic: n }),
            await this.setExpiry(n, ql(Tv)),
            await this.sendResult({ id: i, topic: n, result: !0 }),
            this.client.events.emit("session_extend", { id: i, topic: n });
        } catch (s) {
          await this.sendError(i, n, s), this.client.logger.error(s);
        }
      }),
      (this.onSessionExtendResponse = (n, r) => {
        const { id: i } = r;
        Ic(r)
          ? this.events.emit(Bi("session_extend", i), {})
          : Kl(r) &&
            this.events.emit(Bi("session_extend", i), { error: r.error });
      }),
      (this.onSessionPingRequest = async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidPing({ topic: n }),
            await this.sendResult({ id: i, topic: n, result: !0 }),
            this.client.events.emit("session_ping", { id: i, topic: n });
        } catch (s) {
          await this.sendError(i, n, s), this.client.logger.error(s);
        }
      }),
      (this.onSessionPingResponse = (n, r) => {
        const { id: i } = r;
        setTimeout(() => {
          Ic(r)
            ? this.events.emit(Bi("session_ping", i), {})
            : Kl(r) &&
              this.events.emit(Bi("session_ping", i), { error: r.error });
        }, 500);
      }),
      (this.onSessionDeleteRequest = async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidDisconnect({ topic: n, reason: r.params }),
            await Promise.all([
              new Promise((s) => {
                this.client.core.relayer.once(ta.publish, async () => {
                  s(await this.deleteSession(n));
                });
              }),
              this.sendResult({ id: i, topic: n, result: !0 }),
            ]),
            this.client.events.emit("session_delete", { id: i, topic: n });
        } catch (s) {
          this.client.logger.error(s);
        }
      }),
      (this.onSessionRequest = async (n, r) => {
        const { id: i, params: s } = r;
        try {
          this.isValidRequest(Ga({ topic: n }, s));
          const a = w0(JSON.stringify(E0("wc_sessionRequest", s, i))),
            o = this.client.session.get(n),
            l = await this.getVerifyContext(a, o.peer.metadata),
            u = { id: i, topic: n, params: s, verifyContext: l };
          await this.setPendingSessionRequest(u),
            this.addSessionRequestToSessionRequestQueue(u),
            this.processSessionRequestQueue();
        } catch (a) {
          await this.sendError(i, n, a), this.client.logger.error(a);
        }
      }),
      (this.onSessionRequestResponse = (n, r) => {
        const { id: i } = r;
        Ic(r)
          ? this.events.emit(Bi("session_request", i), { result: r.result })
          : Kl(r) &&
            this.events.emit(Bi("session_request", i), { error: r.error });
      }),
      (this.onSessionEventRequest = async (n, r) => {
        const { id: i, params: s } = r;
        try {
          const a = `${n}_session_event_${s.event.name}`,
            o = _v.get(a);
          if (o && this.isRequestOutOfSync(o, i)) {
            this.client.logger.info(`Discarding out of sync request - ${i}`);
            return;
          }
          this.isValidEmit(Ga({ topic: n }, s)),
            this.client.events.emit("session_event", {
              id: i,
              topic: n,
              params: s,
            }),
            _v.set(a, i);
        } catch (a) {
          await this.sendError(i, n, a), this.client.logger.error(a);
        }
      }),
      (this.addSessionRequestToSessionRequestQueue = (n) => {
        this.sessionRequestQueue.queue.push(n);
      }),
      (this.cleanupAfterResponse = (n) => {
        this.deletePendingSessionRequest(n.response.id, {
          message: "fulfilled",
          code: 0,
        }),
          setTimeout(() => {
            (this.sessionRequestQueue.state = xc.idle),
              this.processSessionRequestQueue();
          }, Vt.toMiliseconds(this.requestQueueDelay));
      }),
      (this.processSessionRequestQueue = () => {
        if (this.sessionRequestQueue.state === xc.active) {
          this.client.logger.info("session request queue is already active.");
          return;
        }
        const n = this.sessionRequestQueue.queue[0];
        if (!n) {
          this.client.logger.info("session request queue is empty.");
          return;
        }
        try {
          (this.sessionRequestQueue.state = xc.active),
            this.client.events.emit("session_request", n);
        } catch (r) {
          this.client.logger.error(r);
        }
      }),
      (this.onPairingCreated = (n) => {
        if (n.active) return;
        const r = this.client.proposal
          .getAll()
          .find((i) => i.pairingTopic === n.topic);
        r &&
          this.onSessionProposeRequest(
            n.topic,
            E0(
              "wc_sessionPropose",
              {
                requiredNamespaces: r.requiredNamespaces,
                optionalNamespaces: r.optionalNamespaces,
                relays: r.relays,
                proposer: r.proposer,
                sessionProperties: r.sessionProperties,
              },
              r.id
            )
          );
      }),
      (this.isValidConnect = async (n) => {
        if (!Ka(n)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `connect() params: ${JSON.stringify(n)}`
          );
          throw new Error(l);
        }
        const {
          pairingTopic: r,
          requiredNamespaces: i,
          optionalNamespaces: s,
          sessionProperties: a,
          relays: o,
        } = n;
        if ((ba(r) || (await this.isValidPairingTopic(r)), !$4e(o, !0))) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `connect() relays: ${o}`
          );
          throw new Error(l);
        }
        !ba(i) &&
          _0(i) !== 0 &&
          this.validateNamespaces(i, "requiredNamespaces"),
          !ba(s) &&
            _0(s) !== 0 &&
            this.validateNamespaces(s, "optionalNamespaces"),
          ba(a) || this.validateSessionProps(a, "sessionProperties");
      }),
      (this.validateNamespaces = (n, r) => {
        const i = F4e(n, "connect()", r);
        if (i) throw new Error(i.message);
      }),
      (this.isValidApprove = async (n) => {
        if (!Ka(n))
          throw new Error(
            ut("MISSING_OR_INVALID", `approve() params: ${n}`).message
          );
        const {
          id: r,
          namespaces: i,
          relayProtocol: s,
          sessionProperties: a,
        } = n;
        await this.isValidProposalId(r);
        const o = this.client.proposal.get(r),
          l = gb(i, "approve()");
        if (l) throw new Error(l.message);
        const u = LM(o.requiredNamespaces, i, "approve()");
        if (u) throw new Error(u.message);
        if (!Es(s, !0)) {
          const { message: f } = ut(
            "MISSING_OR_INVALID",
            `approve() relayProtocol: ${s}`
          );
          throw new Error(f);
        }
        ba(a) || this.validateSessionProps(a, "sessionProperties");
      }),
      (this.isValidReject = async (n) => {
        if (!Ka(n)) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `reject() params: ${n}`
          );
          throw new Error(s);
        }
        const { id: r, reason: i } = n;
        if ((await this.isValidProposalId(r), !j4e(i))) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `reject() reason: ${JSON.stringify(i)}`
          );
          throw new Error(s);
        }
      }),
      (this.isValidSessionSettleRequest = (n) => {
        if (!Ka(n)) {
          const { message: u } = ut(
            "MISSING_OR_INVALID",
            `onSessionSettleRequest() params: ${n}`
          );
          throw new Error(u);
        }
        const { relay: r, controller: i, namespaces: s, expiry: a } = n;
        if (!mW(r)) {
          const { message: u } = ut(
            "MISSING_OR_INVALID",
            "onSessionSettleRequest() relay protocol should be a string"
          );
          throw new Error(u);
        }
        const o = N4e(i, "onSessionSettleRequest()");
        if (o) throw new Error(o.message);
        const l = gb(s, "onSessionSettleRequest()");
        if (l) throw new Error(l.message);
        if (Rf(a)) {
          const { message: u } = ut("EXPIRED", "onSessionSettleRequest()");
          throw new Error(u);
        }
      }),
      (this.isValidUpdate = async (n) => {
        if (!Ka(n)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `update() params: ${n}`
          );
          throw new Error(l);
        }
        const { topic: r, namespaces: i } = n;
        await this.isValidSessionTopic(r);
        const s = this.client.session.get(r),
          a = gb(i, "update()");
        if (a) throw new Error(a.message);
        const o = LM(s.requiredNamespaces, i, "update()");
        if (o) throw new Error(o.message);
      }),
      (this.isValidExtend = async (n) => {
        if (!Ka(n)) {
          const { message: i } = ut(
            "MISSING_OR_INVALID",
            `extend() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidSessionTopic(r);
      }),
      (this.isValidRequest = async (n) => {
        if (!Ka(n)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `request() params: ${n}`
          );
          throw new Error(l);
        }
        const { topic: r, request: i, chainId: s, expiry: a } = n;
        await this.isValidSessionTopic(r);
        const { namespaces: o } = this.client.session.get(r);
        if (!MM(o, s)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `request() chainId: ${s}`
          );
          throw new Error(l);
        }
        if (!H4e(i)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `request() ${JSON.stringify(i)}`
          );
          throw new Error(l);
        }
        if (!G4e(o, s, i.method)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `request() method: ${i.method}`
          );
          throw new Error(l);
        }
        if (a && !X4e(a, z8)) {
          const { message: l } = ut(
            "MISSING_OR_INVALID",
            `request() expiry: ${a}. Expiry must be a number (in seconds) between ${z8.min} and ${z8.max}`
          );
          throw new Error(l);
        }
      }),
      (this.isValidRespond = async (n) => {
        if (!Ka(n)) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `respond() params: ${n}`
          );
          throw new Error(s);
        }
        const { topic: r, response: i } = n;
        if ((await this.isValidSessionTopic(r), !z4e(i))) {
          const { message: s } = ut(
            "MISSING_OR_INVALID",
            `respond() response: ${JSON.stringify(i)}`
          );
          throw new Error(s);
        }
      }),
      (this.isValidPing = async (n) => {
        if (!Ka(n)) {
          const { message: i } = ut(
            "MISSING_OR_INVALID",
            `ping() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidSessionOrPairingTopic(r);
      }),
      (this.isValidEmit = async (n) => {
        if (!Ka(n)) {
          const { message: o } = ut(
            "MISSING_OR_INVALID",
            `emit() params: ${n}`
          );
          throw new Error(o);
        }
        const { topic: r, event: i, chainId: s } = n;
        await this.isValidSessionTopic(r);
        const { namespaces: a } = this.client.session.get(r);
        if (!MM(a, s)) {
          const { message: o } = ut(
            "MISSING_OR_INVALID",
            `emit() chainId: ${s}`
          );
          throw new Error(o);
        }
        if (!V4e(i)) {
          const { message: o } = ut(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(i)}`
          );
          throw new Error(o);
        }
        if (!W4e(a, s, i.name)) {
          const { message: o } = ut(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(i)}`
          );
          throw new Error(o);
        }
      }),
      (this.isValidDisconnect = async (n) => {
        if (!Ka(n)) {
          const { message: i } = ut(
            "MISSING_OR_INVALID",
            `disconnect() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidSessionOrPairingTopic(r);
      }),
      (this.getVerifyContext = async (n, r) => {
        const i = {
          verified: {
            verifyUrl: r.verifyUrl || Qp,
            validation: "UNKNOWN",
            origin: r.url || "",
          },
        };
        try {
          const s = await this.client.core.verify.resolve({
            attestationId: n,
            verifyUrl: r.verifyUrl,
          });
          s &&
            ((i.verified.origin = s.origin),
            (i.verified.isScam = s.isScam),
            (i.verified.validation =
              s.origin === new URL(r.url).origin ? "VALID" : "INVALID"));
        } catch (s) {
          this.client.logger.info(s);
        }
        return (
          this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i
        );
      }),
      (this.validateSessionProps = (n, r) => {
        Object.values(n).forEach((i) => {
          if (!Es(i, !1)) {
            const { message: s } = ut(
              "MISSING_OR_INVALID",
              `${r} must be in Record<string, string> format. Received: ${JSON.stringify(
                i
              )}`
            );
            throw new Error(s);
          }
        });
      });
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = ut("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(ta.message, async (e) => {
      const { topic: n, message: r } = e;
      if (
        this.ignoredPayloadTypes.includes(
          this.client.core.crypto.getPayloadType(r)
        )
      )
        return;
      const i = await this.client.core.crypto.decode(n, r);
      try {
        dS(i)
          ? (this.client.core.history.set(n, i),
            this.onRelayEventRequest({ topic: n, payload: i }))
          : v6(i)
          ? (await this.client.core.history.resolve(i),
            await this.onRelayEventResponse({ topic: n, payload: i }),
            this.client.core.history.delete(n, i.id))
          : this.onRelayEventUnknownPayload({ topic: n, payload: i });
      } catch (s) {
        this.client.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(sl.expired, async (e) => {
      const { topic: n, id: r } = hW(e.target);
      if (r && this.client.pendingRequest.keys.includes(r))
        return await this.deletePendingSessionRequest(r, ut("EXPIRED"), !0);
      n
        ? this.client.session.keys.includes(n) &&
          (await this.deleteSession(n, !0),
          this.client.events.emit("session_expire", { topic: n }))
        : r &&
          (await this.deleteProposal(r, !0),
          this.client.events.emit("proposal_expire", { id: r }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Km.create, (e) =>
      this.onPairingCreated(e)
    );
  }
  isValidPairingTopic(e) {
    if (!Es(e, !1)) {
      const { message: n } = ut(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${e}`
      );
      throw new Error(n);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: n } = ut(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (Rf(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: n } = ut("EXPIRED", `pairing topic: ${e}`);
      throw new Error(n);
    }
  }
  async isValidSessionTopic(e) {
    if (!Es(e, !1)) {
      const { message: n } = ut(
        "MISSING_OR_INVALID",
        `session topic should be a string: ${e}`
      );
      throw new Error(n);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: n } = ut(
        "NO_MATCHING_KEY",
        `session topic doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (Rf(this.client.session.get(e).expiry)) {
      await this.deleteSession(e);
      const { message: n } = ut("EXPIRED", `session topic: ${e}`);
      throw new Error(n);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (Es(e, !1)) {
      const { message: n } = ut(
        "NO_MATCHING_KEY",
        `session or pairing topic doesn't exist: ${e}`
      );
      throw new Error(n);
    } else {
      const { message: n } = ut(
        "MISSING_OR_INVALID",
        `session or pairing topic should be a string: ${e}`
      );
      throw new Error(n);
    }
  }
  async isValidProposalId(e) {
    if (!U4e(e)) {
      const { message: n } = ut(
        "MISSING_OR_INVALID",
        `proposal id should be a number: ${e}`
      );
      throw new Error(n);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: n } = ut(
        "NO_MATCHING_KEY",
        `proposal id doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (Rf(this.client.proposal.get(e).expiry)) {
      await this.deleteProposal(e);
      const { message: n } = ut("EXPIRED", `proposal id: ${e}`);
      throw new Error(n);
    }
  }
}
class bTe extends w6 {
  constructor(e, n) {
    super(e, n, lTe, mS), (this.core = e), (this.logger = n);
  }
}
class wTe extends w6 {
  constructor(e, n) {
    super(e, n, uTe, mS), (this.core = e), (this.logger = n);
  }
}
class _Te extends w6 {
  constructor(e, n) {
    super(e, n, fTe, mS, (r) => r.id), (this.core = e), (this.logger = n);
  }
}
let ETe = class ZW extends YEe {
  constructor(e) {
    super(e),
      (this.protocol = WW),
      (this.version = qW),
      (this.name = H8.name),
      (this.events = new Fo.EventEmitter()),
      (this.on = (r, i) => this.events.on(r, i)),
      (this.once = (r, i) => this.events.once(r, i)),
      (this.off = (r, i) => this.events.off(r, i)),
      (this.removeListener = (r, i) => this.events.removeListener(r, i)),
      (this.removeAllListeners = (r) => this.events.removeAllListeners(r)),
      (this.connect = async (r) => {
        try {
          return await this.engine.connect(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.pair = async (r) => {
        try {
          return await this.engine.pair(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.approve = async (r) => {
        try {
          return await this.engine.approve(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.reject = async (r) => {
        try {
          return await this.engine.reject(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.update = async (r) => {
        try {
          return await this.engine.update(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.extend = async (r) => {
        try {
          return await this.engine.extend(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.request = async (r) => {
        try {
          return await this.engine.request(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.respond = async (r) => {
        try {
          return await this.engine.respond(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.ping = async (r) => {
        try {
          return await this.engine.ping(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.emit = async (r) => {
        try {
          return await this.engine.emit(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.disconnect = async (r) => {
        try {
          return await this.engine.disconnect(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.find = (r) => {
        try {
          return this.engine.find(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.getPendingSessionRequests = () => {
        try {
          return this.engine.getPendingSessionRequests();
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      (this.name = e?.name || H8.name),
      (this.metadata = e?.metadata || r4e());
    const n =
      typeof e?.logger < "u" && typeof e?.logger != "string"
        ? e.logger
        : Qn.pino(
            Qn.getDefaultLoggerOptions({ level: e?.logger || H8.logger })
          );
    (this.core = e?.core || new oTe(e)),
      (this.logger = Qn.generateChildLogger(n, this.name)),
      (this.session = new wTe(this.core, this.logger)),
      (this.proposal = new bTe(this.core, this.logger)),
      (this.pendingRequest = new _Te(this.core, this.logger)),
      (this.engine = new vTe(this));
  }
  static async init(e) {
    const n = new ZW(e);
    return await n.initialize(), n;
  }
  get context() {
    return Qn.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(),
        await this.session.init(),
        await this.proposal.init(),
        await this.pendingRequest.init(),
        await this.engine.init(),
        this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }),
        this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw (
        (this.logger.info("SignClient Initialization Failure"),
        this.logger.error(e.message),
        e)
      );
    }
  }
};
var qx = { exports: {} };
(function (t, e) {
  var n = typeof self < "u" ? self : Ur,
    r = (function () {
      function s() {
        (this.fetch = !1), (this.DOMException = n.DOMException);
      }
      return (s.prototype = n), new s();
    })();
  (function (s) {
    (function (a) {
      var o = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob:
          "FileReader" in s &&
          "Blob" in s &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s,
      };
      function l(I) {
        return I && DataView.prototype.isPrototypeOf(I);
      }
      if (o.arrayBuffer)
        var u = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]",
          ],
          f =
            ArrayBuffer.isView ||
            function (I) {
              return I && u.indexOf(Object.prototype.toString.call(I)) > -1;
            };
      function c(I) {
        if (
          (typeof I != "string" && (I = String(I)),
          /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(I))
        )
          throw new TypeError("Invalid character in header field name");
        return I.toLowerCase();
      }
      function d(I) {
        return typeof I != "string" && (I = String(I)), I;
      }
      function p(I) {
        var k = {
          next: function () {
            var L = I.shift();
            return { done: L === void 0, value: L };
          },
        };
        return (
          o.iterable &&
            (k[Symbol.iterator] = function () {
              return k;
            }),
          k
        );
      }
      function m(I) {
        (this.map = {}),
          I instanceof m
            ? I.forEach(function (k, L) {
                this.append(L, k);
              }, this)
            : Array.isArray(I)
            ? I.forEach(function (k) {
                this.append(k[0], k[1]);
              }, this)
            : I &&
              Object.getOwnPropertyNames(I).forEach(function (k) {
                this.append(k, I[k]);
              }, this);
      }
      (m.prototype.append = function (I, k) {
        (I = c(I)), (k = d(k));
        var L = this.map[I];
        this.map[I] = L ? L + ", " + k : k;
      }),
        (m.prototype.delete = function (I) {
          delete this.map[c(I)];
        }),
        (m.prototype.get = function (I) {
          return (I = c(I)), this.has(I) ? this.map[I] : null;
        }),
        (m.prototype.has = function (I) {
          return this.map.hasOwnProperty(c(I));
        }),
        (m.prototype.set = function (I, k) {
          this.map[c(I)] = d(k);
        }),
        (m.prototype.forEach = function (I, k) {
          for (var L in this.map)
            this.map.hasOwnProperty(L) && I.call(k, this.map[L], L, this);
        }),
        (m.prototype.keys = function () {
          var I = [];
          return (
            this.forEach(function (k, L) {
              I.push(L);
            }),
            p(I)
          );
        }),
        (m.prototype.values = function () {
          var I = [];
          return (
            this.forEach(function (k) {
              I.push(k);
            }),
            p(I)
          );
        }),
        (m.prototype.entries = function () {
          var I = [];
          return (
            this.forEach(function (k, L) {
              I.push([L, k]);
            }),
            p(I)
          );
        }),
        o.iterable && (m.prototype[Symbol.iterator] = m.prototype.entries);
      function g(I) {
        if (I.bodyUsed) return Promise.reject(new TypeError("Already read"));
        I.bodyUsed = !0;
      }
      function w(I) {
        return new Promise(function (k, L) {
          (I.onload = function () {
            k(I.result);
          }),
            (I.onerror = function () {
              L(I.error);
            });
        });
      }
      function y(I) {
        var k = new FileReader(),
          L = w(k);
        return k.readAsArrayBuffer(I), L;
      }
      function v(I) {
        var k = new FileReader(),
          L = w(k);
        return k.readAsText(I), L;
      }
      function E(I) {
        for (
          var k = new Uint8Array(I), L = new Array(k.length), U = 0;
          U < k.length;
          U++
        )
          L[U] = String.fromCharCode(k[U]);
        return L.join("");
      }
      function S(I) {
        if (I.slice) return I.slice(0);
        var k = new Uint8Array(I.byteLength);
        return k.set(new Uint8Array(I)), k.buffer;
      }
      function D() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (I) {
            (this._bodyInit = I),
              I
                ? typeof I == "string"
                  ? (this._bodyText = I)
                  : o.blob && Blob.prototype.isPrototypeOf(I)
                  ? (this._bodyBlob = I)
                  : o.formData && FormData.prototype.isPrototypeOf(I)
                  ? (this._bodyFormData = I)
                  : o.searchParams && URLSearchParams.prototype.isPrototypeOf(I)
                  ? (this._bodyText = I.toString())
                  : o.arrayBuffer && o.blob && l(I)
                  ? ((this._bodyArrayBuffer = S(I.buffer)),
                    (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : o.arrayBuffer &&
                    (ArrayBuffer.prototype.isPrototypeOf(I) || f(I))
                  ? (this._bodyArrayBuffer = S(I))
                  : (this._bodyText = I = Object.prototype.toString.call(I))
                : (this._bodyText = ""),
              this.headers.get("content-type") ||
                (typeof I == "string"
                  ? this.headers.set("content-type", "text/plain;charset=UTF-8")
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set("content-type", this._bodyBlob.type)
                  : o.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(I) &&
                    this.headers.set(
                      "content-type",
                      "application/x-www-form-urlencoded;charset=UTF-8"
                    ));
          }),
          o.blob &&
            ((this.blob = function () {
              var I = g(this);
              if (I) return I;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer
                ? g(this) || Promise.resolve(this._bodyArrayBuffer)
                : this.blob().then(y);
            })),
          (this.text = function () {
            var I = g(this);
            if (I) return I;
            if (this._bodyBlob) return v(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(E(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }),
          o.formData &&
            (this.formData = function () {
              return this.text().then(A);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var P = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function x(I) {
        var k = I.toUpperCase();
        return P.indexOf(k) > -1 ? k : I;
      }
      function _(I, k) {
        k = k || {};
        var L = k.body;
        if (I instanceof _) {
          if (I.bodyUsed) throw new TypeError("Already read");
          (this.url = I.url),
            (this.credentials = I.credentials),
            k.headers || (this.headers = new m(I.headers)),
            (this.method = I.method),
            (this.mode = I.mode),
            (this.signal = I.signal),
            !L && I._bodyInit != null && ((L = I._bodyInit), (I.bodyUsed = !0));
        } else this.url = String(I);
        if (
          ((this.credentials =
            k.credentials || this.credentials || "same-origin"),
          (k.headers || !this.headers) && (this.headers = new m(k.headers)),
          (this.method = x(k.method || this.method || "GET")),
          (this.mode = k.mode || this.mode || null),
          (this.signal = k.signal || this.signal),
          (this.referrer = null),
          (this.method === "GET" || this.method === "HEAD") && L)
        )
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(L);
      }
      _.prototype.clone = function () {
        return new _(this, { body: this._bodyInit });
      };
      function A(I) {
        var k = new FormData();
        return (
          I.trim()
            .split("&")
            .forEach(function (L) {
              if (L) {
                var U = L.split("="),
                  $ = U.shift().replace(/\+/g, " "),
                  B = U.join("=").replace(/\+/g, " ");
                k.append(decodeURIComponent($), decodeURIComponent(B));
              }
            }),
          k
        );
      }
      function N(I) {
        var k = new m(),
          L = I.replace(/\r?\n[\t ]+/g, " ");
        return (
          L.split(/\r?\n/).forEach(function (U) {
            var $ = U.split(":"),
              B = $.shift().trim();
            if (B) {
              var R = $.join(":").trim();
              k.append(B, R);
            }
          }),
          k
        );
      }
      D.call(_.prototype);
      function M(I, k) {
        k || (k = {}),
          (this.type = "default"),
          (this.status = k.status === void 0 ? 200 : k.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = "statusText" in k ? k.statusText : "OK"),
          (this.headers = new m(k.headers)),
          (this.url = k.url || ""),
          this._initBody(I);
      }
      D.call(M.prototype),
        (M.prototype.clone = function () {
          return new M(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new m(this.headers),
            url: this.url,
          });
        }),
        (M.error = function () {
          var I = new M(null, { status: 0, statusText: "" });
          return (I.type = "error"), I;
        });
      var T = [301, 302, 303, 307, 308];
      (M.redirect = function (I, k) {
        if (T.indexOf(k) === -1) throw new RangeError("Invalid status code");
        return new M(null, { status: k, headers: { location: I } });
      }),
        (a.DOMException = s.DOMException);
      try {
        new a.DOMException();
      } catch {
        (a.DOMException = function (k, L) {
          (this.message = k), (this.name = L);
          var U = Error(k);
          this.stack = U.stack;
        }),
          (a.DOMException.prototype = Object.create(Error.prototype)),
          (a.DOMException.prototype.constructor = a.DOMException);
      }
      function O(I, k) {
        return new Promise(function (L, U) {
          var $ = new _(I, k);
          if ($.signal && $.signal.aborted)
            return U(new a.DOMException("Aborted", "AbortError"));
          var B = new XMLHttpRequest();
          function R() {
            B.abort();
          }
          (B.onload = function () {
            var V = {
              status: B.status,
              statusText: B.statusText,
              headers: N(B.getAllResponseHeaders() || ""),
            };
            V.url =
              "responseURL" in B
                ? B.responseURL
                : V.headers.get("X-Request-URL");
            var oe = "response" in B ? B.response : B.responseText;
            L(new M(oe, V));
          }),
            (B.onerror = function () {
              U(new TypeError("Network request failed"));
            }),
            (B.ontimeout = function () {
              U(new TypeError("Network request failed"));
            }),
            (B.onabort = function () {
              U(new a.DOMException("Aborted", "AbortError"));
            }),
            B.open($.method, $.url, !0),
            $.credentials === "include"
              ? (B.withCredentials = !0)
              : $.credentials === "omit" && (B.withCredentials = !1),
            "responseType" in B && o.blob && (B.responseType = "blob"),
            $.headers.forEach(function (V, oe) {
              B.setRequestHeader(oe, V);
            }),
            $.signal &&
              ($.signal.addEventListener("abort", R),
              (B.onreadystatechange = function () {
                B.readyState === 4 && $.signal.removeEventListener("abort", R);
              })),
            B.send(typeof $._bodyInit > "u" ? null : $._bodyInit);
        });
      }
      return (
        (O.polyfill = !0),
        s.fetch ||
          ((s.fetch = O), (s.Headers = m), (s.Request = _), (s.Response = M)),
        (a.Headers = m),
        (a.Request = _),
        (a.Response = M),
        (a.fetch = O),
        Object.defineProperty(a, "__esModule", { value: !0 }),
        a
      );
    })({});
  })(r),
    (r.fetch.ponyfill = !0),
    delete r.fetch.polyfill;
  var i = r;
  (e = i.fetch),
    (e.default = i.fetch),
    (e.fetch = i.fetch),
    (e.Headers = i.Headers),
    (e.Request = i.Request),
    (e.Response = i.Response),
    (t.exports = e);
})(qx, qx.exports);
var xTe = qx.exports;
const kL = oa(xTe),
  TTe = { Accept: "application/json", "Content-Type": "application/json" },
  STe = "POST",
  IL = { headers: TTe, method: STe },
  OL = 10;
class YW {
  constructor(e, n = !1) {
    if (
      ((this.url = e),
      (this.disableProviderPing = n),
      (this.events = new Fo.EventEmitter()),
      (this.isAvailable = !1),
      (this.registering = !1),
      !rL(e))
    )
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    (this.url = e), (this.disableProviderPing = n);
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e, n) {
    this.isAvailable || (await this.register());
    try {
      const r = kh(e),
        s = await (
          await kL(this.url, Object.assign(Object.assign({}, IL), { body: r }))
        ).json();
      this.onPayload({ data: s });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!rL(e))
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (
        (this.events.listenerCount("register_error") >= n ||
          this.events.listenerCount("open") >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once("register_error", (s) => {
            this.resetMaxListeners(), i(s);
          }),
            this.events.once("open", () => {
              if ((this.resetMaxListeners(), typeof this.isAvailable > "u"))
                return i(new Error("HTTP connection is missing or invalid"));
              r();
            });
        })
      );
    }
    (this.url = e), (this.registering = !0);
    try {
      if (!this.disableProviderPing) {
        const n = kh({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await kL(e, Object.assign(Object.assign({}, IL), { body: n }));
      }
      this.onOpen();
    } catch (n) {
      const r = this.parseError(n);
      throw (this.events.emit("register_error", r), this.onClose(), r);
    }
  }
  onOpen() {
    (this.isAvailable = !0), (this.registering = !1), this.events.emit("open");
  }
  onClose() {
    (this.isAvailable = !1), (this.registering = !1), this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const n = typeof e.data == "string" ? Wy(e.data) : e.data;
    this.events.emit("payload", n);
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = y6(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, n = this.url) {
    return CW(e, n, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > OL && this.events.setMaxListeners(OL);
  }
}
const Vh = YW,
  PL = "error",
  ATe = "wss://relay.walletconnect.com",
  CTe = "wc",
  kTe = "universal_provider",
  NL = `${CTe}@2:${kTe}:`,
  ITe = "https://rpc.walletconnect.com/v1/",
  ff = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var Am =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {},
  Kx = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ (function (t, e) {
  (function () {
    var n,
      r = "4.17.21",
      i = 200,
      s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      a = "Expected a function",
      o = "Invalid `variable` option passed into `_.template`",
      l = "__lodash_hash_undefined__",
      u = 500,
      f = "__lodash_placeholder__",
      c = 1,
      d = 2,
      p = 4,
      m = 1,
      g = 2,
      w = 1,
      y = 2,
      v = 4,
      E = 8,
      S = 16,
      D = 32,
      P = 64,
      x = 128,
      _ = 256,
      A = 512,
      N = 30,
      M = "...",
      T = 800,
      O = 16,
      I = 1,
      k = 2,
      L = 3,
      U = 1 / 0,
      $ = 9007199254740991,
      B = 17976931348623157e292,
      R = 0 / 0,
      V = 4294967295,
      oe = V - 1,
      le = V >>> 1,
      fe = [
        ["ary", x],
        ["bind", w],
        ["bindKey", y],
        ["curry", E],
        ["curryRight", S],
        ["flip", A],
        ["partial", D],
        ["partialRight", P],
        ["rearg", _],
      ],
      z = "[object Arguments]",
      se = "[object Array]",
      Y = "[object AsyncFunction]",
      Q = "[object Boolean]",
      ee = "[object Date]",
      F = "[object DOMException]",
      te = "[object Error]",
      he = "[object Function]",
      Te = "[object GeneratorFunction]",
      Ce = "[object Map]",
      ke = "[object Number]",
      at = "[object Null]",
      Rt = "[object Object]",
      Ft = "[object Promise]",
      Nt = "[object Proxy]",
      Ot = "[object RegExp]",
      et = "[object Set]",
      st = "[object String]",
      vt = "[object Symbol]",
      Re = "[object Undefined]",
      me = "[object WeakMap]",
      $e = "[object WeakSet]",
      De = "[object ArrayBuffer]",
      je = "[object DataView]",
      lt = "[object Float32Array]",
      Ke = "[object Float64Array]",
      tt = "[object Int8Array]",
      jt = "[object Int16Array]",
      ct = "[object Int32Array]",
      rt = "[object Uint8Array]",
      Dt = "[object Uint8ClampedArray]",
      Ht = "[object Uint16Array]",
      Yt = "[object Uint32Array]",
      sr = /\b__p \+= '';/g,
      Bt = /\b(__p \+=) '' \+/g,
      en = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      Tr = /&(?:amp|lt|gt|quot|#39);/g,
      on = /[&<>"']/g,
      Pt = RegExp(Tr.source),
      fn = RegExp(on.source),
      Wt = /<%-([\s\S]+?)%>/g,
      qt = /<%([\s\S]+?)%>/g,
      Ye = /<%=([\s\S]+?)%>/g,
      xe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      nt = /^\w*$/,
      gt =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      ht = /[\\^$.*+?()[\]{}|]/g,
      wt = RegExp(ht.source),
      rn = /^\s+/,
      ot = /\s/,
      pt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      zt = /\{\n\/\* \[wrapped with (.+)\] \*/,
      Zt = /,? & /,
      $t = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      Vr = /[()=,{}\[\]\/\s]/,
      $n = /\\(\\)?/g,
      En = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      In = /\w*$/,
      as = /^[-+]0x[0-9a-f]+$/i,
      os = /^0b[01]+$/i,
      ls = /^\[object .+?Constructor\]$/,
      us = /^0o[0-7]+$/i,
      Or = /^(?:0|[1-9]\d*)$/,
      ar = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      cs = /($^)/,
      lo = /['\n\r\u2028\u2029\\]/g,
      zi = "\\ud800-\\udfff",
      la = "\\u0300-\\u036f",
      xi = "\\ufe20-\\ufe2f",
      ci = "\\u20d0-\\u20ff",
      ua = la + xi + ci,
      Ra = "\\u2700-\\u27bf",
      pr = "a-z\\xdf-\\xf6\\xf8-\\xff",
      uo = "\\xac\\xb1\\xd7\\xf7",
      fs = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      co = "\\u2000-\\u206f",
      lc =
        " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      ds = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      cu = "\\ufe0e\\ufe0f",
      $s = uo + fs + co + lc,
      Al = "['’]",
      fo = "[" + zi + "]",
      Cl = "[" + $s + "]",
      ho = "[" + ua + "]",
      Ma = "\\d+",
      po = "[" + Ra + "]",
      jo = "[" + pr + "]",
      Ho = "[^" + zi + $s + Ma + Ra + pr + ds + "]",
      La = "\\ud83c[\\udffb-\\udfff]",
      fu = "(?:" + ho + "|" + La + ")",
      du = "[^" + zi + "]",
      zo = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Ba = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      Mi = "[" + ds + "]",
      hu = "\\u200d",
      pu = "(?:" + jo + "|" + Ho + ")",
      Us = "(?:" + Mi + "|" + Ho + ")",
      Vo = "(?:" + Al + "(?:d|ll|m|re|s|t|ve))?",
      kl = "(?:" + Al + "(?:D|LL|M|RE|S|T|VE))?",
      mu = fu + "?",
      Il = "[" + cu + "]?",
      Go = "(?:" + hu + "(?:" + [du, zo, Ba].join("|") + ")" + Il + mu + ")*",
      Vi = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
      Wo = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
      qo = Il + mu + Go,
      hs = "(?:" + [po, zo, Ba].join("|") + ")" + qo,
      gu = "(?:" + [du + ho + "?", ho, zo, Ba, fo].join("|") + ")",
      Qr = RegExp(Al, "g"),
      Gr = RegExp(ho, "g"),
      ps = RegExp(La + "(?=" + La + ")|" + gu + qo, "g"),
      js = RegExp(
        [
          Mi + "?" + jo + "+" + Vo + "(?=" + [Cl, Mi, "$"].join("|") + ")",
          Us + "+" + kl + "(?=" + [Cl, Mi + pu, "$"].join("|") + ")",
          Mi + "?" + pu + "+" + Vo,
          Mi + "+" + kl,
          Wo,
          Vi,
          Ma,
          hs,
        ].join("|"),
        "g"
      ),
      Hs = RegExp("[" + hu + zi + ua + cu + "]"),
      Fa = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      yu = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout",
      ],
      vu = -1,
      qn = {};
    (qn[lt] =
      qn[Ke] =
      qn[tt] =
      qn[jt] =
      qn[ct] =
      qn[rt] =
      qn[Dt] =
      qn[Ht] =
      qn[Yt] =
        !0),
      (qn[z] =
        qn[se] =
        qn[De] =
        qn[Q] =
        qn[je] =
        qn[ee] =
        qn[te] =
        qn[he] =
        qn[Ce] =
        qn[ke] =
        qn[Rt] =
        qn[Ot] =
        qn[et] =
        qn[st] =
        qn[me] =
          !1);
    var Un = {};
    (Un[z] =
      Un[se] =
      Un[De] =
      Un[je] =
      Un[Q] =
      Un[ee] =
      Un[lt] =
      Un[Ke] =
      Un[tt] =
      Un[jt] =
      Un[ct] =
      Un[Ce] =
      Un[ke] =
      Un[Rt] =
      Un[Ot] =
      Un[et] =
      Un[st] =
      Un[vt] =
      Un[rt] =
      Un[Dt] =
      Un[Ht] =
      Un[Yt] =
        !0),
      (Un[te] = Un[he] = Un[me] = !1);
    var re = {
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s",
      },
      pe = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      },
      q = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
      },
      ie = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029",
      },
      ve = parseFloat,
      Me = parseInt,
      St = typeof Am == "object" && Am && Am.Object === Object && Am,
      kt = typeof self == "object" && self && self.Object === Object && self,
      _t = St || kt || Function("return this")(),
      Et = e && !e.nodeType && e,
      tn = Et && !0 && t && !t.nodeType && t,
      Kn = tn && tn.exports === Et,
      pn = Kn && St.process,
      xn = (function () {
        try {
          var ye = tn && tn.require && tn.require("util").types;
          return ye || (pn && pn.binding && pn.binding("util"));
        } catch {}
      })(),
      Sr = xn && xn.isArrayBuffer,
      Gi = xn && xn.isDate,
      Wi = xn && xn.isMap,
      $a = xn && xn.isRegExp,
      uc = xn && xn.isSet,
      zs = xn && xn.isTypedArray;
    function fi(ye, Pe, Ae) {
      switch (Ae.length) {
        case 0:
          return ye.call(Pe);
        case 1:
          return ye.call(Pe, Ae[0]);
        case 2:
          return ye.call(Pe, Ae[0], Ae[1]);
        case 3:
          return ye.call(Pe, Ae[0], Ae[1], Ae[2]);
      }
      return ye.apply(Pe, Ae);
    }
    function L1(ye, Pe, Ae, Tt) {
      for (var mn = -1, ur = ye == null ? 0 : ye.length; ++mn < ur; ) {
        var Ki = ye[mn];
        Pe(Tt, Ki, Ae(Ki), ye);
      }
      return Tt;
    }
    function X(ye, Pe) {
      for (
        var Ae = -1, Tt = ye == null ? 0 : ye.length;
        ++Ae < Tt && Pe(ye[Ae], Ae, ye) !== !1;

      );
      return ye;
    }
    function j(ye, Pe) {
      for (
        var Ae = ye == null ? 0 : ye.length;
        Ae-- && Pe(ye[Ae], Ae, ye) !== !1;

      );
      return ye;
    }
    function K(ye, Pe) {
      for (var Ae = -1, Tt = ye == null ? 0 : ye.length; ++Ae < Tt; )
        if (!Pe(ye[Ae], Ae, ye)) return !1;
      return !0;
    }
    function ce(ye, Pe) {
      for (
        var Ae = -1, Tt = ye == null ? 0 : ye.length, mn = 0, ur = [];
        ++Ae < Tt;

      ) {
        var Ki = ye[Ae];
        Pe(Ki, Ae, ye) && (ur[mn++] = Ki);
      }
      return ur;
    }
    function Ee(ye, Pe) {
      var Ae = ye == null ? 0 : ye.length;
      return !!Ae && Br(ye, Pe, 0) > -1;
    }
    function Ne(ye, Pe, Ae) {
      for (var Tt = -1, mn = ye == null ? 0 : ye.length; ++Tt < mn; )
        if (Ae(Pe, ye[Tt])) return !0;
      return !1;
    }
    function Ie(ye, Pe) {
      for (
        var Ae = -1, Tt = ye == null ? 0 : ye.length, mn = Array(Tt);
        ++Ae < Tt;

      )
        mn[Ae] = Pe(ye[Ae], Ae, ye);
      return mn;
    }
    function xt(ye, Pe) {
      for (var Ae = -1, Tt = Pe.length, mn = ye.length; ++Ae < Tt; )
        ye[mn + Ae] = Pe[Ae];
      return ye;
    }
    function Kt(ye, Pe, Ae, Tt) {
      var mn = -1,
        ur = ye == null ? 0 : ye.length;
      for (Tt && ur && (Ae = ye[++mn]); ++mn < ur; )
        Ae = Pe(Ae, ye[mn], mn, ye);
      return Ae;
    }
    function ln(ye, Pe, Ae, Tt) {
      var mn = ye == null ? 0 : ye.length;
      for (Tt && mn && (Ae = ye[--mn]); mn--; ) Ae = Pe(Ae, ye[mn], mn, ye);
      return Ae;
    }
    function Tn(ye, Pe) {
      for (var Ae = -1, Tt = ye == null ? 0 : ye.length; ++Ae < Tt; )
        if (Pe(ye[Ae], Ae, ye)) return !0;
      return !1;
    }
    var On = go("length");
    function wn(ye) {
      return ye.split("");
    }
    function jn(ye) {
      return ye.match($t) || [];
    }
    function br(ye, Pe, Ae) {
      var Tt;
      return (
        Ae(ye, function (mn, ur, Ki) {
          if (Pe(mn, ur, Ki)) return (Tt = ur), !1;
        }),
        Tt
      );
    }
    function Pr(ye, Pe, Ae, Tt) {
      for (var mn = ye.length, ur = Ae + (Tt ? 1 : -1); Tt ? ur-- : ++ur < mn; )
        if (Pe(ye[ur], ur, ye)) return ur;
      return -1;
    }
    function Br(ye, Pe, Ae) {
      return Pe === Pe ? AK(ye, Pe, Ae) : Pr(ye, mo, Ae);
    }
    function qi(ye, Pe, Ae, Tt) {
      for (var mn = Ae - 1, ur = ye.length; ++mn < ur; )
        if (Tt(ye[mn], Pe)) return mn;
      return -1;
    }
    function mo(ye) {
      return ye !== ye;
    }
    function bu(ye, Pe) {
      var Ae = ye == null ? 0 : ye.length;
      return Ae ? X6(ye, Pe) / Ae : R;
    }
    function go(ye) {
      return function (Pe) {
        return Pe == null ? n : Pe[ye];
      };
    }
    function df(ye) {
      return function (Pe) {
        return ye == null ? n : ye[Pe];
      };
    }
    function zS(ye, Pe, Ae, Tt, mn) {
      return (
        mn(ye, function (ur, Ki, Ar) {
          Ae = Tt ? ((Tt = !1), ur) : Pe(Ae, ur, Ki, Ar);
        }),
        Ae
      );
    }
    function gK(ye, Pe) {
      var Ae = ye.length;
      for (ye.sort(Pe); Ae--; ) ye[Ae] = ye[Ae].value;
      return ye;
    }
    function X6(ye, Pe) {
      for (var Ae, Tt = -1, mn = ye.length; ++Tt < mn; ) {
        var ur = Pe(ye[Tt]);
        ur !== n && (Ae = Ae === n ? ur : Ae + ur);
      }
      return Ae;
    }
    function Z6(ye, Pe) {
      for (var Ae = -1, Tt = Array(ye); ++Ae < ye; ) Tt[Ae] = Pe(Ae);
      return Tt;
    }
    function yK(ye, Pe) {
      return Ie(Pe, function (Ae) {
        return [Ae, ye[Ae]];
      });
    }
    function VS(ye) {
      return ye && ye.slice(0, KS(ye) + 1).replace(rn, "");
    }
    function yo(ye) {
      return function (Pe) {
        return ye(Pe);
      };
    }
    function Y6(ye, Pe) {
      return Ie(Pe, function (Ae) {
        return ye[Ae];
      });
    }
    function B1(ye, Pe) {
      return ye.has(Pe);
    }
    function GS(ye, Pe) {
      for (var Ae = -1, Tt = ye.length; ++Ae < Tt && Br(Pe, ye[Ae], 0) > -1; );
      return Ae;
    }
    function WS(ye, Pe) {
      for (var Ae = ye.length; Ae-- && Br(Pe, ye[Ae], 0) > -1; );
      return Ae;
    }
    function vK(ye, Pe) {
      for (var Ae = ye.length, Tt = 0; Ae--; ) ye[Ae] === Pe && ++Tt;
      return Tt;
    }
    var bK = df(re),
      wK = df(pe);
    function _K(ye) {
      return "\\" + ie[ye];
    }
    function EK(ye, Pe) {
      return ye == null ? n : ye[Pe];
    }
    function Xh(ye) {
      return Hs.test(ye);
    }
    function xK(ye) {
      return Fa.test(ye);
    }
    function TK(ye) {
      for (var Pe, Ae = []; !(Pe = ye.next()).done; ) Ae.push(Pe.value);
      return Ae;
    }
    function Q6(ye) {
      var Pe = -1,
        Ae = Array(ye.size);
      return (
        ye.forEach(function (Tt, mn) {
          Ae[++Pe] = [mn, Tt];
        }),
        Ae
      );
    }
    function qS(ye, Pe) {
      return function (Ae) {
        return ye(Pe(Ae));
      };
    }
    function hf(ye, Pe) {
      for (var Ae = -1, Tt = ye.length, mn = 0, ur = []; ++Ae < Tt; ) {
        var Ki = ye[Ae];
        (Ki === Pe || Ki === f) && ((ye[Ae] = f), (ur[mn++] = Ae));
      }
      return ur;
    }
    function e2(ye) {
      var Pe = -1,
        Ae = Array(ye.size);
      return (
        ye.forEach(function (Tt) {
          Ae[++Pe] = Tt;
        }),
        Ae
      );
    }
    function SK(ye) {
      var Pe = -1,
        Ae = Array(ye.size);
      return (
        ye.forEach(function (Tt) {
          Ae[++Pe] = [Tt, Tt];
        }),
        Ae
      );
    }
    function AK(ye, Pe, Ae) {
      for (var Tt = Ae - 1, mn = ye.length; ++Tt < mn; )
        if (ye[Tt] === Pe) return Tt;
      return -1;
    }
    function CK(ye, Pe, Ae) {
      for (var Tt = Ae + 1; Tt--; ) if (ye[Tt] === Pe) return Tt;
      return Tt;
    }
    function Zh(ye) {
      return Xh(ye) ? IK(ye) : On(ye);
    }
    function Ol(ye) {
      return Xh(ye) ? OK(ye) : wn(ye);
    }
    function KS(ye) {
      for (var Pe = ye.length; Pe-- && ot.test(ye.charAt(Pe)); );
      return Pe;
    }
    var kK = df(q);
    function IK(ye) {
      for (var Pe = (ps.lastIndex = 0); ps.test(ye); ) ++Pe;
      return Pe;
    }
    function OK(ye) {
      return ye.match(ps) || [];
    }
    function PK(ye) {
      return ye.match(js) || [];
    }
    var NK = function ye(Pe) {
        Pe = Pe == null ? _t : Yh.defaults(_t.Object(), Pe, Yh.pick(_t, yu));
        var Ae = Pe.Array,
          Tt = Pe.Date,
          mn = Pe.Error,
          ur = Pe.Function,
          Ki = Pe.Math,
          Ar = Pe.Object,
          J6 = Pe.RegExp,
          DK = Pe.String,
          Ko = Pe.TypeError,
          t2 = Ae.prototype,
          RK = ur.prototype,
          Qh = Ar.prototype,
          n2 = Pe["__core-js_shared__"],
          r2 = RK.toString,
          mr = Qh.hasOwnProperty,
          MK = 0,
          XS = (function () {
            var h = /[^.]+$/.exec((n2 && n2.keys && n2.keys.IE_PROTO) || "");
            return h ? "Symbol(src)_1." + h : "";
          })(),
          i2 = Qh.toString,
          LK = r2.call(Ar),
          BK = _t._,
          FK = J6(
            "^" +
              r2
                .call(mr)
                .replace(ht, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          ),
          s2 = Kn ? Pe.Buffer : n,
          pf = Pe.Symbol,
          a2 = Pe.Uint8Array,
          ZS = s2 ? s2.allocUnsafe : n,
          o2 = qS(Ar.getPrototypeOf, Ar),
          YS = Ar.create,
          QS = Qh.propertyIsEnumerable,
          l2 = t2.splice,
          JS = pf ? pf.isConcatSpreadable : n,
          F1 = pf ? pf.iterator : n,
          Ad = pf ? pf.toStringTag : n,
          u2 = (function () {
            try {
              var h = Pd(Ar, "defineProperty");
              return h({}, "", {}), h;
            } catch {}
          })(),
          $K = Pe.clearTimeout !== _t.clearTimeout && Pe.clearTimeout,
          UK = Tt && Tt.now !== _t.Date.now && Tt.now,
          jK = Pe.setTimeout !== _t.setTimeout && Pe.setTimeout,
          c2 = Ki.ceil,
          f2 = Ki.floor,
          e3 = Ar.getOwnPropertySymbols,
          HK = s2 ? s2.isBuffer : n,
          eA = Pe.isFinite,
          zK = t2.join,
          VK = qS(Ar.keys, Ar),
          Xi = Ki.max,
          Vs = Ki.min,
          GK = Tt.now,
          WK = Pe.parseInt,
          tA = Ki.random,
          qK = t2.reverse,
          t3 = Pd(Pe, "DataView"),
          $1 = Pd(Pe, "Map"),
          n3 = Pd(Pe, "Promise"),
          Jh = Pd(Pe, "Set"),
          U1 = Pd(Pe, "WeakMap"),
          j1 = Pd(Ar, "create"),
          d2 = U1 && new U1(),
          ep = {},
          KK = Nd(t3),
          XK = Nd($1),
          ZK = Nd(n3),
          YK = Nd(Jh),
          QK = Nd(U1),
          h2 = pf ? pf.prototype : n,
          H1 = h2 ? h2.valueOf : n,
          nA = h2 ? h2.toString : n;
        function J(h) {
          if (di(h) && !yn(h) && !(h instanceof Hn)) {
            if (h instanceof Xo) return h;
            if (mr.call(h, "__wrapped__")) return rC(h);
          }
          return new Xo(h);
        }
        var tp = (function () {
          function h() {}
          return function (b) {
            if (!Jr(b)) return {};
            if (YS) return YS(b);
            h.prototype = b;
            var C = new h();
            return (h.prototype = n), C;
          };
        })();
        function p2() {}
        function Xo(h, b) {
          (this.__wrapped__ = h),
            (this.__actions__ = []),
            (this.__chain__ = !!b),
            (this.__index__ = 0),
            (this.__values__ = n);
        }
        (J.templateSettings = {
          escape: Wt,
          evaluate: qt,
          interpolate: Ye,
          variable: "",
          imports: { _: J },
        }),
          (J.prototype = p2.prototype),
          (J.prototype.constructor = J),
          (Xo.prototype = tp(p2.prototype)),
          (Xo.prototype.constructor = Xo);
        function Hn(h) {
          (this.__wrapped__ = h),
            (this.__actions__ = []),
            (this.__dir__ = 1),
            (this.__filtered__ = !1),
            (this.__iteratees__ = []),
            (this.__takeCount__ = V),
            (this.__views__ = []);
        }
        function JK() {
          var h = new Hn(this.__wrapped__);
          return (
            (h.__actions__ = Ua(this.__actions__)),
            (h.__dir__ = this.__dir__),
            (h.__filtered__ = this.__filtered__),
            (h.__iteratees__ = Ua(this.__iteratees__)),
            (h.__takeCount__ = this.__takeCount__),
            (h.__views__ = Ua(this.__views__)),
            h
          );
        }
        function eX() {
          if (this.__filtered__) {
            var h = new Hn(this);
            (h.__dir__ = -1), (h.__filtered__ = !0);
          } else (h = this.clone()), (h.__dir__ *= -1);
          return h;
        }
        function tX() {
          var h = this.__wrapped__.value(),
            b = this.__dir__,
            C = yn(h),
            H = b < 0,
            W = C ? h.length : 0,
            ne = hZ(0, W, this.__views__),
            ue = ne.start,
            de = ne.end,
            we = de - ue,
            Le = H ? de : ue - 1,
            Be = this.__iteratees__,
            Ve = Be.length,
            ft = 0,
            Ut = Vs(we, this.__takeCount__);
          if (!C || (!H && W == we && Ut == we)) return AA(h, this.__actions__);
          var un = [];
          e: for (; we-- && ft < Ut; ) {
            Le += b;
            for (var Pn = -1, cn = h[Le]; ++Pn < Ve; ) {
              var Fn = Be[Pn],
                Xn = Fn.iteratee,
                wo = Fn.type,
                da = Xn(cn);
              if (wo == k) cn = da;
              else if (!da) {
                if (wo == I) continue e;
                break e;
              }
            }
            un[ft++] = cn;
          }
          return un;
        }
        (Hn.prototype = tp(p2.prototype)), (Hn.prototype.constructor = Hn);
        function Cd(h) {
          var b = -1,
            C = h == null ? 0 : h.length;
          for (this.clear(); ++b < C; ) {
            var H = h[b];
            this.set(H[0], H[1]);
          }
        }
        function nX() {
          (this.__data__ = j1 ? j1(null) : {}), (this.size = 0);
        }
        function rX(h) {
          var b = this.has(h) && delete this.__data__[h];
          return (this.size -= b ? 1 : 0), b;
        }
        function iX(h) {
          var b = this.__data__;
          if (j1) {
            var C = b[h];
            return C === l ? n : C;
          }
          return mr.call(b, h) ? b[h] : n;
        }
        function sX(h) {
          var b = this.__data__;
          return j1 ? b[h] !== n : mr.call(b, h);
        }
        function aX(h, b) {
          var C = this.__data__;
          return (
            (this.size += this.has(h) ? 0 : 1),
            (C[h] = j1 && b === n ? l : b),
            this
          );
        }
        (Cd.prototype.clear = nX),
          (Cd.prototype.delete = rX),
          (Cd.prototype.get = iX),
          (Cd.prototype.has = sX),
          (Cd.prototype.set = aX);
        function cc(h) {
          var b = -1,
            C = h == null ? 0 : h.length;
          for (this.clear(); ++b < C; ) {
            var H = h[b];
            this.set(H[0], H[1]);
          }
        }
        function oX() {
          (this.__data__ = []), (this.size = 0);
        }
        function lX(h) {
          var b = this.__data__,
            C = m2(b, h);
          if (C < 0) return !1;
          var H = b.length - 1;
          return C == H ? b.pop() : l2.call(b, C, 1), --this.size, !0;
        }
        function uX(h) {
          var b = this.__data__,
            C = m2(b, h);
          return C < 0 ? n : b[C][1];
        }
        function cX(h) {
          return m2(this.__data__, h) > -1;
        }
        function fX(h, b) {
          var C = this.__data__,
            H = m2(C, h);
          return H < 0 ? (++this.size, C.push([h, b])) : (C[H][1] = b), this;
        }
        (cc.prototype.clear = oX),
          (cc.prototype.delete = lX),
          (cc.prototype.get = uX),
          (cc.prototype.has = cX),
          (cc.prototype.set = fX);
        function fc(h) {
          var b = -1,
            C = h == null ? 0 : h.length;
          for (this.clear(); ++b < C; ) {
            var H = h[b];
            this.set(H[0], H[1]);
          }
        }
        function dX() {
          (this.size = 0),
            (this.__data__ = {
              hash: new Cd(),
              map: new ($1 || cc)(),
              string: new Cd(),
            });
        }
        function hX(h) {
          var b = C2(this, h).delete(h);
          return (this.size -= b ? 1 : 0), b;
        }
        function pX(h) {
          return C2(this, h).get(h);
        }
        function mX(h) {
          return C2(this, h).has(h);
        }
        function gX(h, b) {
          var C = C2(this, h),
            H = C.size;
          return C.set(h, b), (this.size += C.size == H ? 0 : 1), this;
        }
        (fc.prototype.clear = dX),
          (fc.prototype.delete = hX),
          (fc.prototype.get = pX),
          (fc.prototype.has = mX),
          (fc.prototype.set = gX);
        function kd(h) {
          var b = -1,
            C = h == null ? 0 : h.length;
          for (this.__data__ = new fc(); ++b < C; ) this.add(h[b]);
        }
        function yX(h) {
          return this.__data__.set(h, l), this;
        }
        function vX(h) {
          return this.__data__.has(h);
        }
        (kd.prototype.add = kd.prototype.push = yX), (kd.prototype.has = vX);
        function Pl(h) {
          var b = (this.__data__ = new cc(h));
          this.size = b.size;
        }
        function bX() {
          (this.__data__ = new cc()), (this.size = 0);
        }
        function wX(h) {
          var b = this.__data__,
            C = b.delete(h);
          return (this.size = b.size), C;
        }
        function _X(h) {
          return this.__data__.get(h);
        }
        function EX(h) {
          return this.__data__.has(h);
        }
        function xX(h, b) {
          var C = this.__data__;
          if (C instanceof cc) {
            var H = C.__data__;
            if (!$1 || H.length < i - 1)
              return H.push([h, b]), (this.size = ++C.size), this;
            C = this.__data__ = new fc(H);
          }
          return C.set(h, b), (this.size = C.size), this;
        }
        (Pl.prototype.clear = bX),
          (Pl.prototype.delete = wX),
          (Pl.prototype.get = _X),
          (Pl.prototype.has = EX),
          (Pl.prototype.set = xX);
        function rA(h, b) {
          var C = yn(h),
            H = !C && Dd(h),
            W = !C && !H && bf(h),
            ne = !C && !H && !W && sp(h),
            ue = C || H || W || ne,
            de = ue ? Z6(h.length, DK) : [],
            we = de.length;
          for (var Le in h)
            (b || mr.call(h, Le)) &&
              !(
                ue &&
                (Le == "length" ||
                  (W && (Le == "offset" || Le == "parent")) ||
                  (ne &&
                    (Le == "buffer" ||
                      Le == "byteLength" ||
                      Le == "byteOffset")) ||
                  mc(Le, we))
              ) &&
              de.push(Le);
          return de;
        }
        function iA(h) {
          var b = h.length;
          return b ? h[h3(0, b - 1)] : n;
        }
        function TX(h, b) {
          return k2(Ua(h), Id(b, 0, h.length));
        }
        function SX(h) {
          return k2(Ua(h));
        }
        function r3(h, b, C) {
          ((C !== n && !Nl(h[b], C)) || (C === n && !(b in h))) && dc(h, b, C);
        }
        function z1(h, b, C) {
          var H = h[b];
          (!(mr.call(h, b) && Nl(H, C)) || (C === n && !(b in h))) &&
            dc(h, b, C);
        }
        function m2(h, b) {
          for (var C = h.length; C--; ) if (Nl(h[C][0], b)) return C;
          return -1;
        }
        function AX(h, b, C, H) {
          return (
            mf(h, function (W, ne, ue) {
              b(H, W, C(W), ue);
            }),
            H
          );
        }
        function sA(h, b) {
          return h && _u(b, ms(b), h);
        }
        function CX(h, b) {
          return h && _u(b, Ha(b), h);
        }
        function dc(h, b, C) {
          b == "__proto__" && u2
            ? u2(h, b, {
                configurable: !0,
                enumerable: !0,
                value: C,
                writable: !0,
              })
            : (h[b] = C);
        }
        function i3(h, b) {
          for (var C = -1, H = b.length, W = Ae(H), ne = h == null; ++C < H; )
            W[C] = ne ? n : F3(h, b[C]);
          return W;
        }
        function Id(h, b, C) {
          return (
            h === h &&
              (C !== n && (h = h <= C ? h : C),
              b !== n && (h = h >= b ? h : b)),
            h
          );
        }
        function Zo(h, b, C, H, W, ne) {
          var ue,
            de = b & c,
            we = b & d,
            Le = b & p;
          if ((C && (ue = W ? C(h, H, W, ne) : C(h)), ue !== n)) return ue;
          if (!Jr(h)) return h;
          var Be = yn(h);
          if (Be) {
            if (((ue = mZ(h)), !de)) return Ua(h, ue);
          } else {
            var Ve = Gs(h),
              ft = Ve == he || Ve == Te;
            if (bf(h)) return IA(h, de);
            if (Ve == Rt || Ve == z || (ft && !W)) {
              if (((ue = we || ft ? {} : KA(h)), !de))
                return we ? iZ(h, CX(ue, h)) : rZ(h, sA(ue, h));
            } else {
              if (!Un[Ve]) return W ? h : {};
              ue = gZ(h, Ve, de);
            }
          }
          ne || (ne = new Pl());
          var Ut = ne.get(h);
          if (Ut) return Ut;
          ne.set(h, ue),
            xC(h)
              ? h.forEach(function (cn) {
                  ue.add(Zo(cn, b, C, cn, h, ne));
                })
              : _C(h) &&
                h.forEach(function (cn, Fn) {
                  ue.set(Fn, Zo(cn, b, C, Fn, h, ne));
                });
          var un = Le ? (we ? T3 : x3) : we ? Ha : ms,
            Pn = Be ? n : un(h);
          return (
            X(Pn || h, function (cn, Fn) {
              Pn && ((Fn = cn), (cn = h[Fn])),
                z1(ue, Fn, Zo(cn, b, C, Fn, h, ne));
            }),
            ue
          );
        }
        function kX(h) {
          var b = ms(h);
          return function (C) {
            return aA(C, h, b);
          };
        }
        function aA(h, b, C) {
          var H = C.length;
          if (h == null) return !H;
          for (h = Ar(h); H--; ) {
            var W = C[H],
              ne = b[W],
              ue = h[W];
            if ((ue === n && !(W in h)) || !ne(ue)) return !1;
          }
          return !0;
        }
        function oA(h, b, C) {
          if (typeof h != "function") throw new Ko(a);
          return Z1(function () {
            h.apply(n, C);
          }, b);
        }
        function V1(h, b, C, H) {
          var W = -1,
            ne = Ee,
            ue = !0,
            de = h.length,
            we = [],
            Le = b.length;
          if (!de) return we;
          C && (b = Ie(b, yo(C))),
            H
              ? ((ne = Ne), (ue = !1))
              : b.length >= i && ((ne = B1), (ue = !1), (b = new kd(b)));
          e: for (; ++W < de; ) {
            var Be = h[W],
              Ve = C == null ? Be : C(Be);
            if (((Be = H || Be !== 0 ? Be : 0), ue && Ve === Ve)) {
              for (var ft = Le; ft--; ) if (b[ft] === Ve) continue e;
              we.push(Be);
            } else ne(b, Ve, H) || we.push(Be);
          }
          return we;
        }
        var mf = RA(wu),
          lA = RA(a3, !0);
        function IX(h, b) {
          var C = !0;
          return (
            mf(h, function (H, W, ne) {
              return (C = !!b(H, W, ne)), C;
            }),
            C
          );
        }
        function g2(h, b, C) {
          for (var H = -1, W = h.length; ++H < W; ) {
            var ne = h[H],
              ue = b(ne);
            if (ue != null && (de === n ? ue === ue && !bo(ue) : C(ue, de)))
              var de = ue,
                we = ne;
          }
          return we;
        }
        function OX(h, b, C, H) {
          var W = h.length;
          for (
            C = Sn(C),
              C < 0 && (C = -C > W ? 0 : W + C),
              H = H === n || H > W ? W : Sn(H),
              H < 0 && (H += W),
              H = C > H ? 0 : SC(H);
            C < H;

          )
            h[C++] = b;
          return h;
        }
        function uA(h, b) {
          var C = [];
          return (
            mf(h, function (H, W, ne) {
              b(H, W, ne) && C.push(H);
            }),
            C
          );
        }
        function Is(h, b, C, H, W) {
          var ne = -1,
            ue = h.length;
          for (C || (C = vZ), W || (W = []); ++ne < ue; ) {
            var de = h[ne];
            b > 0 && C(de)
              ? b > 1
                ? Is(de, b - 1, C, H, W)
                : xt(W, de)
              : H || (W[W.length] = de);
          }
          return W;
        }
        var s3 = MA(),
          cA = MA(!0);
        function wu(h, b) {
          return h && s3(h, b, ms);
        }
        function a3(h, b) {
          return h && cA(h, b, ms);
        }
        function y2(h, b) {
          return ce(b, function (C) {
            return gc(h[C]);
          });
        }
        function Od(h, b) {
          b = yf(b, h);
          for (var C = 0, H = b.length; h != null && C < H; ) h = h[Eu(b[C++])];
          return C && C == H ? h : n;
        }
        function fA(h, b, C) {
          var H = b(h);
          return yn(h) ? H : xt(H, C(h));
        }
        function ca(h) {
          return h == null
            ? h === n
              ? Re
              : at
            : Ad && Ad in Ar(h)
            ? dZ(h)
            : SZ(h);
        }
        function o3(h, b) {
          return h > b;
        }
        function PX(h, b) {
          return h != null && mr.call(h, b);
        }
        function NX(h, b) {
          return h != null && b in Ar(h);
        }
        function DX(h, b, C) {
          return h >= Vs(b, C) && h < Xi(b, C);
        }
        function l3(h, b, C) {
          for (
            var H = C ? Ne : Ee,
              W = h[0].length,
              ne = h.length,
              ue = ne,
              de = Ae(ne),
              we = 1 / 0,
              Le = [];
            ue--;

          ) {
            var Be = h[ue];
            ue && b && (Be = Ie(Be, yo(b))),
              (we = Vs(Be.length, we)),
              (de[ue] =
                !C && (b || (W >= 120 && Be.length >= 120))
                  ? new kd(ue && Be)
                  : n);
          }
          Be = h[0];
          var Ve = -1,
            ft = de[0];
          e: for (; ++Ve < W && Le.length < we; ) {
            var Ut = Be[Ve],
              un = b ? b(Ut) : Ut;
            if (
              ((Ut = C || Ut !== 0 ? Ut : 0), !(ft ? B1(ft, un) : H(Le, un, C)))
            ) {
              for (ue = ne; --ue; ) {
                var Pn = de[ue];
                if (!(Pn ? B1(Pn, un) : H(h[ue], un, C))) continue e;
              }
              ft && ft.push(un), Le.push(Ut);
            }
          }
          return Le;
        }
        function RX(h, b, C, H) {
          return (
            wu(h, function (W, ne, ue) {
              b(H, C(W), ne, ue);
            }),
            H
          );
        }
        function G1(h, b, C) {
          (b = yf(b, h)), (h = QA(h, b));
          var H = h == null ? h : h[Eu(Qo(b))];
          return H == null ? n : fi(H, h, C);
        }
        function dA(h) {
          return di(h) && ca(h) == z;
        }
        function MX(h) {
          return di(h) && ca(h) == De;
        }
        function LX(h) {
          return di(h) && ca(h) == ee;
        }
        function W1(h, b, C, H, W) {
          return h === b
            ? !0
            : h == null || b == null || (!di(h) && !di(b))
            ? h !== h && b !== b
            : BX(h, b, C, H, W1, W);
        }
        function BX(h, b, C, H, W, ne) {
          var ue = yn(h),
            de = yn(b),
            we = ue ? se : Gs(h),
            Le = de ? se : Gs(b);
          (we = we == z ? Rt : we), (Le = Le == z ? Rt : Le);
          var Be = we == Rt,
            Ve = Le == Rt,
            ft = we == Le;
          if (ft && bf(h)) {
            if (!bf(b)) return !1;
            (ue = !0), (Be = !1);
          }
          if (ft && !Be)
            return (
              ne || (ne = new Pl()),
              ue || sp(h) ? GA(h, b, C, H, W, ne) : cZ(h, b, we, C, H, W, ne)
            );
          if (!(C & m)) {
            var Ut = Be && mr.call(h, "__wrapped__"),
              un = Ve && mr.call(b, "__wrapped__");
            if (Ut || un) {
              var Pn = Ut ? h.value() : h,
                cn = un ? b.value() : b;
              return ne || (ne = new Pl()), W(Pn, cn, C, H, ne);
            }
          }
          return ft ? (ne || (ne = new Pl()), fZ(h, b, C, H, W, ne)) : !1;
        }
        function FX(h) {
          return di(h) && Gs(h) == Ce;
        }
        function u3(h, b, C, H) {
          var W = C.length,
            ne = W,
            ue = !H;
          if (h == null) return !ne;
          for (h = Ar(h); W--; ) {
            var de = C[W];
            if (ue && de[2] ? de[1] !== h[de[0]] : !(de[0] in h)) return !1;
          }
          for (; ++W < ne; ) {
            de = C[W];
            var we = de[0],
              Le = h[we],
              Be = de[1];
            if (ue && de[2]) {
              if (Le === n && !(we in h)) return !1;
            } else {
              var Ve = new Pl();
              if (H) var ft = H(Le, Be, we, h, b, Ve);
              if (!(ft === n ? W1(Be, Le, m | g, H, Ve) : ft)) return !1;
            }
          }
          return !0;
        }
        function hA(h) {
          if (!Jr(h) || wZ(h)) return !1;
          var b = gc(h) ? FK : ls;
          return b.test(Nd(h));
        }
        function $X(h) {
          return di(h) && ca(h) == Ot;
        }
        function UX(h) {
          return di(h) && Gs(h) == et;
        }
        function jX(h) {
          return di(h) && R2(h.length) && !!qn[ca(h)];
        }
        function pA(h) {
          return typeof h == "function"
            ? h
            : h == null
            ? za
            : typeof h == "object"
            ? yn(h)
              ? yA(h[0], h[1])
              : gA(h)
            : LC(h);
        }
        function c3(h) {
          if (!X1(h)) return VK(h);
          var b = [];
          for (var C in Ar(h)) mr.call(h, C) && C != "constructor" && b.push(C);
          return b;
        }
        function HX(h) {
          if (!Jr(h)) return TZ(h);
          var b = X1(h),
            C = [];
          for (var H in h)
            (H == "constructor" && (b || !mr.call(h, H))) || C.push(H);
          return C;
        }
        function f3(h, b) {
          return h < b;
        }
        function mA(h, b) {
          var C = -1,
            H = ja(h) ? Ae(h.length) : [];
          return (
            mf(h, function (W, ne, ue) {
              H[++C] = b(W, ne, ue);
            }),
            H
          );
        }
        function gA(h) {
          var b = A3(h);
          return b.length == 1 && b[0][2]
            ? ZA(b[0][0], b[0][1])
            : function (C) {
                return C === h || u3(C, h, b);
              };
        }
        function yA(h, b) {
          return k3(h) && XA(b)
            ? ZA(Eu(h), b)
            : function (C) {
                var H = F3(C, h);
                return H === n && H === b ? $3(C, h) : W1(b, H, m | g);
              };
        }
        function v2(h, b, C, H, W) {
          h !== b &&
            s3(
              b,
              function (ne, ue) {
                if ((W || (W = new Pl()), Jr(ne))) zX(h, b, ue, C, v2, H, W);
                else {
                  var de = H ? H(O3(h, ue), ne, ue + "", h, b, W) : n;
                  de === n && (de = ne), r3(h, ue, de);
                }
              },
              Ha
            );
        }
        function zX(h, b, C, H, W, ne, ue) {
          var de = O3(h, C),
            we = O3(b, C),
            Le = ue.get(we);
          if (Le) {
            r3(h, C, Le);
            return;
          }
          var Be = ne ? ne(de, we, C + "", h, b, ue) : n,
            Ve = Be === n;
          if (Ve) {
            var ft = yn(we),
              Ut = !ft && bf(we),
              un = !ft && !Ut && sp(we);
            (Be = we),
              ft || Ut || un
                ? yn(de)
                  ? (Be = de)
                  : Ti(de)
                  ? (Be = Ua(de))
                  : Ut
                  ? ((Ve = !1), (Be = IA(we, !0)))
                  : un
                  ? ((Ve = !1), (Be = OA(we, !0)))
                  : (Be = [])
                : Y1(we) || Dd(we)
                ? ((Be = de),
                  Dd(de) ? (Be = AC(de)) : (!Jr(de) || gc(de)) && (Be = KA(we)))
                : (Ve = !1);
          }
          Ve && (ue.set(we, Be), W(Be, we, H, ne, ue), ue.delete(we)),
            r3(h, C, Be);
        }
        function vA(h, b) {
          var C = h.length;
          if (C) return (b += b < 0 ? C : 0), mc(b, C) ? h[b] : n;
        }
        function bA(h, b, C) {
          b.length
            ? (b = Ie(b, function (ne) {
                return yn(ne)
                  ? function (ue) {
                      return Od(ue, ne.length === 1 ? ne[0] : ne);
                    }
                  : ne;
              }))
            : (b = [za]);
          var H = -1;
          b = Ie(b, yo(sn()));
          var W = mA(h, function (ne, ue, de) {
            var we = Ie(b, function (Le) {
              return Le(ne);
            });
            return { criteria: we, index: ++H, value: ne };
          });
          return gK(W, function (ne, ue) {
            return nZ(ne, ue, C);
          });
        }
        function VX(h, b) {
          return wA(h, b, function (C, H) {
            return $3(h, H);
          });
        }
        function wA(h, b, C) {
          for (var H = -1, W = b.length, ne = {}; ++H < W; ) {
            var ue = b[H],
              de = Od(h, ue);
            C(de, ue) && q1(ne, yf(ue, h), de);
          }
          return ne;
        }
        function GX(h) {
          return function (b) {
            return Od(b, h);
          };
        }
        function d3(h, b, C, H) {
          var W = H ? qi : Br,
            ne = -1,
            ue = b.length,
            de = h;
          for (h === b && (b = Ua(b)), C && (de = Ie(h, yo(C))); ++ne < ue; )
            for (
              var we = 0, Le = b[ne], Be = C ? C(Le) : Le;
              (we = W(de, Be, we, H)) > -1;

            )
              de !== h && l2.call(de, we, 1), l2.call(h, we, 1);
          return h;
        }
        function _A(h, b) {
          for (var C = h ? b.length : 0, H = C - 1; C--; ) {
            var W = b[C];
            if (C == H || W !== ne) {
              var ne = W;
              mc(W) ? l2.call(h, W, 1) : g3(h, W);
            }
          }
          return h;
        }
        function h3(h, b) {
          return h + f2(tA() * (b - h + 1));
        }
        function WX(h, b, C, H) {
          for (
            var W = -1, ne = Xi(c2((b - h) / (C || 1)), 0), ue = Ae(ne);
            ne--;

          )
            (ue[H ? ne : ++W] = h), (h += C);
          return ue;
        }
        function p3(h, b) {
          var C = "";
          if (!h || b < 1 || b > $) return C;
          do b % 2 && (C += h), (b = f2(b / 2)), b && (h += h);
          while (b);
          return C;
        }
        function Nn(h, b) {
          return P3(YA(h, b, za), h + "");
        }
        function qX(h) {
          return iA(ap(h));
        }
        function KX(h, b) {
          var C = ap(h);
          return k2(C, Id(b, 0, C.length));
        }
        function q1(h, b, C, H) {
          if (!Jr(h)) return h;
          b = yf(b, h);
          for (
            var W = -1, ne = b.length, ue = ne - 1, de = h;
            de != null && ++W < ne;

          ) {
            var we = Eu(b[W]),
              Le = C;
            if (
              we === "__proto__" ||
              we === "constructor" ||
              we === "prototype"
            )
              return h;
            if (W != ue) {
              var Be = de[we];
              (Le = H ? H(Be, we, de) : n),
                Le === n && (Le = Jr(Be) ? Be : mc(b[W + 1]) ? [] : {});
            }
            z1(de, we, Le), (de = de[we]);
          }
          return h;
        }
        var EA = d2
            ? function (h, b) {
                return d2.set(h, b), h;
              }
            : za,
          XX = u2
            ? function (h, b) {
                return u2(h, "toString", {
                  configurable: !0,
                  enumerable: !1,
                  value: j3(b),
                  writable: !0,
                });
              }
            : za;
        function ZX(h) {
          return k2(ap(h));
        }
        function Yo(h, b, C) {
          var H = -1,
            W = h.length;
          b < 0 && (b = -b > W ? 0 : W + b),
            (C = C > W ? W : C),
            C < 0 && (C += W),
            (W = b > C ? 0 : (C - b) >>> 0),
            (b >>>= 0);
          for (var ne = Ae(W); ++H < W; ) ne[H] = h[H + b];
          return ne;
        }
        function YX(h, b) {
          var C;
          return (
            mf(h, function (H, W, ne) {
              return (C = b(H, W, ne)), !C;
            }),
            !!C
          );
        }
        function b2(h, b, C) {
          var H = 0,
            W = h == null ? H : h.length;
          if (typeof b == "number" && b === b && W <= le) {
            for (; H < W; ) {
              var ne = (H + W) >>> 1,
                ue = h[ne];
              ue !== null && !bo(ue) && (C ? ue <= b : ue < b)
                ? (H = ne + 1)
                : (W = ne);
            }
            return W;
          }
          return m3(h, b, za, C);
        }
        function m3(h, b, C, H) {
          var W = 0,
            ne = h == null ? 0 : h.length;
          if (ne === 0) return 0;
          b = C(b);
          for (
            var ue = b !== b, de = b === null, we = bo(b), Le = b === n;
            W < ne;

          ) {
            var Be = f2((W + ne) / 2),
              Ve = C(h[Be]),
              ft = Ve !== n,
              Ut = Ve === null,
              un = Ve === Ve,
              Pn = bo(Ve);
            if (ue) var cn = H || un;
            else
              Le
                ? (cn = un && (H || ft))
                : de
                ? (cn = un && ft && (H || !Ut))
                : we
                ? (cn = un && ft && !Ut && (H || !Pn))
                : Ut || Pn
                ? (cn = !1)
                : (cn = H ? Ve <= b : Ve < b);
            cn ? (W = Be + 1) : (ne = Be);
          }
          return Vs(ne, oe);
        }
        function xA(h, b) {
          for (var C = -1, H = h.length, W = 0, ne = []; ++C < H; ) {
            var ue = h[C],
              de = b ? b(ue) : ue;
            if (!C || !Nl(de, we)) {
              var we = de;
              ne[W++] = ue === 0 ? 0 : ue;
            }
          }
          return ne;
        }
        function TA(h) {
          return typeof h == "number" ? h : bo(h) ? R : +h;
        }
        function vo(h) {
          if (typeof h == "string") return h;
          if (yn(h)) return Ie(h, vo) + "";
          if (bo(h)) return nA ? nA.call(h) : "";
          var b = h + "";
          return b == "0" && 1 / h == -U ? "-0" : b;
        }
        function gf(h, b, C) {
          var H = -1,
            W = Ee,
            ne = h.length,
            ue = !0,
            de = [],
            we = de;
          if (C) (ue = !1), (W = Ne);
          else if (ne >= i) {
            var Le = b ? null : lZ(h);
            if (Le) return e2(Le);
            (ue = !1), (W = B1), (we = new kd());
          } else we = b ? [] : de;
          e: for (; ++H < ne; ) {
            var Be = h[H],
              Ve = b ? b(Be) : Be;
            if (((Be = C || Be !== 0 ? Be : 0), ue && Ve === Ve)) {
              for (var ft = we.length; ft--; ) if (we[ft] === Ve) continue e;
              b && we.push(Ve), de.push(Be);
            } else W(we, Ve, C) || (we !== de && we.push(Ve), de.push(Be));
          }
          return de;
        }
        function g3(h, b) {
          return (
            (b = yf(b, h)), (h = QA(h, b)), h == null || delete h[Eu(Qo(b))]
          );
        }
        function SA(h, b, C, H) {
          return q1(h, b, C(Od(h, b)), H);
        }
        function w2(h, b, C, H) {
          for (
            var W = h.length, ne = H ? W : -1;
            (H ? ne-- : ++ne < W) && b(h[ne], ne, h);

          );
          return C
            ? Yo(h, H ? 0 : ne, H ? ne + 1 : W)
            : Yo(h, H ? ne + 1 : 0, H ? W : ne);
        }
        function AA(h, b) {
          var C = h;
          return (
            C instanceof Hn && (C = C.value()),
            Kt(
              b,
              function (H, W) {
                return W.func.apply(W.thisArg, xt([H], W.args));
              },
              C
            )
          );
        }
        function y3(h, b, C) {
          var H = h.length;
          if (H < 2) return H ? gf(h[0]) : [];
          for (var W = -1, ne = Ae(H); ++W < H; )
            for (var ue = h[W], de = -1; ++de < H; )
              de != W && (ne[W] = V1(ne[W] || ue, h[de], b, C));
          return gf(Is(ne, 1), b, C);
        }
        function CA(h, b, C) {
          for (var H = -1, W = h.length, ne = b.length, ue = {}; ++H < W; ) {
            var de = H < ne ? b[H] : n;
            C(ue, h[H], de);
          }
          return ue;
        }
        function v3(h) {
          return Ti(h) ? h : [];
        }
        function b3(h) {
          return typeof h == "function" ? h : za;
        }
        function yf(h, b) {
          return yn(h) ? h : k3(h, b) ? [h] : nC(fr(h));
        }
        var QX = Nn;
        function vf(h, b, C) {
          var H = h.length;
          return (C = C === n ? H : C), !b && C >= H ? h : Yo(h, b, C);
        }
        var kA =
          $K ||
          function (h) {
            return _t.clearTimeout(h);
          };
        function IA(h, b) {
          if (b) return h.slice();
          var C = h.length,
            H = ZS ? ZS(C) : new h.constructor(C);
          return h.copy(H), H;
        }
        function w3(h) {
          var b = new h.constructor(h.byteLength);
          return new a2(b).set(new a2(h)), b;
        }
        function JX(h, b) {
          var C = b ? w3(h.buffer) : h.buffer;
          return new h.constructor(C, h.byteOffset, h.byteLength);
        }
        function eZ(h) {
          var b = new h.constructor(h.source, In.exec(h));
          return (b.lastIndex = h.lastIndex), b;
        }
        function tZ(h) {
          return H1 ? Ar(H1.call(h)) : {};
        }
        function OA(h, b) {
          var C = b ? w3(h.buffer) : h.buffer;
          return new h.constructor(C, h.byteOffset, h.length);
        }
        function PA(h, b) {
          if (h !== b) {
            var C = h !== n,
              H = h === null,
              W = h === h,
              ne = bo(h),
              ue = b !== n,
              de = b === null,
              we = b === b,
              Le = bo(b);
            if (
              (!de && !Le && !ne && h > b) ||
              (ne && ue && we && !de && !Le) ||
              (H && ue && we) ||
              (!C && we) ||
              !W
            )
              return 1;
            if (
              (!H && !ne && !Le && h < b) ||
              (Le && C && W && !H && !ne) ||
              (de && C && W) ||
              (!ue && W) ||
              !we
            )
              return -1;
          }
          return 0;
        }
        function nZ(h, b, C) {
          for (
            var H = -1,
              W = h.criteria,
              ne = b.criteria,
              ue = W.length,
              de = C.length;
            ++H < ue;

          ) {
            var we = PA(W[H], ne[H]);
            if (we) {
              if (H >= de) return we;
              var Le = C[H];
              return we * (Le == "desc" ? -1 : 1);
            }
          }
          return h.index - b.index;
        }
        function NA(h, b, C, H) {
          for (
            var W = -1,
              ne = h.length,
              ue = C.length,
              de = -1,
              we = b.length,
              Le = Xi(ne - ue, 0),
              Be = Ae(we + Le),
              Ve = !H;
            ++de < we;

          )
            Be[de] = b[de];
          for (; ++W < ue; ) (Ve || W < ne) && (Be[C[W]] = h[W]);
          for (; Le--; ) Be[de++] = h[W++];
          return Be;
        }
        function DA(h, b, C, H) {
          for (
            var W = -1,
              ne = h.length,
              ue = -1,
              de = C.length,
              we = -1,
              Le = b.length,
              Be = Xi(ne - de, 0),
              Ve = Ae(Be + Le),
              ft = !H;
            ++W < Be;

          )
            Ve[W] = h[W];
          for (var Ut = W; ++we < Le; ) Ve[Ut + we] = b[we];
          for (; ++ue < de; ) (ft || W < ne) && (Ve[Ut + C[ue]] = h[W++]);
          return Ve;
        }
        function Ua(h, b) {
          var C = -1,
            H = h.length;
          for (b || (b = Ae(H)); ++C < H; ) b[C] = h[C];
          return b;
        }
        function _u(h, b, C, H) {
          var W = !C;
          C || (C = {});
          for (var ne = -1, ue = b.length; ++ne < ue; ) {
            var de = b[ne],
              we = H ? H(C[de], h[de], de, C, h) : n;
            we === n && (we = h[de]), W ? dc(C, de, we) : z1(C, de, we);
          }
          return C;
        }
        function rZ(h, b) {
          return _u(h, C3(h), b);
        }
        function iZ(h, b) {
          return _u(h, WA(h), b);
        }
        function _2(h, b) {
          return function (C, H) {
            var W = yn(C) ? L1 : AX,
              ne = b ? b() : {};
            return W(C, h, sn(H, 2), ne);
          };
        }
        function np(h) {
          return Nn(function (b, C) {
            var H = -1,
              W = C.length,
              ne = W > 1 ? C[W - 1] : n,
              ue = W > 2 ? C[2] : n;
            for (
              ne = h.length > 3 && typeof ne == "function" ? (W--, ne) : n,
                ue && fa(C[0], C[1], ue) && ((ne = W < 3 ? n : ne), (W = 1)),
                b = Ar(b);
              ++H < W;

            ) {
              var de = C[H];
              de && h(b, de, H, ne);
            }
            return b;
          });
        }
        function RA(h, b) {
          return function (C, H) {
            if (C == null) return C;
            if (!ja(C)) return h(C, H);
            for (
              var W = C.length, ne = b ? W : -1, ue = Ar(C);
              (b ? ne-- : ++ne < W) && H(ue[ne], ne, ue) !== !1;

            );
            return C;
          };
        }
        function MA(h) {
          return function (b, C, H) {
            for (var W = -1, ne = Ar(b), ue = H(b), de = ue.length; de--; ) {
              var we = ue[h ? de : ++W];
              if (C(ne[we], we, ne) === !1) break;
            }
            return b;
          };
        }
        function sZ(h, b, C) {
          var H = b & w,
            W = K1(h);
          function ne() {
            var ue = this && this !== _t && this instanceof ne ? W : h;
            return ue.apply(H ? C : this, arguments);
          }
          return ne;
        }
        function LA(h) {
          return function (b) {
            b = fr(b);
            var C = Xh(b) ? Ol(b) : n,
              H = C ? C[0] : b.charAt(0),
              W = C ? vf(C, 1).join("") : b.slice(1);
            return H[h]() + W;
          };
        }
        function rp(h) {
          return function (b) {
            return Kt(RC(DC(b).replace(Qr, "")), h, "");
          };
        }
        function K1(h) {
          return function () {
            var b = arguments;
            switch (b.length) {
              case 0:
                return new h();
              case 1:
                return new h(b[0]);
              case 2:
                return new h(b[0], b[1]);
              case 3:
                return new h(b[0], b[1], b[2]);
              case 4:
                return new h(b[0], b[1], b[2], b[3]);
              case 5:
                return new h(b[0], b[1], b[2], b[3], b[4]);
              case 6:
                return new h(b[0], b[1], b[2], b[3], b[4], b[5]);
              case 7:
                return new h(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
            }
            var C = tp(h.prototype),
              H = h.apply(C, b);
            return Jr(H) ? H : C;
          };
        }
        function aZ(h, b, C) {
          var H = K1(h);
          function W() {
            for (
              var ne = arguments.length, ue = Ae(ne), de = ne, we = ip(W);
              de--;

            )
              ue[de] = arguments[de];
            var Le =
              ne < 3 && ue[0] !== we && ue[ne - 1] !== we ? [] : hf(ue, we);
            if (((ne -= Le.length), ne < C))
              return jA(h, b, E2, W.placeholder, n, ue, Le, n, n, C - ne);
            var Be = this && this !== _t && this instanceof W ? H : h;
            return fi(Be, this, ue);
          }
          return W;
        }
        function BA(h) {
          return function (b, C, H) {
            var W = Ar(b);
            if (!ja(b)) {
              var ne = sn(C, 3);
              (b = ms(b)),
                (C = function (de) {
                  return ne(W[de], de, W);
                });
            }
            var ue = h(b, C, H);
            return ue > -1 ? W[ne ? b[ue] : ue] : n;
          };
        }
        function FA(h) {
          return pc(function (b) {
            var C = b.length,
              H = C,
              W = Xo.prototype.thru;
            for (h && b.reverse(); H--; ) {
              var ne = b[H];
              if (typeof ne != "function") throw new Ko(a);
              if (W && !ue && A2(ne) == "wrapper") var ue = new Xo([], !0);
            }
            for (H = ue ? H : C; ++H < C; ) {
              ne = b[H];
              var de = A2(ne),
                we = de == "wrapper" ? S3(ne) : n;
              we &&
              I3(we[0]) &&
              we[1] == (x | E | D | _) &&
              !we[4].length &&
              we[9] == 1
                ? (ue = ue[A2(we[0])].apply(ue, we[3]))
                : (ue = ne.length == 1 && I3(ne) ? ue[de]() : ue.thru(ne));
            }
            return function () {
              var Le = arguments,
                Be = Le[0];
              if (ue && Le.length == 1 && yn(Be)) return ue.plant(Be).value();
              for (var Ve = 0, ft = C ? b[Ve].apply(this, Le) : Be; ++Ve < C; )
                ft = b[Ve].call(this, ft);
              return ft;
            };
          });
        }
        function E2(h, b, C, H, W, ne, ue, de, we, Le) {
          var Be = b & x,
            Ve = b & w,
            ft = b & y,
            Ut = b & (E | S),
            un = b & A,
            Pn = ft ? n : K1(h);
          function cn() {
            for (var Fn = arguments.length, Xn = Ae(Fn), wo = Fn; wo--; )
              Xn[wo] = arguments[wo];
            if (Ut)
              var da = ip(cn),
                _o = vK(Xn, da);
            if (
              (H && (Xn = NA(Xn, H, W, Ut)),
              ne && (Xn = DA(Xn, ne, ue, Ut)),
              (Fn -= _o),
              Ut && Fn < Le)
            ) {
              var Si = hf(Xn, da);
              return jA(h, b, E2, cn.placeholder, C, Xn, Si, de, we, Le - Fn);
            }
            var Dl = Ve ? C : this,
              vc = ft ? Dl[h] : h;
            return (
              (Fn = Xn.length),
              de ? (Xn = AZ(Xn, de)) : un && Fn > 1 && Xn.reverse(),
              Be && we < Fn && (Xn.length = we),
              this && this !== _t && this instanceof cn && (vc = Pn || K1(vc)),
              vc.apply(Dl, Xn)
            );
          }
          return cn;
        }
        function $A(h, b) {
          return function (C, H) {
            return RX(C, h, b(H), {});
          };
        }
        function x2(h, b) {
          return function (C, H) {
            var W;
            if (C === n && H === n) return b;
            if ((C !== n && (W = C), H !== n)) {
              if (W === n) return H;
              typeof C == "string" || typeof H == "string"
                ? ((C = vo(C)), (H = vo(H)))
                : ((C = TA(C)), (H = TA(H))),
                (W = h(C, H));
            }
            return W;
          };
        }
        function _3(h) {
          return pc(function (b) {
            return (
              (b = Ie(b, yo(sn()))),
              Nn(function (C) {
                var H = this;
                return h(b, function (W) {
                  return fi(W, H, C);
                });
              })
            );
          });
        }
        function T2(h, b) {
          b = b === n ? " " : vo(b);
          var C = b.length;
          if (C < 2) return C ? p3(b, h) : b;
          var H = p3(b, c2(h / Zh(b)));
          return Xh(b) ? vf(Ol(H), 0, h).join("") : H.slice(0, h);
        }
        function oZ(h, b, C, H) {
          var W = b & w,
            ne = K1(h);
          function ue() {
            for (
              var de = -1,
                we = arguments.length,
                Le = -1,
                Be = H.length,
                Ve = Ae(Be + we),
                ft = this && this !== _t && this instanceof ue ? ne : h;
              ++Le < Be;

            )
              Ve[Le] = H[Le];
            for (; we--; ) Ve[Le++] = arguments[++de];
            return fi(ft, W ? C : this, Ve);
          }
          return ue;
        }
        function UA(h) {
          return function (b, C, H) {
            return (
              H && typeof H != "number" && fa(b, C, H) && (C = H = n),
              (b = yc(b)),
              C === n ? ((C = b), (b = 0)) : (C = yc(C)),
              (H = H === n ? (b < C ? 1 : -1) : yc(H)),
              WX(b, C, H, h)
            );
          };
        }
        function S2(h) {
          return function (b, C) {
            return (
              (typeof b == "string" && typeof C == "string") ||
                ((b = Jo(b)), (C = Jo(C))),
              h(b, C)
            );
          };
        }
        function jA(h, b, C, H, W, ne, ue, de, we, Le) {
          var Be = b & E,
            Ve = Be ? ue : n,
            ft = Be ? n : ue,
            Ut = Be ? ne : n,
            un = Be ? n : ne;
          (b |= Be ? D : P), (b &= ~(Be ? P : D)), b & v || (b &= ~(w | y));
          var Pn = [h, b, W, Ut, Ve, un, ft, de, we, Le],
            cn = C.apply(n, Pn);
          return I3(h) && JA(cn, Pn), (cn.placeholder = H), eC(cn, h, b);
        }
        function E3(h) {
          var b = Ki[h];
          return function (C, H) {
            if (
              ((C = Jo(C)), (H = H == null ? 0 : Vs(Sn(H), 292)), H && eA(C))
            ) {
              var W = (fr(C) + "e").split("e"),
                ne = b(W[0] + "e" + (+W[1] + H));
              return (
                (W = (fr(ne) + "e").split("e")), +(W[0] + "e" + (+W[1] - H))
              );
            }
            return b(C);
          };
        }
        var lZ =
          Jh && 1 / e2(new Jh([, -0]))[1] == U
            ? function (h) {
                return new Jh(h);
              }
            : V3;
        function HA(h) {
          return function (b) {
            var C = Gs(b);
            return C == Ce ? Q6(b) : C == et ? SK(b) : yK(b, h(b));
          };
        }
        function hc(h, b, C, H, W, ne, ue, de) {
          var we = b & y;
          if (!we && typeof h != "function") throw new Ko(a);
          var Le = H ? H.length : 0;
          if (
            (Le || ((b &= ~(D | P)), (H = W = n)),
            (ue = ue === n ? ue : Xi(Sn(ue), 0)),
            (de = de === n ? de : Sn(de)),
            (Le -= W ? W.length : 0),
            b & P)
          ) {
            var Be = H,
              Ve = W;
            H = W = n;
          }
          var ft = we ? n : S3(h),
            Ut = [h, b, C, H, W, Be, Ve, ne, ue, de];
          if (
            (ft && xZ(Ut, ft),
            (h = Ut[0]),
            (b = Ut[1]),
            (C = Ut[2]),
            (H = Ut[3]),
            (W = Ut[4]),
            (de = Ut[9] =
              Ut[9] === n ? (we ? 0 : h.length) : Xi(Ut[9] - Le, 0)),
            !de && b & (E | S) && (b &= ~(E | S)),
            !b || b == w)
          )
            var un = sZ(h, b, C);
          else
            b == E || b == S
              ? (un = aZ(h, b, de))
              : (b == D || b == (w | D)) && !W.length
              ? (un = oZ(h, b, C, H))
              : (un = E2.apply(n, Ut));
          var Pn = ft ? EA : JA;
          return eC(Pn(un, Ut), h, b);
        }
        function zA(h, b, C, H) {
          return h === n || (Nl(h, Qh[C]) && !mr.call(H, C)) ? b : h;
        }
        function VA(h, b, C, H, W, ne) {
          return (
            Jr(h) && Jr(b) && (ne.set(b, h), v2(h, b, n, VA, ne), ne.delete(b)),
            h
          );
        }
        function uZ(h) {
          return Y1(h) ? n : h;
        }
        function GA(h, b, C, H, W, ne) {
          var ue = C & m,
            de = h.length,
            we = b.length;
          if (de != we && !(ue && we > de)) return !1;
          var Le = ne.get(h),
            Be = ne.get(b);
          if (Le && Be) return Le == b && Be == h;
          var Ve = -1,
            ft = !0,
            Ut = C & g ? new kd() : n;
          for (ne.set(h, b), ne.set(b, h); ++Ve < de; ) {
            var un = h[Ve],
              Pn = b[Ve];
            if (H)
              var cn = ue ? H(Pn, un, Ve, b, h, ne) : H(un, Pn, Ve, h, b, ne);
            if (cn !== n) {
              if (cn) continue;
              ft = !1;
              break;
            }
            if (Ut) {
              if (
                !Tn(b, function (Fn, Xn) {
                  if (!B1(Ut, Xn) && (un === Fn || W(un, Fn, C, H, ne)))
                    return Ut.push(Xn);
                })
              ) {
                ft = !1;
                break;
              }
            } else if (!(un === Pn || W(un, Pn, C, H, ne))) {
              ft = !1;
              break;
            }
          }
          return ne.delete(h), ne.delete(b), ft;
        }
        function cZ(h, b, C, H, W, ne, ue) {
          switch (C) {
            case je:
              if (h.byteLength != b.byteLength || h.byteOffset != b.byteOffset)
                return !1;
              (h = h.buffer), (b = b.buffer);
            case De:
              return !(
                h.byteLength != b.byteLength || !ne(new a2(h), new a2(b))
              );
            case Q:
            case ee:
            case ke:
              return Nl(+h, +b);
            case te:
              return h.name == b.name && h.message == b.message;
            case Ot:
            case st:
              return h == b + "";
            case Ce:
              var de = Q6;
            case et:
              var we = H & m;
              if ((de || (de = e2), h.size != b.size && !we)) return !1;
              var Le = ue.get(h);
              if (Le) return Le == b;
              (H |= g), ue.set(h, b);
              var Be = GA(de(h), de(b), H, W, ne, ue);
              return ue.delete(h), Be;
            case vt:
              if (H1) return H1.call(h) == H1.call(b);
          }
          return !1;
        }
        function fZ(h, b, C, H, W, ne) {
          var ue = C & m,
            de = x3(h),
            we = de.length,
            Le = x3(b),
            Be = Le.length;
          if (we != Be && !ue) return !1;
          for (var Ve = we; Ve--; ) {
            var ft = de[Ve];
            if (!(ue ? ft in b : mr.call(b, ft))) return !1;
          }
          var Ut = ne.get(h),
            un = ne.get(b);
          if (Ut && un) return Ut == b && un == h;
          var Pn = !0;
          ne.set(h, b), ne.set(b, h);
          for (var cn = ue; ++Ve < we; ) {
            ft = de[Ve];
            var Fn = h[ft],
              Xn = b[ft];
            if (H)
              var wo = ue ? H(Xn, Fn, ft, b, h, ne) : H(Fn, Xn, ft, h, b, ne);
            if (!(wo === n ? Fn === Xn || W(Fn, Xn, C, H, ne) : wo)) {
              Pn = !1;
              break;
            }
            cn || (cn = ft == "constructor");
          }
          if (Pn && !cn) {
            var da = h.constructor,
              _o = b.constructor;
            da != _o &&
              "constructor" in h &&
              "constructor" in b &&
              !(
                typeof da == "function" &&
                da instanceof da &&
                typeof _o == "function" &&
                _o instanceof _o
              ) &&
              (Pn = !1);
          }
          return ne.delete(h), ne.delete(b), Pn;
        }
        function pc(h) {
          return P3(YA(h, n, aC), h + "");
        }
        function x3(h) {
          return fA(h, ms, C3);
        }
        function T3(h) {
          return fA(h, Ha, WA);
        }
        var S3 = d2
          ? function (h) {
              return d2.get(h);
            }
          : V3;
        function A2(h) {
          for (
            var b = h.name + "", C = ep[b], H = mr.call(ep, b) ? C.length : 0;
            H--;

          ) {
            var W = C[H],
              ne = W.func;
            if (ne == null || ne == h) return W.name;
          }
          return b;
        }
        function ip(h) {
          var b = mr.call(J, "placeholder") ? J : h;
          return b.placeholder;
        }
        function sn() {
          var h = J.iteratee || H3;
          return (
            (h = h === H3 ? pA : h),
            arguments.length ? h(arguments[0], arguments[1]) : h
          );
        }
        function C2(h, b) {
          var C = h.__data__;
          return bZ(b) ? C[typeof b == "string" ? "string" : "hash"] : C.map;
        }
        function A3(h) {
          for (var b = ms(h), C = b.length; C--; ) {
            var H = b[C],
              W = h[H];
            b[C] = [H, W, XA(W)];
          }
          return b;
        }
        function Pd(h, b) {
          var C = EK(h, b);
          return hA(C) ? C : n;
        }
        function dZ(h) {
          var b = mr.call(h, Ad),
            C = h[Ad];
          try {
            h[Ad] = n;
            var H = !0;
          } catch {}
          var W = i2.call(h);
          return H && (b ? (h[Ad] = C) : delete h[Ad]), W;
        }
        var C3 = e3
            ? function (h) {
                return h == null
                  ? []
                  : ((h = Ar(h)),
                    ce(e3(h), function (b) {
                      return QS.call(h, b);
                    }));
              }
            : G3,
          WA = e3
            ? function (h) {
                for (var b = []; h; ) xt(b, C3(h)), (h = o2(h));
                return b;
              }
            : G3,
          Gs = ca;
        ((t3 && Gs(new t3(new ArrayBuffer(1))) != je) ||
          ($1 && Gs(new $1()) != Ce) ||
          (n3 && Gs(n3.resolve()) != Ft) ||
          (Jh && Gs(new Jh()) != et) ||
          (U1 && Gs(new U1()) != me)) &&
          (Gs = function (h) {
            var b = ca(h),
              C = b == Rt ? h.constructor : n,
              H = C ? Nd(C) : "";
            if (H)
              switch (H) {
                case KK:
                  return je;
                case XK:
                  return Ce;
                case ZK:
                  return Ft;
                case YK:
                  return et;
                case QK:
                  return me;
              }
            return b;
          });
        function hZ(h, b, C) {
          for (var H = -1, W = C.length; ++H < W; ) {
            var ne = C[H],
              ue = ne.size;
            switch (ne.type) {
              case "drop":
                h += ue;
                break;
              case "dropRight":
                b -= ue;
                break;
              case "take":
                b = Vs(b, h + ue);
                break;
              case "takeRight":
                h = Xi(h, b - ue);
                break;
            }
          }
          return { start: h, end: b };
        }
        function pZ(h) {
          var b = h.match(zt);
          return b ? b[1].split(Zt) : [];
        }
        function qA(h, b, C) {
          b = yf(b, h);
          for (var H = -1, W = b.length, ne = !1; ++H < W; ) {
            var ue = Eu(b[H]);
            if (!(ne = h != null && C(h, ue))) break;
            h = h[ue];
          }
          return ne || ++H != W
            ? ne
            : ((W = h == null ? 0 : h.length),
              !!W && R2(W) && mc(ue, W) && (yn(h) || Dd(h)));
        }
        function mZ(h) {
          var b = h.length,
            C = new h.constructor(b);
          return (
            b &&
              typeof h[0] == "string" &&
              mr.call(h, "index") &&
              ((C.index = h.index), (C.input = h.input)),
            C
          );
        }
        function KA(h) {
          return typeof h.constructor == "function" && !X1(h) ? tp(o2(h)) : {};
        }
        function gZ(h, b, C) {
          var H = h.constructor;
          switch (b) {
            case De:
              return w3(h);
            case Q:
            case ee:
              return new H(+h);
            case je:
              return JX(h, C);
            case lt:
            case Ke:
            case tt:
            case jt:
            case ct:
            case rt:
            case Dt:
            case Ht:
            case Yt:
              return OA(h, C);
            case Ce:
              return new H();
            case ke:
            case st:
              return new H(h);
            case Ot:
              return eZ(h);
            case et:
              return new H();
            case vt:
              return tZ(h);
          }
        }
        function yZ(h, b) {
          var C = b.length;
          if (!C) return h;
          var H = C - 1;
          return (
            (b[H] = (C > 1 ? "& " : "") + b[H]),
            (b = b.join(C > 2 ? ", " : " ")),
            h.replace(
              pt,
              `{
/* [wrapped with ` +
                b +
                `] */
`
            )
          );
        }
        function vZ(h) {
          return yn(h) || Dd(h) || !!(JS && h && h[JS]);
        }
        function mc(h, b) {
          var C = typeof h;
          return (
            (b = b ?? $),
            !!b &&
              (C == "number" || (C != "symbol" && Or.test(h))) &&
              h > -1 &&
              h % 1 == 0 &&
              h < b
          );
        }
        function fa(h, b, C) {
          if (!Jr(C)) return !1;
          var H = typeof b;
          return (
            H == "number" ? ja(C) && mc(b, C.length) : H == "string" && b in C
          )
            ? Nl(C[b], h)
            : !1;
        }
        function k3(h, b) {
          if (yn(h)) return !1;
          var C = typeof h;
          return C == "number" ||
            C == "symbol" ||
            C == "boolean" ||
            h == null ||
            bo(h)
            ? !0
            : nt.test(h) || !xe.test(h) || (b != null && h in Ar(b));
        }
        function bZ(h) {
          var b = typeof h;
          return b == "string" ||
            b == "number" ||
            b == "symbol" ||
            b == "boolean"
            ? h !== "__proto__"
            : h === null;
        }
        function I3(h) {
          var b = A2(h),
            C = J[b];
          if (typeof C != "function" || !(b in Hn.prototype)) return !1;
          if (h === C) return !0;
          var H = S3(C);
          return !!H && h === H[0];
        }
        function wZ(h) {
          return !!XS && XS in h;
        }
        var _Z = n2 ? gc : W3;
        function X1(h) {
          var b = h && h.constructor,
            C = (typeof b == "function" && b.prototype) || Qh;
          return h === C;
        }
        function XA(h) {
          return h === h && !Jr(h);
        }
        function ZA(h, b) {
          return function (C) {
            return C == null ? !1 : C[h] === b && (b !== n || h in Ar(C));
          };
        }
        function EZ(h) {
          var b = N2(h, function (H) {
              return C.size === u && C.clear(), H;
            }),
            C = b.cache;
          return b;
        }
        function xZ(h, b) {
          var C = h[1],
            H = b[1],
            W = C | H,
            ne = W < (w | y | x),
            ue =
              (H == x && C == E) ||
              (H == x && C == _ && h[7].length <= b[8]) ||
              (H == (x | _) && b[7].length <= b[8] && C == E);
          if (!(ne || ue)) return h;
          H & w && ((h[2] = b[2]), (W |= C & w ? 0 : v));
          var de = b[3];
          if (de) {
            var we = h[3];
            (h[3] = we ? NA(we, de, b[4]) : de),
              (h[4] = we ? hf(h[3], f) : b[4]);
          }
          return (
            (de = b[5]),
            de &&
              ((we = h[5]),
              (h[5] = we ? DA(we, de, b[6]) : de),
              (h[6] = we ? hf(h[5], f) : b[6])),
            (de = b[7]),
            de && (h[7] = de),
            H & x && (h[8] = h[8] == null ? b[8] : Vs(h[8], b[8])),
            h[9] == null && (h[9] = b[9]),
            (h[0] = b[0]),
            (h[1] = W),
            h
          );
        }
        function TZ(h) {
          var b = [];
          if (h != null) for (var C in Ar(h)) b.push(C);
          return b;
        }
        function SZ(h) {
          return i2.call(h);
        }
        function YA(h, b, C) {
          return (
            (b = Xi(b === n ? h.length - 1 : b, 0)),
            function () {
              for (
                var H = arguments,
                  W = -1,
                  ne = Xi(H.length - b, 0),
                  ue = Ae(ne);
                ++W < ne;

              )
                ue[W] = H[b + W];
              W = -1;
              for (var de = Ae(b + 1); ++W < b; ) de[W] = H[W];
              return (de[b] = C(ue)), fi(h, this, de);
            }
          );
        }
        function QA(h, b) {
          return b.length < 2 ? h : Od(h, Yo(b, 0, -1));
        }
        function AZ(h, b) {
          for (var C = h.length, H = Vs(b.length, C), W = Ua(h); H--; ) {
            var ne = b[H];
            h[H] = mc(ne, C) ? W[ne] : n;
          }
          return h;
        }
        function O3(h, b) {
          if (
            !(b === "constructor" && typeof h[b] == "function") &&
            b != "__proto__"
          )
            return h[b];
        }
        var JA = tC(EA),
          Z1 =
            jK ||
            function (h, b) {
              return _t.setTimeout(h, b);
            },
          P3 = tC(XX);
        function eC(h, b, C) {
          var H = b + "";
          return P3(h, yZ(H, CZ(pZ(H), C)));
        }
        function tC(h) {
          var b = 0,
            C = 0;
          return function () {
            var H = GK(),
              W = O - (H - C);
            if (((C = H), W > 0)) {
              if (++b >= T) return arguments[0];
            } else b = 0;
            return h.apply(n, arguments);
          };
        }
        function k2(h, b) {
          var C = -1,
            H = h.length,
            W = H - 1;
          for (b = b === n ? H : b; ++C < b; ) {
            var ne = h3(C, W),
              ue = h[ne];
            (h[ne] = h[C]), (h[C] = ue);
          }
          return (h.length = b), h;
        }
        var nC = EZ(function (h) {
          var b = [];
          return (
            h.charCodeAt(0) === 46 && b.push(""),
            h.replace(gt, function (C, H, W, ne) {
              b.push(W ? ne.replace($n, "$1") : H || C);
            }),
            b
          );
        });
        function Eu(h) {
          if (typeof h == "string" || bo(h)) return h;
          var b = h + "";
          return b == "0" && 1 / h == -U ? "-0" : b;
        }
        function Nd(h) {
          if (h != null) {
            try {
              return r2.call(h);
            } catch {}
            try {
              return h + "";
            } catch {}
          }
          return "";
        }
        function CZ(h, b) {
          return (
            X(fe, function (C) {
              var H = "_." + C[0];
              b & C[1] && !Ee(h, H) && h.push(H);
            }),
            h.sort()
          );
        }
        function rC(h) {
          if (h instanceof Hn) return h.clone();
          var b = new Xo(h.__wrapped__, h.__chain__);
          return (
            (b.__actions__ = Ua(h.__actions__)),
            (b.__index__ = h.__index__),
            (b.__values__ = h.__values__),
            b
          );
        }
        function kZ(h, b, C) {
          (C ? fa(h, b, C) : b === n) ? (b = 1) : (b = Xi(Sn(b), 0));
          var H = h == null ? 0 : h.length;
          if (!H || b < 1) return [];
          for (var W = 0, ne = 0, ue = Ae(c2(H / b)); W < H; )
            ue[ne++] = Yo(h, W, (W += b));
          return ue;
        }
        function IZ(h) {
          for (
            var b = -1, C = h == null ? 0 : h.length, H = 0, W = [];
            ++b < C;

          ) {
            var ne = h[b];
            ne && (W[H++] = ne);
          }
          return W;
        }
        function OZ() {
          var h = arguments.length;
          if (!h) return [];
          for (var b = Ae(h - 1), C = arguments[0], H = h; H--; )
            b[H - 1] = arguments[H];
          return xt(yn(C) ? Ua(C) : [C], Is(b, 1));
        }
        var PZ = Nn(function (h, b) {
            return Ti(h) ? V1(h, Is(b, 1, Ti, !0)) : [];
          }),
          NZ = Nn(function (h, b) {
            var C = Qo(b);
            return (
              Ti(C) && (C = n), Ti(h) ? V1(h, Is(b, 1, Ti, !0), sn(C, 2)) : []
            );
          }),
          DZ = Nn(function (h, b) {
            var C = Qo(b);
            return Ti(C) && (C = n), Ti(h) ? V1(h, Is(b, 1, Ti, !0), n, C) : [];
          });
        function RZ(h, b, C) {
          var H = h == null ? 0 : h.length;
          return H
            ? ((b = C || b === n ? 1 : Sn(b)), Yo(h, b < 0 ? 0 : b, H))
            : [];
        }
        function MZ(h, b, C) {
          var H = h == null ? 0 : h.length;
          return H
            ? ((b = C || b === n ? 1 : Sn(b)),
              (b = H - b),
              Yo(h, 0, b < 0 ? 0 : b))
            : [];
        }
        function LZ(h, b) {
          return h && h.length ? w2(h, sn(b, 3), !0, !0) : [];
        }
        function BZ(h, b) {
          return h && h.length ? w2(h, sn(b, 3), !0) : [];
        }
        function FZ(h, b, C, H) {
          var W = h == null ? 0 : h.length;
          return W
            ? (C && typeof C != "number" && fa(h, b, C) && ((C = 0), (H = W)),
              OX(h, b, C, H))
            : [];
        }
        function iC(h, b, C) {
          var H = h == null ? 0 : h.length;
          if (!H) return -1;
          var W = C == null ? 0 : Sn(C);
          return W < 0 && (W = Xi(H + W, 0)), Pr(h, sn(b, 3), W);
        }
        function sC(h, b, C) {
          var H = h == null ? 0 : h.length;
          if (!H) return -1;
          var W = H - 1;
          return (
            C !== n && ((W = Sn(C)), (W = C < 0 ? Xi(H + W, 0) : Vs(W, H - 1))),
            Pr(h, sn(b, 3), W, !0)
          );
        }
        function aC(h) {
          var b = h == null ? 0 : h.length;
          return b ? Is(h, 1) : [];
        }
        function $Z(h) {
          var b = h == null ? 0 : h.length;
          return b ? Is(h, U) : [];
        }
        function UZ(h, b) {
          var C = h == null ? 0 : h.length;
          return C ? ((b = b === n ? 1 : Sn(b)), Is(h, b)) : [];
        }
        function jZ(h) {
          for (var b = -1, C = h == null ? 0 : h.length, H = {}; ++b < C; ) {
            var W = h[b];
            H[W[0]] = W[1];
          }
          return H;
        }
        function oC(h) {
          return h && h.length ? h[0] : n;
        }
        function HZ(h, b, C) {
          var H = h == null ? 0 : h.length;
          if (!H) return -1;
          var W = C == null ? 0 : Sn(C);
          return W < 0 && (W = Xi(H + W, 0)), Br(h, b, W);
        }
        function zZ(h) {
          var b = h == null ? 0 : h.length;
          return b ? Yo(h, 0, -1) : [];
        }
        var VZ = Nn(function (h) {
            var b = Ie(h, v3);
            return b.length && b[0] === h[0] ? l3(b) : [];
          }),
          GZ = Nn(function (h) {
            var b = Qo(h),
              C = Ie(h, v3);
            return (
              b === Qo(C) ? (b = n) : C.pop(),
              C.length && C[0] === h[0] ? l3(C, sn(b, 2)) : []
            );
          }),
          WZ = Nn(function (h) {
            var b = Qo(h),
              C = Ie(h, v3);
            return (
              (b = typeof b == "function" ? b : n),
              b && C.pop(),
              C.length && C[0] === h[0] ? l3(C, n, b) : []
            );
          });
        function qZ(h, b) {
          return h == null ? "" : zK.call(h, b);
        }
        function Qo(h) {
          var b = h == null ? 0 : h.length;
          return b ? h[b - 1] : n;
        }
        function KZ(h, b, C) {
          var H = h == null ? 0 : h.length;
          if (!H) return -1;
          var W = H;
          return (
            C !== n && ((W = Sn(C)), (W = W < 0 ? Xi(H + W, 0) : Vs(W, H - 1))),
            b === b ? CK(h, b, W) : Pr(h, mo, W, !0)
          );
        }
        function XZ(h, b) {
          return h && h.length ? vA(h, Sn(b)) : n;
        }
        var ZZ = Nn(lC);
        function lC(h, b) {
          return h && h.length && b && b.length ? d3(h, b) : h;
        }
        function YZ(h, b, C) {
          return h && h.length && b && b.length ? d3(h, b, sn(C, 2)) : h;
        }
        function QZ(h, b, C) {
          return h && h.length && b && b.length ? d3(h, b, n, C) : h;
        }
        var JZ = pc(function (h, b) {
          var C = h == null ? 0 : h.length,
            H = i3(h, b);
          return (
            _A(
              h,
              Ie(b, function (W) {
                return mc(W, C) ? +W : W;
              }).sort(PA)
            ),
            H
          );
        });
        function eY(h, b) {
          var C = [];
          if (!(h && h.length)) return C;
          var H = -1,
            W = [],
            ne = h.length;
          for (b = sn(b, 3); ++H < ne; ) {
            var ue = h[H];
            b(ue, H, h) && (C.push(ue), W.push(H));
          }
          return _A(h, W), C;
        }
        function N3(h) {
          return h == null ? h : qK.call(h);
        }
        function tY(h, b, C) {
          var H = h == null ? 0 : h.length;
          return H
            ? (C && typeof C != "number" && fa(h, b, C)
                ? ((b = 0), (C = H))
                : ((b = b == null ? 0 : Sn(b)), (C = C === n ? H : Sn(C))),
              Yo(h, b, C))
            : [];
        }
        function nY(h, b) {
          return b2(h, b);
        }
        function rY(h, b, C) {
          return m3(h, b, sn(C, 2));
        }
        function iY(h, b) {
          var C = h == null ? 0 : h.length;
          if (C) {
            var H = b2(h, b);
            if (H < C && Nl(h[H], b)) return H;
          }
          return -1;
        }
        function sY(h, b) {
          return b2(h, b, !0);
        }
        function aY(h, b, C) {
          return m3(h, b, sn(C, 2), !0);
        }
        function oY(h, b) {
          var C = h == null ? 0 : h.length;
          if (C) {
            var H = b2(h, b, !0) - 1;
            if (Nl(h[H], b)) return H;
          }
          return -1;
        }
        function lY(h) {
          return h && h.length ? xA(h) : [];
        }
        function uY(h, b) {
          return h && h.length ? xA(h, sn(b, 2)) : [];
        }
        function cY(h) {
          var b = h == null ? 0 : h.length;
          return b ? Yo(h, 1, b) : [];
        }
        function fY(h, b, C) {
          return h && h.length
            ? ((b = C || b === n ? 1 : Sn(b)), Yo(h, 0, b < 0 ? 0 : b))
            : [];
        }
        function dY(h, b, C) {
          var H = h == null ? 0 : h.length;
          return H
            ? ((b = C || b === n ? 1 : Sn(b)),
              (b = H - b),
              Yo(h, b < 0 ? 0 : b, H))
            : [];
        }
        function hY(h, b) {
          return h && h.length ? w2(h, sn(b, 3), !1, !0) : [];
        }
        function pY(h, b) {
          return h && h.length ? w2(h, sn(b, 3)) : [];
        }
        var mY = Nn(function (h) {
            return gf(Is(h, 1, Ti, !0));
          }),
          gY = Nn(function (h) {
            var b = Qo(h);
            return Ti(b) && (b = n), gf(Is(h, 1, Ti, !0), sn(b, 2));
          }),
          yY = Nn(function (h) {
            var b = Qo(h);
            return (
              (b = typeof b == "function" ? b : n), gf(Is(h, 1, Ti, !0), n, b)
            );
          });
        function vY(h) {
          return h && h.length ? gf(h) : [];
        }
        function bY(h, b) {
          return h && h.length ? gf(h, sn(b, 2)) : [];
        }
        function wY(h, b) {
          return (
            (b = typeof b == "function" ? b : n),
            h && h.length ? gf(h, n, b) : []
          );
        }
        function D3(h) {
          if (!(h && h.length)) return [];
          var b = 0;
          return (
            (h = ce(h, function (C) {
              if (Ti(C)) return (b = Xi(C.length, b)), !0;
            })),
            Z6(b, function (C) {
              return Ie(h, go(C));
            })
          );
        }
        function uC(h, b) {
          if (!(h && h.length)) return [];
          var C = D3(h);
          return b == null
            ? C
            : Ie(C, function (H) {
                return fi(b, n, H);
              });
        }
        var _Y = Nn(function (h, b) {
            return Ti(h) ? V1(h, b) : [];
          }),
          EY = Nn(function (h) {
            return y3(ce(h, Ti));
          }),
          xY = Nn(function (h) {
            var b = Qo(h);
            return Ti(b) && (b = n), y3(ce(h, Ti), sn(b, 2));
          }),
          TY = Nn(function (h) {
            var b = Qo(h);
            return (b = typeof b == "function" ? b : n), y3(ce(h, Ti), n, b);
          }),
          SY = Nn(D3);
        function AY(h, b) {
          return CA(h || [], b || [], z1);
        }
        function CY(h, b) {
          return CA(h || [], b || [], q1);
        }
        var kY = Nn(function (h) {
          var b = h.length,
            C = b > 1 ? h[b - 1] : n;
          return (C = typeof C == "function" ? (h.pop(), C) : n), uC(h, C);
        });
        function cC(h) {
          var b = J(h);
          return (b.__chain__ = !0), b;
        }
        function IY(h, b) {
          return b(h), h;
        }
        function I2(h, b) {
          return b(h);
        }
        var OY = pc(function (h) {
          var b = h.length,
            C = b ? h[0] : 0,
            H = this.__wrapped__,
            W = function (ne) {
              return i3(ne, h);
            };
          return b > 1 ||
            this.__actions__.length ||
            !(H instanceof Hn) ||
            !mc(C)
            ? this.thru(W)
            : ((H = H.slice(C, +C + (b ? 1 : 0))),
              H.__actions__.push({ func: I2, args: [W], thisArg: n }),
              new Xo(H, this.__chain__).thru(function (ne) {
                return b && !ne.length && ne.push(n), ne;
              }));
        });
        function PY() {
          return cC(this);
        }
        function NY() {
          return new Xo(this.value(), this.__chain__);
        }
        function DY() {
          this.__values__ === n && (this.__values__ = TC(this.value()));
          var h = this.__index__ >= this.__values__.length,
            b = h ? n : this.__values__[this.__index__++];
          return { done: h, value: b };
        }
        function RY() {
          return this;
        }
        function MY(h) {
          for (var b, C = this; C instanceof p2; ) {
            var H = rC(C);
            (H.__index__ = 0),
              (H.__values__ = n),
              b ? (W.__wrapped__ = H) : (b = H);
            var W = H;
            C = C.__wrapped__;
          }
          return (W.__wrapped__ = h), b;
        }
        function LY() {
          var h = this.__wrapped__;
          if (h instanceof Hn) {
            var b = h;
            return (
              this.__actions__.length && (b = new Hn(this)),
              (b = b.reverse()),
              b.__actions__.push({ func: I2, args: [N3], thisArg: n }),
              new Xo(b, this.__chain__)
            );
          }
          return this.thru(N3);
        }
        function BY() {
          return AA(this.__wrapped__, this.__actions__);
        }
        var FY = _2(function (h, b, C) {
          mr.call(h, C) ? ++h[C] : dc(h, C, 1);
        });
        function $Y(h, b, C) {
          var H = yn(h) ? K : IX;
          return C && fa(h, b, C) && (b = n), H(h, sn(b, 3));
        }
        function UY(h, b) {
          var C = yn(h) ? ce : uA;
          return C(h, sn(b, 3));
        }
        var jY = BA(iC),
          HY = BA(sC);
        function zY(h, b) {
          return Is(O2(h, b), 1);
        }
        function VY(h, b) {
          return Is(O2(h, b), U);
        }
        function GY(h, b, C) {
          return (C = C === n ? 1 : Sn(C)), Is(O2(h, b), C);
        }
        function fC(h, b) {
          var C = yn(h) ? X : mf;
          return C(h, sn(b, 3));
        }
        function dC(h, b) {
          var C = yn(h) ? j : lA;
          return C(h, sn(b, 3));
        }
        var WY = _2(function (h, b, C) {
          mr.call(h, C) ? h[C].push(b) : dc(h, C, [b]);
        });
        function qY(h, b, C, H) {
          (h = ja(h) ? h : ap(h)), (C = C && !H ? Sn(C) : 0);
          var W = h.length;
          return (
            C < 0 && (C = Xi(W + C, 0)),
            M2(h) ? C <= W && h.indexOf(b, C) > -1 : !!W && Br(h, b, C) > -1
          );
        }
        var KY = Nn(function (h, b, C) {
            var H = -1,
              W = typeof b == "function",
              ne = ja(h) ? Ae(h.length) : [];
            return (
              mf(h, function (ue) {
                ne[++H] = W ? fi(b, ue, C) : G1(ue, b, C);
              }),
              ne
            );
          }),
          XY = _2(function (h, b, C) {
            dc(h, C, b);
          });
        function O2(h, b) {
          var C = yn(h) ? Ie : mA;
          return C(h, sn(b, 3));
        }
        function ZY(h, b, C, H) {
          return h == null
            ? []
            : (yn(b) || (b = b == null ? [] : [b]),
              (C = H ? n : C),
              yn(C) || (C = C == null ? [] : [C]),
              bA(h, b, C));
        }
        var YY = _2(
          function (h, b, C) {
            h[C ? 0 : 1].push(b);
          },
          function () {
            return [[], []];
          }
        );
        function QY(h, b, C) {
          var H = yn(h) ? Kt : zS,
            W = arguments.length < 3;
          return H(h, sn(b, 4), C, W, mf);
        }
        function JY(h, b, C) {
          var H = yn(h) ? ln : zS,
            W = arguments.length < 3;
          return H(h, sn(b, 4), C, W, lA);
        }
        function eQ(h, b) {
          var C = yn(h) ? ce : uA;
          return C(h, D2(sn(b, 3)));
        }
        function tQ(h) {
          var b = yn(h) ? iA : qX;
          return b(h);
        }
        function nQ(h, b, C) {
          (C ? fa(h, b, C) : b === n) ? (b = 1) : (b = Sn(b));
          var H = yn(h) ? TX : KX;
          return H(h, b);
        }
        function rQ(h) {
          var b = yn(h) ? SX : ZX;
          return b(h);
        }
        function iQ(h) {
          if (h == null) return 0;
          if (ja(h)) return M2(h) ? Zh(h) : h.length;
          var b = Gs(h);
          return b == Ce || b == et ? h.size : c3(h).length;
        }
        function sQ(h, b, C) {
          var H = yn(h) ? Tn : YX;
          return C && fa(h, b, C) && (b = n), H(h, sn(b, 3));
        }
        var aQ = Nn(function (h, b) {
            if (h == null) return [];
            var C = b.length;
            return (
              C > 1 && fa(h, b[0], b[1])
                ? (b = [])
                : C > 2 && fa(b[0], b[1], b[2]) && (b = [b[0]]),
              bA(h, Is(b, 1), [])
            );
          }),
          P2 =
            UK ||
            function () {
              return _t.Date.now();
            };
        function oQ(h, b) {
          if (typeof b != "function") throw new Ko(a);
          return (
            (h = Sn(h)),
            function () {
              if (--h < 1) return b.apply(this, arguments);
            }
          );
        }
        function hC(h, b, C) {
          return (
            (b = C ? n : b),
            (b = h && b == null ? h.length : b),
            hc(h, x, n, n, n, n, b)
          );
        }
        function pC(h, b) {
          var C;
          if (typeof b != "function") throw new Ko(a);
          return (
            (h = Sn(h)),
            function () {
              return (
                --h > 0 && (C = b.apply(this, arguments)), h <= 1 && (b = n), C
              );
            }
          );
        }
        var R3 = Nn(function (h, b, C) {
            var H = w;
            if (C.length) {
              var W = hf(C, ip(R3));
              H |= D;
            }
            return hc(h, H, b, C, W);
          }),
          mC = Nn(function (h, b, C) {
            var H = w | y;
            if (C.length) {
              var W = hf(C, ip(mC));
              H |= D;
            }
            return hc(b, H, h, C, W);
          });
        function gC(h, b, C) {
          b = C ? n : b;
          var H = hc(h, E, n, n, n, n, n, b);
          return (H.placeholder = gC.placeholder), H;
        }
        function yC(h, b, C) {
          b = C ? n : b;
          var H = hc(h, S, n, n, n, n, n, b);
          return (H.placeholder = yC.placeholder), H;
        }
        function vC(h, b, C) {
          var H,
            W,
            ne,
            ue,
            de,
            we,
            Le = 0,
            Be = !1,
            Ve = !1,
            ft = !0;
          if (typeof h != "function") throw new Ko(a);
          (b = Jo(b) || 0),
            Jr(C) &&
              ((Be = !!C.leading),
              (Ve = "maxWait" in C),
              (ne = Ve ? Xi(Jo(C.maxWait) || 0, b) : ne),
              (ft = "trailing" in C ? !!C.trailing : ft));
          function Ut(Si) {
            var Dl = H,
              vc = W;
            return (H = W = n), (Le = Si), (ue = h.apply(vc, Dl)), ue;
          }
          function un(Si) {
            return (Le = Si), (de = Z1(Fn, b)), Be ? Ut(Si) : ue;
          }
          function Pn(Si) {
            var Dl = Si - we,
              vc = Si - Le,
              BC = b - Dl;
            return Ve ? Vs(BC, ne - vc) : BC;
          }
          function cn(Si) {
            var Dl = Si - we,
              vc = Si - Le;
            return we === n || Dl >= b || Dl < 0 || (Ve && vc >= ne);
          }
          function Fn() {
            var Si = P2();
            if (cn(Si)) return Xn(Si);
            de = Z1(Fn, Pn(Si));
          }
          function Xn(Si) {
            return (de = n), ft && H ? Ut(Si) : ((H = W = n), ue);
          }
          function wo() {
            de !== n && kA(de), (Le = 0), (H = we = W = de = n);
          }
          function da() {
            return de === n ? ue : Xn(P2());
          }
          function _o() {
            var Si = P2(),
              Dl = cn(Si);
            if (((H = arguments), (W = this), (we = Si), Dl)) {
              if (de === n) return un(we);
              if (Ve) return kA(de), (de = Z1(Fn, b)), Ut(we);
            }
            return de === n && (de = Z1(Fn, b)), ue;
          }
          return (_o.cancel = wo), (_o.flush = da), _o;
        }
        var lQ = Nn(function (h, b) {
            return oA(h, 1, b);
          }),
          uQ = Nn(function (h, b, C) {
            return oA(h, Jo(b) || 0, C);
          });
        function cQ(h) {
          return hc(h, A);
        }
        function N2(h, b) {
          if (typeof h != "function" || (b != null && typeof b != "function"))
            throw new Ko(a);
          var C = function () {
            var H = arguments,
              W = b ? b.apply(this, H) : H[0],
              ne = C.cache;
            if (ne.has(W)) return ne.get(W);
            var ue = h.apply(this, H);
            return (C.cache = ne.set(W, ue) || ne), ue;
          };
          return (C.cache = new (N2.Cache || fc)()), C;
        }
        N2.Cache = fc;
        function D2(h) {
          if (typeof h != "function") throw new Ko(a);
          return function () {
            var b = arguments;
            switch (b.length) {
              case 0:
                return !h.call(this);
              case 1:
                return !h.call(this, b[0]);
              case 2:
                return !h.call(this, b[0], b[1]);
              case 3:
                return !h.call(this, b[0], b[1], b[2]);
            }
            return !h.apply(this, b);
          };
        }
        function fQ(h) {
          return pC(2, h);
        }
        var dQ = QX(function (h, b) {
            b =
              b.length == 1 && yn(b[0])
                ? Ie(b[0], yo(sn()))
                : Ie(Is(b, 1), yo(sn()));
            var C = b.length;
            return Nn(function (H) {
              for (var W = -1, ne = Vs(H.length, C); ++W < ne; )
                H[W] = b[W].call(this, H[W]);
              return fi(h, this, H);
            });
          }),
          M3 = Nn(function (h, b) {
            var C = hf(b, ip(M3));
            return hc(h, D, n, b, C);
          }),
          bC = Nn(function (h, b) {
            var C = hf(b, ip(bC));
            return hc(h, P, n, b, C);
          }),
          hQ = pc(function (h, b) {
            return hc(h, _, n, n, n, b);
          });
        function pQ(h, b) {
          if (typeof h != "function") throw new Ko(a);
          return (b = b === n ? b : Sn(b)), Nn(h, b);
        }
        function mQ(h, b) {
          if (typeof h != "function") throw new Ko(a);
          return (
            (b = b == null ? 0 : Xi(Sn(b), 0)),
            Nn(function (C) {
              var H = C[b],
                W = vf(C, 0, b);
              return H && xt(W, H), fi(h, this, W);
            })
          );
        }
        function gQ(h, b, C) {
          var H = !0,
            W = !0;
          if (typeof h != "function") throw new Ko(a);
          return (
            Jr(C) &&
              ((H = "leading" in C ? !!C.leading : H),
              (W = "trailing" in C ? !!C.trailing : W)),
            vC(h, b, { leading: H, maxWait: b, trailing: W })
          );
        }
        function yQ(h) {
          return hC(h, 1);
        }
        function vQ(h, b) {
          return M3(b3(b), h);
        }
        function bQ() {
          if (!arguments.length) return [];
          var h = arguments[0];
          return yn(h) ? h : [h];
        }
        function wQ(h) {
          return Zo(h, p);
        }
        function _Q(h, b) {
          return (b = typeof b == "function" ? b : n), Zo(h, p, b);
        }
        function EQ(h) {
          return Zo(h, c | p);
        }
        function xQ(h, b) {
          return (b = typeof b == "function" ? b : n), Zo(h, c | p, b);
        }
        function TQ(h, b) {
          return b == null || aA(h, b, ms(b));
        }
        function Nl(h, b) {
          return h === b || (h !== h && b !== b);
        }
        var SQ = S2(o3),
          AQ = S2(function (h, b) {
            return h >= b;
          }),
          Dd = dA(
            (function () {
              return arguments;
            })()
          )
            ? dA
            : function (h) {
                return di(h) && mr.call(h, "callee") && !QS.call(h, "callee");
              },
          yn = Ae.isArray,
          CQ = Sr ? yo(Sr) : MX;
        function ja(h) {
          return h != null && R2(h.length) && !gc(h);
        }
        function Ti(h) {
          return di(h) && ja(h);
        }
        function kQ(h) {
          return h === !0 || h === !1 || (di(h) && ca(h) == Q);
        }
        var bf = HK || W3,
          IQ = Gi ? yo(Gi) : LX;
        function OQ(h) {
          return di(h) && h.nodeType === 1 && !Y1(h);
        }
        function PQ(h) {
          if (h == null) return !0;
          if (
            ja(h) &&
            (yn(h) ||
              typeof h == "string" ||
              typeof h.splice == "function" ||
              bf(h) ||
              sp(h) ||
              Dd(h))
          )
            return !h.length;
          var b = Gs(h);
          if (b == Ce || b == et) return !h.size;
          if (X1(h)) return !c3(h).length;
          for (var C in h) if (mr.call(h, C)) return !1;
          return !0;
        }
        function NQ(h, b) {
          return W1(h, b);
        }
        function DQ(h, b, C) {
          C = typeof C == "function" ? C : n;
          var H = C ? C(h, b) : n;
          return H === n ? W1(h, b, n, C) : !!H;
        }
        function L3(h) {
          if (!di(h)) return !1;
          var b = ca(h);
          return (
            b == te ||
            b == F ||
            (typeof h.message == "string" &&
              typeof h.name == "string" &&
              !Y1(h))
          );
        }
        function RQ(h) {
          return typeof h == "number" && eA(h);
        }
        function gc(h) {
          if (!Jr(h)) return !1;
          var b = ca(h);
          return b == he || b == Te || b == Y || b == Nt;
        }
        function wC(h) {
          return typeof h == "number" && h == Sn(h);
        }
        function R2(h) {
          return typeof h == "number" && h > -1 && h % 1 == 0 && h <= $;
        }
        function Jr(h) {
          var b = typeof h;
          return h != null && (b == "object" || b == "function");
        }
        function di(h) {
          return h != null && typeof h == "object";
        }
        var _C = Wi ? yo(Wi) : FX;
        function MQ(h, b) {
          return h === b || u3(h, b, A3(b));
        }
        function LQ(h, b, C) {
          return (C = typeof C == "function" ? C : n), u3(h, b, A3(b), C);
        }
        function BQ(h) {
          return EC(h) && h != +h;
        }
        function FQ(h) {
          if (_Z(h)) throw new mn(s);
          return hA(h);
        }
        function $Q(h) {
          return h === null;
        }
        function UQ(h) {
          return h == null;
        }
        function EC(h) {
          return typeof h == "number" || (di(h) && ca(h) == ke);
        }
        function Y1(h) {
          if (!di(h) || ca(h) != Rt) return !1;
          var b = o2(h);
          if (b === null) return !0;
          var C = mr.call(b, "constructor") && b.constructor;
          return typeof C == "function" && C instanceof C && r2.call(C) == LK;
        }
        var B3 = $a ? yo($a) : $X;
        function jQ(h) {
          return wC(h) && h >= -$ && h <= $;
        }
        var xC = uc ? yo(uc) : UX;
        function M2(h) {
          return typeof h == "string" || (!yn(h) && di(h) && ca(h) == st);
        }
        function bo(h) {
          return typeof h == "symbol" || (di(h) && ca(h) == vt);
        }
        var sp = zs ? yo(zs) : jX;
        function HQ(h) {
          return h === n;
        }
        function zQ(h) {
          return di(h) && Gs(h) == me;
        }
        function VQ(h) {
          return di(h) && ca(h) == $e;
        }
        var GQ = S2(f3),
          WQ = S2(function (h, b) {
            return h <= b;
          });
        function TC(h) {
          if (!h) return [];
          if (ja(h)) return M2(h) ? Ol(h) : Ua(h);
          if (F1 && h[F1]) return TK(h[F1]());
          var b = Gs(h),
            C = b == Ce ? Q6 : b == et ? e2 : ap;
          return C(h);
        }
        function yc(h) {
          if (!h) return h === 0 ? h : 0;
          if (((h = Jo(h)), h === U || h === -U)) {
            var b = h < 0 ? -1 : 1;
            return b * B;
          }
          return h === h ? h : 0;
        }
        function Sn(h) {
          var b = yc(h),
            C = b % 1;
          return b === b ? (C ? b - C : b) : 0;
        }
        function SC(h) {
          return h ? Id(Sn(h), 0, V) : 0;
        }
        function Jo(h) {
          if (typeof h == "number") return h;
          if (bo(h)) return R;
          if (Jr(h)) {
            var b = typeof h.valueOf == "function" ? h.valueOf() : h;
            h = Jr(b) ? b + "" : b;
          }
          if (typeof h != "string") return h === 0 ? h : +h;
          h = VS(h);
          var C = os.test(h);
          return C || us.test(h)
            ? Me(h.slice(2), C ? 2 : 8)
            : as.test(h)
            ? R
            : +h;
        }
        function AC(h) {
          return _u(h, Ha(h));
        }
        function qQ(h) {
          return h ? Id(Sn(h), -$, $) : h === 0 ? h : 0;
        }
        function fr(h) {
          return h == null ? "" : vo(h);
        }
        var KQ = np(function (h, b) {
            if (X1(b) || ja(b)) {
              _u(b, ms(b), h);
              return;
            }
            for (var C in b) mr.call(b, C) && z1(h, C, b[C]);
          }),
          CC = np(function (h, b) {
            _u(b, Ha(b), h);
          }),
          L2 = np(function (h, b, C, H) {
            _u(b, Ha(b), h, H);
          }),
          XQ = np(function (h, b, C, H) {
            _u(b, ms(b), h, H);
          }),
          ZQ = pc(i3);
        function YQ(h, b) {
          var C = tp(h);
          return b == null ? C : sA(C, b);
        }
        var QQ = Nn(function (h, b) {
            h = Ar(h);
            var C = -1,
              H = b.length,
              W = H > 2 ? b[2] : n;
            for (W && fa(b[0], b[1], W) && (H = 1); ++C < H; )
              for (
                var ne = b[C], ue = Ha(ne), de = -1, we = ue.length;
                ++de < we;

              ) {
                var Le = ue[de],
                  Be = h[Le];
                (Be === n || (Nl(Be, Qh[Le]) && !mr.call(h, Le))) &&
                  (h[Le] = ne[Le]);
              }
            return h;
          }),
          JQ = Nn(function (h) {
            return h.push(n, VA), fi(kC, n, h);
          });
        function eJ(h, b) {
          return br(h, sn(b, 3), wu);
        }
        function tJ(h, b) {
          return br(h, sn(b, 3), a3);
        }
        function nJ(h, b) {
          return h == null ? h : s3(h, sn(b, 3), Ha);
        }
        function rJ(h, b) {
          return h == null ? h : cA(h, sn(b, 3), Ha);
        }
        function iJ(h, b) {
          return h && wu(h, sn(b, 3));
        }
        function sJ(h, b) {
          return h && a3(h, sn(b, 3));
        }
        function aJ(h) {
          return h == null ? [] : y2(h, ms(h));
        }
        function oJ(h) {
          return h == null ? [] : y2(h, Ha(h));
        }
        function F3(h, b, C) {
          var H = h == null ? n : Od(h, b);
          return H === n ? C : H;
        }
        function lJ(h, b) {
          return h != null && qA(h, b, PX);
        }
        function $3(h, b) {
          return h != null && qA(h, b, NX);
        }
        var uJ = $A(function (h, b, C) {
            b != null && typeof b.toString != "function" && (b = i2.call(b)),
              (h[b] = C);
          }, j3(za)),
          cJ = $A(function (h, b, C) {
            b != null && typeof b.toString != "function" && (b = i2.call(b)),
              mr.call(h, b) ? h[b].push(C) : (h[b] = [C]);
          }, sn),
          fJ = Nn(G1);
        function ms(h) {
          return ja(h) ? rA(h) : c3(h);
        }
        function Ha(h) {
          return ja(h) ? rA(h, !0) : HX(h);
        }
        function dJ(h, b) {
          var C = {};
          return (
            (b = sn(b, 3)),
            wu(h, function (H, W, ne) {
              dc(C, b(H, W, ne), H);
            }),
            C
          );
        }
        function hJ(h, b) {
          var C = {};
          return (
            (b = sn(b, 3)),
            wu(h, function (H, W, ne) {
              dc(C, W, b(H, W, ne));
            }),
            C
          );
        }
        var pJ = np(function (h, b, C) {
            v2(h, b, C);
          }),
          kC = np(function (h, b, C, H) {
            v2(h, b, C, H);
          }),
          mJ = pc(function (h, b) {
            var C = {};
            if (h == null) return C;
            var H = !1;
            (b = Ie(b, function (ne) {
              return (ne = yf(ne, h)), H || (H = ne.length > 1), ne;
            })),
              _u(h, T3(h), C),
              H && (C = Zo(C, c | d | p, uZ));
            for (var W = b.length; W--; ) g3(C, b[W]);
            return C;
          });
        function gJ(h, b) {
          return IC(h, D2(sn(b)));
        }
        var yJ = pc(function (h, b) {
          return h == null ? {} : VX(h, b);
        });
        function IC(h, b) {
          if (h == null) return {};
          var C = Ie(T3(h), function (H) {
            return [H];
          });
          return (
            (b = sn(b)),
            wA(h, C, function (H, W) {
              return b(H, W[0]);
            })
          );
        }
        function vJ(h, b, C) {
          b = yf(b, h);
          var H = -1,
            W = b.length;
          for (W || ((W = 1), (h = n)); ++H < W; ) {
            var ne = h == null ? n : h[Eu(b[H])];
            ne === n && ((H = W), (ne = C)), (h = gc(ne) ? ne.call(h) : ne);
          }
          return h;
        }
        function bJ(h, b, C) {
          return h == null ? h : q1(h, b, C);
        }
        function wJ(h, b, C, H) {
          return (
            (H = typeof H == "function" ? H : n), h == null ? h : q1(h, b, C, H)
          );
        }
        var OC = HA(ms),
          PC = HA(Ha);
        function _J(h, b, C) {
          var H = yn(h),
            W = H || bf(h) || sp(h);
          if (((b = sn(b, 4)), C == null)) {
            var ne = h && h.constructor;
            W
              ? (C = H ? new ne() : [])
              : Jr(h)
              ? (C = gc(ne) ? tp(o2(h)) : {})
              : (C = {});
          }
          return (
            (W ? X : wu)(h, function (ue, de, we) {
              return b(C, ue, de, we);
            }),
            C
          );
        }
        function EJ(h, b) {
          return h == null ? !0 : g3(h, b);
        }
        function xJ(h, b, C) {
          return h == null ? h : SA(h, b, b3(C));
        }
        function TJ(h, b, C, H) {
          return (
            (H = typeof H == "function" ? H : n),
            h == null ? h : SA(h, b, b3(C), H)
          );
        }
        function ap(h) {
          return h == null ? [] : Y6(h, ms(h));
        }
        function SJ(h) {
          return h == null ? [] : Y6(h, Ha(h));
        }
        function AJ(h, b, C) {
          return (
            C === n && ((C = b), (b = n)),
            C !== n && ((C = Jo(C)), (C = C === C ? C : 0)),
            b !== n && ((b = Jo(b)), (b = b === b ? b : 0)),
            Id(Jo(h), b, C)
          );
        }
        function CJ(h, b, C) {
          return (
            (b = yc(b)),
            C === n ? ((C = b), (b = 0)) : (C = yc(C)),
            (h = Jo(h)),
            DX(h, b, C)
          );
        }
        function kJ(h, b, C) {
          if (
            (C && typeof C != "boolean" && fa(h, b, C) && (b = C = n),
            C === n &&
              (typeof b == "boolean"
                ? ((C = b), (b = n))
                : typeof h == "boolean" && ((C = h), (h = n))),
            h === n && b === n
              ? ((h = 0), (b = 1))
              : ((h = yc(h)), b === n ? ((b = h), (h = 0)) : (b = yc(b))),
            h > b)
          ) {
            var H = h;
            (h = b), (b = H);
          }
          if (C || h % 1 || b % 1) {
            var W = tA();
            return Vs(h + W * (b - h + ve("1e-" + ((W + "").length - 1))), b);
          }
          return h3(h, b);
        }
        var IJ = rp(function (h, b, C) {
          return (b = b.toLowerCase()), h + (C ? NC(b) : b);
        });
        function NC(h) {
          return U3(fr(h).toLowerCase());
        }
        function DC(h) {
          return (h = fr(h)), h && h.replace(ar, bK).replace(Gr, "");
        }
        function OJ(h, b, C) {
          (h = fr(h)), (b = vo(b));
          var H = h.length;
          C = C === n ? H : Id(Sn(C), 0, H);
          var W = C;
          return (C -= b.length), C >= 0 && h.slice(C, W) == b;
        }
        function PJ(h) {
          return (h = fr(h)), h && fn.test(h) ? h.replace(on, wK) : h;
        }
        function NJ(h) {
          return (h = fr(h)), h && wt.test(h) ? h.replace(ht, "\\$&") : h;
        }
        var DJ = rp(function (h, b, C) {
            return h + (C ? "-" : "") + b.toLowerCase();
          }),
          RJ = rp(function (h, b, C) {
            return h + (C ? " " : "") + b.toLowerCase();
          }),
          MJ = LA("toLowerCase");
        function LJ(h, b, C) {
          (h = fr(h)), (b = Sn(b));
          var H = b ? Zh(h) : 0;
          if (!b || H >= b) return h;
          var W = (b - H) / 2;
          return T2(f2(W), C) + h + T2(c2(W), C);
        }
        function BJ(h, b, C) {
          (h = fr(h)), (b = Sn(b));
          var H = b ? Zh(h) : 0;
          return b && H < b ? h + T2(b - H, C) : h;
        }
        function FJ(h, b, C) {
          (h = fr(h)), (b = Sn(b));
          var H = b ? Zh(h) : 0;
          return b && H < b ? T2(b - H, C) + h : h;
        }
        function $J(h, b, C) {
          return (
            C || b == null ? (b = 0) : b && (b = +b),
            WK(fr(h).replace(rn, ""), b || 0)
          );
        }
        function UJ(h, b, C) {
          return (
            (C ? fa(h, b, C) : b === n) ? (b = 1) : (b = Sn(b)), p3(fr(h), b)
          );
        }
        function jJ() {
          var h = arguments,
            b = fr(h[0]);
          return h.length < 3 ? b : b.replace(h[1], h[2]);
        }
        var HJ = rp(function (h, b, C) {
          return h + (C ? "_" : "") + b.toLowerCase();
        });
        function zJ(h, b, C) {
          return (
            C && typeof C != "number" && fa(h, b, C) && (b = C = n),
            (C = C === n ? V : C >>> 0),
            C
              ? ((h = fr(h)),
                h &&
                (typeof b == "string" || (b != null && !B3(b))) &&
                ((b = vo(b)), !b && Xh(h))
                  ? vf(Ol(h), 0, C)
                  : h.split(b, C))
              : []
          );
        }
        var VJ = rp(function (h, b, C) {
          return h + (C ? " " : "") + U3(b);
        });
        function GJ(h, b, C) {
          return (
            (h = fr(h)),
            (C = C == null ? 0 : Id(Sn(C), 0, h.length)),
            (b = vo(b)),
            h.slice(C, C + b.length) == b
          );
        }
        function WJ(h, b, C) {
          var H = J.templateSettings;
          C && fa(h, b, C) && (b = n), (h = fr(h)), (b = L2({}, b, H, zA));
          var W = L2({}, b.imports, H.imports, zA),
            ne = ms(W),
            ue = Y6(W, ne),
            de,
            we,
            Le = 0,
            Be = b.interpolate || cs,
            Ve = "__p += '",
            ft = J6(
              (b.escape || cs).source +
                "|" +
                Be.source +
                "|" +
                (Be === Ye ? En : cs).source +
                "|" +
                (b.evaluate || cs).source +
                "|$",
              "g"
            ),
            Ut =
              "//# sourceURL=" +
              (mr.call(b, "sourceURL")
                ? (b.sourceURL + "").replace(/\s/g, " ")
                : "lodash.templateSources[" + ++vu + "]") +
              `
`;
          h.replace(ft, function (cn, Fn, Xn, wo, da, _o) {
            return (
              Xn || (Xn = wo),
              (Ve += h.slice(Le, _o).replace(lo, _K)),
              Fn &&
                ((de = !0),
                (Ve +=
                  `' +
__e(` +
                  Fn +
                  `) +
'`)),
              da &&
                ((we = !0),
                (Ve +=
                  `';
` +
                  da +
                  `;
__p += '`)),
              Xn &&
                (Ve +=
                  `' +
((__t = (` +
                  Xn +
                  `)) == null ? '' : __t) +
'`),
              (Le = _o + cn.length),
              cn
            );
          }),
            (Ve += `';
`);
          var un = mr.call(b, "variable") && b.variable;
          if (!un)
            Ve =
              `with (obj) {
` +
              Ve +
              `
}
`;
          else if (Vr.test(un)) throw new mn(o);
          (Ve = (we ? Ve.replace(sr, "") : Ve)
            .replace(Bt, "$1")
            .replace(en, "$1;")),
            (Ve =
              "function(" +
              (un || "obj") +
              `) {
` +
              (un
                ? ""
                : `obj || (obj = {});
`) +
              "var __t, __p = ''" +
              (de ? ", __e = _.escape" : "") +
              (we
                ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                : `;
`) +
              Ve +
              `return __p
}`);
          var Pn = MC(function () {
            return ur(ne, Ut + "return " + Ve).apply(n, ue);
          });
          if (((Pn.source = Ve), L3(Pn))) throw Pn;
          return Pn;
        }
        function qJ(h) {
          return fr(h).toLowerCase();
        }
        function KJ(h) {
          return fr(h).toUpperCase();
        }
        function XJ(h, b, C) {
          if (((h = fr(h)), h && (C || b === n))) return VS(h);
          if (!h || !(b = vo(b))) return h;
          var H = Ol(h),
            W = Ol(b),
            ne = GS(H, W),
            ue = WS(H, W) + 1;
          return vf(H, ne, ue).join("");
        }
        function ZJ(h, b, C) {
          if (((h = fr(h)), h && (C || b === n))) return h.slice(0, KS(h) + 1);
          if (!h || !(b = vo(b))) return h;
          var H = Ol(h),
            W = WS(H, Ol(b)) + 1;
          return vf(H, 0, W).join("");
        }
        function YJ(h, b, C) {
          if (((h = fr(h)), h && (C || b === n))) return h.replace(rn, "");
          if (!h || !(b = vo(b))) return h;
          var H = Ol(h),
            W = GS(H, Ol(b));
          return vf(H, W).join("");
        }
        function QJ(h, b) {
          var C = N,
            H = M;
          if (Jr(b)) {
            var W = "separator" in b ? b.separator : W;
            (C = "length" in b ? Sn(b.length) : C),
              (H = "omission" in b ? vo(b.omission) : H);
          }
          h = fr(h);
          var ne = h.length;
          if (Xh(h)) {
            var ue = Ol(h);
            ne = ue.length;
          }
          if (C >= ne) return h;
          var de = C - Zh(H);
          if (de < 1) return H;
          var we = ue ? vf(ue, 0, de).join("") : h.slice(0, de);
          if (W === n) return we + H;
          if ((ue && (de += we.length - de), B3(W))) {
            if (h.slice(de).search(W)) {
              var Le,
                Be = we;
              for (
                W.global || (W = J6(W.source, fr(In.exec(W)) + "g")),
                  W.lastIndex = 0;
                (Le = W.exec(Be));

              )
                var Ve = Le.index;
              we = we.slice(0, Ve === n ? de : Ve);
            }
          } else if (h.indexOf(vo(W), de) != de) {
            var ft = we.lastIndexOf(W);
            ft > -1 && (we = we.slice(0, ft));
          }
          return we + H;
        }
        function JJ(h) {
          return (h = fr(h)), h && Pt.test(h) ? h.replace(Tr, kK) : h;
        }
        var eee = rp(function (h, b, C) {
            return h + (C ? " " : "") + b.toUpperCase();
          }),
          U3 = LA("toUpperCase");
        function RC(h, b, C) {
          return (
            (h = fr(h)),
            (b = C ? n : b),
            b === n ? (xK(h) ? PK(h) : jn(h)) : h.match(b) || []
          );
        }
        var MC = Nn(function (h, b) {
            try {
              return fi(h, n, b);
            } catch (C) {
              return L3(C) ? C : new mn(C);
            }
          }),
          tee = pc(function (h, b) {
            return (
              X(b, function (C) {
                (C = Eu(C)), dc(h, C, R3(h[C], h));
              }),
              h
            );
          });
        function nee(h) {
          var b = h == null ? 0 : h.length,
            C = sn();
          return (
            (h = b
              ? Ie(h, function (H) {
                  if (typeof H[1] != "function") throw new Ko(a);
                  return [C(H[0]), H[1]];
                })
              : []),
            Nn(function (H) {
              for (var W = -1; ++W < b; ) {
                var ne = h[W];
                if (fi(ne[0], this, H)) return fi(ne[1], this, H);
              }
            })
          );
        }
        function ree(h) {
          return kX(Zo(h, c));
        }
        function j3(h) {
          return function () {
            return h;
          };
        }
        function iee(h, b) {
          return h == null || h !== h ? b : h;
        }
        var see = FA(),
          aee = FA(!0);
        function za(h) {
          return h;
        }
        function H3(h) {
          return pA(typeof h == "function" ? h : Zo(h, c));
        }
        function oee(h) {
          return gA(Zo(h, c));
        }
        function lee(h, b) {
          return yA(h, Zo(b, c));
        }
        var uee = Nn(function (h, b) {
            return function (C) {
              return G1(C, h, b);
            };
          }),
          cee = Nn(function (h, b) {
            return function (C) {
              return G1(h, C, b);
            };
          });
        function z3(h, b, C) {
          var H = ms(b),
            W = y2(b, H);
          C == null &&
            !(Jr(b) && (W.length || !H.length)) &&
            ((C = b), (b = h), (h = this), (W = y2(b, ms(b))));
          var ne = !(Jr(C) && "chain" in C) || !!C.chain,
            ue = gc(h);
          return (
            X(W, function (de) {
              var we = b[de];
              (h[de] = we),
                ue &&
                  (h.prototype[de] = function () {
                    var Le = this.__chain__;
                    if (ne || Le) {
                      var Be = h(this.__wrapped__),
                        Ve = (Be.__actions__ = Ua(this.__actions__));
                      return (
                        Ve.push({ func: we, args: arguments, thisArg: h }),
                        (Be.__chain__ = Le),
                        Be
                      );
                    }
                    return we.apply(h, xt([this.value()], arguments));
                  });
            }),
            h
          );
        }
        function fee() {
          return _t._ === this && (_t._ = BK), this;
        }
        function V3() {}
        function dee(h) {
          return (
            (h = Sn(h)),
            Nn(function (b) {
              return vA(b, h);
            })
          );
        }
        var hee = _3(Ie),
          pee = _3(K),
          mee = _3(Tn);
        function LC(h) {
          return k3(h) ? go(Eu(h)) : GX(h);
        }
        function gee(h) {
          return function (b) {
            return h == null ? n : Od(h, b);
          };
        }
        var yee = UA(),
          vee = UA(!0);
        function G3() {
          return [];
        }
        function W3() {
          return !1;
        }
        function bee() {
          return {};
        }
        function wee() {
          return "";
        }
        function _ee() {
          return !0;
        }
        function Eee(h, b) {
          if (((h = Sn(h)), h < 1 || h > $)) return [];
          var C = V,
            H = Vs(h, V);
          (b = sn(b)), (h -= V);
          for (var W = Z6(H, b); ++C < h; ) b(C);
          return W;
        }
        function xee(h) {
          return yn(h) ? Ie(h, Eu) : bo(h) ? [h] : Ua(nC(fr(h)));
        }
        function Tee(h) {
          var b = ++MK;
          return fr(h) + b;
        }
        var See = x2(function (h, b) {
            return h + b;
          }, 0),
          Aee = E3("ceil"),
          Cee = x2(function (h, b) {
            return h / b;
          }, 1),
          kee = E3("floor");
        function Iee(h) {
          return h && h.length ? g2(h, za, o3) : n;
        }
        function Oee(h, b) {
          return h && h.length ? g2(h, sn(b, 2), o3) : n;
        }
        function Pee(h) {
          return bu(h, za);
        }
        function Nee(h, b) {
          return bu(h, sn(b, 2));
        }
        function Dee(h) {
          return h && h.length ? g2(h, za, f3) : n;
        }
        function Ree(h, b) {
          return h && h.length ? g2(h, sn(b, 2), f3) : n;
        }
        var Mee = x2(function (h, b) {
            return h * b;
          }, 1),
          Lee = E3("round"),
          Bee = x2(function (h, b) {
            return h - b;
          }, 0);
        function Fee(h) {
          return h && h.length ? X6(h, za) : 0;
        }
        function $ee(h, b) {
          return h && h.length ? X6(h, sn(b, 2)) : 0;
        }
        return (
          (J.after = oQ),
          (J.ary = hC),
          (J.assign = KQ),
          (J.assignIn = CC),
          (J.assignInWith = L2),
          (J.assignWith = XQ),
          (J.at = ZQ),
          (J.before = pC),
          (J.bind = R3),
          (J.bindAll = tee),
          (J.bindKey = mC),
          (J.castArray = bQ),
          (J.chain = cC),
          (J.chunk = kZ),
          (J.compact = IZ),
          (J.concat = OZ),
          (J.cond = nee),
          (J.conforms = ree),
          (J.constant = j3),
          (J.countBy = FY),
          (J.create = YQ),
          (J.curry = gC),
          (J.curryRight = yC),
          (J.debounce = vC),
          (J.defaults = QQ),
          (J.defaultsDeep = JQ),
          (J.defer = lQ),
          (J.delay = uQ),
          (J.difference = PZ),
          (J.differenceBy = NZ),
          (J.differenceWith = DZ),
          (J.drop = RZ),
          (J.dropRight = MZ),
          (J.dropRightWhile = LZ),
          (J.dropWhile = BZ),
          (J.fill = FZ),
          (J.filter = UY),
          (J.flatMap = zY),
          (J.flatMapDeep = VY),
          (J.flatMapDepth = GY),
          (J.flatten = aC),
          (J.flattenDeep = $Z),
          (J.flattenDepth = UZ),
          (J.flip = cQ),
          (J.flow = see),
          (J.flowRight = aee),
          (J.fromPairs = jZ),
          (J.functions = aJ),
          (J.functionsIn = oJ),
          (J.groupBy = WY),
          (J.initial = zZ),
          (J.intersection = VZ),
          (J.intersectionBy = GZ),
          (J.intersectionWith = WZ),
          (J.invert = uJ),
          (J.invertBy = cJ),
          (J.invokeMap = KY),
          (J.iteratee = H3),
          (J.keyBy = XY),
          (J.keys = ms),
          (J.keysIn = Ha),
          (J.map = O2),
          (J.mapKeys = dJ),
          (J.mapValues = hJ),
          (J.matches = oee),
          (J.matchesProperty = lee),
          (J.memoize = N2),
          (J.merge = pJ),
          (J.mergeWith = kC),
          (J.method = uee),
          (J.methodOf = cee),
          (J.mixin = z3),
          (J.negate = D2),
          (J.nthArg = dee),
          (J.omit = mJ),
          (J.omitBy = gJ),
          (J.once = fQ),
          (J.orderBy = ZY),
          (J.over = hee),
          (J.overArgs = dQ),
          (J.overEvery = pee),
          (J.overSome = mee),
          (J.partial = M3),
          (J.partialRight = bC),
          (J.partition = YY),
          (J.pick = yJ),
          (J.pickBy = IC),
          (J.property = LC),
          (J.propertyOf = gee),
          (J.pull = ZZ),
          (J.pullAll = lC),
          (J.pullAllBy = YZ),
          (J.pullAllWith = QZ),
          (J.pullAt = JZ),
          (J.range = yee),
          (J.rangeRight = vee),
          (J.rearg = hQ),
          (J.reject = eQ),
          (J.remove = eY),
          (J.rest = pQ),
          (J.reverse = N3),
          (J.sampleSize = nQ),
          (J.set = bJ),
          (J.setWith = wJ),
          (J.shuffle = rQ),
          (J.slice = tY),
          (J.sortBy = aQ),
          (J.sortedUniq = lY),
          (J.sortedUniqBy = uY),
          (J.split = zJ),
          (J.spread = mQ),
          (J.tail = cY),
          (J.take = fY),
          (J.takeRight = dY),
          (J.takeRightWhile = hY),
          (J.takeWhile = pY),
          (J.tap = IY),
          (J.throttle = gQ),
          (J.thru = I2),
          (J.toArray = TC),
          (J.toPairs = OC),
          (J.toPairsIn = PC),
          (J.toPath = xee),
          (J.toPlainObject = AC),
          (J.transform = _J),
          (J.unary = yQ),
          (J.union = mY),
          (J.unionBy = gY),
          (J.unionWith = yY),
          (J.uniq = vY),
          (J.uniqBy = bY),
          (J.uniqWith = wY),
          (J.unset = EJ),
          (J.unzip = D3),
          (J.unzipWith = uC),
          (J.update = xJ),
          (J.updateWith = TJ),
          (J.values = ap),
          (J.valuesIn = SJ),
          (J.without = _Y),
          (J.words = RC),
          (J.wrap = vQ),
          (J.xor = EY),
          (J.xorBy = xY),
          (J.xorWith = TY),
          (J.zip = SY),
          (J.zipObject = AY),
          (J.zipObjectDeep = CY),
          (J.zipWith = kY),
          (J.entries = OC),
          (J.entriesIn = PC),
          (J.extend = CC),
          (J.extendWith = L2),
          z3(J, J),
          (J.add = See),
          (J.attempt = MC),
          (J.camelCase = IJ),
          (J.capitalize = NC),
          (J.ceil = Aee),
          (J.clamp = AJ),
          (J.clone = wQ),
          (J.cloneDeep = EQ),
          (J.cloneDeepWith = xQ),
          (J.cloneWith = _Q),
          (J.conformsTo = TQ),
          (J.deburr = DC),
          (J.defaultTo = iee),
          (J.divide = Cee),
          (J.endsWith = OJ),
          (J.eq = Nl),
          (J.escape = PJ),
          (J.escapeRegExp = NJ),
          (J.every = $Y),
          (J.find = jY),
          (J.findIndex = iC),
          (J.findKey = eJ),
          (J.findLast = HY),
          (J.findLastIndex = sC),
          (J.findLastKey = tJ),
          (J.floor = kee),
          (J.forEach = fC),
          (J.forEachRight = dC),
          (J.forIn = nJ),
          (J.forInRight = rJ),
          (J.forOwn = iJ),
          (J.forOwnRight = sJ),
          (J.get = F3),
          (J.gt = SQ),
          (J.gte = AQ),
          (J.has = lJ),
          (J.hasIn = $3),
          (J.head = oC),
          (J.identity = za),
          (J.includes = qY),
          (J.indexOf = HZ),
          (J.inRange = CJ),
          (J.invoke = fJ),
          (J.isArguments = Dd),
          (J.isArray = yn),
          (J.isArrayBuffer = CQ),
          (J.isArrayLike = ja),
          (J.isArrayLikeObject = Ti),
          (J.isBoolean = kQ),
          (J.isBuffer = bf),
          (J.isDate = IQ),
          (J.isElement = OQ),
          (J.isEmpty = PQ),
          (J.isEqual = NQ),
          (J.isEqualWith = DQ),
          (J.isError = L3),
          (J.isFinite = RQ),
          (J.isFunction = gc),
          (J.isInteger = wC),
          (J.isLength = R2),
          (J.isMap = _C),
          (J.isMatch = MQ),
          (J.isMatchWith = LQ),
          (J.isNaN = BQ),
          (J.isNative = FQ),
          (J.isNil = UQ),
          (J.isNull = $Q),
          (J.isNumber = EC),
          (J.isObject = Jr),
          (J.isObjectLike = di),
          (J.isPlainObject = Y1),
          (J.isRegExp = B3),
          (J.isSafeInteger = jQ),
          (J.isSet = xC),
          (J.isString = M2),
          (J.isSymbol = bo),
          (J.isTypedArray = sp),
          (J.isUndefined = HQ),
          (J.isWeakMap = zQ),
          (J.isWeakSet = VQ),
          (J.join = qZ),
          (J.kebabCase = DJ),
          (J.last = Qo),
          (J.lastIndexOf = KZ),
          (J.lowerCase = RJ),
          (J.lowerFirst = MJ),
          (J.lt = GQ),
          (J.lte = WQ),
          (J.max = Iee),
          (J.maxBy = Oee),
          (J.mean = Pee),
          (J.meanBy = Nee),
          (J.min = Dee),
          (J.minBy = Ree),
          (J.stubArray = G3),
          (J.stubFalse = W3),
          (J.stubObject = bee),
          (J.stubString = wee),
          (J.stubTrue = _ee),
          (J.multiply = Mee),
          (J.nth = XZ),
          (J.noConflict = fee),
          (J.noop = V3),
          (J.now = P2),
          (J.pad = LJ),
          (J.padEnd = BJ),
          (J.padStart = FJ),
          (J.parseInt = $J),
          (J.random = kJ),
          (J.reduce = QY),
          (J.reduceRight = JY),
          (J.repeat = UJ),
          (J.replace = jJ),
          (J.result = vJ),
          (J.round = Lee),
          (J.runInContext = ye),
          (J.sample = tQ),
          (J.size = iQ),
          (J.snakeCase = HJ),
          (J.some = sQ),
          (J.sortedIndex = nY),
          (J.sortedIndexBy = rY),
          (J.sortedIndexOf = iY),
          (J.sortedLastIndex = sY),
          (J.sortedLastIndexBy = aY),
          (J.sortedLastIndexOf = oY),
          (J.startCase = VJ),
          (J.startsWith = GJ),
          (J.subtract = Bee),
          (J.sum = Fee),
          (J.sumBy = $ee),
          (J.template = WJ),
          (J.times = Eee),
          (J.toFinite = yc),
          (J.toInteger = Sn),
          (J.toLength = SC),
          (J.toLower = qJ),
          (J.toNumber = Jo),
          (J.toSafeInteger = qQ),
          (J.toString = fr),
          (J.toUpper = KJ),
          (J.trim = XJ),
          (J.trimEnd = ZJ),
          (J.trimStart = YJ),
          (J.truncate = QJ),
          (J.unescape = JJ),
          (J.uniqueId = Tee),
          (J.upperCase = eee),
          (J.upperFirst = U3),
          (J.each = fC),
          (J.eachRight = dC),
          (J.first = oC),
          z3(
            J,
            (function () {
              var h = {};
              return (
                wu(J, function (b, C) {
                  mr.call(J.prototype, C) || (h[C] = b);
                }),
                h
              );
            })(),
            { chain: !1 }
          ),
          (J.VERSION = r),
          X(
            [
              "bind",
              "bindKey",
              "curry",
              "curryRight",
              "partial",
              "partialRight",
            ],
            function (h) {
              J[h].placeholder = J;
            }
          ),
          X(["drop", "take"], function (h, b) {
            (Hn.prototype[h] = function (C) {
              C = C === n ? 1 : Xi(Sn(C), 0);
              var H = this.__filtered__ && !b ? new Hn(this) : this.clone();
              return (
                H.__filtered__
                  ? (H.__takeCount__ = Vs(C, H.__takeCount__))
                  : H.__views__.push({
                      size: Vs(C, V),
                      type: h + (H.__dir__ < 0 ? "Right" : ""),
                    }),
                H
              );
            }),
              (Hn.prototype[h + "Right"] = function (C) {
                return this.reverse()[h](C).reverse();
              });
          }),
          X(["filter", "map", "takeWhile"], function (h, b) {
            var C = b + 1,
              H = C == I || C == L;
            Hn.prototype[h] = function (W) {
              var ne = this.clone();
              return (
                ne.__iteratees__.push({ iteratee: sn(W, 3), type: C }),
                (ne.__filtered__ = ne.__filtered__ || H),
                ne
              );
            };
          }),
          X(["head", "last"], function (h, b) {
            var C = "take" + (b ? "Right" : "");
            Hn.prototype[h] = function () {
              return this[C](1).value()[0];
            };
          }),
          X(["initial", "tail"], function (h, b) {
            var C = "drop" + (b ? "" : "Right");
            Hn.prototype[h] = function () {
              return this.__filtered__ ? new Hn(this) : this[C](1);
            };
          }),
          (Hn.prototype.compact = function () {
            return this.filter(za);
          }),
          (Hn.prototype.find = function (h) {
            return this.filter(h).head();
          }),
          (Hn.prototype.findLast = function (h) {
            return this.reverse().find(h);
          }),
          (Hn.prototype.invokeMap = Nn(function (h, b) {
            return typeof h == "function"
              ? new Hn(this)
              : this.map(function (C) {
                  return G1(C, h, b);
                });
          })),
          (Hn.prototype.reject = function (h) {
            return this.filter(D2(sn(h)));
          }),
          (Hn.prototype.slice = function (h, b) {
            h = Sn(h);
            var C = this;
            return C.__filtered__ && (h > 0 || b < 0)
              ? new Hn(C)
              : (h < 0 ? (C = C.takeRight(-h)) : h && (C = C.drop(h)),
                b !== n &&
                  ((b = Sn(b)), (C = b < 0 ? C.dropRight(-b) : C.take(b - h))),
                C);
          }),
          (Hn.prototype.takeRightWhile = function (h) {
            return this.reverse().takeWhile(h).reverse();
          }),
          (Hn.prototype.toArray = function () {
            return this.take(V);
          }),
          wu(Hn.prototype, function (h, b) {
            var C = /^(?:filter|find|map|reject)|While$/.test(b),
              H = /^(?:head|last)$/.test(b),
              W = J[H ? "take" + (b == "last" ? "Right" : "") : b],
              ne = H || /^find/.test(b);
            W &&
              (J.prototype[b] = function () {
                var ue = this.__wrapped__,
                  de = H ? [1] : arguments,
                  we = ue instanceof Hn,
                  Le = de[0],
                  Be = we || yn(ue),
                  Ve = function (Fn) {
                    var Xn = W.apply(J, xt([Fn], de));
                    return H && ft ? Xn[0] : Xn;
                  };
                Be &&
                  C &&
                  typeof Le == "function" &&
                  Le.length != 1 &&
                  (we = Be = !1);
                var ft = this.__chain__,
                  Ut = !!this.__actions__.length,
                  un = ne && !ft,
                  Pn = we && !Ut;
                if (!ne && Be) {
                  ue = Pn ? ue : new Hn(this);
                  var cn = h.apply(ue, de);
                  return (
                    cn.__actions__.push({ func: I2, args: [Ve], thisArg: n }),
                    new Xo(cn, ft)
                  );
                }
                return un && Pn
                  ? h.apply(this, de)
                  : ((cn = this.thru(Ve)),
                    un ? (H ? cn.value()[0] : cn.value()) : cn);
              });
          }),
          X(
            ["pop", "push", "shift", "sort", "splice", "unshift"],
            function (h) {
              var b = t2[h],
                C = /^(?:push|sort|unshift)$/.test(h) ? "tap" : "thru",
                H = /^(?:pop|shift)$/.test(h);
              J.prototype[h] = function () {
                var W = arguments;
                if (H && !this.__chain__) {
                  var ne = this.value();
                  return b.apply(yn(ne) ? ne : [], W);
                }
                return this[C](function (ue) {
                  return b.apply(yn(ue) ? ue : [], W);
                });
              };
            }
          ),
          wu(Hn.prototype, function (h, b) {
            var C = J[b];
            if (C) {
              var H = C.name + "";
              mr.call(ep, H) || (ep[H] = []), ep[H].push({ name: b, func: C });
            }
          }),
          (ep[E2(n, y).name] = [{ name: "wrapper", func: n }]),
          (Hn.prototype.clone = JK),
          (Hn.prototype.reverse = eX),
          (Hn.prototype.value = tX),
          (J.prototype.at = OY),
          (J.prototype.chain = PY),
          (J.prototype.commit = NY),
          (J.prototype.next = DY),
          (J.prototype.plant = MY),
          (J.prototype.reverse = LY),
          (J.prototype.toJSON = J.prototype.valueOf = J.prototype.value = BY),
          (J.prototype.first = J.prototype.head),
          F1 && (J.prototype[F1] = RY),
          J
        );
      },
      Yh = NK();
    tn ? (((tn.exports = Yh)._ = Yh), (Et._ = Yh)) : (_t._ = Yh);
  }).call(Am);
})(Kx, Kx.exports);
var OTe = Object.defineProperty,
  PTe = Object.defineProperties,
  NTe = Object.getOwnPropertyDescriptors,
  DL = Object.getOwnPropertySymbols,
  DTe = Object.prototype.hasOwnProperty,
  RTe = Object.prototype.propertyIsEnumerable,
  RL = (t, e, n) =>
    e in t
      ? OTe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Sv = (t, e) => {
    for (var n in e || (e = {})) DTe.call(e, n) && RL(t, n, e[n]);
    if (DL) for (var n of DL(e)) RTe.call(e, n) && RL(t, n, e[n]);
    return t;
  },
  MTe = (t, e) => PTe(t, NTe(e));
function pd(t, e, n) {
  var r;
  const i = $8e(t);
  return (
    ((r = e.rpcMap) == null ? void 0 : r[i.reference]) ||
    `${ITe}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
  );
}
function Gh(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function QW(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function LTe(t, e) {
  const n = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!n.length) return [];
  const r = [];
  return (
    n.forEach((i) => {
      const s = e.namespaces[i].accounts;
      r.push(...s);
    }),
    r
  );
}
function BTe(t = {}, e = {}) {
  const n = ML(t),
    r = ML(e);
  return Kx.exports.merge(n, r);
}
function ML(t) {
  var e, n, r, i;
  const s = {};
  if (!_0(t)) return s;
  for (const [a, o] of Object.entries(t)) {
    const l = aS(a) ? [a] : o.chains,
      u = o.methods || [],
      f = o.events || [],
      c = o.rpcMap || {},
      d = qm(a);
    s[d] = MTe(Sv(Sv({}, s[d]), o), {
      chains: P8(l, (e = s[d]) == null ? void 0 : e.chains),
      methods: P8(u, (n = s[d]) == null ? void 0 : n.methods),
      events: P8(f, (r = s[d]) == null ? void 0 : r.events),
      rpcMap: Sv(Sv({}, c), (i = s[d]) == null ? void 0 : i.rpcMap),
    });
  }
  return s;
}
function FTe(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function $Te(t) {
  const e = {};
  for (const [n, r] of Object.entries(t)) {
    const i = r.methods || [],
      s = r.events || [],
      a = r.accounts || [],
      o = aS(n) ? [n] : r.chains ? r.chains : QW(r.accounts);
    e[n] = { chains: o, methods: i, events: s, accounts: a };
  }
  return e;
}
function V8(t) {
  return typeof t == "number"
    ? t
    : t.includes("0x")
    ? parseInt(t, 16)
    : t.includes(":")
    ? Number(t.split(":")[1])
    : Number(t);
}
const JW = {},
  Yr = (t) => JW[t],
  G8 = (t, e) => {
    JW[t] = e;
  };
class UTe {
  constructor(e) {
    (this.name = "polkadot"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((n) => n.split(":")[1] === this.chainId.toString())
          .map((n) => n.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = Gh(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class jTe {
  constructor(e) {
    (this.name = "eip155"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.httpProviders = this.createHttpProviders()),
      (this.chainId = parseInt(this.getDefaultChain()));
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(e.request.method)
      ? await this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), n),
      (this.chainId = parseInt(e)),
      this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, n) {
    const r =
      n || pd(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new YW(r, Yr("disableProviderPing")));
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = parseInt(Gh(n));
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  getHttpProvider() {
    const e = this.chainId,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  async handleSwitchChain(e) {
    var n, r;
    let i = e.request.params
      ? (n = e.request.params[0]) == null
        ? void 0
        : n.chainId
      : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({
        topic: e.topic,
        request: { method: e.request.method, params: [{ chainId: i }] },
        chainId: (r = this.namespace.chains) == null ? void 0 : r[0],
      }),
        this.setDefaultChain(`${s}`);
    else
      throw new Error(
        `Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
      );
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
}
class HTe {
  constructor(e) {
    (this.name = "solana"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = Gh(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class zTe {
  constructor(e) {
    (this.name = "cosmos"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(
        ff.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = Gh(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class VTe {
  constructor(e) {
    (this.name = "cip34"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(
        ff.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        const r = this.getCardanoRPCUrl(n),
          i = Gh(n);
        e[i] = this.createHttpProvider(i, r);
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  getCardanoRPCUrl(e) {
    const n = this.namespace.rpcMap;
    if (n) return n[e];
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || this.getCardanoRPCUrl(e);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class GTe {
  constructor(e) {
    (this.name = "elrond"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = Gh(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class WTe {
  constructor(e) {
    (this.name = "multiversx"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = Gh(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
class qTe {
  constructor(e) {
    (this.name = "near"),
      (this.namespace = e.namespace),
      (this.events = Yr("events")),
      (this.client = Yr("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || pd(`${this.name}:${e}`, this.namespace);
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, r);
    }
    this.events.emit(ff.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((n) => n.split(":")[1] === this.chainId.toString())
          .map((n) => n.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        e[n] = this.createHttpProvider(
          n,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || pd(e, this.namespace);
    return typeof r > "u"
      ? void 0
      : new cf(new Vh(r, Yr("disableProviderPing")));
  }
}
var KTe = Object.defineProperty,
  XTe = Object.defineProperties,
  ZTe = Object.getOwnPropertyDescriptors,
  LL = Object.getOwnPropertySymbols,
  YTe = Object.prototype.hasOwnProperty,
  QTe = Object.prototype.propertyIsEnumerable,
  BL = (t, e, n) =>
    e in t
      ? KTe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Av = (t, e) => {
    for (var n in e || (e = {})) YTe.call(e, n) && BL(t, n, e[n]);
    if (LL) for (var n of LL(e)) QTe.call(e, n) && BL(t, n, e[n]);
    return t;
  },
  W8 = (t, e) => XTe(t, ZTe(e));
class gS {
  constructor(e) {
    (this.events = new ZT()),
      (this.rpcProviders = {}),
      (this.shouldAbortPairingAttempt = !1),
      (this.maxPairingAttempts = 10),
      (this.disableProviderPing = !1),
      (this.providerOpts = e),
      (this.logger =
        typeof e?.logger < "u" && typeof e?.logger != "string"
          ? e.logger
          : Qn.pino(Qn.getDefaultLoggerOptions({ level: e?.logger || PL }))),
      (this.disableProviderPing = e?.disableProviderPing || !1);
  }
  static async init(e) {
    const n = new gS(e);
    return await n.initialize(), n;
  }
  async request(e, n) {
    const [r, i] = this.validateChain(n);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(r).request({
      request: Av({}, e),
      chainId: `${r}:${i}`,
      topic: this.session.topic,
    });
  }
  sendAsync(e, n, r) {
    this.request(e, r)
      .then((i) => n(null, i))
      .catch((i) => n(i, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return (
      this.session ||
        (await this.connect({
          namespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
        })),
      await this.requestAccounts()
    );
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({
      topic: (e = this.session) == null ? void 0 : e.topic,
      reason: ki("USER_DISCONNECTED"),
    }),
      await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (
      (this.setNamespaces(e),
      await this.cleanupPendingPairings(),
      !e.skipPairing)
    )
      return await this.pair(e.pairingTopic);
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let n = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (n >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: r, approval: i } = await this.client.connect({
        pairingTopic: e,
        requiredNamespaces: this.namespaces,
        optionalNamespaces: this.optionalNamespaces,
        sessionProperties: this.sessionProperties,
      });
      r && ((this.uri = r), this.events.emit("display_uri", r)),
        await i()
          .then((s) => {
            (this.session = s),
              this.namespaces ||
                ((this.namespaces = $Te(s.namespaces)),
                this.persist("namespaces", this.namespaces));
          })
          .catch((s) => {
            if (s.message !== XW) throw s;
            n++;
          });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, n) {
    try {
      if (!this.session) return;
      const [r, i] = this.validateChain(e);
      this.getProvider(r).setDefaultChain(i, n);
    } catch (r) {
      if (!/Please call connect/.test(r.message)) throw r;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const n = this.client.pairing.getAll();
    if (tc(n)) {
      for (const r of n)
        e.deletePairings
          ? this.client.core.expirer.set(r.topic, 0)
          : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
      this.logger.info(`Inactive pairings cleared: ${n.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (
      ((this.namespaces = await this.getFromStore("namespaces")),
      (this.optionalNamespaces =
        (await this.getFromStore("optionalNamespaces")) || {}),
      this.client.session.length)
    ) {
      const e = this.client.session.keys.length - 1;
      (this.session = this.client.session.get(this.client.session.keys[e])),
        this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"),
      await this.createClient(),
      await this.checkStorage(),
      this.registerEventListeners();
  }
  async createClient() {
    (this.client =
      this.providerOpts.client ||
      (await ETe.init({
        logger: this.providerOpts.logger || PL,
        relayUrl: this.providerOpts.relayUrl || ATe,
        projectId: this.providerOpts.projectId,
        metadata: this.providerOpts.metadata,
        storageOptions: this.providerOpts.storageOptions,
        storage: this.providerOpts.storage,
        name: this.providerOpts.name,
      }))),
      this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error(
        "Session not initialized. Please call connect() before enable()"
      );
    const e = [
      ...new Set(Object.keys(this.session.namespaces).map((n) => qm(n))),
    ];
    G8("client", this.client),
      G8("events", this.events),
      G8("disableProviderPing", this.disableProviderPing),
      e.forEach((n) => {
        if (!this.session) return;
        const r = LTe(n, this.session),
          i = QW(r),
          s = BTe(this.namespaces, this.optionalNamespaces),
          a = W8(Av({}, s[n]), { accounts: r, chains: i });
        switch (n) {
          case "eip155":
            this.rpcProviders[n] = new jTe({ namespace: a });
            break;
          case "solana":
            this.rpcProviders[n] = new HTe({ namespace: a });
            break;
          case "cosmos":
            this.rpcProviders[n] = new zTe({ namespace: a });
            break;
          case "polkadot":
            this.rpcProviders[n] = new UTe({ namespace: a });
            break;
          case "cip34":
            this.rpcProviders[n] = new VTe({ namespace: a });
            break;
          case "elrond":
            this.rpcProviders[n] = new GTe({ namespace: a });
            break;
          case "multiversx":
            this.rpcProviders[n] = new WTe({ namespace: a });
            break;
          case "near":
            this.rpcProviders[n] = new qTe({ namespace: a });
            break;
        }
      });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }),
      this.client.on("session_event", (e) => {
        const { params: n } = e,
          { event: r } = n;
        if (r.name === "accountsChanged") {
          const i = r.data;
          i && tc(i) && this.events.emit("accountsChanged", i.map(FTe));
        } else if (r.name === "chainChanged") {
          const i = n.chainId,
            s = n.event.data,
            a = qm(i),
            o = V8(i) !== V8(s) ? `${a}:${V8(s)}` : i;
          this.onChainChanged(o);
        } else this.events.emit(r.name, r.data);
        this.events.emit("session_event", e);
      }),
      this.client.on("session_update", ({ topic: e, params: n }) => {
        var r;
        const { namespaces: i } = n,
          s = (r = this.client) == null ? void 0 : r.session.get(e);
        (this.session = W8(Av({}, s), { namespaces: i })),
          this.onSessionUpdate(),
          this.events.emit("session_update", { topic: e, params: n });
      }),
      this.client.on("session_delete", async (e) => {
        await this.cleanup(),
          this.events.emit("session_delete", e),
          this.events.emit(
            "disconnect",
            W8(Av({}, ki("USER_DISCONNECTED")), { data: e.topic })
          );
      }),
      this.on(ff.DEFAULT_CHAIN_CHANGED, (e) => {
        this.onChainChanged(e, !0);
      });
  }
  getProvider(e) {
    if (!this.rpcProviders[e]) throw new Error(`Provider not found: ${e}`);
    return this.rpcProviders[e];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var n;
      this.getProvider(e).updateNamespace(
        (n = this.session) == null ? void 0 : n.namespaces[e]
      );
    });
  }
  setNamespaces(e) {
    const { namespaces: n, optionalNamespaces: r, sessionProperties: i } = e;
    n && Object.keys(n).length && (this.namespaces = n),
      r && Object.keys(r).length && (this.optionalNamespaces = r),
      (this.sessionProperties = i),
      this.persist("namespaces", n),
      this.persist("optionalNamespaces", r);
  }
  validateChain(e) {
    const [n, r] = e?.split(":") || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r];
    if (
      n &&
      !Object.keys(this.namespaces || {})
        .map((a) => qm(a))
        .includes(n)
    )
      throw new Error(
        `Namespace '${n}' is not configured. Please call connect() first with namespace config.`
      );
    if (n && r) return [n, r];
    const i = qm(Object.keys(this.namespaces)[0]),
      s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, n = !1) {
    var r;
    if (!this.namespaces) return;
    const [i, s] = this.validateChain(e);
    n || this.getProvider(i).setDefaultChain(s),
      (((r = this.namespaces[i]) != null
        ? r
        : this.namespaces[`${i}:${s}`]
      ).defaultChain = s),
      this.persist("namespaces", this.namespaces),
      this.events.emit("chainChanged", s);
  }
  onConnect() {
    this.createProviders(),
      this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    (this.session = void 0),
      (this.namespaces = void 0),
      (this.optionalNamespaces = void 0),
      (this.sessionProperties = void 0),
      this.persist("namespaces", void 0),
      this.persist("optionalNamespaces", void 0),
      this.persist("sessionProperties", void 0),
      await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, n) {
    this.client.core.storage.setItem(`${NL}/${e}`, n);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${NL}/${e}`);
  }
}
const JTe = gS,
  eSe = "wc",
  tSe = "ethereum_provider",
  nSe = `${eSe}@2:${tSe}:`,
  rSe = "https://rpc.walletconnect.com/v1/",
  e1 = ["eth_sendTransaction", "personal_sign"],
  eq = [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
  ],
  ew = ["chainChanged", "accountsChanged"],
  tq = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var iSe = Object.defineProperty,
  sSe = Object.defineProperties,
  aSe = Object.getOwnPropertyDescriptors,
  FL = Object.getOwnPropertySymbols,
  oSe = Object.prototype.hasOwnProperty,
  lSe = Object.prototype.propertyIsEnumerable,
  $L = (t, e, n) =>
    e in t
      ? iSe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Xm = (t, e) => {
    for (var n in e || (e = {})) oSe.call(e, n) && $L(t, n, e[n]);
    if (FL) for (var n of FL(e)) lSe.call(e, n) && $L(t, n, e[n]);
    return t;
  },
  UL = (t, e) => sSe(t, aSe(e));
function tw(t) {
  return Number(t[0].split(":")[1]);
}
function q8(t) {
  return `0x${t.toString(16)}`;
}
function uSe(t) {
  const {
    chains: e,
    optionalChains: n,
    methods: r,
    optionalMethods: i,
    events: s,
    optionalEvents: a,
    rpcMap: o,
  } = t;
  if (!tc(e)) throw new Error("Invalid chains");
  const l = {
      chains: e,
      methods: r || e1,
      events: s || ew,
      rpcMap: Xm({}, e.length ? { [tw(e)]: o[tw(e)] } : {}),
    },
    u = s?.filter((p) => !ew.includes(p)),
    f = r?.filter((p) => !e1.includes(p));
  if (!n && !a && !i && !(u != null && u.length) && !(f != null && f.length))
    return { required: e.length ? l : void 0 };
  const c = (u?.length && f?.length) || !n,
    d = {
      chains: [...new Set(c ? l.chains.concat(n || []) : n)],
      methods: [...new Set(l.methods.concat(i != null && i.length ? i : eq))],
      events: [...new Set(l.events.concat(a != null && a.length ? a : tq))],
      rpcMap: o,
    };
  return { required: e.length ? l : void 0, optional: n.length ? d : void 0 };
}
let nq = class rq {
  constructor() {
    (this.events = new Fo.EventEmitter()),
      (this.namespace = "eip155"),
      (this.accounts = []),
      (this.chainId = 1),
      (this.STORAGE_KEY = nSe),
      (this.on = (e, n) => (this.events.on(e, n), this)),
      (this.once = (e, n) => (this.events.once(e, n), this)),
      (this.removeListener = (e, n) => (
        this.events.removeListener(e, n), this
      )),
      (this.off = (e, n) => (this.events.off(e, n), this)),
      (this.parseAccount = (e) =>
        this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e),
      (this.signer = {}),
      (this.rpc = {});
  }
  static async init(e) {
    const n = new rq();
    return await n.initialize(e), n;
  }
  async request(e) {
    return await this.signer.request(e, this.formatChainId(this.chainId));
  }
  sendAsync(e, n) {
    this.signer.sendAsync(e, n, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : !1;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;
  }
  async enable() {
    return (
      this.session || (await this.connect()),
      await this.request({ method: "eth_requestAccounts" })
    );
  }
  async connect(e) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(e);
    const { required: n, optional: r } = uSe(this.rpc);
    try {
      const i = await new Promise(async (a, o) => {
        var l;
        this.rpc.showQrModal &&
          ((l = this.modal) == null ||
            l.subscribeModal((u) => {
              !u.open &&
                !this.signer.session &&
                (this.signer.abortPairingAttempt(),
                o(new Error("Connection request reset. Please try again.")));
            })),
          await this.signer
            .connect(
              UL(
                Xm(
                  { namespaces: Xm({}, n && { [this.namespace]: n }) },
                  r && { optionalNamespaces: { [this.namespace]: r } }
                ),
                { pairingTopic: e?.pairingTopic }
              )
            )
            .then((u) => {
              a(u);
            })
            .catch((u) => {
              o(new Error(u.message));
            });
      });
      if (!i) return;
      const s = U8e(i.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : s),
        this.setAccounts(s),
        this.events.emit("connect", { chainId: q8(this.chainId) });
    } catch (i) {
      throw (this.signer.logger.error(i), i);
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && (await this.signer.disconnect()), this.reset();
  }
  get isWalletConnect() {
    return !0;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (e) => {
      const { params: n } = e,
        { event: r } = n;
      r.name === "accountsChanged"
        ? ((this.accounts = this.parseAccounts(r.data)),
          this.events.emit("accountsChanged", this.accounts))
        : r.name === "chainChanged"
        ? this.setChainId(this.formatChainId(r.data))
        : this.events.emit(r.name, r.data),
        this.events.emit("session_event", e);
    }),
      this.signer.on("chainChanged", (e) => {
        const n = parseInt(e);
        (this.chainId = n),
          this.events.emit("chainChanged", q8(this.chainId)),
          this.persist();
      }),
      this.signer.on("session_update", (e) => {
        this.events.emit("session_update", e);
      }),
      this.signer.on("session_delete", (e) => {
        this.reset(),
          this.events.emit("session_delete", e),
          this.events.emit(
            "disconnect",
            UL(Xm({}, ki("USER_DISCONNECTED")), {
              data: e.topic,
              name: "USER_DISCONNECTED",
            })
          );
      }),
      this.signer.on("display_uri", (e) => {
        var n, r;
        this.rpc.showQrModal &&
          ((n = this.modal) == null || n.closeModal(),
          (r = this.modal) == null || r.openModal({ uri: e })),
          this.events.emit("display_uri", e);
      });
  }
  switchEthereumChain(e) {
    this.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: e.toString(16) }],
    });
  }
  isCompatibleChainId(e) {
    return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1;
  }
  formatChainId(e) {
    return `${this.namespace}:${e}`;
  }
  parseChainId(e) {
    return Number(e.split(":")[1]);
  }
  setChainIds(e) {
    const n = e
      .filter((r) => this.isCompatibleChainId(r))
      .map((r) => this.parseChainId(r));
    n.length &&
      ((this.chainId = n[0]),
      this.events.emit("chainChanged", q8(this.chainId)),
      this.persist());
  }
  setChainId(e) {
    if (this.isCompatibleChainId(e)) {
      const n = this.parseChainId(e);
      (this.chainId = n), this.switchEthereumChain(n);
    }
  }
  parseAccountId(e) {
    const [n, r, i] = e.split(":");
    return { chainId: `${n}:${r}`, address: i };
  }
  setAccounts(e) {
    (this.accounts = e
      .filter(
        (n) =>
          this.parseChainId(this.parseAccountId(n).chainId) === this.chainId
      )
      .map((n) => this.parseAccountId(n).address)),
      this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(e) {
    var n, r;
    const i = (n = e?.chains) != null ? n : [],
      s = (r = e?.optionalChains) != null ? r : [],
      a = i.concat(s);
    if (!a.length)
      throw new Error(
        "No chains specified in either `chains` or `optionalChains`"
      );
    const o = i.length ? e?.methods || e1 : [],
      l = i.length ? e?.events || ew : [],
      u = e?.optionalMethods || [],
      f = e?.optionalEvents || [],
      c = e?.rpcMap || this.buildRpcMap(a, e.projectId),
      d = e?.qrModalOptions || void 0;
    return {
      chains: i?.map((p) => this.formatChainId(p)),
      optionalChains: s.map((p) => this.formatChainId(p)),
      methods: o,
      events: l,
      optionalMethods: u,
      optionalEvents: f,
      rpcMap: c,
      showQrModal: !!(e != null && e.showQrModal),
      qrModalOptions: d,
      projectId: e.projectId,
      metadata: e.metadata,
    };
  }
  buildRpcMap(e, n) {
    const r = {};
    return (
      e.forEach((i) => {
        r[i] = this.getRpcUrl(i, n);
      }),
      r
    );
  }
  async initialize(e) {
    if (
      ((this.rpc = this.getRpcConfig(e)),
      (this.chainId = this.rpc.chains.length
        ? tw(this.rpc.chains)
        : tw(this.rpc.optionalChains)),
      (this.signer = await JTe.init({
        projectId: this.rpc.projectId,
        metadata: this.rpc.metadata,
        disableProviderPing: e.disableProviderPing,
        relayUrl: e.relayUrl,
        storageOptions: e.storageOptions,
      })),
      this.registerEventListeners(),
      await this.loadPersistedSession(),
      this.rpc.showQrModal)
    ) {
      let n;
      try {
        const { WalletConnectModal: r } = await qe(
          () => import("./index-55399556.js").then((i) => i.i),
          ["assets/index-55399556.js", "assets/index.modern-10b57bf4.js"]
        );
        n = r;
      } catch {
        throw new Error(
          "To use QR modal, please install @walletconnect/modal package"
        );
      }
      if (n)
        try {
          this.modal = new n(
            Xm(
              {
                walletConnectVersion: 2,
                projectId: this.rpc.projectId,
                standaloneChains: this.rpc.chains,
              },
              this.rpc.qrModalOptions
            )
          );
        } catch (r) {
          throw (
            (this.signer.logger.error(r),
            new Error("Could not generate WalletConnectModal Instance"))
          );
        }
    }
  }
  loadConnectOpts(e) {
    if (!e) return;
    const { chains: n, optionalChains: r, rpcMap: i } = e;
    n &&
      tc(n) &&
      ((this.rpc.chains = n.map((s) => this.formatChainId(s))),
      n.forEach((s) => {
        this.rpc.rpcMap[s] = i?.[s] || this.getRpcUrl(s);
      })),
      r &&
        tc(r) &&
        ((this.rpc.optionalChains = []),
        (this.rpc.optionalChains = r?.map((s) => this.formatChainId(s))),
        r.forEach((s) => {
          this.rpc.rpcMap[s] = i?.[s] || this.getRpcUrl(s);
        }));
  }
  getRpcUrl(e, n) {
    var r;
    return (
      ((r = this.rpc.rpcMap) == null ? void 0 : r[e]) ||
      `${rSe}?chainId=eip155:${e}&projectId=${n || this.rpc.projectId}`
    );
  }
  async loadPersistedSession() {
    if (!this.session) return;
    const e = await this.signer.client.core.storage.getItem(
        `${this.STORAGE_KEY}/chainId`
      ),
      n = this.session.namespaces[`${this.namespace}:${e}`]
        ? this.session.namespaces[`${this.namespace}:${e}`]
        : this.session.namespaces[this.namespace];
    this.setChainIds(e ? [this.formatChainId(e)] : n?.accounts),
      this.setAccounts(n?.accounts);
  }
  reset() {
    (this.chainId = 1), (this.accounts = []);
  }
  persist() {
    this.session &&
      this.signer.client.core.storage.setItem(
        `${this.STORAGE_KEY}/chainId`,
        this.chainId
      );
  }
  parseAccounts(e) {
    return typeof e == "string" || e instanceof String
      ? [this.parseAccount(e)]
      : e.map((n) => this.parseAccount(n));
  }
};
const cSe = nq,
  fSe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        EthereumProvider: cSe,
        OPTIONAL_EVENTS: tq,
        OPTIONAL_METHODS: eq,
        REQUIRED_EVENTS: ew,
        REQUIRED_METHODS: e1,
        default: nq,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  jL = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "personal_sign",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v4",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
  ];
function dSe(t) {
  if (!t.projectId)
    throw new Error(
      "WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one."
    );
  t.dappUrl ||
    console.warn(
      "It is strongly recommended to supply a dappUrl to the WalletConnect init object as it is required by some wallets (i.e. MetaMask) to allow connection."
    );
  const {
    projectId: e,
    handleUri: n,
    requiredChains: r,
    optionalChains: i,
    qrModalOptions: s,
    additionalRequiredMethods: a,
    additionalOptionalMethods: o,
    dappUrl: l,
  } = t;
  let u;
  return () => ({
    label: "WalletConnect",
    getIcon: async () =>
      (await qe(() => import("./icon-dac2f3dc.js"), [])).default,
    getInterface: async ({ chains: f, EventEmitter: c, appMetadata: d }) => {
      const { ProviderRpcError: p, ProviderRpcErrorCode: m } = await qe(
          () => import("./index-89223ecf.js"),
          []
        ),
        { default: g } = await qe(
          () => Promise.resolve().then(() => fSe),
          void 0
        ),
        { Subject: w, fromEvent: y } = await qe(
          () => import("./index-0b890d5a.js"),
          [
            "assets/index-0b890d5a.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
            "assets/merge-f9009254.js",
          ]
        ),
        { takeUntil: v, take: E } = await qe(
          () => import("./index-dde4fcd0.js"),
          [
            "assets/index-dde4fcd0.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
          ]
        ),
        S = () => {
          if (!d) return;
          const O = l || d.explore || "";
          !O &&
            !O.length &&
            console.warn(
              "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection."
            );
          const I = {
            name: d.name,
            description: d.description || "",
            url: O,
            icons: [],
          };
          return (
            d.icon !== void 0 && d.icon.length && (I.icons = [d.icon]),
            d.logo !== void 0 &&
              d.logo.length &&
              (I.icons = I.icons.length ? [...I.icons, d.logo] : [d.logo]),
            I
          );
        },
        D =
          Array.isArray(r) && r.length && r.every((O) => !isNaN(O))
            ? r.map((O) => parseInt(O))
            : [],
        P =
          Array.isArray(i) && i.length && i.every((O) => !isNaN(O))
            ? i.map((O) => parseInt(O))
            : f.map(({ id: O }) => parseInt(O, 16)),
        x = new Set(a && Array.isArray(a) ? [...a, ...e1] : e1),
        _ = Array.from(x),
        A = o && Array.isArray(o) ? [...o, ...jL] : jL,
        N = await g.init({
          projectId: e,
          chains: D,
          methods: _,
          optionalChains: P,
          optionalMethods: A,
          showQrModal: !0,
          rpcMap: f
            .map(({ id: O, rpcUrl: I }) => ({ id: O, rpcUrl: I }))
            .reduce(
              (O, { id: I, rpcUrl: k }) => ((O[parseInt(I, 16)] = k || ""), O),
              {}
            ),
          metadata: S(),
          qrModalOptions: s,
        }),
        M = new c();
      class T {
        constructor({ connector: I, chains: k }) {
          (this.emit = M.emit.bind(M)),
            (this.on = M.on.bind(M)),
            (this.removeListener = M.removeListener.bind(M)),
            (this.connector = I),
            (this.chains = k),
            (this.disconnected$ = new w()),
            y(this.connector, "accountsChanged", (U) => U)
              .pipe(v(this.disconnected$))
              .subscribe({
                next: (U) => {
                  const $ = Array.isArray(U) ? U : [U];
                  this.emit("accountsChanged", $);
                },
                error: console.warn,
              }),
            y(this.connector, "chainChanged", (U) => U)
              .pipe(v(this.disconnected$))
              .subscribe({
                next: (U) => {
                  const $ = K8(U) ? U : `0x${U.toString(16)}`;
                  this.emit("chainChanged", $);
                },
                error: console.warn,
              }),
            y(this.connector, "session_delete", (U) => U)
              .pipe(v(this.disconnected$))
              .subscribe({
                next: () => {
                  this.emit("accountsChanged", []),
                    this.disconnected$.next(!0),
                    typeof localStorage < "u" &&
                      localStorage.removeItem("walletconnect");
                },
                error: console.warn,
              }),
            (this.disconnect = () => {
              this.connector.session &&
                (this.connector.disconnect(), (u = null));
            }),
            t &&
              n &&
              y(this.connector, "display_uri", (U) => U)
                .pipe(v(this.disconnected$))
                .subscribe(async (U) => {
                  try {
                    n && (await n(U));
                  } catch ($) {
                    throw `An error occurred when handling the URI. Error: ${$}`;
                  }
                }),
            (() => {
              const U = this.connector.session;
              (u = U),
                U &&
                  (this.emit("accountsChanged", this.connector.accounts),
                  this.emit("chainChanged", this.connector.chainId));
            })(),
            (this.request = async ({ method: U, params: $ }) => {
              if (U === "eth_chainId")
                return K8(this.connector.chainId)
                  ? this.connector.chainId
                  : `0x${this.connector.chainId.toString(16)}`;
              if (U === "eth_requestAccounts")
                return new Promise(async (B, R) => {
                  if (
                    (y(this.connector, "connect", (V) => V)
                      .pipe(E(1))
                      .subscribe({
                        next: ({ chainId: V }) => {
                          this.emit("accountsChanged", this.connector.accounts);
                          const oe = K8(V) ? V : `0x${V.toString(16)}`;
                          this.emit("chainChanged", oe),
                            B(this.connector.accounts);
                        },
                        error: R,
                      }),
                    !this.connector.session)
                  )
                    await this.connector.connect().catch((V) => {
                      console.error("err creating new session: ", V),
                        R(
                          new p({
                            code: 4001,
                            message: "User rejected the request.",
                          })
                        );
                    });
                  else {
                    const V = this.connector.accounts,
                      oe = this.connector.chainId;
                    u = this.connector.session;
                    const le = `0x${oe.toString(16)}`;
                    return this.emit("chainChanged", le), B(V);
                  }
                });
              if (U === "eth_selectAccounts")
                throw new p({
                  code: m.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${U}`,
                });
              if (U == "wallet_switchEthereumChain") {
                if (!$)
                  throw new p({
                    code: m.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                const B = $[0];
                if (!B.hasOwnProperty("chainId") || typeof B.chainId > "u")
                  throw new p({
                    code: m.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                return this.connector.request({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: B.chainId }],
                });
              }
              return this.connector.request({ method: U, params: $ });
            });
        }
      }
      return { provider: new T({ chains: f, connector: N }), instance: u };
    },
  });
}
const K8 = (t) => !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/));
function hSe(t) {
  if (!t)
    throw new Error(
      "WalletConnect requires an initialization object to be passed - see the official docs for an example: https://onboard.blocknative.com/docs/wallets/walletconnect"
    );
  if (t) {
    const e = z6e(t);
    if (e) throw e;
  }
  return dSe(t);
}
function pSe(t) {
  const {
    whitelistedDomains: e = [
      /^https:\/\/app\.safe\.global$/,
      /^https:\/\/safe\.global$/,
    ],
  } = t || {};
  return () =>
    window.self !== window.top
      ? {
          label: "Safe",
          getIcon: async () =>
            (await qe(() => import("./icon-0c67d57d.js"), [])).default,
          getInterface: async () => {
            const { default: r } = await qe(
                () => import("./index-64f3910f.js").then((d) => d.i),
                []
              ),
              { SafeAppProvider: i } = await qe(
                () => import("./index-b9a10edd.js").then((d) => d.i),
                []
              ),
              { createEIP1193Provider: s } = await qe(
                () => import("./index-89223ecf.js"),
                []
              ),
              a = r.default || r,
              o = { whitelistedDomains: e },
              l = new a(o),
              u = await Promise.race([
                l.safe.getInfo(),
                new Promise((d) => setTimeout(d, 200)),
              ]);
            if (!u)
              throw new Error(
                'App must be loaded in a Safe App context, head to <a href="https://app.safe.global/">the Safe</a> and open this website as an app.'
              );
            const f = new i(u, l);
            return {
              provider: s(f, {
                eth_requestAccounts: () => Promise.resolve([u.safeAddress]),
              }),
              instance: l,
            };
          },
        }
      : [];
}
function mSe(t = { walletConnectVersion: 1 }) {
  return () => ({
    label: "Ledger",
    getIcon: async () =>
      (await qe(() => import("./icon-e5293b86.js"), [])).default,
    getInterface: async ({ chains: e, EventEmitter: n }) => {
      const {
          loadConnectKit: r,
          SupportedProviders: i,
          SupportedProviderImplementations: s,
        } = await qe(() => import("./index-415cd7e2.js"), []),
        a = await r();
      t.enableDebugLogs && a.enableDebugLogs();
      const o = a.checkSupport({
          providerType: i.Ethereum,
          chainId: t?.chainId,
          infuraId: t?.infuraId,
          rpc: t?.rpc,
        }),
        l = await a.getProvider();
      if (o.providerImplementation === s.LedgerConnect) return { provider: l };
      const { StaticJsonRpcProvider: u } = await qe(
          () => import("./index-1bcacc07.js"),
          []
        ),
        { ProviderRpcError: f, ProviderRpcErrorCode: c } = await qe(
          () => import("./index-89223ecf.js"),
          []
        );
      await qe(() => import("./index-ef272306.js"), []);
      const { Subject: d, fromEvent: p } = await qe(
          () => import("./index-0b890d5a.js"),
          [
            "assets/index-0b890d5a.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
            "assets/merge-f9009254.js",
          ]
        ),
        { takeUntil: m, take: g } = await qe(
          () => import("./index-dde4fcd0.js"),
          [
            "assets/index-dde4fcd0.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
          ]
        ),
        w = l.connector,
        y = new n();
      class v {
        constructor({ connector: S, chains: D }) {
          (this.emit = y.emit.bind(y)),
            (this.on = y.on.bind(y)),
            (this.removeListener = y.removeListener.bind(y)),
            (this.connector = S),
            (this.chains = D),
            (this.disconnected$ = new d()),
            (this.providers = {});
          let P;
          p(this.connector, "session_update", (x, _) => {
            if (x) throw x;
            return _;
          })
            .pipe(m(this.disconnected$))
            .subscribe({
              next: ({ params: x }) => {
                const [{ accounts: _, chainId: A }] = x,
                  N = _.map((T) => T.toLowerCase());
                this.emit("accountsChanged", N);
                const M = Vf(A) ? A : `0x${A.toString(16)}`;
                (!P || P !== M) && (this.emit("chainChanged", M), (P = M));
              },
              error: console.warn,
            }),
            p(this.connector, "disconnect", (x, _) => {
              if (x) throw x;
              return _;
            })
              .pipe(m(this.disconnected$))
              .subscribe({
                next: () => {
                  this.emit("accountsChanged", []),
                    this.disconnected$.next(!0),
                    typeof localStorage < "u" &&
                      localStorage.removeItem("walletconnect");
                },
                error: console.warn,
              }),
            (this.disconnect = () => this.connector.killSession()),
            (this.request = async ({ method: x, params: _ }) => {
              if (x === "eth_chainId")
                return Vf(this.connector.chainId)
                  ? this.connector.chainId
                  : `0x${this.connector.chainId.toString(16)}`;
              if (x === "eth_requestAccounts")
                return new Promise((N, M) => {
                  if (
                    (p(this.connector, "connect", (T, O) => {
                      if (T) throw T;
                      return O;
                    })
                      .pipe(g(1))
                      .subscribe({
                        next: ({ params: T }) => {
                          const [{ accounts: O, chainId: I }] = T,
                            k = O.map((U) => U.toLowerCase());
                          this.emit("accountsChanged", k);
                          const L = Vf(I) ? I : `0x${I.toString(16)}`;
                          P || (P = L), this.emit("chainChanged", L), N(k);
                        },
                        error: M,
                      }),
                    !this.connector.connected)
                  )
                    N(l.request({ method: x, params: _ }));
                  else {
                    const { accounts: T, chainId: O } = this.connector.session,
                      I = Vf(O) ? O : `0x${O.toString(16)}`;
                    this.emit("chainChanged", I), P || (P = I);
                    const k = T.map((L) => L.toLowerCase());
                    return N(k);
                  }
                });
              if (x === "eth_selectAccounts")
                throw new f({
                  code: c.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${x}`,
                });
              if (x == "wallet_switchEthereumChain") {
                if (!_)
                  throw new f({
                    code: c.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                const N = _[0];
                if (!N.hasOwnProperty("chainId") || typeof N.chainId > "u")
                  throw new f({
                    code: c.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                return this.connector.sendCustomRequest({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: N.chainId }],
                });
              }
              if (x === "eth_sendTransaction")
                return this.connector.sendTransaction(_[0]);
              if (x === "eth_signTransaction")
                return this.connector.signTransaction(_[0]);
              if (x === "personal_sign")
                return this.connector.signPersonalMessage(_);
              if (x === "eth_sign") return this.connector.signMessage(_);
              if (x.includes("eth_signTypedData"))
                return this.connector.signTypedData(_);
              if (x === "eth_accounts")
                return this.connector.sendCustomRequest({
                  id: 1337,
                  jsonrpc: "2.0",
                  method: x,
                  params: _,
                });
              const A = await this.request({ method: "eth_chainId" });
              if (!this.providers[A]) {
                const N = D.find(({ id: M }) => M === A);
                if (!N)
                  throw new f({
                    code: c.CHAIN_NOT_ADDED,
                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${x}`,
                  });
                this.providers[A] = new u(N.rpcUrl);
              }
              return this.providers[A].send(x, _);
            });
        }
      }
      return { provider: new v({ chains: e, connector: w }) };
    },
  });
}
const HL = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4",
];
function gSe(t) {
  if (!t?.projectId)
    throw new Error(
      "WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one."
    );
  return () => ({
    label: "Ledger",
    getIcon: async () =>
      (await qe(() => import("./icon-e5293b86.js"), [])).default,
    getInterface: async ({ chains: e, EventEmitter: n }) => {
      var r;
      const {
          loadConnectKit: i,
          SupportedProviders: s,
          SupportedProviderImplementations: a,
        } = await qe(() => import("./index-415cd7e2.js"), []),
        o = await i();
      t?.enableDebugLogs && o.enableDebugLogs();
      const l =
          (r = t?.requiredChains) === null || r === void 0
            ? void 0
            : r.map((D) =>
                typeof D == "string" && Vf(D) ? parseInt(D, 16) : D
              ),
        u =
          t.optionalMethods && Array.isArray(t.optionalMethods)
            ? [...t.optionalMethods, ...HL]
            : HL,
        f = o.checkSupport({
          providerType: s.Ethereum,
          walletConnectVersion: 2,
          projectId: t?.projectId,
          chains: l,
          optionalChains: e.map(({ id: D }) => parseInt(D, 16)),
          methods: t?.requiredMethods,
          optionalMethods: u,
          events: t?.requiredEvents,
          optionalEvents: t?.optionalEvents,
          rpcMap: e
            .map(({ id: D, rpcUrl: P }) => ({ id: D, rpcUrl: P }))
            .reduce(
              (D, { id: P, rpcUrl: x }) => ((D[parseInt(P, 16)] = x || ""), D),
              {}
            ),
        }),
        c = await o.getProvider();
      if (f.providerImplementation === a.LedgerConnect) return { provider: c };
      const { ProviderRpcError: d, ProviderRpcErrorCode: p } = await qe(
        () => import("./index-89223ecf.js"),
        []
      );
      await qe(() => import("./index.es-4983a315.js"), []);
      const { Subject: m, fromEvent: g } = await qe(
          () => import("./index-0b890d5a.js"),
          [
            "assets/index-0b890d5a.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
            "assets/merge-f9009254.js",
          ]
        ),
        { takeUntil: w, take: y } = await qe(
          () => import("./index-dde4fcd0.js"),
          [
            "assets/index-dde4fcd0.js",
            "assets/zipWith-d975ae57.js",
            "assets/skip-5d19e776.js",
          ]
        ),
        v = c,
        E = new n();
      class S {
        constructor({ connector: P, chains: x }) {
          (this.emit = E.emit.bind(E)),
            (this.on = E.on.bind(E)),
            (this.removeListener = E.removeListener.bind(E)),
            (this.connector = P),
            (this.chains = x),
            (this.disconnected$ = new m()),
            g(this.connector, "accountsChanged", (A) => A)
              .pipe(w(this.disconnected$))
              .subscribe({
                next: (A) => {
                  this.emit("accountsChanged", A);
                },
                error: console.warn,
              }),
            g(this.connector, "chainChanged", (A) => A)
              .pipe(w(this.disconnected$))
              .subscribe({
                next: (A) => {
                  const N = Vf(A) ? A : `0x${A.toString(16)}`;
                  this.emit("chainChanged", N);
                },
                error: console.warn,
              }),
            g(this.connector, "session_delete", (A) => A)
              .pipe(w(this.disconnected$))
              .subscribe({
                next: () => {
                  this.emit("accountsChanged", []),
                    this.disconnected$.next(!0),
                    typeof localStorage < "u" &&
                      localStorage.removeItem("walletconnect");
                },
                error: console.warn,
              }),
            (this.disconnect = () => {
              this.connector.session && this.connector.disconnect();
            }),
            (() => {
              this.connector.session &&
                (this.emit("accountsChanged", this.connector.accounts),
                this.emit("chainChanged", this.connector.chainId));
            })(),
            (this.request = async ({ method: A, params: N }) => {
              if (A === "eth_chainId")
                return Vf(this.connector.chainId)
                  ? this.connector.chainId
                  : `0x${this.connector.chainId.toString(16)}`;
              if (A === "eth_requestAccounts")
                return new Promise(async (M, T) => {
                  if (
                    (g(this.connector, "connect", (O) => O)
                      .pipe(y(1))
                      .subscribe({
                        next: ({ chainId: O }) => {
                          this.emit("accountsChanged", this.connector.accounts);
                          const I = Vf(O) ? O : `0x${O.toString(16)}`;
                          this.emit("chainChanged", I),
                            M(this.connector.accounts);
                        },
                        error: T,
                      }),
                    !this.connector.session)
                  )
                    await c.request({ method: A }).catch((O) => {
                      console.error("err creating new session: ", O),
                        T(
                          new d({
                            code: 4001,
                            message: "User rejected the request.",
                          })
                        );
                    });
                  else {
                    const O = this.connector.accounts,
                      k = `0x${this.connector.chainId.toString(16)}`;
                    return this.emit("chainChanged", k), M(O);
                  }
                });
              if (A === "eth_selectAccounts")
                throw new d({
                  code: p.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${A}`,
                });
              if (A == "wallet_switchEthereumChain") {
                if (!N)
                  throw new d({
                    code: p.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                const M = N[0];
                if (!M.hasOwnProperty("chainId") || typeof M.chainId > "u")
                  throw new d({
                    code: p.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                return this.connector.request({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: M.chainId }],
                });
              }
              return this.connector.request({ method: A, params: N });
            });
        }
      }
      return { provider: new S({ chains: e, connector: v }) };
    },
  });
}
const Vf = (t) => !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/));
function ySe(t) {
  return (t?.walletConnectVersion || 2) === 1 ? mSe(t) : gSe(t);
}
const zL = "/assets/CVG-4d04f1dd.webp",
  vSe = "https://rpc.ankr.com/eth",
  bSe = { id: Qd(+"1"), token: "ETH", label: "mainnet", rpcUrl: vSe },
  wSe = {
    name: "Convergence ",
    icon: zL,
    logo: zL,
    description: "Governance Aggregator",
    recommendedInjectedWallets: [
      { name: "Coinbase", url: "https://wallet.coinbase.com/" },
      { name: "MetaMask", url: "https://metamask.io" },
    ],
  },
  _Se = [bSe],
  iq = {
    projectId: "1888aa23974cc2e255ca3e932fff0dd1",
    requiredChains: [+"1"],
    dappUrl: "https://app.cvg.finance/",
  },
  ESe = hSe(iq),
  xSe = pSe(),
  TSe = ySe(iq),
  SSe = [U6e(), ESe, xSe, TSe],
  ASe = ome({
    wallets: SSe,
    chains: _Se,
    appMetadata: wSe,
    theme: "dark",
    accountCenter: {
      desktop: { enabled: !0, position: "topRight" },
      mobile: { enabled: !0, position: "topRight" },
    },
    connect: { autoConnectLastWallet: !0 },
  });
function Xx() {
  return (
    (Xx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Xx.apply(this, arguments)
  );
}
function Zx(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function CSe(t) {
  if (Array.isArray(t)) return Zx(t);
}
function kSe(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function sq(t, e) {
  if (t) {
    if (typeof t == "string") return Zx(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Zx(t, e);
  }
}
function ISe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function OSe(t) {
  return CSe(t) || kSe(t) || sq(t) || ISe();
}
function PSe(t) {
  if (Array.isArray(t)) return t;
}
function NSe(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function DSe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Tc(t, e) {
  return PSe(t) || NSe(t, e) || sq(t, e) || DSe();
}
var N1 = Z.forwardRef(function (t, e) {
  var n = Z.useState(t.id),
    r = Tc(n, 2),
    i = r[0],
    s = r[1],
    a = Z.useState(!1),
    o = Tc(a, 2),
    l = o[0],
    u = o[1],
    f = Z.useState(!1),
    c = Tc(f, 2),
    d = c[0],
    p = c[1],
    m = Z.useState(t.maximized),
    g = Tc(m, 2),
    w = g[0],
    y = g[1],
    v = Z.useRef(null),
    E = Z.useRef(null),
    S = Z.useRef(null),
    D = Z.useRef(null),
    P = Z.useRef(null),
    x = Z.useRef(null),
    _ = Z.useRef(!1),
    A = Z.useRef(!1),
    N = Z.useRef(null),
    M = Z.useRef(null),
    T = Z.useRef(null),
    O = Z.useRef(""),
    I = t.onMaximize ? t.maximized : w,
    k = Gd({
      type: "keydown",
      listener: function (xe) {
        return Nt(xe);
      },
    }),
    L = Tc(k, 2),
    U = L[0],
    $ = L[1],
    B = Gd({
      type: "mousemove",
      target: function () {
        return window.document;
      },
      listener: function (xe) {
        return me(xe);
      },
    }),
    R = Tc(B, 2),
    V = R[0],
    oe = R[1],
    le = Gd({
      type: "mouseup",
      target: function () {
        return window.document;
      },
      listener: function (xe) {
        return $e(xe);
      },
    }),
    fe = Tc(le, 2),
    z = fe[0],
    se = fe[1],
    Y = Gd({
      type: "mousemove",
      target: function () {
        return window.document;
      },
      listener: function (xe) {
        return et(xe);
      },
    }),
    Q = Tc(Y, 2),
    ee = Q[0],
    F = Q[1],
    te = Gd({
      type: "mouseup",
      target: function () {
        return window.document;
      },
      listener: function (xe) {
        return st(xe);
      },
    }),
    he = Tc(te, 2),
    Te = he[0],
    Ce = he[1],
    ke = function (xe) {
      t.onHide(), xe.preventDefault();
    },
    at = function () {
      var xe = document.activeElement,
        nt = xe && v.current && v.current.contains(xe);
      !nt && t.closable && t.showHeader && x.current.focus();
    },
    Rt = function (xe) {
      t.dismissableMask && t.modal && E.current === xe.target && ke(xe),
        t.onMaskClick && t.onMaskClick(xe);
    },
    Ft = function (xe) {
      t.onMaximize
        ? t.onMaximize({ originalEvent: xe, maximized: !I })
        : y(function (nt) {
            return !nt;
          }),
        xe.preventDefault();
    },
    Nt = function (xe) {
      var nt = xe.currentTarget;
      if (!(!nt || !nt.primeDialogParams)) {
        var gt = nt.primeDialogParams,
          ht = gt.length,
          wt = gt[ht - 1] ? gt[ht - 1].id : void 0;
        if (wt === i) {
          var rn = document.getElementById(wt);
          if (t.closable && t.closeOnEscape && xe.key === "Escape")
            ke(xe), xe.stopImmediatePropagation(), gt.splice(ht - 1, 1);
          else if (xe.key === "Tab") {
            xe.preventDefault();
            var ot = it.getFocusableElements(rn);
            if (ot && ot.length > 0)
              if (!document.activeElement) ot[0].focus();
              else {
                var pt = ot.indexOf(document.activeElement);
                xe.shiftKey
                  ? pt === -1 || pt === 0
                    ? ot[ot.length - 1].focus()
                    : ot[pt - 1].focus()
                  : pt === -1 || pt === ot.length - 1
                  ? ot[0].focus()
                  : ot[pt + 1].focus();
              }
          }
        }
      }
    },
    Ot = function (xe) {
      it.hasClass(xe.target, "p-dialog-header-icon") ||
        it.hasClass(xe.target.parentElement, "p-dialog-header-icon") ||
        (t.draggable &&
          ((_.current = !0),
          (N.current = xe.pageX),
          (M.current = xe.pageY),
          (v.current.style.margin = "0"),
          it.addClass(document.body, "p-unselectable-text"),
          t.onDragStart && t.onDragStart(xe)));
    },
    et = function (xe) {
      if (_.current) {
        var nt = it.getOuterWidth(v.current),
          gt = it.getOuterHeight(v.current),
          ht = xe.pageX - N.current,
          wt = xe.pageY - M.current,
          rn = v.current.getBoundingClientRect(),
          ot = rn.left + ht,
          pt = rn.top + wt,
          zt = it.getViewport();
        (v.current.style.position = "fixed"),
          t.keepInViewport
            ? (ot >= t.minX &&
                ot + nt < zt.width &&
                ((N.current = xe.pageX), (v.current.style.left = ot + "px")),
              pt >= t.minY &&
                pt + gt < zt.height &&
                ((M.current = xe.pageY), (v.current.style.top = pt + "px")))
            : ((N.current = xe.pageX),
              (v.current.style.left = ot + "px"),
              (M.current = xe.pageY),
              (v.current.style.top = pt + "px")),
          t.onDrag && t.onDrag(xe);
      }
    },
    st = function (xe) {
      _.current &&
        ((_.current = !1),
        it.removeClass(document.body, "p-unselectable-text"),
        t.onDragEnd && t.onDragEnd(xe));
    },
    vt = function (xe) {
      t.resizable &&
        ((A.current = !0),
        (N.current = xe.pageX),
        (M.current = xe.pageY),
        it.addClass(document.body, "p-unselectable-text"),
        t.onResizeStart && t.onResizeStart(xe));
    },
    Re = function (xe, nt, gt) {
      !gt && (gt = it.getViewport());
      var ht = parseInt(xe);
      return /^(\d+|(\.\d+))(\.\d+)?%$/.test(xe) ? ht * (gt[nt] / 100) : ht;
    },
    me = function (xe) {
      if (A.current) {
        var nt = xe.pageX - N.current,
          gt = xe.pageY - M.current,
          ht = it.getOuterWidth(v.current),
          wt = it.getOuterHeight(v.current),
          rn = v.current.getBoundingClientRect(),
          ot = it.getViewport(),
          pt =
            !parseInt(v.current.style.top) || !parseInt(v.current.style.left),
          zt = Re(v.current.style.minWidth, "width", ot),
          Zt = Re(v.current.style.minHeight, "height", ot),
          $t = ht + nt,
          Vr = wt + gt;
        pt && (($t += nt), (Vr += gt)),
          (!zt || $t > zt) &&
            rn.left + $t < ot.width &&
            (v.current.style.width = $t + "px"),
          (!Zt || Vr > Zt) &&
            rn.top + Vr < ot.height &&
            (v.current.style.height = Vr + "px"),
          (N.current = xe.pageX),
          (M.current = xe.pageY),
          t.onResize && t.onResize(xe);
      }
    },
    $e = function (xe) {
      A.current &&
        ((A.current = !1),
        it.removeClass(document.body, "p-unselectable-text"),
        t.onResizeEnd && t.onResizeEnd(xe));
    },
    De = function () {
      (v.current.style.position = ""),
        (v.current.style.left = ""),
        (v.current.style.top = ""),
        (v.current.style.margin = "");
    },
    je = function () {
      var xe = [
          "center",
          "left",
          "right",
          "top",
          "top-left",
          "top-right",
          "bottom",
          "bottom-left",
          "bottom-right",
        ],
        nt = xe.find(function (gt) {
          return gt === t.position || gt.replace("-", "") === t.position;
        });
      return nt ? "p-dialog-".concat(nt) : "";
    },
    lt = function () {
      v.current.setAttribute(O.current, "");
    },
    Ke = function () {
      t.onShow && t.onShow(), t.focusOnShow && at(), ct();
    },
    tt = function () {
      t.modal && it.addClass(E.current, "p-component-overlay-leave"),
        t.blockScroll && it.removeClass(document.body, "p-overflow-hidden");
    },
    jt = function () {
      (_.current = !1), wa.clear(E.current), u(!1), rt();
    },
    ct = function () {
      Dt(),
        (t.blockScroll || (t.maximizable && I)) &&
          it.addClass(document.body, "p-overflow-hidden");
    },
    rt = function () {
      Ht();
      var xe = t.maximizable && I;
      if (t.modal) {
        var nt =
          document.primeDialogParams &&
          document.primeDialogParams.some(function (gt) {
            return gt.hasBlockScroll;
          });
        (nt || xe) && it.removeClass(document.body, "p-overflow-hidden");
      } else
        (t.blockScroll || xe) &&
          it.removeClass(document.body, "p-overflow-hidden");
    },
    Dt = function () {
      t.draggable && (ee(), Te()), t.resizable && (V(), z()), U();
      var xe = { id: i, hasBlockScroll: t.blockScroll };
      document.primeDialogParams = document.primeDialogParams
        ? [].concat(OSe(document.primeDialogParams), [xe])
        : [xe];
    },
    Ht = function () {
      F(),
        Ce(),
        oe(),
        se(),
        $(),
        (document.primeDialogParams =
          document.primeDialogParams &&
          document.primeDialogParams.filter(function (xe) {
            return xe.id !== i;
          }));
    },
    Yt = function () {
      if (!T.current) {
        T.current = it.createInlineStyle(Lr.nonce);
        var xe = "";
        for (var nt in t.breakpoints)
          xe += `
                    @media screen and (max-width: `
            .concat(
              nt,
              `) {
                        .p-dialog[`
            )
            .concat(
              O.current,
              `] {
                            width: `
            )
            .concat(
              t.breakpoints[nt],
              ` !important;
                        }
                    }
                `
            );
        T.current.innerHTML = xe;
      }
    },
    sr = function () {
      if (!t.blockScroll) {
        var xe = I ? "addClass" : "removeClass";
        it[xe](document.body, "p-overflow-hidden");
      }
    };
  f1(function () {
    var Ye = lU();
    i || s(Ye),
      O.current || (O.current = Ye),
      t.visible && u(!0),
      t.breakpoints && Yt();
  }),
    zu(function () {
      t.visible && !l && u(!0), t.visible !== d && l && p(t.visible);
    }),
    zu(
      function () {
        l &&
          (wa.set(
            "modal",
            E.current,
            Lr.autoZIndex,
            t.baseZIndex || Lr.zIndex.modal
          ),
          p(!0));
      },
      [l]
    ),
    zu(
      function () {
        sr();
      },
      [t.maximized, w]
    ),
    bl(function () {
      rt(), it.removeInlineStyle(T.current), wa.clear(E.current);
    }),
    Z.useImperativeHandle(e, function () {
      return {
        props: t,
        resetPosition: De,
        getElement: function () {
          return v.current;
        },
        getMask: function () {
          return E.current;
        },
        getContent: function () {
          return S.current;
        },
        getHeader: function () {
          return D.current;
        },
        getFooter: function () {
          return P.current;
        },
        getCloseButton: function () {
          return x.current;
        },
      };
    });
  var Bt = function () {
      if (t.closable) {
        var xe = t.ariaCloseIconLabel || Zb("close");
        return Z.createElement(
          "button",
          {
            ref: x,
            type: "button",
            className: "p-dialog-header-icon p-dialog-header-close p-link",
            "aria-label": xe,
            onClick: ke,
          },
          Z.createElement("span", {
            className: "p-dialog-header-close-icon pi pi-times",
            "aria-hidden": "true",
          }),
          Z.createElement(mh, null)
        );
      }
      return null;
    },
    en = function () {
      var xe = ji("p-dialog-header-maximize-icon pi", {
        "pi-window-maximize": !I,
        "pi-window-minimize": I,
      });
      return t.maximizable
        ? Z.createElement(
            "button",
            {
              type: "button",
              className: "p-dialog-header-icon p-dialog-header-maximize p-link",
              onClick: Ft,
            },
            Z.createElement("span", { className: xe }),
            Z.createElement(mh, null)
          )
        : null;
    },
    Tr = function () {
      if (t.showHeader) {
        var xe = Bt(),
          nt = en(),
          gt = Vn.getJSXElement(t.icons, t),
          ht = Vn.getJSXElement(t.header, t),
          wt = i + "_header",
          rn = ji("p-dialog-header", t.headerClassName);
        return Z.createElement(
          "div",
          { ref: D, style: t.headerStyle, className: rn, onMouseDown: Ot },
          Z.createElement("div", { id: wt, className: "p-dialog-title" }, ht),
          Z.createElement(
            "div",
            { className: "p-dialog-header-icons" },
            gt,
            nt,
            xe
          )
        );
      }
      return null;
    },
    on = function () {
      var xe = ji("p-dialog-content", t.contentClassName),
        nt = i + "_content";
      return Z.createElement(
        "div",
        { id: nt, ref: S, className: xe, style: t.contentStyle },
        t.children
      );
    },
    Pt = function () {
      var xe = Vn.getJSXElement(t.footer, t);
      return (
        xe &&
        Z.createElement("div", { ref: P, className: "p-dialog-footer" }, xe)
      );
    },
    fn = function () {
      return t.resizable
        ? Z.createElement("span", {
            className: "p-resizable-handle",
            style: { zIndex: 90 },
            onMouseDown: vt,
          })
        : null;
    },
    Wt = function () {
      var xe = Vn.findDiffKeys(t, N1.defaultProps),
        nt = ji("p-dialog p-component", t.className, {
          "p-dialog-rtl": t.rtl,
          "p-dialog-maximized": I,
          "p-dialog-default": !I,
        }),
        gt = ji(
          "p-dialog-mask",
          je(),
          {
            "p-component-overlay p-component-overlay-enter": t.modal,
            "p-dialog-visible": l,
            "p-dialog-draggable": t.draggable,
            "p-dialog-resizable": t.resizable,
          },
          t.maskClassName
        ),
        ht = Tr(),
        wt = on(),
        rn = Pt(),
        ot = fn(),
        pt = i + "_header",
        zt = i + "_content",
        Zt = {
          enter: t.position === "center" ? 150 : 300,
          exit: t.position === "center" ? 150 : 300,
        };
      return Z.createElement(
        "div",
        { ref: E, style: t.maskStyle, className: gt, onClick: Rt },
        Z.createElement(
          Uy,
          {
            nodeRef: v,
            classNames: "p-dialog",
            timeout: Zt,
            in: d,
            options: t.transitionOptions,
            unmountOnExit: !0,
            onEnter: lt,
            onEntered: Ke,
            onExiting: tt,
            onExited: jt,
          },
          Z.createElement(
            "div",
            Xx(
              {
                ref: v,
                id: i,
                className: nt,
                style: t.style,
                onClick: t.onClick,
                role: "dialog",
              },
              xe,
              {
                "aria-labelledby": pt,
                "aria-describedby": zt,
                "aria-modal": t.modal,
              }
            ),
            ht,
            wt,
            rn,
            ot
          )
        )
      );
    },
    qt = function () {
      var xe = Wt();
      return Z.createElement(Dh, {
        element: xe,
        appendTo: t.appendTo,
        visible: !0,
      });
    };
  return l && qt();
});
N1.displayName = "Dialog";
N1.defaultProps = {
  __TYPE: "Dialog",
  appendTo: null,
  ariaCloseIconLabel: null,
  baseZIndex: 0,
  blockScroll: !1,
  breakpoints: null,
  className: null,
  closable: !0,
  closeOnEscape: !0,
  contentClassName: null,
  contentStyle: null,
  dismissableMask: !1,
  draggable: !0,
  focusOnShow: !0,
  footer: null,
  header: null,
  headerClassName: null,
  headerStyle: null,
  icons: null,
  id: null,
  keepInViewport: !0,
  maskClassName: null,
  maskStyle: null,
  maximizable: !1,
  maximized: !1,
  minX: 0,
  minY: 0,
  modal: !0,
  onClick: null,
  onDrag: null,
  onDragEnd: null,
  onDragStart: null,
  onHide: null,
  onMaskClick: null,
  onMaximize: null,
  onResize: null,
  onResizeEnd: null,
  onResizeStart: null,
  onShow: null,
  position: "center",
  resizable: !0,
  rtl: !1,
  showHeader: !0,
  style: null,
  transitionOptions: null,
  visible: !1,
};
function Yx() {
  return (
    (Yx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Yx.apply(this, arguments)
  );
}
function RSe(t) {
  if (Array.isArray(t)) return t;
}
function MSe(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      s,
      a,
      o = [],
      l = !0,
      u = !1;
    try {
      if (((s = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== e);
          l = !0
        );
    } catch (f) {
      (u = !0), (i = f);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function VL(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function LSe(t, e) {
  if (t) {
    if (typeof t == "string") return VL(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return VL(t, e);
  }
}
function BSe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function GL(t, e) {
  return RSe(t) || MSe(t, e) || LSe(t, e) || BSe();
}
var _6 = Z.memo(
  Z.forwardRef(function (t, e) {
    var n = Z.useState(t.visible),
      r = GL(n, 2),
      i = r[0],
      s = r[1],
      a = Z.useState(!1),
      o = GL(a, 2),
      l = o[0],
      u = o[1],
      f = Z.useRef(null),
      c = function () {
        return f.current || t;
      },
      d = function (A) {
        return (f.current || t)[A];
      },
      p = function (A) {
        for (
          var N = arguments.length, M = new Array(N > 1 ? N - 1 : 0), T = 1;
          T < N;
          T++
        )
          M[T - 1] = arguments[T];
        return Vn.getPropValue(d(A), M);
      },
      m = d("acceptLabel") || Zb("accept"),
      g = d("rejectLabel") || Zb("reject"),
      w = function () {
        p("accept"), E("accept");
      },
      y = function () {
        p("reject"), E("reject");
      },
      v = function () {
        s(!0);
      },
      E = function () {
        var A =
          arguments.length > 0 && arguments[0] !== void 0
            ? arguments[0]
            : "cancel";
        s(!1), p("onHide", A);
      },
      S = function (A) {
        if (A.tagKey === t.tagKey) {
          var N = i !== A.visible,
            M = d("target") !== A.target;
          M && !t.target
            ? (E(), (f.current = A), u(!0))
            : N && ((f.current = A), A.visible ? v() : E());
        }
      };
    Z.useEffect(
      function () {
        t.visible ? v() : E();
      },
      [t.visible]
    ),
      Z.useEffect(
        function () {
          return (
            !t.target && !t.message && rh.on("confirm-dialog", S),
            function () {
              rh.off("confirm-dialog", S);
            }
          );
        },
        [t.target]
      ),
      zu(
        function () {
          l && v();
        },
        [l]
      ),
      bl(function () {
        rh.off("confirm-dialog", S);
      }),
      Z.useImperativeHandle(e, function () {
        return { props: t, confirm: S };
      });
    var D = function () {
        var A = ji("p-confirm-dialog-accept", d("acceptClassName")),
          N = ji(
            "p-confirm-dialog-reject",
            { "p-button-text": !d("rejectClassName") },
            d("rejectClassName")
          ),
          M = Z.createElement(
            Z.Fragment,
            null,
            Z.createElement(iu, {
              label: g,
              icon: d("rejectIcon"),
              className: N,
              onClick: y,
            }),
            Z.createElement(iu, {
              label: m,
              icon: d("acceptIcon"),
              className: A,
              onClick: w,
              autoFocus: !0,
            })
          );
        if (d("footer")) {
          var T = {
            accept: w,
            reject: y,
            acceptClassName: A,
            rejectClassName: N,
            acceptLabel: m,
            rejectLabel: g,
            element: M,
            props: c(),
          };
          return Vn.getJSXElement(d("footer"), T);
        }
        return M;
      },
      P = function () {
        var A = c(),
          N = ji("p-confirm-dialog", d("className")),
          M = Vn.findDiffKeys(A, _6.defaultProps),
          T = Vn.getJSXElement(d("message"), A),
          O = oU.getJSXIcon(
            d("icon"),
            { className: "p-confirm-dialog-icon" },
            { props: A }
          ),
          I = D();
        return Z.createElement(
          N1,
          Yx({ visible: i }, M, {
            className: N,
            footer: I,
            onHide: E,
            breakpoints: d("breakpoints"),
          }),
          O,
          Z.createElement("span", { className: "p-confirm-dialog-message" }, T)
        );
      },
      x = P();
    return Z.createElement(Dh, { element: x, appendTo: d("appendTo") });
  })
);
_6.displayName = "ConfirmDialog";
_6.defaultProps = {
  __TYPE: "ConfirmDialog",
  tagKey: void 0,
  visible: void 0,
  message: null,
  rejectLabel: null,
  acceptLabel: null,
  icon: null,
  rejectIcon: null,
  acceptIcon: null,
  rejectClassName: null,
  acceptClassName: null,
  className: null,
  appendTo: null,
  footer: null,
  breakpoints: null,
  onHide: null,
  accept: null,
  reject: null,
};
function FSe({ children: t }) {
  return G.jsx("div", { className: "w-full  container mx-auto", children: t });
}
const $Se = "hh-sol-artifact-1",
  USe = "LockingPositionManager",
  jSe = "contracts/Locking/LockingPositionManager.sol",
  HSe = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "BUFFER",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "checkFullCompliance",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        { internalType: "address", name: "_operator", type: "address" },
      ],
      name: "checkOwnership",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256[]", name: "_tokenIds", type: "uint256[]" },
        { internalType: "address", name: "_operator", type: "address" },
      ],
      name: "checkOwnerships",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "checkYsClaim",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionDelegate",
      outputs: [
        {
          internalType: "contract ILockingPositionDelegate",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "lockingPositionService",
      outputs: [
        {
          internalType: "contract ILockingPositionService",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "logo",
      outputs: [
        { internalType: "contract ILockingLogo", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "logoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "cvgLocked", type: "uint256" },
            { internalType: "uint256", name: "lockEnd", type: "uint256" },
            { internalType: "uint256", name: "ysPercentage", type: "uint256" },
            { internalType: "uint256", name: "mgCvg", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct ILockingLogo.LogoInfos",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "maxLockingTime",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "mint",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "_newBaseURI", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "timestamp", type: "uint256" },
      ],
      name: "setLock",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ILockingPositionService",
          name: "_lockingPositionService",
          type: "address",
        },
      ],
      name: "setLockingPositionService",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ILockingLogo",
          name: "_logo",
          type: "address",
        },
      ],
      name: "setLogo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "newMaxLockingTime", type: "uint256" },
      ],
      name: "setMaxLockingTime",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "unlockingTimestampPerToken",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  X8 = { _format: $Se, contractName: USe, sourceName: jSe, abi: HSe },
  zSe = "hh-sol-artifact-1",
  VSe = "VestingCvg",
  GSe = "contracts/PresaleVesting/VestingCvg.sol",
  WSe = [
    {
      inputs: [
        {
          internalType: "contract IPresaleCvgWl",
          name: "_presaleWl",
          type: "address",
        },
        {
          internalType: "contract IPresaleCvgSeed",
          name: "_presaleSeed",
          type: "address",
        },
        {
          internalType: "contract IboInterface",
          name: "_ibo",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "MAX_SUPPLY_DAO",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_SUPPLY_TEAM",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "ONE_DAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "ONE_GWEI",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "amountReleasedIdIbo",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "amountReleasedIdSeed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "amountReleasedIdWl",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvg",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        {
          internalType: "enum VestingCvg.VestingType",
          name: "_vestingType",
          type: "uint8",
        },
      ],
      name: "getInfoVestingTokenId",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "amountReleasable",
              type: "uint256",
            },
            { internalType: "uint256", name: "totalCvg", type: "uint256" },
            {
              internalType: "uint256",
              name: "amountRedeemed",
              type: "uint256",
            },
          ],
          internalType: "struct VestingCvg.InfoVestingTokenId",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "enum VestingCvg.VestingType",
          name: "_vestingType",
          type: "uint8",
        },
      ],
      name: "getTotalReleasedScheduleId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "ibo",
      outputs: [
        { internalType: "contract IboInterface", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "openVesting",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "presaleSeed",
      outputs: [
        { internalType: "contract IPresaleCvgSeed", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "presaleWl",
      outputs: [
        { internalType: "contract IPresaleCvgWl", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }],
      name: "releaseIbo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }],
      name: "releaseSeed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bool", name: "_isTeam", type: "bool" }],
      name: "releaseTeamOrDao",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }],
      name: "releaseWl",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract IERC20", name: "_cvg", type: "address" },
      ],
      name: "setVesting",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "newWhitelistedDao", type: "address" },
      ],
      name: "setWhitelistDao",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newWhitelistedTeam",
          type: "address",
        },
      ],
      name: "setWhitelistTeam",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "startTimestamp",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "state",
      outputs: [
        { internalType: "enum VestingCvg.State", name: "", type: "uint8" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "enum VestingCvg.VestingType",
          name: "",
          type: "uint8",
        },
      ],
      name: "vestingSchedules",
      outputs: [
        { internalType: "uint80", name: "daysBeforeCliff", type: "uint80" },
        { internalType: "uint80", name: "daysAfterCliff", type: "uint80" },
        { internalType: "uint96", name: "dropCliff", type: "uint96" },
        { internalType: "uint256", name: "totalAmount", type: "uint256" },
        { internalType: "uint256", name: "totalReleased", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "whitelistedDao",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "whitelistedTeam",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  WL = { _format: zSe, contractName: VSe, sourceName: GSe, abi: WSe },
  qSe = "hh-sol-artifact-1",
  KSe = "LockingLogo",
  XSe = "contracts/Locking/LockingLogo.sol",
  ZSe = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "cvgLocked", type: "uint256" },
            { internalType: "uint256", name: "lockEnd", type: "uint256" },
            { internalType: "uint256", name: "ysPercentage", type: "uint256" },
            { internalType: "uint256", name: "mgCvg", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct ILockingLogo.LogoInfos",
          name: "_logoInfos",
          type: "tuple",
        },
      ],
      name: "_tokenURI",
      outputs: [{ internalType: "string", name: "output", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getLogoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "cvgLocked", type: "uint256" },
            { internalType: "uint256", name: "lockEnd", type: "uint256" },
            { internalType: "uint256", name: "ysPercentage", type: "uint256" },
            { internalType: "uint256", name: "mgCvg", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "cvgLockedInUsd",
              type: "uint256",
            },
            { internalType: "uint256", name: "ysCvgActual", type: "uint256" },
            { internalType: "uint256", name: "ysCvgNext", type: "uint256" },
            { internalType: "uint256", name: "veCvg", type: "uint256" },
            {
              components: [
                { internalType: "uint256", name: "ysWidth", type: "uint256" },
                { internalType: "uint256", name: "veWidth", type: "uint256" },
              ],
              internalType: "struct ILockingLogo.GaugePosition",
              name: "gaugePosition",
              type: "tuple",
            },
            {
              internalType: "uint256",
              name: "claimableInUsd",
              type: "uint256",
            },
            { internalType: "bool", name: "isLocked", type: "bool" },
            { internalType: "uint256", name: "hoursLock", type: "uint256" },
          ],
          internalType: "struct ILockingLogo.LogoInfosFull",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tdeStart", type: "uint256" }],
      name: "setStartTdePriceFetching",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  YSe = { _format: qSe, contractName: KSe, sourceName: XSe, abi: ZSe },
  QSe = "hh-sol-artifact-1",
  JSe = "BondLogo",
  eAe = "contracts/Bond/BondLogo.sol",
  tAe = [
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "termTimestamp", type: "uint256" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct IBondLogo.LogoInfos",
          name: "logoInfos",
          type: "tuple",
        },
      ],
      name: "_tokenURI",
      outputs: [{ internalType: "string", name: "output", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getLogoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "termTimestamp", type: "uint256" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
            { internalType: "uint256", name: "year", type: "uint256" },
            { internalType: "uint256", name: "month", type: "uint256" },
            { internalType: "uint256", name: "day", type: "uint256" },
            { internalType: "bool", name: "isLocked", type: "bool" },
            { internalType: "uint256", name: "hoursLock", type: "uint256" },
            { internalType: "uint256", name: "cvgPrice", type: "uint256" },
          ],
          internalType: "struct IBondLogo.LogoInfosFull",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  nAe = { _format: QSe, contractName: JSe, sourceName: eAe, abi: tAe },
  rAe = "hh-sol-artifact-1",
  iAe = "SdtStakingLogo",
  sAe = "contracts/Staking/StakeDAO/SdtStakingLogo.sol",
  aAe = [
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_TOKEN_LOGO",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "symbol", type: "string" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "totalStaked", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              components: [
                {
                  internalType: "contract IERC20",
                  name: "token",
                  type: "address",
                },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              internalType: "struct ICommonStruct.TokenAmount[]",
              name: "sdtClaimable",
              type: "tuple[]",
            },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct ISdtStakingLogo.LogoInfos",
          name: "logoInfos",
          type: "tuple",
        },
      ],
      name: "_tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getLogoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "symbol", type: "string" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "totalStaked", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              components: [
                {
                  internalType: "contract IERC20",
                  name: "token",
                  type: "address",
                },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              internalType: "struct ICommonStruct.TokenAmount[]",
              name: "sdtClaimable",
              type: "tuple[]",
            },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "claimableInUsd",
              type: "uint256",
            },
            { internalType: "bool", name: "erroneousAmount", type: "bool" },
            { internalType: "bool", name: "isLocked", type: "bool" },
            { internalType: "uint256", name: "hoursLock", type: "uint256" },
          ],
          internalType: "struct ISdtStakingLogo.LogoInfosFull",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "sdt",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "string[]", name: "_symbols", type: "string[]" },
        { internalType: "string[]", name: "_tokensLogo", type: "string[]" },
      ],
      name: "setTokensLogo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  oAe = { _format: rAe, contractName: iAe, sourceName: sAe, abi: aAe },
  lAe = "hh-sol-artifact-1",
  uAe = "GalleryInfo",
  cAe = "contracts/ChainView/GalleryInfo.sol",
  fAe = [
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      inputs: [
        {
          components: [
            {
              components: [
                { internalType: "uint256", name: "tokenId", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "termTimestamp",
                  type: "uint256",
                },
                { internalType: "uint256", name: "pending", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "cvgClaimable",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "unlockingTimestamp",
                  type: "uint256",
                },
                { internalType: "uint256", name: "year", type: "uint256" },
                { internalType: "uint256", name: "month", type: "uint256" },
                { internalType: "uint256", name: "day", type: "uint256" },
                { internalType: "bool", name: "isLocked", type: "bool" },
                { internalType: "uint256", name: "hoursLock", type: "uint256" },
                { internalType: "uint256", name: "cvgPrice", type: "uint256" },
              ],
              internalType: "struct IBondLogo.LogoInfosFull[]",
              name: "bondInfos",
              type: "tuple[]",
            },
            {
              components: [
                { internalType: "uint256", name: "tokenId", type: "uint256" },
                { internalType: "uint256", name: "cvgLocked", type: "uint256" },
                { internalType: "uint256", name: "lockEnd", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "ysPercentage",
                  type: "uint256",
                },
                { internalType: "uint256", name: "mgCvg", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "unlockingTimestamp",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "cvgLockedInUsd",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "ysCvgActual",
                  type: "uint256",
                },
                { internalType: "uint256", name: "ysCvgNext", type: "uint256" },
                { internalType: "uint256", name: "veCvg", type: "uint256" },
                {
                  components: [
                    {
                      internalType: "uint256",
                      name: "ysWidth",
                      type: "uint256",
                    },
                    {
                      internalType: "uint256",
                      name: "veWidth",
                      type: "uint256",
                    },
                  ],
                  internalType: "struct ILockingLogo.GaugePosition",
                  name: "gaugePosition",
                  type: "tuple",
                },
                {
                  internalType: "uint256",
                  name: "claimableInUsd",
                  type: "uint256",
                },
                { internalType: "bool", name: "isLocked", type: "bool" },
                { internalType: "uint256", name: "hoursLock", type: "uint256" },
              ],
              internalType: "struct ILockingLogo.LogoInfosFull[]",
              name: "lockingInfos",
              type: "tuple[]",
            },
            {
              components: [
                { internalType: "uint256", name: "tokenId", type: "uint256" },
                { internalType: "string", name: "symbol", type: "string" },
                { internalType: "uint256", name: "pending", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "totalStaked",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "cvgClaimable",
                  type: "uint256",
                },
                {
                  components: [
                    {
                      internalType: "contract IERC20",
                      name: "token",
                      type: "address",
                    },
                    {
                      internalType: "uint256",
                      name: "amount",
                      type: "uint256",
                    },
                  ],
                  internalType: "struct ICommonStruct.TokenAmount[]",
                  name: "sdtClaimable",
                  type: "tuple[]",
                },
                {
                  internalType: "uint256",
                  name: "unlockingTimestamp",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "claimableInUsd",
                  type: "uint256",
                },
                { internalType: "bool", name: "erroneousAmount", type: "bool" },
                { internalType: "bool", name: "isLocked", type: "bool" },
                { internalType: "uint256", name: "hoursLock", type: "uint256" },
              ],
              internalType: "struct ISdtStakingLogo.LogoInfosFull[]",
              name: "sdtStakingInfos",
              type: "tuple[]",
            },
            {
              components: [
                { internalType: "uint256", name: "tokenId", type: "uint256" },
                {
                  components: [
                    {
                      internalType: "uint256",
                      name: "amountReleasable",
                      type: "uint256",
                    },
                    {
                      internalType: "uint256",
                      name: "totalCvg",
                      type: "uint256",
                    },
                    {
                      internalType: "uint256",
                      name: "amountRedeemed",
                      type: "uint256",
                    },
                  ],
                  internalType: "struct IVestingCvg.InfoVestingTokenId",
                  name: "presaleInfo",
                  type: "tuple",
                },
                {
                  internalType: "enum IVestingCvg.VestingType",
                  name: "presaleType",
                  type: "uint8",
                },
                {
                  components: [
                    {
                      internalType: "uint256",
                      name: "totalBoost",
                      type: "uint256",
                    },
                    {
                      internalType: "uint256",
                      name: "alreadyClaimedBoost",
                      type: "uint256",
                    },
                    {
                      internalType: "uint256",
                      name: "claimableBoost",
                      type: "uint256",
                    },
                  ],
                  internalType: "struct BoostStruct",
                  name: "boostStruct",
                  type: "tuple",
                },
              ],
              internalType: "struct PresaleInfo[]",
              name: "presaleInfos",
              type: "tuple[]",
            },
            {
              components: [
                { internalType: "string", name: "tokenURI", type: "string" },
                {
                  internalType: "uint256[]",
                  name: "tokenIds",
                  type: "uint256[]",
                },
              ],
              internalType: "struct CvgPepeInfo",
              name: "cvgPepeInfos",
              type: "tuple",
            },
          ],
          internalType: "struct GalleryUserInfo",
          name: "galleryUserInfo",
          type: "tuple",
        },
      ],
      name: "GalleryUserInfoError",
      type: "error",
    },
  ],
  dAe =
    "0x608060405234801561000f575f80fd5b50604051611d6f380380611d6f83398101604081905261002e91611243565b6100378161003d565b50611d25565b604051633f28890160e11b81526001600160a01b03821660048201525f907359e8fbceac829b7da182d8f749ba4a038c6272ea90637e511202906024015f60405180830381865afa158015610094573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526100bb9190810190611339565b90505f81516001600160401b038111156100d7576100d7611265565b60405190808252806020026020018201604052801561015c57816020015b6101496040518061016001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f151581526020015f81526020015f81525090565b8152602001906001900390816100f55790505b5090505f5b825181101561022a5773b85e083c505edb68fed355f13149b493230efc7e6001600160a01b031663840fc67484838151811061019f5761019f6113c9565b60200260200101516040518263ffffffff1660e01b81526004016101c591815260200190565b61016060405180830381865afa1580156101e1573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061020591906113f1565b828281518110610217576102176113c9565b6020908102919091010152600101610161565b50604051633f28890160e11b81526001600160a01b038416600482015260609250730edb88aa3aa665782121fa2509b382f414a0c0ce90637e511202906024015f60405180830381865afa158015610284573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102ab9190810190611339565b91505f82516001600160401b038111156102c7576102c7611265565b60405190808252806020026020018201604052801561030057816020015b6102ed61114c565b8152602001906001900390816102e55790505b5090505f5b83518110156103ce577305816acfe129553a3c387389980bf7e4871e29e96001600160a01b031663840fc674858381518110610343576103436113c9565b60200260200101516040518263ffffffff1660e01b815260040161036991815260200190565b6101e060405180830381865afa158015610385573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103a991906114b3565b8282815181106103bb576103bb6113c9565b6020908102919091010152600101610305565b50604051633f28890160e11b81526001600160a01b038516600482015260609350737319662ad7d7ce2d1595073ea042b723f6d0dc4890637e511202906024015f60405180830381865afa158015610428573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261044f9190810190611339565b92505f83516001600160401b0381111561046b5761046b611265565b6040519080825280602002602001820160405280156104f457816020015b6104e16040518061016001604052805f8152602001606081526020015f81526020015f81526020015f8152602001606081526020015f81526020015f81526020015f151581526020015f151581526020015f81525090565b8152602001906001900390816104895790505b5090505f5b84518110156105c35773ac4c0b8b3f1918984dc31f8d31a1e27b28de5dfe6001600160a01b031663840fc674868381518110610537576105376113c9565b60200260200101516040518263ffffffff1660e01b815260040161055d91815260200190565b5f60405180830381865afa158015610577573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261059e919081019061168e565b8282815181106105b0576105b06113c9565b60209081029190910101526001016104f9565b506040516370a0823160e01b81526001600160a01b0386166004820152606094505f9073822ee3715e2c15372e45a4a62376bf786ff45511906370a0823190602401602060405180830381865afa158015610620573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610644919061178c565b90505f816001600160401b0381111561065f5761065f611265565b604051908082528060200260200182016040528015610688578160200160208202803683370190505b5090505f5b8281101561073b57604051632f745c5960e01b81526001600160a01b03891660048201526024810182905273822ee3715e2c15372e45a4a62376bf786ff4551190632f745c5990604401602060405180830381865afa1580156106f2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610716919061178c565b828281518110610728576107286113c9565b602090810291909101015260010161068d565b505f91506040518060a0016040528086815260200185815260200184815260200161076b8961081d60201b60201c565b8152604080518082019182905263c87b56dd60e01b909152600160448201526020909101908073822ee3715e2c15372e45a4a62376bf786ff4551163c87b56dd606483015f60405180830381865afa1580156107c9573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526107f091908101906117a3565b81526020018490529052604051630a56be6760e11b81526108149190600401611b0c565b60405180910390fd5b604051633f28890160e11b81526001600160a01b03821660048201526060905f907306feb7a047e540b8d92620a2c13ec96e1ff5e19b90637e511202906024015f60405180830381865afa158015610877573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261089e9190810190611339565b604051633f28890160e11b81526001600160a01b03851660048201529091505f9073c9740aa94a8a02a3373f5f1b493d7e10d99ae81190637e511202906024015f60405180830381865afa1580156108f8573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261091f9190810190611339565b604051633f28890160e11b81526001600160a01b03861660048201529091505f90735f02134c35449d9b6505723a56b02581356320fb90637e511202906024015f60405180830381865afa158015610979573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526109a09190810190611339565b90505f8151835185516109b39190611c4f565b6109bd9190611c4f565b6001600160401b038111156109d4576109d4611265565b604051908082528060200260200182016040528015610a0d57816020015b6109fa6111c9565b8152602001906001900390816109f25790505b5090505f5b8451811015610b2d576040518060800160405280868381518110610a3857610a386113c9565b6020026020010151815260200173c929ba60ef82fe55de3bc848dd9453b3b12a0c306001600160a01b031663493aadfa888581518110610a7a57610a7a6113c9565b60200260200101515f6040518363ffffffff1660e01b8152600401610aa0929190611c68565b606060405180830381865afa158015610abb573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610adf9190611c7c565b81526020015f815260200160405180606001604052805f81526020015f81526020015f815250815250828281518110610b1a57610b1a6113c9565b6020908102919091010152600101610a12565b5083515f5b8451811015610e32575f629896806207a12073c9740aa94a8a02a3373f5f1b493d7e10d99ae8116001600160a01b031663afa1c811898681518110610b7957610b796113c9565b60200260200101516040518263ffffffff1660e01b8152600401610b9f91815260200190565b6040805180830381865afa158015610bb9573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bdd9190611cd5565b60200151610beb9190611cef565b610bf59190611d06565b90505f7336ade2a8c459f6ed97176936b6abd5f0b07166206001600160a01b0316637c1007b2888581518110610c2d57610c2d6113c9565b60200260200101516040518263ffffffff1660e01b8152600401610c5391815260200190565b602060405180830381865afa158015610c6e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c92919061178c565b6040516309edf24d60e41b815260048101849052602481018290529091505f907336ade2a8c459f6ed97176936b6abd5f0b071662090639edf24d090604401602060405180830381865afa158015610cec573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d10919061178c565b90506040518060800160405280898681518110610d2f57610d2f6113c9565b6020026020010151815260200173c929ba60ef82fe55de3bc848dd9453b3b12a0c306001600160a01b031663493aadfa8b8881518110610d7157610d716113c9565b602002602001015160016040518363ffffffff1660e01b8152600401610d98929190611c68565b606060405180830381865afa158015610db3573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610dd79190611c7c565b81526020016001815260408051606081018252868152602081810187905291810185905291015286610e098787611c4f565b81518110610e1957610e196113c9565b6020026020010181905250836001019350505050610b32565b508351610e3f9082611c4f565b90505f5b8351811015611140575f629896806207a120735f02134c35449d9b6505723a56b02581356320fb6001600160a01b031663a915cc4c888681518110610e8a57610e8a6113c9565b60200260200101516040518263ffffffff1660e01b8152600401610eb091815260200190565b602060405180830381865afa158015610ecb573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610eef919061178c565b610ef99190611cef565b610f039190611d06565b90505f7336ade2a8c459f6ed97176936b6abd5f0b07166206001600160a01b0316638a50bc67878581518110610f3b57610f3b6113c9565b60200260200101516040518263ffffffff1660e01b8152600401610f6191815260200190565b602060405180830381865afa158015610f7c573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610fa0919061178c565b6040516309edf24d60e41b815260048101849052602481018290529091505f907336ade2a8c459f6ed97176936b6abd5f0b071662090639edf24d090604401602060405180830381865afa158015610ffa573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061101e919061178c565b9050604051806080016040528088868151811061103d5761103d6113c9565b6020026020010151815260200173c929ba60ef82fe55de3bc848dd9453b3b12a0c306001600160a01b031663493aadfa8a888151811061107f5761107f6113c9565b602002602001015160026040518363ffffffff1660e01b81526004016110a6929190611c68565b606060405180830381865afa1580156110c1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110e59190611c7c565b815260200160028152604080516060810182528681526020818101879052918101859052910152866111178787611c4f565b81518110611127576111276113c9565b6020026020010181905250836001019350505050610e43565b50909695505050505050565b604051806101c001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020016111af60405180604001604052805f81526020015f81525090565b81526020015f81526020015f151581526020015f81525090565b60405180608001604052805f81526020016111fb60405180606001604052805f81526020015f81526020015f81525090565b81526020015f815260200161122760405180606001604052805f81526020015f81526020015f81525090565b905290565b6001600160a01b0381168114611240575f80fd5b50565b5f60208284031215611253575f80fd5b815161125e8161122c565b9392505050565b634e487b7160e01b5f52604160045260245ffd5b60405161016081016001600160401b038111828210171561129c5761129c611265565b60405290565b604080519081016001600160401b038111828210171561129c5761129c611265565b6040516101c081016001600160401b038111828210171561129c5761129c611265565b604051601f8201601f191681016001600160401b038111828210171561130f5761130f611265565b604052919050565b5f6001600160401b0382111561132f5761132f611265565b5060051b60200190565b5f602080838503121561134a575f80fd5b82516001600160401b0381111561135f575f80fd5b8301601f8101851361136f575f80fd5b805161138261137d82611317565b6112e7565b81815260059190911b820183019083810190878311156113a0575f80fd5b928401925b828410156113be578351825292840192908401906113a5565b979650505050505050565b634e487b7160e01b5f52603260045260245ffd5b805180151581146113ec575f80fd5b919050565b5f6101608284031215611402575f80fd5b61140a611279565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101006114628185016113dd565b908201526101208381015190820152610140928301519281019290925250919050565b5f60408284031215611495575f80fd5b61149d6112a2565b9050815181526020820151602082015292915050565b5f6101e082840312156114c4575f80fd5b6114cc6112c4565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e082015261010080840151818301525061012080840151818301525061014061153d85828601611485565b90820152610180838101516101608301526101a061155c8186016113dd565b828401526101c08501518184015250508091505092915050565b5f5b83811015611590578181015183820152602001611578565b50505f910152565b5f82601f8301126115a7575f80fd5b81516001600160401b038111156115c0576115c0611265565b6115d3601f8201601f19166020016112e7565b8181528460208386010111156115e7575f80fd5b6115f8826020830160208701611576565b949350505050565b5f82601f83011261160f575f80fd5b8151602061161f61137d83611317565b82815260069290921b8401810191818101908684111561163d575f80fd5b8286015b848110156116835760408189031215611658575f80fd5b6116606112a2565b815161166b8161122c565b81528185015185820152835291830191604001611641565b509695505050505050565b5f6020828403121561169e575f80fd5b81516001600160401b03808211156116b4575f80fd5b9083019061016082860312156116c8575f80fd5b6116d0611279565b825181526020830151828111156116e5575f80fd5b6116f187828601611598565b60208301525060408301516040820152606083015160608201526080830151608082015260a083015182811115611726575f80fd5b61173287828601611600565b60a08301525060c083015160c082015260e083015160e0820152610100915061175c8284016113dd565b8282015261012091506117708284016113dd565b9181019190915261014091820151918101919091529392505050565b5f6020828403121561179c575f80fd5b5051919050565b5f602082840312156117b3575f80fd5b81516001600160401b038111156117c8575f80fd5b6115f884828501611598565b5f815180845260208085019450602084015f5b838110156118ab57815180518852838101518489015260408082015190890152606080820151908901526080808201519089015260a0808201519089015260c0808201519089015260e0808201519089015261010080820151908901526101208082015190890152610140808201518051828b015260208101516101608b01525050610160810151610180898101919091528101516101a061188c818b018315159052565b91909101516101c0890152506101e090960195908201906001016117e7565b509495945050505050565b5f81518084526118cd816020860160208601611576565b601f01601f19169290920160200192915050565b5f815180845260208085019450602084015f5b838110156118ab57815180516001600160a01b0316885283015183880152604090960195908201906001016118f4565b5f82825180855260208086019550808260051b8401018186015f5b84811015611a0157601f1986840301895281516101608151855285820151818787015261196e828701826118b6565b60408481015190880152606080850151908801526080808501519088015260a080850151888303828a015291935091506119a883826118e1565b9250505060c080830151818701525060e0808301518187015250610100808301516119d68288018215159052565b505061012082810151151590860152610140918201519190940152978301979083019060010161193f565b5090979650505050505050565b60058110611a2a57634e487b7160e01b5f52602160045260245ffd5b9052565b5f815180845260208085019450602084015f5b838110156118ab5781518051885283810151611a73858a01828051825260208082015190830152604090810151910152565b506040810151611a8660808a0182611a0e565b5060600151805160a0890152602081015160c08901526040015160e08801526101009096019590820190600101611a41565b5f815160408452611acc60408501826118b6565b602084810151868303878301528051808452908201935090915f91908301905b808310156116835784518252938301936001929092019190830190611aec565b5f602080835260c0808401855160a0808588015282825180855260e0945060e08901915086840193505f5b81811015611bb957845180518452888101518985015260408082015190850152606080820151908501526080808201519085015284810151858501528781015188850152868101518785015261010080820151151590850152610120808201519085015261014090810151908401529387019361016090920191600101611b37565b5050858901519550601f19945084888203016040890152611bda81876117d4565b955050505050604085015181858403016060860152611bf98382611924565b925050606085015181858403016080860152611c158382611a2e565b9250506080850151818584030160a0860152611c318382611ab8565b9695505050505050565b634e487b7160e01b5f52601160045260245ffd5b80820180821115611c6257611c62611c3b565b92915050565b8281526040810161125e6020830184611a0e565b5f60608284031215611c8c575f80fd5b604051606081016001600160401b0381118282101715611cae57611cae611265565b80604052508251815260208301516020820152604083015160408201528091505092915050565b5f60408284031215611ce5575f80fd5b61125e8383611485565b8082028115828204841417611c6257611c62611c3b565b5f82611d2057634e487b7160e01b5f52601260045260245ffd5b500490565b603e80611d315f395ff3fe60806040525f80fdfea264697066735822122033744e99c290be922ad68fd22f25c18fc3f522b6c0a1c5c400e58a4d58bfeabc64736f6c63430008180033",
  hAe =
    "0x60806040525f80fdfea264697066735822122033744e99c290be922ad68fd22f25c18fc3f522b6c0a1c5c400e58a4d58bfeabc64736f6c63430008180033",
  pAe = {},
  mAe = {},
  Z8 = {
    _format: lAe,
    contractName: uAe,
    sourceName: cAe,
    abi: fAe,
    bytecode: dAe,
    deployedBytecode: hAe,
    linkReferences: pAe,
    deployedLinkReferences: mAe,
  },
  gAe = "hh-sol-artifact-1",
  yAe = "BoostWlIbo",
  vAe = "contracts/Airdrop/BoostWlIbo.sol",
  bAe = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      inputs: [],
      name: "TOTAL_CVG_AMOUNT_BOOST",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "claimBoostIbo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "claimBoostWl",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cvg",
      outputs: [{ internalType: "contract ICvg", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "iboAlreadyClaimed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "iboPresale",
      outputs: [
        { internalType: "contract IboInterface", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "startAirdrop",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "state",
      outputs: [
        { internalType: "enum BoostWlIbo.State", name: "", type: "uint8" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "vestingEnd",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "vestingStart",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "wlAlreadyClaimed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "wlPresale",
      outputs: [
        { internalType: "contract IPresaleCvgWl", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  wAe = {},
  _Ae = {},
  EAe = {
    _format: gAe,
    contractName: yAe,
    sourceName: vAe,
    abi: bAe,
    linkReferences: wAe,
    deployedLinkReferences: _Ae,
  },
  xAe = "hh-sol-artifact-1",
  TAe = "Ibo",
  SAe = "contracts/PresaleVesting/Ibo.sol",
  AAe = [
    {
      inputs: [
        { internalType: "address", name: "_treasuryBonds", type: "address" },
        {
          internalType: "contract IBondCalculator",
          name: "_bondCalculator",
          type: "address",
        },
        {
          internalType: "contract ICvgOracle",
          name: "_cvgOracle",
          type: "address",
        },
        { internalType: "bytes32", name: "_merklePepe", type: "bytes32" },
        { internalType: "bytes32", name: "_merkleWl", type: "bytes32" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDeposited",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "cvgAdded",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountDepositedUsd",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "contract IERC20Metadata",
          name: "token",
          type: "address",
        },
      ],
      name: "BondDeposit",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "CVG_PRICE_NO_ROI",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "IBO_DURATION",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_CVG_PEPE_PRIVILEGE",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_CVG_WL_PRIVILEGE",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "bondCalculator",
      outputs: [
        { internalType: "contract IBondCalculator", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "bondsParams",
      outputs: [
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "composedFunction",
          type: "uint8",
        },
        {
          internalType: "contract IERC20Metadata",
          name: "token",
          type: "address",
        },
        { internalType: "uint24", name: "gamma", type: "uint24" },
        { internalType: "uint16", name: "scale", type: "uint16" },
        { internalType: "uint24", name: "minRoi", type: "uint24" },
        { internalType: "uint24", name: "maxRoi", type: "uint24" },
        {
          internalType: "uint256",
          name: "percentageMaxCvgToMint",
          type: "uint256",
        },
        { internalType: "uint256", name: "maxCvgToMint", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "enum IBondStruct.BondFunction",
              name: "composedFunction",
              type: "uint8",
            },
            {
              internalType: "contract IERC20Metadata",
              name: "token",
              type: "address",
            },
            { internalType: "uint24", name: "gamma", type: "uint24" },
            { internalType: "uint16", name: "scale", type: "uint16" },
            { internalType: "uint24", name: "minRoi", type: "uint24" },
            { internalType: "uint24", name: "maxRoi", type: "uint24" },
            {
              internalType: "uint256",
              name: "percentageMaxCvgToMint",
              type: "uint256",
            },
            { internalType: "uint256", name: "maxCvgToMint", type: "uint256" },
          ],
          internalType: "struct Ibo.BondParams",
          name: "bondParams",
          type: "tuple",
        },
      ],
      name: "createBond",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgOracle",
      outputs: [
        { internalType: "contract ICvgOracle", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "bondId", type: "uint256" },
        { internalType: "uint256", name: "amountIn", type: "uint256" },
        { internalType: "uint256", name: "amountOutMin", type: "uint256" },
        { internalType: "uint256", name: "privilegeType", type: "uint256" },
        { internalType: "bytes32[]", name: "_merkleProof", type: "bytes32[]" },
      ],
      name: "deposit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getTotalCvgDue",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "iboStartTimestamp",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "merkleRootPepe",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "merkleRootWl",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextIdBond",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextIdToken",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "baseURI_", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "bondId", type: "uint256" },
        {
          internalType: "enum IBondStruct.BondFunction",
          name: "newComposedFunction",
          type: "uint8",
        },
      ],
      name: "setComposedFunction",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "startTimestamp", type: "uint256" },
      ],
      name: "setStartTimestamp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "soldDuringPrivilege",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "totalCvgDuePerBond",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "totalCvgPerToken",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "treasuryBonds",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  CAe = { _format: xAe, contractName: TAe, sourceName: SAe, abi: AAe },
  kAe = "hh-sol-artifact-1",
  IAe = "WlPresaleCvg",
  OAe = "contracts/PresaleVesting/WlPresaleCvg.sol",
  PAe = [
    {
      inputs: [
        { internalType: "bytes32", name: "_merkleRootWlS", type: "bytes32" },
        { internalType: "bytes32", name: "_merkleRootWlM", type: "bytes32" },
        { internalType: "bytes32", name: "_merkleRootWlL", type: "bytes32" },
        { internalType: "contract IERC20", name: "_Dai", type: "address" },
        { internalType: "contract IERC20", name: "_Frax", type: "address" },
        { internalType: "address", name: "_treasuryDao", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "Dai",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "Frax",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_SUPPLY_PRESALE",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "NUMERATOR",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "PRICE_WL",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAmountCvgForVesting",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_wallet", type: "address" },
        { internalType: "uint256", name: "_index", type: "uint256" },
      ],
      name: "getTokenIdAndType",
      outputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "vestingType", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getTotalCvg",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32[]", name: "_merkleProof", type: "bytes32[]" },
        { internalType: "uint256", name: "_amount", type: "uint256" },
        { internalType: "bool", name: "_isDai", type: "bool" },
        { internalType: "uint256", name: "_type", type: "uint256" },
      ],
      name: "investMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "mintersToggle",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextTokenId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "presaleInfos",
      outputs: [
        { internalType: "uint256", name: "vestingType", type: "uint256" },
        { internalType: "uint256", name: "cvgAmount", type: "uint256" },
        { internalType: "uint256", name: "stableInvested", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        { internalType: "uint256", name: "_amount", type: "uint256" },
        { internalType: "bool", name: "_isDai", type: "bool" },
      ],
      name: "refillToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "saleState",
      outputs: [
        {
          internalType: "enum WlPresaleCvg.SaleState",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "baseURI_", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "_newMerkleRootWl", type: "bytes32" },
        { internalType: "uint256", name: "_type", type: "uint256" },
      ],
      name: "setMerkleRootWl",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "enum WlPresaleCvg.SaleState",
          name: "_saleState",
          type: "uint8",
        },
      ],
      name: "setSaleState",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "supply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "withdrawFunds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract IERC20", name: "_token", type: "address" },
      ],
      name: "withdrawToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "wlParams",
      outputs: [
        { internalType: "uint256", name: "minInvest", type: "uint256" },
        { internalType: "uint256", name: "maxInvest", type: "uint256" },
        { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
        { internalType: "uint256", name: "cvgRedeemable", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  NAe = { _format: kAe, contractName: IAe, sourceName: OAe, abi: PAe },
  DAe = "hh-sol-artifact-1",
  RAe = "SeedPresaleCvg",
  MAe = "contracts/PresaleVesting/SeedPresaleCvg.sol",
  LAe = [
    {
      inputs: [
        { internalType: "contract IERC20", name: "_Dai", type: "address" },
        { internalType: "contract IERC20", name: "_Frax", type: "address" },
        { internalType: "address", name: "multisig", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "Dai",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "Frax",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_STABLE_PRESEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_STABLE_SEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_SUPPLY_PRESEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "MAX_SUPPLY_SEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "NUMERATOR",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "PRICE_PRESEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "PRICE_SEED",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "allocationPreseed",
      outputs: [
        { internalType: "uint256", name: "allocation", type: "uint256" },
        { internalType: "bool", name: "isClaimed", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "allocationSeed",
      outputs: [
        { internalType: "uint256", name: "allocation", type: "uint256" },
        { internalType: "bool", name: "isClaimed", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "allocationStablePreseed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "allocationStableSeed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getAllocation",
      outputs: [
        { internalType: "uint256", name: "allocationStable", type: "uint256" },
        { internalType: "uint256", name: "allocationCvg", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getRemainingCvgPreseed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getRemainingCvgSeed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_wallet", type: "address" },
        { internalType: "uint256", name: "_index", type: "uint256" },
      ],
      name: "getTokenIdAndType",
      outputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "vestingType", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getTotalCvg",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_wallet", type: "address" },
        { internalType: "uint256", name: "_amount", type: "uint256" },
      ],
      name: "grantPreseed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_wallet", type: "address" },
        { internalType: "uint256", name: "_amount", type: "uint256" },
      ],
      name: "grantSeed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bool", name: "_isDai", type: "bool" }],
      name: "investMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextTokenId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "presaleInfoTokenId",
      outputs: [
        { internalType: "uint256", name: "vestingType", type: "uint256" },
        { internalType: "uint256", name: "cvgAmount", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "saleState",
      outputs: [
        {
          internalType: "enum SeedPresaleCvg.SaleState",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "baseURI_", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "enum SeedPresaleCvg.SaleState",
          name: "_saleState",
          type: "uint8",
        },
      ],
      name: "setSaleState",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalCvgPreseed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalCvgSeed",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "withdrawFunds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "contract IERC20", name: "_token", type: "address" },
      ],
      name: "withdrawToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  BAe = { _format: DAe, contractName: RAe, sourceName: MAe, abi: LAe };
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var FAe = function (t) {
  return t != null && (aq(t) || $Ae(t) || !!t._isBuffer);
};
function aq(t) {
  return (
    !!t.constructor &&
    typeof t.constructor.isBuffer == "function" &&
    t.constructor.isBuffer(t)
  );
}
function $Ae(t) {
  return (
    typeof t.readFloatLE == "function" &&
    typeof t.slice == "function" &&
    aq(t.slice(0, 0))
  );
}
var UAe = FAe,
  jAe = Object.prototype.toString,
  HAe = function (e) {
    if (typeof e > "u") return "undefined";
    if (e === null) return "null";
    if (e === !0 || e === !1 || e instanceof Boolean) return "boolean";
    if (typeof e == "string" || e instanceof String) return "string";
    if (typeof e == "number" || e instanceof Number) return "number";
    if (typeof e == "function" || e instanceof Function) return "function";
    if (typeof Array.isArray < "u" && Array.isArray(e)) return "array";
    if (e instanceof RegExp) return "regexp";
    if (e instanceof Date) return "date";
    var n = jAe.call(e);
    return n === "[object RegExp]"
      ? "regexp"
      : n === "[object Date]"
      ? "date"
      : n === "[object Arguments]"
      ? "arguments"
      : n === "[object Error]"
      ? "error"
      : UAe(e)
      ? "buffer"
      : n === "[object Set]"
      ? "set"
      : n === "[object WeakSet]"
      ? "weakset"
      : n === "[object Map]"
      ? "map"
      : n === "[object WeakMap]"
      ? "weakmap"
      : n === "[object Symbol]"
      ? "symbol"
      : n === "[object Int8Array]"
      ? "int8array"
      : n === "[object Uint8Array]"
      ? "uint8array"
      : n === "[object Uint8ClampedArray]"
      ? "uint8clampedarray"
      : n === "[object Int16Array]"
      ? "int16array"
      : n === "[object Uint16Array]"
      ? "uint16array"
      : n === "[object Int32Array]"
      ? "int32array"
      : n === "[object Uint32Array]"
      ? "uint32array"
      : n === "[object Float32Array]"
      ? "float32array"
      : n === "[object Float64Array]"
      ? "float64array"
      : "object";
  },
  oq = { exports: {} };
(function (t) {
  (function () {
    function e(n, r) {
      if (typeof r != "function") return n;
      var i = {};
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) &&
          (i[r(s, n[s]) || s] = n[s]);
      return i;
    }
    t.exports ? (t.exports = e) : (window.rename = e);
  })();
})(oq);
var zAe = oq.exports;
/*!
 * deep-rename-keys <https://github.com/jonschlinkert/deep-rename-keys>
 *
 * Copyright (c) 2015 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */ var Y8 = HAe,
  VAe = zAe,
  GAe = function t(e, n) {
    var r = Y8(e);
    if (r !== "object" && r !== "array") throw new Error("expected an object");
    var i = [];
    r === "object" && ((e = VAe(e, n)), (i = {}));
    for (var s in e)
      if (e.hasOwnProperty(s)) {
        var a = e[s];
        Y8(a) === "object" || Y8(a) === "array" ? (i[s] = t(a, n)) : (i[s] = a);
      }
    return i;
  };
const WAe = oa(GAe);
var lq = { exports: {} };
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(a, o, l) {
    (this.fn = a), (this.context = o), (this.once = l || !1);
  }
  function s() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (s.prototype.eventNames = function () {
    var o = [],
      l,
      u;
    if (this._eventsCount === 0) return o;
    for (u in (l = this._events)) e.call(l, u) && o.push(n ? u.slice(1) : u);
    return Object.getOwnPropertySymbols
      ? o.concat(Object.getOwnPropertySymbols(l))
      : o;
  }),
    (s.prototype.listeners = function (o, l) {
      var u = n ? n + o : o,
        f = this._events[u];
      if (l) return !!f;
      if (!f) return [];
      if (f.fn) return [f.fn];
      for (var c = 0, d = f.length, p = new Array(d); c < d; c++)
        p[c] = f[c].fn;
      return p;
    }),
    (s.prototype.emit = function (o, l, u, f, c, d) {
      var p = n ? n + o : o;
      if (!this._events[p]) return !1;
      var m = this._events[p],
        g = arguments.length,
        w,
        y;
      if (m.fn) {
        switch ((m.once && this.removeListener(o, m.fn, void 0, !0), g)) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, l), !0;
          case 3:
            return m.fn.call(m.context, l, u), !0;
          case 4:
            return m.fn.call(m.context, l, u, f), !0;
          case 5:
            return m.fn.call(m.context, l, u, f, c), !0;
          case 6:
            return m.fn.call(m.context, l, u, f, c, d), !0;
        }
        for (y = 1, w = new Array(g - 1); y < g; y++) w[y - 1] = arguments[y];
        m.fn.apply(m.context, w);
      } else {
        var v = m.length,
          E;
        for (y = 0; y < v; y++)
          switch (
            (m[y].once && this.removeListener(o, m[y].fn, void 0, !0), g)
          ) {
            case 1:
              m[y].fn.call(m[y].context);
              break;
            case 2:
              m[y].fn.call(m[y].context, l);
              break;
            case 3:
              m[y].fn.call(m[y].context, l, u);
              break;
            case 4:
              m[y].fn.call(m[y].context, l, u, f);
              break;
            default:
              if (!w)
                for (E = 1, w = new Array(g - 1); E < g; E++)
                  w[E - 1] = arguments[E];
              m[y].fn.apply(m[y].context, w);
          }
      }
      return !0;
    }),
    (s.prototype.on = function (o, l, u) {
      var f = new i(l, u || this),
        c = n ? n + o : o;
      return (
        this._events[c]
          ? this._events[c].fn
            ? (this._events[c] = [this._events[c], f])
            : this._events[c].push(f)
          : ((this._events[c] = f), this._eventsCount++),
        this
      );
    }),
    (s.prototype.once = function (o, l, u) {
      var f = new i(l, u || this, !0),
        c = n ? n + o : o;
      return (
        this._events[c]
          ? this._events[c].fn
            ? (this._events[c] = [this._events[c], f])
            : this._events[c].push(f)
          : ((this._events[c] = f), this._eventsCount++),
        this
      );
    }),
    (s.prototype.removeListener = function (o, l, u, f) {
      var c = n ? n + o : o;
      if (!this._events[c]) return this;
      if (!l)
        return (
          --this._eventsCount === 0
            ? (this._events = new r())
            : delete this._events[c],
          this
        );
      var d = this._events[c];
      if (d.fn)
        d.fn === l &&
          (!f || d.once) &&
          (!u || d.context === u) &&
          (--this._eventsCount === 0
            ? (this._events = new r())
            : delete this._events[c]);
      else {
        for (var p = 0, m = [], g = d.length; p < g; p++)
          (d[p].fn !== l || (f && !d[p].once) || (u && d[p].context !== u)) &&
            m.push(d[p]);
        m.length
          ? (this._events[c] = m.length === 1 ? m[0] : m)
          : --this._eventsCount === 0
          ? (this._events = new r())
          : delete this._events[c];
      }
      return this;
    }),
    (s.prototype.removeAllListeners = function (o) {
      var l;
      return (
        o
          ? ((l = n ? n + o : o),
            this._events[l] &&
              (--this._eventsCount === 0
                ? (this._events = new r())
                : delete this._events[l]))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prototype.setMaxListeners = function () {
      return this;
    }),
    (s.prefixed = n),
    (s.EventEmitter = s),
    (t.exports = s);
})(lq);
var qAe = lq.exports,
  uq = { exports: {} };
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(a, o, l) {
    (this.fn = a), (this.context = o), (this.once = l || !1);
  }
  function s() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (s.prototype.eventNames = function () {
    var o = [],
      l,
      u;
    if (this._eventsCount === 0) return o;
    for (u in (l = this._events)) e.call(l, u) && o.push(n ? u.slice(1) : u);
    return Object.getOwnPropertySymbols
      ? o.concat(Object.getOwnPropertySymbols(l))
      : o;
  }),
    (s.prototype.listeners = function (o, l) {
      var u = n ? n + o : o,
        f = this._events[u];
      if (l) return !!f;
      if (!f) return [];
      if (f.fn) return [f.fn];
      for (var c = 0, d = f.length, p = new Array(d); c < d; c++)
        p[c] = f[c].fn;
      return p;
    }),
    (s.prototype.emit = function (o, l, u, f, c, d) {
      var p = n ? n + o : o;
      if (!this._events[p]) return !1;
      var m = this._events[p],
        g = arguments.length,
        w,
        y;
      if (m.fn) {
        switch ((m.once && this.removeListener(o, m.fn, void 0, !0), g)) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, l), !0;
          case 3:
            return m.fn.call(m.context, l, u), !0;
          case 4:
            return m.fn.call(m.context, l, u, f), !0;
          case 5:
            return m.fn.call(m.context, l, u, f, c), !0;
          case 6:
            return m.fn.call(m.context, l, u, f, c, d), !0;
        }
        for (y = 1, w = new Array(g - 1); y < g; y++) w[y - 1] = arguments[y];
        m.fn.apply(m.context, w);
      } else {
        var v = m.length,
          E;
        for (y = 0; y < v; y++)
          switch (
            (m[y].once && this.removeListener(o, m[y].fn, void 0, !0), g)
          ) {
            case 1:
              m[y].fn.call(m[y].context);
              break;
            case 2:
              m[y].fn.call(m[y].context, l);
              break;
            case 3:
              m[y].fn.call(m[y].context, l, u);
              break;
            case 4:
              m[y].fn.call(m[y].context, l, u, f);
              break;
            default:
              if (!w)
                for (E = 1, w = new Array(g - 1); E < g; E++)
                  w[E - 1] = arguments[E];
              m[y].fn.apply(m[y].context, w);
          }
      }
      return !0;
    }),
    (s.prototype.on = function (o, l, u) {
      var f = new i(l, u || this),
        c = n ? n + o : o;
      return (
        this._events[c]
          ? this._events[c].fn
            ? (this._events[c] = [this._events[c], f])
            : this._events[c].push(f)
          : ((this._events[c] = f), this._eventsCount++),
        this
      );
    }),
    (s.prototype.once = function (o, l, u) {
      var f = new i(l, u || this, !0),
        c = n ? n + o : o;
      return (
        this._events[c]
          ? this._events[c].fn
            ? (this._events[c] = [this._events[c], f])
            : this._events[c].push(f)
          : ((this._events[c] = f), this._eventsCount++),
        this
      );
    }),
    (s.prototype.removeListener = function (o, l, u, f) {
      var c = n ? n + o : o;
      if (!this._events[c]) return this;
      if (!l)
        return (
          --this._eventsCount === 0
            ? (this._events = new r())
            : delete this._events[c],
          this
        );
      var d = this._events[c];
      if (d.fn)
        d.fn === l &&
          (!f || d.once) &&
          (!u || d.context === u) &&
          (--this._eventsCount === 0
            ? (this._events = new r())
            : delete this._events[c]);
      else {
        for (var p = 0, m = [], g = d.length; p < g; p++)
          (d[p].fn !== l || (f && !d[p].once) || (u && d[p].context !== u)) &&
            m.push(d[p]);
        m.length
          ? (this._events[c] = m.length === 1 ? m[0] : m)
          : --this._eventsCount === 0
          ? (this._events = new r())
          : delete this._events[c];
      }
      return this;
    }),
    (s.prototype.removeAllListeners = function (o) {
      var l;
      return (
        o
          ? ((l = n ? n + o : o),
            this._events[l] &&
              (--this._eventsCount === 0
                ? (this._events = new r())
                : delete this._events[l]))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prototype.setMaxListeners = function () {
      return this;
    }),
    (s.prefixed = n),
    (s.EventEmitter = s),
    (t.exports = s);
})(uq);
var KAe = uq.exports;
function gn(t, e, n) {
  return (
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
var XAe = KAe,
  Cm = function () {},
  Mn = {
    data: "state-data",
    cdata: "state-cdata",
    tagBegin: "state-tag-begin",
    tagName: "state-tag-name",
    tagEnd: "state-tag-end",
    attributeNameStart: "state-attribute-name-start",
    attributeName: "state-attribute-name",
    attributeNameEnd: "state-attribute-name-end",
    attributeValueBegin: "state-attribute-value-begin",
    attributeValue: "state-attribute-value",
  },
  dn = {
    lt: "action-lt",
    gt: "action-gt",
    space: "action-space",
    equal: "action-equal",
    quote: "action-quote",
    slash: "action-slash",
    char: "action-char",
    error: "action-error",
  },
  ti = {
    text: "text",
    openTag: "open-tag",
    closeTag: "close-tag",
    attributeName: "attribute-name",
    attributeValue: "attribute-value",
  },
  ZAe = {
    " ": dn.space,
    "	": dn.space,
    "\n": dn.space,
    "\r": dn.space,
    "<": dn.lt,
    ">": dn.gt,
    '"': dn.quote,
    "'": dn.quote,
    "=": dn.equal,
    "/": dn.slash,
  },
  YAe = function (e) {
    return ZAe[e] || dn.char;
  },
  QAe = function (e) {
    var n, r, i, s, a, o, l, u, f, c;
    e = Object.assign({ debug: !1 }, e);
    var d = new XAe(),
      p = Mn.data,
      m = "",
      g = "",
      w = "",
      y = "",
      v = "",
      E = "",
      S = function (x, _) {
        if (!(g[0] === "?" || g[0] === "!")) {
          var A = { type: x, value: _ };
          e.debug && console.log("emit:", A), d.emit("data", A);
        }
      };
    d.stateMachine =
      ((c = {}),
      gn(
        c,
        Mn.data,
        ((n = {}),
        gn(n, dn.lt, function () {
          m.trim() && S(ti.text, m), (g = ""), (v = !1), (p = Mn.tagBegin);
        }),
        gn(n, dn.char, function (P) {
          m += P;
        }),
        n)
      ),
      gn(
        c,
        Mn.cdata,
        gn({}, dn.char, function (P) {
          (m += P),
            m.substr(-3) === "]]>" &&
              (S(ti.text, m.slice(0, -3)), (m = ""), (p = Mn.data));
        })
      ),
      gn(
        c,
        Mn.tagBegin,
        ((r = {}),
        gn(r, dn.space, Cm),
        gn(r, dn.char, function (P) {
          (g = P), (p = Mn.tagName);
        }),
        gn(r, dn.slash, function () {
          (g = ""), (v = !0);
        }),
        r)
      ),
      gn(
        c,
        Mn.tagName,
        ((i = {}),
        gn(i, dn.space, function () {
          v ? (p = Mn.tagEnd) : ((p = Mn.attributeNameStart), S(ti.openTag, g));
        }),
        gn(i, dn.gt, function () {
          S(v ? ti.closeTag : ti.openTag, g), (m = ""), (p = Mn.data);
        }),
        gn(i, dn.slash, function () {
          (p = Mn.tagEnd), S(ti.openTag, g);
        }),
        gn(i, dn.char, function (P) {
          (g += P), g === "![CDATA[" && ((p = Mn.cdata), (m = ""), (g = ""));
        }),
        i)
      ),
      gn(
        c,
        Mn.tagEnd,
        ((s = {}),
        gn(s, dn.gt, function () {
          S(ti.closeTag, g), (m = ""), (p = Mn.data);
        }),
        gn(s, dn.char, Cm),
        s)
      ),
      gn(
        c,
        Mn.attributeNameStart,
        ((a = {}),
        gn(a, dn.char, function (P) {
          (w = P), (p = Mn.attributeName);
        }),
        gn(a, dn.gt, function () {
          (m = ""), (p = Mn.data);
        }),
        gn(a, dn.space, Cm),
        gn(a, dn.slash, function () {
          (v = !0), (p = Mn.tagEnd);
        }),
        a)
      ),
      gn(
        c,
        Mn.attributeName,
        ((o = {}),
        gn(o, dn.space, function () {
          p = Mn.attributeNameEnd;
        }),
        gn(o, dn.equal, function () {
          S(ti.attributeName, w), (p = Mn.attributeValueBegin);
        }),
        gn(o, dn.gt, function () {
          (y = ""),
            S(ti.attributeName, w),
            S(ti.attributeValue, y),
            (m = ""),
            (p = Mn.data);
        }),
        gn(o, dn.slash, function () {
          (v = !0),
            (y = ""),
            S(ti.attributeName, w),
            S(ti.attributeValue, y),
            (p = Mn.tagEnd);
        }),
        gn(o, dn.char, function (P) {
          w += P;
        }),
        o)
      ),
      gn(
        c,
        Mn.attributeNameEnd,
        ((l = {}),
        gn(l, dn.space, Cm),
        gn(l, dn.equal, function () {
          S(ti.attributeName, w), (p = Mn.attributeValueBegin);
        }),
        gn(l, dn.gt, function () {
          (y = ""),
            S(ti.attributeName, w),
            S(ti.attributeValue, y),
            (m = ""),
            (p = Mn.data);
        }),
        gn(l, dn.char, function (P) {
          (y = ""),
            S(ti.attributeName, w),
            S(ti.attributeValue, y),
            (w = P),
            (p = Mn.attributeName);
        }),
        l)
      ),
      gn(
        c,
        Mn.attributeValueBegin,
        ((u = {}),
        gn(u, dn.space, Cm),
        gn(u, dn.quote, function (P) {
          (E = P), (y = ""), (p = Mn.attributeValue);
        }),
        gn(u, dn.gt, function () {
          (y = ""), S(ti.attributeValue, y), (m = ""), (p = Mn.data);
        }),
        gn(u, dn.char, function (P) {
          (E = ""), (y = P), (p = Mn.attributeValue);
        }),
        u)
      ),
      gn(
        c,
        Mn.attributeValue,
        ((f = {}),
        gn(f, dn.space, function (P) {
          E ? (y += P) : (S(ti.attributeValue, y), (p = Mn.attributeNameStart));
        }),
        gn(f, dn.quote, function (P) {
          E === P
            ? (S(ti.attributeValue, y), (p = Mn.attributeNameStart))
            : (y += P);
        }),
        gn(f, dn.gt, function (P) {
          E ? (y += P) : (S(ti.attributeValue, y), (m = ""), (p = Mn.data));
        }),
        gn(f, dn.slash, function (P) {
          E ? (y += P) : (S(ti.attributeValue, y), (v = !0), (p = Mn.tagEnd));
        }),
        gn(f, dn.char, function (P) {
          y += P;
        }),
        f)
      ),
      c);
    var D = function (x) {
      e.debug && console.log(p, x);
      var _ = d.stateMachine[p],
        A = _[YAe(x)] || _[dn.error] || _[dn.char];
      A(x);
    };
    return (
      (d.write = function (P) {
        for (var x = P.length, _ = 0; _ < x; _++) D(P[_]);
      }),
      d
    );
  },
  JAe = { State: Mn, Action: dn, Type: ti, create: QAe },
  eCe = qAe,
  cq = JAe,
  km = cq.Type,
  yS = { element: "element", text: "text" },
  Q8 = function (e) {
    return Object.assign(
      {
        name: "",
        type: yS.element,
        value: "",
        parent: null,
        attributes: {},
        children: [],
      },
      e
    );
  },
  fq = function (e) {
    e = Object.assign(
      {
        stream: !1,
        parentNodes: !0,
        doneEvent: "done",
        tagPrefix: "tag:",
        emitTopLevelOnly: !1,
        debug: !1,
      },
      e
    );
    var n = void 0,
      r = void 0,
      i = void 0,
      s = void 0,
      a = new eCe(),
      o = function (u) {
        switch (u.type) {
          case km.openTag:
            if (i === null) (i = r), (i.name = u.value);
            else {
              var f = Q8({ name: u.value, parent: i });
              i.children.push(f), (i = f);
            }
            break;
          case km.closeTag:
            var c = i.parent;
            if ((e.parentNodes || (i.parent = null), i.name !== u.value)) break;
            e.stream && c === r && ((r.children = []), (i.parent = null)),
              (!e.emitTopLevelOnly || c === r) &&
                (a.emit(e.tagPrefix + i.name, i), a.emit("tag", i.name, i)),
              i === r &&
                (n.removeAllListeners("data"),
                a.emit(e.doneEvent, i),
                (r = null)),
              (i = c);
            break;
          case km.text:
            i &&
              i.children.push(
                Q8({
                  type: yS.text,
                  value: u.value,
                  parent: e.parentNodes ? i : null,
                })
              );
            break;
          case km.attributeName:
            (s = u.value), (i.attributes[s] = "");
            break;
          case km.attributeValue:
            i.attributes[s] = u.value;
            break;
        }
      };
    return (
      (a.reset = function () {
        (n = cq.create({ debug: e.debug })),
          n.on("data", o),
          (r = Q8()),
          (i = null),
          (s = ""),
          (a.parse = n.write);
      }),
      a.reset(),
      a
    );
  },
  tCe = function (e, n) {
    n = Object.assign({}, n, { stream: !1, tagPrefix: ":" });
    var r = fq(n),
      i = void 0;
    return (
      r.on("done", function (s) {
        i = s;
      }),
      r.parse(e),
      i
    );
  },
  nCe = { parseSync: tCe, create: fq, NodeType: yS },
  rCe = function (e) {
    var n = nCe.parseSync("<root>".concat(e, "</root>"), { parentNodes: !1 }),
      r =
        n.children &&
        n.children.length > 0 &&
        n.children.every(function (i) {
          return i.name === "svg";
        });
    if (r) return n.children.length === 1 ? n.children[0] : n.children;
    throw Error("nothing to parse");
  },
  iCe = function (e) {
    return WAe(e, function (n) {
      return aCe(n) ? n : sCe(n);
    });
  },
  sCe = function (e) {
    return e.replace(/[-|:]([a-z])/gi, function (n, r) {
      return r.toUpperCase();
    });
  },
  aCe = function (e) {
    return /^(data|aria)(-\w+)/.test(e);
  },
  oCe = function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      r = n.transformNode,
      i =
        r === void 0
          ? function (l) {
              return l;
            }
          : r,
      s = n.camelcase,
      a = s === void 0 ? !1 : s,
      o = function (u) {
        var f;
        return (f = i(u)), a && (f = iCe(f)), f;
      };
    return o(rCe(e));
  };
function Cv() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return new Promise(function (r, i) {
    try {
      var s = oCe.apply(void 0, e);
      r(s);
    } catch (a) {
      i(a);
    }
  });
}
const lCe = [
    {
      balise: "path",
      data: {
        d: "m116.76,172.87l1.94,15.85-12.07,2.46-9.88-2.34-14.65-24.26,4.8-45.07,17.12-22.84,23.49-2.46,21.55-11.82,28.81,14.41-6.5,7.33,47.74,9.48,25.3,17.12s2.34,24.81-5.69,33.49l9.6,56.55h-21.15l4.4-3.91-19.85-43.1-55.75,7.82-19.39,39.19h-21.55l7.08-11.42,14.87-52.88-10.37-9.97-22.32,4.4-2.46,20.62,7.63,7.42,7.3-6.06Z",
        fill: "#fff",
        "stroke-width": "0",
      },
    },
    {
      balise: "polygon",
      data: {
        points:
          "153.24 220.77 175.93 220.77 168.81 182.94 159.46 185.55 152.16 201.13 156.66 218.74 153.24 220.77",
        fill: "#fff",
        "stroke-width": "0",
      },
    },
    {
      balise: "polygon",
      data: {
        points:
          "195.29 220.77 199.87 214 199.87 183.8 206.86 179.24 219.02 199.99 216.8 220.77 195.29 220.77",
        fill: "#fff",
        "stroke-width": "0",
      },
    },
    {
      balise: "text",
      data: {
        transform: "translate(87 260)",
        "font-size": "38",
        "font-family": "andale mono, monospace",
        fill: "#fff",
      },
      textContent: "STRATEGY",
    },
  ],
  uCe = {
    cvgSDT: [
      {
        balise: "path",
        data: {
          d: "M281,186.19a102,102,0,0,1-102,102V276a89.8,89.8,0,0,0,78-134.38l.41-.23,10.18-5.88h0A101.49,101.49,0,0,1,281,186.19Z",
          fill: "#ff0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M179,276v12.24A102.06,102.06,0,0,1,90.4,135.49l10.18,5.88.42.24h0A89.75,89.75,0,0,0,179,276Z",
          fill: "red",
        },
      },
      {
        balise: "path",
        data: {
          d: "M257.32,141.36l-.41.24h0a89.87,89.87,0,0,0-155.91,0l-.41-.24L90.4,135.49a102,102,0,0,1,177.1,0Z",
          fill: "blue",
        },
      },
      {
        balise: "path",
        data: { d: "M267.51,135.49l-10.18,5.88h0l10.18-5.88Z", fill: "blue" },
      },
      {
        balise: "path",
        data: {
          d: "M224.34,174.36l-14.5-9.81-27.36-5.44,3.72-4.19-16.51-8.26-12.35,6.77-13.46,1.42-9.8,13.09-2.76,25.82,8.4,13.9,5.66,1.34,6.92-1.41-1.11-9.08L147,202l-4.38-4.25L144,185.91l12.79-2.52,5.95,5.71-8.52,30.31L150.2,226h12.35l11.11-22.46,32-4.48L217,223.72,214.46,226h12.12l-5.5-32.41C225.68,188.57,224.34,174.36,224.34,174.36Z",
          fill: "#fff",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "175.66 205.78 171.47 214.7 174.05 224.79 172.09 225.96 185.09 225.96 181.02 204.28 175.66 205.78",
          fill: "#fff",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "198.82 204.77 198.82 222.07 196.19 225.96 208.52 225.96 209.79 214.05 202.82 202.16 198.82 204.77",
          fill: "#fff",
        },
      },
    ],
    sdANGLE: [
      {
        balise: "path",
        data: {
          d: "m134.62,211.81l44.15-44.56,44.15,44.56-22.11,22.27-22.11-22.27-22.11,22.27-21.97-22.27h0Z",
          fill: "#faf1e7",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m178.77,211.81l-22.11,22.27-4.41-11.06,26.48-26.74.04,15.52h0Z",
          fill: "#1f2333",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m134.62,211.81l22.11,22.27-4.41-11.06-26.5-26.74,8.79,15.52h0Z",
          fill: "#faf1e7",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m178.77,211.81l22.11,22.27,4.41-11.06-26.5-26.74-.03,15.52h0Z",
          fill: "#faf1e7",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m222.92,211.81l-22.11,22.27,4.41-11.06,26.5-26.74-8.79,15.52h0Z",
          fill: "#1f2333",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m125.79,196.32l52.98-53.46,52.99,53.46-26.5,26.73-26.5-26.73-26.48,26.73-26.5-26.73h0Z",
          fill: "#f4837d",
          stroke: "#1f2333",
          "stroke-linejoin": "round",
          "stroke-width": "5",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdFXS: [
      {
        balise: "path",
        data: {
          d: "m132.63,129.2l-6.96,6.97,8.81,8.81,8.82,8.81-.73,2.15c-.92,2.68-1.37,5.49-1.33,8.33,0,10.21,5.34,18.9,14.8,24.08,3.81,2.08,10.35,4.42,17.6,6.29,14.15,3.65,16.33,4.27,19.11,5.57,3.81,1.82,5.69,3.77,6.48,6.73.34,1.29.32,4.17-.02,5.56-.88,3.36-3.75,6.75-7.3,8.6-4.8,2.52-13.17,3.21-19.48,1.6-2.35-.58-5.67-2.21-7.34-3.58-3.4-2.81-6.06-7.66-7.23-13.25-.19-.89-.35-1.63-.36-1.67s-19.75,1.85-19.85,1.96c-.08.06-.02.86.12,1.79.62,4.44,2.19,9.73,3.96,13.4l1.04,2.13-8.57,8.55-8.54,8.56,6.98,6.98,6.96,6.96,8.82-8.82,8.81-8.81,1.52.63c8.03,3.38,20.09,4.44,31.78,2.75,3.06-.46,6.07-1.17,9-2.15l1.27-.46,8.44,8.44,8.42,8.42,6.96-6.96,6.98-6.98-7.81-7.83-7.81-7.81.98-2c2.04-4.09,2.89-7.57,3.06-12.36.31-9.12-2.06-16.02-7.44-21.69-5.61-5.9-11.94-8.71-29.8-13.21-12.6-3.15-18.02-5.33-20.17-8.06-2.14-2.64-2.33-6.36-.47-9.21,1.09-1.6,3.73-3.31,6.61-4.27,3.25-1.09,8.71-1.6,12.77-1.17,8.56.9,12.86,4.56,14.75,12.56.23.98.44,1.81.46,1.85s13.96-.44,18.13-.65l2.38-.12-.13-1.67c-.24-3.29-.97-6.54-2.17-9.62l-.67-1.79,8.67-8.69,8.67-8.67-6.97-6.97-6.98-6.97-8.76,8.76-8.8,8.8-2.13-.81c-5.25-1.96-10.32-2.83-17.81-3.04-8.17-.21-15.34.85-20.84,3.08l-2.04.82-8.84-8.81-8.85-8.81-6.98,6.98h0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdBAL: [
      {
        balise: "path",
        data: {
          d: "m180.33,231.9c-33.28,0-60.26-9.62-60.26-22.51,0-6.72,7.35-12.78,19.11-17.04,9.18,5.89,24.59,8.9,42.05,8.9s32.12-3.68,41.38-9.32c11.1,4.22,17.98,10.12,17.98,16.61,0,12.91-26.98,23.35-60.26,23.35h0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m180.69,198.36c-25.23,0-45.69-7.97-45.69-17.68,0-5.41,6.31-10.26,16.19-13.48,7.06,3.68,17.63,6.03,29.5,6.03s22.48-2.35,29.45-6.03c9.96,3.25,16.2,8.08,16.2,13.48.06,9.76-20.41,17.68-45.65,17.68h0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m180.52,170.3c-19.5,0-35.32-6.53-35.32-14.57s15.82-14.57,35.32-14.57,35.32,6.53,35.32,14.57-15.82,14.57-35.32,14.57Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdPENDLE: [
      {
        balise: "path",
        data: {
          d: "m185.18,237.19h0c1.5-19.2-12.4-36.2-31.6-38.5h-.1v-86.4",
          fill: "none",
          stroke: "#7a8698",
          "stroke-width": "2",
        },
      },
      {
        balise: "path",
        data: {
          d: "m185.18,237.29h0c-22.6,2.2-44.6-7.5-58.3-25.6-.5-.7-1.3-1.7-2.3-3.1m0-.1h0",
          fill: "none",
          stroke: "#1a3969",
          "stroke-width": "2",
        },
      },
      {
        balise: "path",
        data: {
          d: "m124.58,208.49c5.7-5.5,13-8.9,20.8-9.8v-82.2",
          fill: "none",
          stroke: "#7a8698",
          "stroke-width": "2",
        },
      },
      {
        balise: "path",
        data: {
          d: "m124.58,208.49q-.1,0,0,0",
          fill: "none",
          stroke: "#7e91af",
          "stroke-width": "2",
        },
      },
      {
        balise: "path",
        data: {
          d: "m185.18,237.19h0c1.5-19.2-12.4-36.2-31.6-38.5h-.1v-86.4l.4-.2c33.3-13.7,71.3,2.2,85,35.4,13.7,33.3-2.2,71.3-35.4,85-5.8,2.5-12,4.1-18.3,4.7Z",
          fill: "#dedede",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m153.58,112.29v86.3h0c19.2,2.3,33.1,19.3,31.6,38.5h0l-.1.1h0c-22.5,2.2-44.6-7.5-58.3-25.5-.5-.7-1.3-1.7-2.3-3.1m.1-.1h0c5.7-5.5,13-8.9,20.8-9.8v-82.2c2.6-1.6,5.4-2.9,8.2-4.1l-29,96.1Z",
          fill: "#152e51",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m145.38,116.49v82.2c-7.8.9-15.1,4.4-20.8,9.8q-.1,0,0,0c-6.9-10.4-10.7-22.6-10.9-35.2v-1.9c.3-22.5,12.3-43.3,31.6-54.9h.1Z",
          fill: "#dedede",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m124.48,208.49h0m0,0c1,1.4,1.8,2.5,2.3,3.1,13.7,18,35.7,27.7,58.3,25.5h0c-1.6,18.2-16.5,32.3-34.8,32.8h-1.8c-19.1-.5-34.4-15.9-34.8-35v-1.7c.2-9.3,4.1-18.2,10.8-24.7h0Z",
          fill: "#1e4480",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdCRV: [
      {
        balise: "path",
        data: {
          d: "m210.23,177.53c1.53.11,3.19,1.57,4.57.89,1.1,1.28,3.11,1.4,4.66,2.24-11.6,4.29-24.1,5.51-36.34,6.38-1.75-2.28-.75-7-2.17-9.73.77,9.23,2.43,20.48-6.52,26.24-1.08-2.1-.61-7.83-4.2-3.48-2.39,1.5-3.3-12.67-11.04-10.63,3.4,4.3-12.36-.78-13.14,2.38-2.87,3.5-8.98-1.18-9.71-4.61-.52,1.39-1.04,2.75-1.55,4.12-.09,0-.18,0-.27,0-1.06-5.88-1.83-11.81-3.52-17.75-.5,2.1-.97,4.06-1.49,6.22-1.28-4.28-2.28-8.39-2.76-12.76-2.6,10.39,2.26,20.35,4.64,30.26t0,.01c.02-.12.03-.25.05-.37.03.01.05.02.07.03-.84,8.84,8.63,7.7,14.66,6.74,7.05-.92,14.52-1.62,21.66-2.85,4.45.03,2.79,10.04,4.51,13.03,1.99,5.27,8.96-.99,10.49-3.84,1.2-.85,3.87-.15,3.96-2.13.09.61.39.88,1.11.66,8-1.9,16.03-3.62,24.08-5.28,3.16-1.43,7.94-.17,10.2-3.2,21.08-7.84,35.7-8.44,21.39-34.64-.22,1.02.66,1.79.67,2.78-2.07-1.27-1.23,2.77-1.79,3.94-3.2-2.56-2.96,3.29-5.75,2.92-.5-.1-1.96-1.17-1.81-.01-1.89.93-3.78,3.74-6.14,2.87,1.81-1.2,3.52-2.34,5.24-3.48-.01-.05-.03-.11-.04-.16-4.5,1.08-2.76.14-1.11-2.56-.44.27-.86.51-1.31.78.14-1.23.27-2.37.4-3.56-.83.21-.9,1.14-1.59,1.43-.81-1.08-1.06-2.47-1.92-3.72-.58.62-.61,2.66-1.75,2.31-2.62-2.85-5.76-5-9.03-7.01-.85.69-.08,3.8-1.84,3.33-5.91-2.28-14.36-7.34-20.01-6.69,1.13,8.83-3.25,1.9-15.27,3.3-6.89,1.33.67,10.14.35,14.5,5.59-3.04,13.54-1.48,19.84-.82m-58.19,27.58c.2-.06.1.31.04.41-.14-.14-.14-.37-.04-.41Zm90.31-31.44s0,0,0,.01c0,0,0,0,.01,0h0Z",
          fill: "#fbf100",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m210.23,177.53c1.53.11,3.19,1.57,4.57.89,1.1,1.28,3.11,1.4,4.66,2.24-2.11.78-4.25,1.46-6.41,2.05-5.54-1.9-12.26-1.29-21.16-.81-3.41.18-7.25-.43-10,.18-.13-1.27-.44-3.76-.94-4.78.03-.29.04-.61,0-.94,5.58-3,13.5-1.44,19.77-.78",
          fill: "#b1ff46",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m244.27,168.22c-2.07-1.27-1.23,2.77-1.79,3.94-3.2-2.56-2.97,3.29-5.75,2.92-.5-.1-1.96-1.17-1.81-.01-1.89.93-3.78,3.74-6.14,2.87,1.81-1.2,3.52-2.34,5.24-3.48-.01-.05-.03-.11-.04-.16-4.49,1.08-2.73.09-1.1-2.57.05-.01.09-.02.09-.08-.44.36-.93.55-1.4.87.14-1.23.27-2.37.4-3.56-.83.21-.9,1.14-1.59,1.43-.81-1.08-1.06-2.47-1.92-3.72-.58.62-.61,2.66-1.75,2.31-2.62-2.85-5.76-5-9.03-7.01-.82.69-.1,3.8-1.84,3.33-5.91-2.28-14.36-7.34-20.02-6.69,1.17,8.83-3.35,1.89-15.26,3.3-6.29,1.08-.52,8.76.14,12.93.88,9.74,3.39,22.41-6.25,28.71-1.08-2.1-.61-7.83-4.2-3.48-2.39,1.5-3.3-12.67-11.04-10.63,3.4,4.3-12.36-.78-13.14,2.38-2.87,3.5-8.98-1.18-9.71-4.61-.52,1.39-1.04,2.75-1.55,4.12-.09,0-.18,0-.27,0-1.06-5.88-1.83-11.81-3.52-17.75-.5,2.1-.97,4.06-1.49,6.22-4.73-11.69-1.48-24.52,4.69-35.23-1.66,9.17,2.74,17.99,3.6,27.05,1.09-1.29,2.08-2.45,3.07-3.61.03,2.75.56,5.35.5,8.02,1.04-1.18,3.2-1.31,2.98-3.52.73,1.75-1.43,6.36,1.94,4.04.49-.24,1.4-.34,1.31-1.06,0,0,0,.01,0,.02.05.22.36.4.4.6-.66.78-.16,1.67-.29,2.49-.15.88,1.09.33,1.59.38,2.56-.11,5.29.26,7.5,1.63,1.19.7,2.3,2.18,3.67,2.05,0,0,0,0,0,0,.15-.05.28-.2.35-.34.3-.62.34-1.48.82-1.96,1.17,1.02,2.28,2,3.39,2.98.42-.88.89-1.89,1.43-3.02.15.12.26.26.39.42,0,0,0,0,0,0,4.34,9.35,5.05-3.86,6.63-7.38,1.12,1.7,1.81,3.55,3.03,5.11.44-8.83-.55-17.75-3.34-26.07-.17-1.42.51-2.42,1.65-3.09,1.44-1.93-1.75-4.44-.49-6.35,1.64-.66,8.71,1.62,8.52.28.27-.91-1.32-4.72.31-3.93,3.97.49,8.22,3.22,12.41,3.86.8.11,1.85.07,1.77-.91.13-4.22,6.6,2.56,9.04,1.42.42-1.48,1.34-2.64,2.33-3.76,13.25,5.39,26.33,13.5,34.77,25.36-.12.12-.09.18.08.18-.22,1.02.66,1.79.67,2.78Z",
          fill: "#ff8200",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m208.74,139.91c-.99,1.12-1.92,2.28-2.34,3.76-2.03,1.26-9.02-5.63-9.04-1.42.34,3.31-11.54-3.09-14.17-2.95-.66-.17-.91-.25-.71.63,1.9,6.85-2.62,2.16-8.12,3.03-1.38,1.34,2.33,5.27.17,6.6-1.06.53-1.42,1.65-1.33,2.83,2.8,8.32,3.79,17.24,3.34,26.08-1.23-1.57-1.92-3.42-3.04-5.11-1.14,3.62-1.53,7.4-3.51,10.75-1.17.97-2.34-2.85-3.51-3.79-.54,1.13-1.02,2.14-1.43,3.01-1.1-.97-2.22-1.95-3.39-2.98-.38.39-.48.98-.67,1.53-.59,2.67-4.1-2.06-5.94-2.07-1.78-1.33-7.65-.24-7.34-1.22.13-.82-.37-1.7.29-2.48.05-.06-.45-.5-.4-.66.11.73-.71.82-1.31,1.09-3.38,2.32-1.22-2.29-1.94-4.04.21,2.21-1.95,2.34-2.98,3.52.05-2.67-.48-5.27-.51-8.02-.99,1.16-1.98,2.32-3.07,3.6-.84-11.1-8.88-23.98.73-33.07,17.23-22.48,49.29-7.39,70.2,1.38Z",
          fill: "#d50201",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m131.41,197.29c.52,9.34,8,6.97,14.78,6.41,5.06-.64,10.58-1.3,15.82-1.93,2.34.12,5.83-1.83,7.66-.38,2.37,3.26.84,16.14,5.67,14.37,3.09-.57,5.37-2.29,6.91-4.99.76-1.95,4.58-.56,4.57-2.88.11.78.44.84,1.11.68,8-1.91,16.03-3.62,24.08-5.28,2.63-1.15,9.18-.72,10.2-3.2,8.4-4.47,24.21-4.68,27.16-15.88.21,6.31-.86,12.82-3.79,18.33-3.27.96-4,4.62-7.43,5.2-15.43,5.53-31.45,9.13-47.14,13.71,1.87-3.1-6.85,1.94-8.22,1.73-1.17.13-1.02,1.86-2.12,2.32-2.24,1.65-.44,5.85-3.08,6.93-3.27.73-7.4-1.29-6.35-5.12,3.35-16.75-.13-11.16-12.67-7.95-1.98.87-.92-3.08-2.72-2.65-4.94,1.54-9.92,3.04-14.56,5.36-.6.31-.85.09-.98-.49-.54-.89-.17-3.52-1.42-3.34-7.9,4.86-5.94-4.44-8.87-9.06-3.28-10.92-4.59-22.91-4.17-34.47.92,7.67,3.72,15.29,5.58,22.6Z",
          fill: "#b1ff46",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m245.57,202.53c-10.56,15.26-45.78,14.08-62.98,23.28-.85,2.53-1.72,4.85-2.64,6.97-5.14,1.36-5.63,5.94-7.7,6.15-1.17.06-1.75-.72-3.75-2.61-5.75-5.46-4.49-10.18-5.79-10.12-3.43.18-7.37,9.07-10.46,9.1-4.92-1.06-6.87-6.38-14.33-2.61-3.67-6.86-6.48-15.04-7.93-23.52,2.79,4.6,1.15,13.85,9.17,9.08,1.28.44.22,4.5,2.1,3.8,4.64-2.32,9.62-3.81,14.56-5.35,1.81-.43.74,3.52,2.73,2.65,2.3-.59,4.29-1.25,6-1.85,17.94-8.09-2.51,16.98,13.02,14.93,2.71-1.23.83-5.35,3.08-6.93,1.11-.46.95-2.19,2.12-2.32,1.21.36,9.68-4.84,8.23-1.73,15.68-4.59,31.7-8.19,47.13-13.71,3.43-.58,4.17-4.24,7.44-5.2Z",
          fill: "#00d8ff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m179.96,232.78c-12.57,29.26-31.09,20.41-42.03-.1,7.47-3.76,9.38,1.54,14.33,2.61,3.09-.03,7.03-8.92,10.46-9.1,1.3-.06.03,4.66,5.79,10.12,2,1.89,2.58,2.67,3.75,2.61,2.07-.2,2.57-4.8,7.7-6.15Z",
          fill: "#004cff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m213.06,182.71c-1.01.28-2.02.54-3.03.77-8.79,2.09-17.93,2.92-26.9,3.56-1.06-1.35-.99-2.37-1.19-4.6-.01-.12-.02-.24-.03-.36,2.75-.61,7.38-.6,10.79-.78,8.9-.48,14.82-.5,20.36,1.41Z",
          fill: "#00d8ff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdFXN: [
      {
        balise: "path",
        data: {
          d: "m190.44,250.22c-7.41,1.35-15.47.93-22.92-.35-15.12-2.62-27.99-10.32-37.42-22.51-.02-.02-.25-.27-.73-.75-.29-.29-.42-.62-.42-.96,0-.04,0-.08.02-.12,0-.02.02-.04.02-.08,0-.02.02-.04.02-.06v-.02s.02-.04.04-.06c0-.02.02-.04.04-.04.02-.02.04-.04.06-.08.01-.01.03-.02.04-.02.02-.02.04-.04.06-.04.02-.02.04-.04.08-.04.02-.02.06-.04.08-.04s.04-.02.06-.02.04-.02.08-.02.08-.02.12-.02.1,0,.15.02c15.76,3.47,29.53.1,41.32-10.05,5.03-4.92,8.93-10.61,11.71-17.07.66-1.56,1.33-1.95,2.97-1.97,7.41-.06,14.89-.12,22.43-.21.54,0,1-.46.98-1l-.08-12.65c0-.54-.44-.98-.98-.98l-17.21.04s-.1,0-.17-.02h-.02s-.03,0-.04-.02c-.02,0-.06-.02-.08-.02-.02-.02-.06-.02-.08-.04-.02,0-.04-.02-.06-.02s-.02-.02-.02-.02c-.02-.02-.06-.04-.08-.06-.02-.02-.04-.04-.06-.06-.02-.02-.04-.04-.06-.08l-.04-.04s-.02-.03-.02-.04c0-.02-.02-.02-.02-.04h0v-.02s-.02-.03-.02-.04c-.02-.02-.02-.04-.02-.08,0-.02-.02-.04-.02-.04,0-.02-.02-.04-.02-.06,0-.04-.02-.08-.02-.12,0-.1.02-.21.06-.31.54-1.41,1.31-2.78,2.33-4.09,5.75-7.58,13.43-11.09,23.01-10.49,11.92.73,19.39,10.03,21.43,21.28,5.27,29.34-18,58.12-46.49,63.56h0Z",
          fill: "#ec3f36",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m182.05,116.74h-6.89c-37.27,2.47-65.55,30.67-68.15,67.94v7.18c2.6,37.36,30.79,65.8,68.23,68.15h6.75c37.42-2.49,65.93-30.75,68.29-68.23v-6.75c-2.55-37.42-30.71-65.97-68.23-68.29h0Zm-61.96,71.35c-3.14-25.52,14.29-49.96,37.92-58.81,5.19-1.95,10.34-3.01,15.47-3.22,22.18-.87,41.86,7.29,54.86,25.27.1.17.15.35.1.52-.02.04-.02.08-.04.12v.02s-.04.08-.08.12c-.02.04-.06.06-.08.08l-.02.02c-.08.06-.17.08-.27.1-.04,0-.06.02-.1.02s-.1,0-.17-.02c-23.75-5.71-44.08,5.59-53.63,27.7-.29.66-1,1.02-2.14,1.02-4.59.02-9.2,0-13.79-.02h-.52l-8.26.02c-.81,0-1.2.42-1.2,1.2v12.29c0,.64.52,1.14,1.16,1.14l16.82.02c.62,0,.93.31,1,.91.04.46-.12.98-.5,1.6-5.71,9.76-16.07,14.66-27.08,12.83-11.32-1.87-18.07-11.9-19.44-22.97h0Zm70.35,62.13c-7.41,1.35-15.47.93-22.92-.35-15.12-2.62-27.99-10.32-37.42-22.51-.02-.02-.25-.27-.73-.75-.29-.29-.42-.62-.42-.96,0-.04,0-.08.02-.12,0-.02.02-.04.02-.08,0-.02.02-.04.02-.06v-.02s.02-.04.04-.06c0-.02.02-.04.04-.04.02-.02.04-.04.06-.08.01-.01.03-.02.04-.02.02-.02.04-.04.06-.04.02-.02.04-.04.08-.04.02-.02.06-.04.08-.04s.04-.02.06-.02.04-.02.08-.02.08-.02.12-.02.1,0,.15.02c15.76,3.47,29.53.1,41.32-10.05,5.03-4.92,8.93-10.61,11.71-17.07.66-1.56,1.33-1.95,2.97-1.97,7.41-.06,14.89-.12,22.43-.21.54,0,1-.46.98-1l-.08-12.65c0-.54-.44-.98-.98-.98l-17.21.04s-.1,0-.17-.02h-.02s-.03,0-.04-.02c-.02,0-.06-.02-.08-.02-.02-.02-.06-.02-.08-.04-.02,0-.04-.02-.06-.02s-.02-.02-.02-.02c-.02-.02-.06-.04-.08-.06-.02-.02-.04-.04-.06-.06-.02-.02-.04-.04-.06-.08l-.04-.04s-.02-.03-.02-.04c0-.02-.02-.02-.02-.04h0v-.02s-.02-.03-.02-.04c-.02-.02-.02-.04-.02-.08,0-.02-.02-.04-.02-.04,0-.02-.02-.04-.02-.06,0-.04-.02-.08-.02-.12,0-.1.02-.21.06-.31.54-1.41,1.31-2.78,2.33-4.09,5.75-7.58,13.43-11.09,23.01-10.49,11.92.73,19.39,10.03,21.43,21.28,5.27,29.34-18,58.12-46.49,63.56h0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m228.46,151.87s-.02.08-.04.12v.02s-.04.08-.08.12c-.02.04-.06.06-.08.08l-.02.02c-.08.06-.17.08-.27.1-.04,0-.06.02-.1.02s-.1,0-.17-.02c-23.75-5.71-44.08,5.59-53.63,27.7-.29.66-1,1.02-2.14,1.02-4.59.02-9.2,0-13.79-.02h-.52l-8.26.02c-.81,0-1.2.42-1.2,1.2v12.29c0,.64.52,1.14,1.16,1.14l16.82.02c.62,0,.93.31,1,.91.04.46-.12.98-.5,1.6-5.71,9.76-16.07,14.66-27.08,12.83-11.32-1.89-18.09-11.9-19.44-22.99-3.16-25.52,14.27-49.96,37.9-58.81,5.19-1.95,10.34-3.01,15.49-3.22,22.18-.87,41.86,7.29,54.86,25.27.1.17.15.35.1.54h0Z",
          fill: "#1f6fb7",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdYFI: [
      {
        balise: "path",
        data: {
          d: "M246.73 163.83a70.3 70.3 0 0 0-14.54-21.95c-6.32-6.19-13.73-11.18-21.95-14.54-8.22-3.37-16.97-5.11-25.72-5.11s-17.64 1.75-25.72 5.11a70.3 70.3 0 0 0-21.95 14.54c-6.19 6.32-11.18 13.73-14.54 21.95-3.37 8.22-5.11 16.97-5.11 25.72s1.75 17.64 5.11 25.72a70.3 70.3 0 0 0 14.54 21.95c6.19 6.19 13.73 11.18 21.81 14.54 8.08 3.37 17.1 5.11 25.85 5.11s17.64-1.75 25.72-5.11a70.3 70.3 0 0 0 21.95-14.54c6.19-6.19 11.18-13.73 14.54-21.81 3.37-8.08 5.11-17.1 5.11-25.85 0-8.76-1.75-17.65-5.11-25.73Zm-62.08 73.53c-14.27 0-24.78-10.5-24.78-23.57 0-3.5.27-5.79 1.62-8.75l-7.67 2.56-2.56-5.93 20.47-7.54 5.25 20.06-5.93 1.89-2.96-9.7c-1.08 2.69-1.62 4.98-1.62 7.27 0 9.28 7.54 16.83 18.05 16.83 9.28 0 16.83-7.54 16.83-16.83 0-6.59-3.9-12.39-9.42-15.08v-7.26c9.42 3.1 16.15 11.98 16.29 22.48a23.51 23.51 0 0 1-23.57 23.57m-3.63-17.38v-60.86h7v60.86zm16.3-35.01-5.25-20.06 5.93-1.89 2.96 9.7c1.08-2.69 1.62-4.98 1.62-7.27 0-9.28-7.54-16.83-18.05-16.83-9.28 0-16.83 7.54-16.83 16.83 0 6.59 3.9 12.39 9.42 15.08v7.26c-9.42-3.1-16.15-11.98-16.29-22.48a23.51 23.51 0 0 1 23.57-23.57c14.27 0 24.78 10.5 24.78 23.57 0 3.5-.27 5.79-1.62 8.75l7.67-2.56 2.56 5.93z",
          fill: "#095eb5",
        },
      },
      {
        balise: "path",
        data: { fill: "#fff", d: "M181.02 159.12h7v60.86h-7z" },
      },
      {
        balise: "path",
        data: {
          d: "M207.55 174.06c1.35-2.96 1.62-5.25 1.62-8.75 0-13.06-10.5-23.57-24.78-23.57a23.51 23.51 0 0 0-23.57 23.57c.14 10.5 6.87 19.39 16.29 22.48v-7.26c-5.52-2.69-9.42-8.49-9.42-15.08 0-9.29 7.54-16.83 16.83-16.83 10.5 0 18.05 7.54 18.05 16.83 0 2.29-.54 4.58-1.62 7.27l-2.96-9.7-5.93 1.89 5.25 20.06 20.47-7.54-2.56-5.93z",
          fill: "#fff",
        },
      },
      {
        balise: "path",
        data: {
          d: "M191.93 191.31v7.26c5.52 2.69 9.42 8.49 9.42 15.08 0 9.29-7.54 16.83-16.83 16.83-10.5 0-18.05-7.54-18.05-16.83 0-2.29.54-4.58 1.62-7.27l2.96 9.7 5.93-1.89-5.25-20.06-20.47 7.54 2.56 5.93 7.67-2.56c-1.35 2.96-1.62 5.25-1.62 8.75 0 13.06 10.5 23.57 24.78 23.57a23.51 23.51 0 0 0 23.57-23.57c-.14-10.5-6.87-19.39-16.29-22.48",
          fill: "#fff",
        },
      },
      {
        balise: "path",
        data: {
          d: "M283.89 263.04c-3.82 16.63-18.93 29.51-36.04 30.54-13.32.8-24.43-3.87-33.3-14q-6.42-7.335-8.4-16.92c-2.37-11.5.46-21.56 6.99-31.08l4.45-5.67 4.74-5.32 3.56-4.25 4.11-5.46 3.01-4.45 2.57-4.64 2.07-3.98q1.98-4.485 3.48-9.15l2.66-9.18.91-3.97a.232.232 0 0 1 .45 0l.68 2.84 1.45 5.4 2.5 7.8 1.27 3.04 1.8 4.15c.5 1.43 1.16 2.81 1.99 4.15l1.77 3.04 3.96 5.88 3 3.87 1.56 1.96c2.64 3.04 5.33 6.13 8.08 9.31 8.71 10.02 13.74 22.77 10.68 36.11h.02Z",
          fill: "#6f2adb",
        },
      },
      {
        balise: "path",
        data: {
          d: "m234.13 259.53.44 3.58-2.73.56-2.23-.53-3.3-5.47 1.08-10.17 3.86-5.15 5.3-.56 4.86-2.67 6.5 3.25-1.47 1.65 10.77 2.14 5.71 3.86s.53 5.6-1.28 7.56l2.17 12.76h-4.77l1-.88-4.48-9.72-12.57 1.76-4.38 8.84h-4.86l1.6-2.57 3.35-11.93-2.34-2.25-5.04 1-.56 4.65 1.72 1.67 1.64-1.37Z",
          fill: "#fff",
        },
      },
      {
        balise: "path",
        data: {
          fill: "#fff",
          d: "M242.36 270.33h5.12l-1.61-8.53-2.11.59-1.64 3.51 1.01 3.97z",
        },
      },
      {
        balise: "path",
        data: {
          fill: "#fff",
          d: "m251.85 270.33 1.03-1.52v-6.82l1.58-1.02 2.74 4.68-.5 4.68z",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    sdAPW: [
      {
        balise: "path",
        data: {
          d: "M117.2 193.43v-8.48c.26-.23.2-.55.22-.83.06-2 .38-3.97.72-5.95 1.06-6.22 2.87-12.22 5.63-17.89 3.88-7.97 9.08-15 15.72-20.92 6.47-5.75 13.75-10.16 21.92-13.09 6.95-2.49 14.1-3.91 21.49-4.03 6.62-.1 13.12.66 19.51 2.56 4.19 1.24 8.24 2.7 12.15 4.66 4.55 2.29 8.79 5.05 12.68 8.29 9.89 8.22 16.85 18.46 20.78 30.74 1.24 3.88 2.26 7.81 2.79 11.86.19 1.46.17 2.95.58 4.38v9.38c-.23.14-.2.38-.22.6-.65 8.64-3.07 16.81-6.93 24.53-6.34 12.64-15.81 22.31-28.29 29.02-7.15 3.84-14.76 6.22-22.79 7.33-1.6.22-3.22.4-4.83.59h-8.5c-.12-.18-.31-.19-.49-.2-2.05-.03-4.06-.35-6.07-.69-6.43-1.08-12.6-3-18.44-5.88-8.63-4.27-16.09-10.03-22.2-17.5-8.11-9.88-13.09-21.1-14.8-33.75l-.63-4.72Zm51.47 26.3H149.8c-1.07 0-1.29.31-.7 1.12 1.67 2.26 3.71 3.96 6.61 4.5 1.16.22 2.28.12 3.41.12 7.45 0 14.91.01 22.36 0 3.97 0 7.9-.4 11.66-1.72 13.48-4.71 21.67-14.03 24.25-28.09.85-4.64.32-9.36.44-14.03.02-.67-.34-.83-.9-.83-1.34 0-2.68.01-4.02 0-.65 0-.9.24-.92.93-.06 3.26.01 6.52-.14 9.79a33 33 0 0 1-1.08 7.11c-3.05 11.28-14.23 20.26-25.88 20.94-5.77.33-11.55.03-16.23.16Zm33.11-61.1h16.88c.35 0 .81.17.99-.27.15-.35-.16-.63-.35-.89-2.1-2.87-4.83-4.56-8.48-4.56h-24.26c-5.34 0-10.5.91-15.32 3.26-10.74 5.23-17.54 13.59-19.95 25.35-1.04 5.04-.4 10.16-.56 15.25-.02.6.31.78.83.78 1.38 0 2.76-.01 4.14 0 .81 0 .85-.49.85-1.11-.01-2.94.01-5.88-.01-8.82-.01-1.67.1-3.31.43-4.96 1.33-6.77 4.58-12.4 9.82-16.89 5.72-4.9 12.45-7.06 19.9-7.14 5.03-.06 10.07 0 15.1 0Zm2.6 13.81h17.78c1.22 0 1.38-.18 1.22-1.35-.14-1.06-.33-2.13-.38-3.19-.03-.97-.41-1.26-1.37-1.25-11.7.03-23.4-.04-35.1.05-7.66.06-14 2.97-18.47 9.36-2.56 3.67-4.04 7.73-3.93 12.28.04 1.9.01 3.79.01 5.69 0 2.45 1.22 3.62 3.67 3.52 1.54-.06 2.14-.67 2.15-2.23.01-2.45-.01-4.91.02-7.36.06-4.44 1.92-8.09 5.07-11.11 3.31-3.19 7.41-4.38 11.9-4.4 5.81-.02 11.63 0 17.44 0Zm-38.81 39.26h16.21c3.85 0 7.52-.76 10.93-2.63 5.95-3.28 9.78-8.16 11.27-14.82.74-3.27.4-6.59.44-9.9.05-3.97-.04-4.02-4.07-3.52-1.2.15-1.72.69-1.73 1.95-.02 2.2.03 4.39-.02 6.59-.03 1.29-.08 2.59-.36 3.84-1.66 7.43-8.13 12.65-15.76 12.71-7.6.05-15.21.01-22.81.01-4.43 0-8.87.04-13.3-.03-1.1-.01-1.34.37-1.19 1.33.17 1.1.33 2.21.39 3.32.05.92.44 1.17 1.33 1.16 6.22-.03 12.45-.02 18.67-.01",
          fill: "#63ddbf",
        },
      },
      {
        balise: "path",
        data: {
          d: "M168.67 219.73c4.68-.13 10.46.17 16.23-.16 11.65-.68 22.83-9.66 25.88-20.94.63-2.31.97-4.68 1.08-7.11.15-3.26.08-6.52.14-9.79.01-.68.26-.94.92-.93 1.34.01 2.68 0 4.02 0 .56 0 .92.15.9.83-.13 4.68.41 9.4-.44 14.03-2.59 14.06-10.77 23.38-24.25 28.09-3.77 1.31-7.7 1.71-11.66 1.72-7.45.01-14.91 0-22.36 0-1.14 0-2.25.1-3.41-.12-2.9-.54-4.95-2.24-6.61-4.5-.59-.81-.37-1.12.7-1.12h18.87Z",
          fill: "#2a3230",
        },
      },
      {
        balise: "path",
        data: {
          d: "M201.78 158.63c-5.03 0-10.07-.04-15.1 0-7.45.08-14.18 2.24-19.9 7.14-5.24 4.49-8.49 10.12-9.82 16.89-.33 1.65-.44 3.29-.43 4.96.03 2.94 0 5.88.01 8.82 0 .62-.03 1.12-.85 1.11-1.38-.01-2.76 0-4.14 0-.52 0-.85-.17-.83-.78.16-5.08-.47-10.2.56-15.25 2.41-11.76 9.21-20.12 19.95-25.35 4.83-2.35 9.98-3.26 15.32-3.26h24.26c3.65 0 6.38 1.69 8.48 4.56.19.26.5.53.35.89-.19.44-.65.27-.99.27h-16.88Z",
          fill: "#2a3230",
        },
      },
      {
        balise: "path",
        data: {
          d: "M204.38 172.44c-5.81 0-11.63-.02-17.44 0-4.49.02-8.59 1.22-11.9 4.4-3.15 3.03-5.01 6.68-5.07 11.11-.03 2.45 0 4.91-.02 7.36 0 1.56-.61 2.16-2.15 2.23-2.45.1-3.67-1.07-3.67-3.52 0-1.9.03-3.79-.01-5.69-.11-4.55 1.36-8.61 3.93-12.28 4.47-6.4 10.82-9.31 18.47-9.36 11.7-.09 23.4-.02 35.1-.05.95 0 1.33.29 1.37 1.25.04 1.06.24 2.13.38 3.19.15 1.17 0 1.35-1.22 1.35h-17.78Z",
          fill: "#2a3230",
        },
      },
      {
        balise: "path",
        data: {
          d: "M165.57 211.7c-6.22 0-12.45-.01-18.67.02-.89 0-1.29-.24-1.33-1.16-.06-1.11-.22-2.22-.39-3.32-.15-.97.09-1.35 1.19-1.33 4.43.06 8.87.03 13.3.03 7.6 0 15.21.03 22.81-.01 7.64-.05 14.11-5.27 15.76-12.71.28-1.24.33-2.56.36-3.84.06-2.2 0-4.39.02-6.59.01-1.26.53-1.81 1.73-1.95 4.03-.49 4.12-.45 4.07 3.52-.04 3.3.29 6.63-.44 9.9-1.49 6.65-5.32 11.54-11.27 14.82-3.4 1.88-7.09 2.62-10.93 2.63-5.4.01-10.81 0-16.21 0Z",
          fill: "#2a3230",
        },
      },
      {
        balise: "path",
        data: {
          d: "M283.71 264.64c-3.86 16.78-19.1 29.79-36.37 30.82-13.45.81-24.65-3.9-33.61-14.13-4.32-4.93-7.15-10.63-8.47-17.08-2.39-11.61.47-21.76 7.05-31.37l4.49-5.72 4.79-5.37 3.59-4.29 4.15-5.51 3.04-4.49 2.59-4.68 2.09-4.02c1.33-3.01 2.51-6.09 3.52-9.23l2.69-9.27.92-4.01c.03-.13.15-.2.28-.17.08.02.15.08.17.17l.69 2.86 1.46 5.45 2.52 7.87 1.28 3.06 1.81 4.19a21 21 0 0 0 2.01 4.19l1.79 3.07 3.99 5.93 3.03 3.91 1.57 1.98 8.16 9.39c8.79 10.11 13.87 22.99 10.78 36.44h.02Z",
          fill: "#6f2adb",
        },
      },
      {
        balise: "path",
        data: {
          d: "m233.49 261.1.44 3.61-2.75.56-2.25-.53-3.33-5.52 1.09-10.26 3.9-5.2 5.35-.56 4.9-2.7 6.56 3.28-1.48 1.67 10.87 2.16 5.77 3.9s.53 5.65-1.29 7.63l2.19 12.88h-4.81l1.01-.89-4.52-9.82-12.69 1.78-4.42 8.93h-4.9l1.61-2.6 3.38-12.05-2.36-2.27-5.08 1.01-.56 4.7 1.74 1.69 1.66-1.38Z",
          fill: "#fff",
        },
      },
      {
        balise: "path",
        data: {
          fill: "#fff",
          d: "M241.79 272h5.17l-1.62-8.61-2.13.6-1.66 3.54 1.02 4.01z",
        },
      },
      {
        balise: "path",
        data: {
          fill: "#fff",
          d: "m251.37 272 1.04-1.54v-6.88l1.59-1.03 2.77 4.72-.5 4.73z",
        },
      },
      {
        balise: "path",
        data: {
          d: "m282.55,264.53c-3.95,17.19-19.56,30.51-37.24,31.56-13.77.83-25.25-4-34.42-14.47-4.42-5.05-7.32-10.88-8.68-17.5-2.45-11.89.47-22.28,7.22-32.13l4.6-5.86,4.9-5.5,3.68-4.39,4.25-5.64,3.11-4.59,2.66-4.8,2.15-4.12c1.37-3.09,2.57-6.24,3.6-9.45l2.75-9.49.94-4.1c.03-.13.16-.2.28-.18.08.02.15.09.17.17l.71,2.93,1.49,5.58,2.58,8.06,1.31,3.14,1.86,4.29c.51,1.48,1.19,2.91,2.06,4.29l1.83,3.14,4.09,6.08,3.1,4,1.61,2.03c2.72,3.13,5.51,6.34,8.35,9.62,9,10.36,14.2,23.54,11.04,37.32h0Z",
          fill: "#6f2adb",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m231.12,260.9l.45,3.7-2.81.57-2.31-.55-3.42-5.65,1.12-10.51,3.99-5.33,5.48-.57,5.02-2.76,6.72,3.36-1.51,1.71,11.14,2.21,5.9,3.99s.55,5.78-1.33,7.81l2.24,13.19h-4.93l1.03-.91-4.63-10.05-13,1.82-4.53,9.14h-5.02l1.65-2.66,3.47-12.33-2.42-2.33-5.21,1.03-.57,4.81,1.78,1.73,1.7-1.41h0,0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "239.63 272.07 244.92 272.07 243.26 263.25 241.08 263.86 239.37 267.49 240.42 271.6 239.63 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "249.43 272.07 250.5 270.5 250.5 263.45 252.13 262.39 254.97 267.23 254.45 272.07 249.43 272.07",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
    ],
    cvgCVX: [
      {
        balise: "rect",
        data: {
          x: "208.1",
          y: "176.36",
          width: "5.94",
          height: "8.99",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "190.17",
          y: "158.43",
          width: "5.64",
          height: "9.01",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "178.48 167.42 178.48 167.44 177.8 167.44 177.8 176.44 172.24 176.44 172.24 167.42 178.48 167.42",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "163.25",
          y: "203.28",
          width: "5.54",
          height: "26.91",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "169.55 176.36 169.55 176.44 168.79 176.44 168.79 203.28 163.25 203.28 163.25 176.36 169.55 176.36",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "217.02",
          y: "185.45",
          width: "5.92",
          height: "8.88",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "217.02",
          y: "212.2",
          width: "5.92",
          height: "8.99",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "208.1",
          y: "221.21",
          width: "5.8",
          height: "8.96",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "190.17",
          y: "239.2",
          width: "5.64",
          height: "8.92",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "172.24",
          y: "230.19",
          width: "5.56",
          height: "8.93",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M222.94,185.45h-8.9v-9.09h-18.01v9.09h-8.99v35.76h8.85v8.96h18.01v-8.98h9.04v-9.01h17.88v18.01h-8.99v9.01h-18.01v8.98h-18.01v-8.98h-18.01v-9.01h-9.01v-53.75h9.01v-9h18.01v-9.01h18.01v9.01h18.01v8.84h8.99c-.02.21.04,17.97-.02,18.17h-17.86v-9Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M290.03,203.31c0,48.6-39.39,87.99-87.99,87.99v-10.56c58.17,1.47,97.14-66.26,67.24-115.89l.35-.2,8.78-5.07h0c7.64,13.31,11.64,28.39,11.62,43.73Z",
          fill: "#ff0",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M202.03,280.74v10.56c-66.1,1.65-110.37-75.34-76.37-131.73l8.78,5.08.37.21h0c-30.17,49.76,9.29,117.23,67.23,115.89Z",
          fill: "red",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M269.62,164.64l-.35.2h0c-27.84-51.49-106.62-51.22-134.46,0l-.37-.2-8.78-5.07c29.49-57.88,123.25-57.87,152.74,0l-8.78,5.07Z",
          fill: "blue",
          "stroke-width": "0",
        },
      },
    ],
    cvxCRV: [
      {
        balise: "path",
        data: {
          d: "m210.23,177.53c1.53.11,3.19,1.57,4.57.89,1.1,1.28,3.11,1.4,4.66,2.24-11.6,4.29-24.1,5.51-36.34,6.38-1.75-2.28-.75-7-2.17-9.73.77,9.23,2.43,20.48-6.52,26.24-1.08-2.1-.61-7.83-4.2-3.48-2.39,1.5-3.3-12.67-11.04-10.63,3.4,4.3-12.36-.78-13.14,2.38-2.87,3.5-8.98-1.18-9.71-4.61-.52,1.39-1.04,2.75-1.55,4.12-.09,0-.18,0-.27,0-1.06-5.88-1.83-11.81-3.52-17.75-.5,2.1-.97,4.06-1.49,6.22-1.28-4.28-2.28-8.39-2.76-12.76-2.6,10.39,2.26,20.35,4.64,30.26t0,.01c.02-.12.03-.25.05-.37.03.01.05.02.07.03-.84,8.84,8.63,7.7,14.66,6.74,7.05-.92,14.52-1.62,21.66-2.85,4.45.03,2.79,10.04,4.51,13.03,1.99,5.27,8.96-.99,10.49-3.84,1.2-.85,3.87-.15,3.96-2.13.09.61.39.88,1.11.66,8-1.9,16.03-3.62,24.08-5.28,3.16-1.43,7.94-.17,10.2-3.2,21.08-7.84,35.7-8.44,21.39-34.64-.22,1.02.66,1.79.67,2.78-2.07-1.27-1.23,2.77-1.79,3.94-3.2-2.56-2.96,3.29-5.75,2.92-.5-.1-1.96-1.17-1.81-.01-1.89.93-3.78,3.74-6.14,2.87,1.81-1.2,3.52-2.34,5.24-3.48-.01-.05-.03-.11-.04-.16-4.5,1.08-2.76.14-1.11-2.56-.44.27-.86.51-1.31.78.14-1.23.27-2.37.4-3.56-.83.21-.9,1.14-1.59,1.43-.81-1.08-1.06-2.47-1.92-3.72-.58.62-.61,2.66-1.75,2.31-2.62-2.85-5.76-5-9.03-7.01-.85.69-.08,3.8-1.84,3.33-5.91-2.28-14.36-7.34-20.01-6.69,1.13,8.83-3.25,1.9-15.27,3.3-6.89,1.33.67,10.14.35,14.5,5.59-3.04,13.54-1.48,19.84-.82m-58.19,27.58c.2-.06.1.31.04.41-.14-.14-.14-.37-.04-.41Zm90.31-31.44s0,0,0,.01c0,0,0,0,.01,0h0Z",
          fill: "#fbf100",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m210.23,177.53c1.53.11,3.19,1.57,4.57.89,1.1,1.28,3.11,1.4,4.66,2.24-2.11.78-4.25,1.46-6.41,2.05-5.54-1.9-12.26-1.29-21.16-.81-3.41.18-7.25-.43-10,.18-.13-1.27-.44-3.76-.94-4.78.03-.29.04-.61,0-.94,5.58-3,13.5-1.44,19.77-.78",
          fill: "#b1ff46",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m244.27,168.22c-2.07-1.27-1.23,2.77-1.79,3.94-3.2-2.56-2.97,3.29-5.75,2.92-.5-.1-1.96-1.17-1.81-.01-1.89.93-3.78,3.74-6.14,2.87,1.81-1.2,3.52-2.34,5.24-3.48-.01-.05-.03-.11-.04-.16-4.49,1.08-2.73.09-1.1-2.57.05-.01.09-.02.09-.08-.44.36-.93.55-1.4.87.14-1.23.27-2.37.4-3.56-.83.21-.9,1.14-1.59,1.43-.81-1.08-1.06-2.47-1.92-3.72-.58.62-.61,2.66-1.75,2.31-2.62-2.85-5.76-5-9.03-7.01-.82.69-.1,3.8-1.84,3.33-5.91-2.28-14.36-7.34-20.02-6.69,1.17,8.83-3.35,1.89-15.26,3.3-6.29,1.08-.52,8.76.14,12.93.88,9.74,3.39,22.41-6.25,28.71-1.08-2.1-.61-7.83-4.2-3.48-2.39,1.5-3.3-12.67-11.04-10.63,3.4,4.3-12.36-.78-13.14,2.38-2.87,3.5-8.98-1.18-9.71-4.61-.52,1.39-1.04,2.75-1.55,4.12-.09,0-.18,0-.27,0-1.06-5.88-1.83-11.81-3.52-17.75-.5,2.1-.97,4.06-1.49,6.22-4.73-11.69-1.48-24.52,4.69-35.23-1.66,9.17,2.74,17.99,3.6,27.05,1.09-1.29,2.08-2.45,3.07-3.61.03,2.75.56,5.35.5,8.02,1.04-1.18,3.2-1.31,2.98-3.52.73,1.75-1.43,6.36,1.94,4.04.49-.24,1.4-.34,1.31-1.06,0,0,0,.01,0,.02.05.22.36.4.4.6-.66.78-.16,1.67-.29,2.49-.15.88,1.09.33,1.59.38,2.56-.11,5.29.26,7.5,1.63,1.19.7,2.3,2.18,3.67,2.05,0,0,0,0,0,0,.15-.05.28-.2.35-.34.3-.62.34-1.48.82-1.96,1.17,1.02,2.28,2,3.39,2.98.42-.88.89-1.89,1.43-3.02.15.12.26.26.39.42,0,0,0,0,0,0,4.34,9.35,5.05-3.86,6.63-7.38,1.12,1.7,1.81,3.55,3.03,5.11.44-8.83-.55-17.75-3.34-26.07-.17-1.42.51-2.42,1.65-3.09,1.44-1.93-1.75-4.44-.49-6.35,1.64-.66,8.71,1.62,8.52.28.27-.91-1.32-4.72.31-3.93,3.97.49,8.22,3.22,12.41,3.86.8.11,1.85.07,1.77-.91.13-4.22,6.6,2.56,9.04,1.42.42-1.48,1.34-2.64,2.33-3.76,13.25,5.39,26.33,13.5,34.77,25.36-.12.12-.09.18.08.18-.22,1.02.66,1.79.67,2.78Z",
          fill: "#ff8200",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m208.74,139.91c-.99,1.12-1.92,2.28-2.34,3.76-2.03,1.26-9.02-5.63-9.04-1.42.34,3.31-11.54-3.09-14.17-2.95-.66-.17-.91-.25-.71.63,1.9,6.85-2.62,2.16-8.12,3.03-1.38,1.34,2.33,5.27.17,6.6-1.06.53-1.42,1.65-1.33,2.83,2.8,8.32,3.79,17.24,3.34,26.08-1.23-1.57-1.92-3.42-3.04-5.11-1.14,3.62-1.53,7.4-3.51,10.75-1.17.97-2.34-2.85-3.51-3.79-.54,1.13-1.02,2.14-1.43,3.01-1.1-.97-2.22-1.95-3.39-2.98-.38.39-.48.98-.67,1.53-.59,2.67-4.1-2.06-5.94-2.07-1.78-1.33-7.65-.24-7.34-1.22.13-.82-.37-1.7.29-2.48.05-.06-.45-.5-.4-.66.11.73-.71.82-1.31,1.09-3.38,2.32-1.22-2.29-1.94-4.04.21,2.21-1.95,2.34-2.98,3.52.05-2.67-.48-5.27-.51-8.02-.99,1.16-1.98,2.32-3.07,3.6-.84-11.1-8.88-23.98.73-33.07,17.23-22.48,49.29-7.39,70.2,1.38Z",
          fill: "#d50201",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m131.41,197.29c.52,9.34,8,6.97,14.78,6.41,5.06-.64,10.58-1.3,15.82-1.93,2.34.12,5.83-1.83,7.66-.38,2.37,3.26.84,16.14,5.67,14.37,3.09-.57,5.37-2.29,6.91-4.99.76-1.95,4.58-.56,4.57-2.88.11.78.44.84,1.11.68,8-1.91,16.03-3.62,24.08-5.28,2.63-1.15,9.18-.72,10.2-3.2,8.4-4.47,24.21-4.68,27.16-15.88.21,6.31-.86,12.82-3.79,18.33-3.27.96-4,4.62-7.43,5.2-15.43,5.53-31.45,9.13-47.14,13.71,1.87-3.1-6.85,1.94-8.22,1.73-1.17.13-1.02,1.86-2.12,2.32-2.24,1.65-.44,5.85-3.08,6.93-3.27.73-7.4-1.29-6.35-5.12,3.35-16.75-.13-11.16-12.67-7.95-1.98.87-.92-3.08-2.72-2.65-4.94,1.54-9.92,3.04-14.56,5.36-.6.31-.85.09-.98-.49-.54-.89-.17-3.52-1.42-3.34-7.9,4.86-5.94-4.44-8.87-9.06-3.28-10.92-4.59-22.91-4.17-34.47.92,7.67,3.72,15.29,5.58,22.6Z",
          fill: "#b1ff46",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m245.57,202.53c-10.56,15.26-45.78,14.08-62.98,23.28-.85,2.53-1.72,4.85-2.64,6.97-5.14,1.36-5.63,5.94-7.7,6.15-1.17.06-1.75-.72-3.75-2.61-5.75-5.46-4.49-10.18-5.79-10.12-3.43.18-7.37,9.07-10.46,9.1-4.92-1.06-6.87-6.38-14.33-2.61-3.67-6.86-6.48-15.04-7.93-23.52,2.79,4.6,1.15,13.85,9.17,9.08,1.28.44.22,4.5,2.1,3.8,4.64-2.32,9.62-3.81,14.56-5.35,1.81-.43.74,3.52,2.73,2.65,2.3-.59,4.29-1.25,6-1.85,17.94-8.09-2.51,16.98,13.02,14.93,2.71-1.23.83-5.35,3.08-6.93,1.11-.46.95-2.19,2.12-2.32,1.21.36,9.68-4.84,8.23-1.73,15.68-4.59,31.7-8.19,47.13-13.71,3.43-.58,4.17-4.24,7.44-5.2Z",
          fill: "#00d8ff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m179.96,232.78c-12.57,29.26-31.09,20.41-42.03-.1,7.47-3.76,9.38,1.54,14.33,2.61,3.09-.03,7.03-8.92,10.46-9.1,1.3-.06.03,4.66,5.79,10.12,2,1.89,2.58,2.67,3.75,2.61,2.07-.2,2.57-4.8,7.7-6.15Z",
          fill: "#004cff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "m213.06,182.71c-1.01.28-2.02.54-3.03.77-8.79,2.09-17.93,2.92-26.9,3.56-1.06-1.35-.99-2.37-1.19-4.6-.01-.12-.02-.24-.03-.36,2.75-.61,7.38-.6,10.79-.78,8.9-.48,14.82-.5,20.36,1.41Z",
          fill: "#00d8ff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M240.09,198.14c-23.96,0-43.39,19.43-43.39,43.39s19.43,43.39,43.39,43.39,43.39-19.42,43.39-43.39-19.43-43.39-43.39-43.39ZM264.6,235.84v.1h-11.3v-.08h-3.74v-5.62h-1.88v-.06h-3.76v-5.67h-7.63v5.74h-5.68v22.6h5.59v5.66h7.72v-5.66h3.66s1.97-.01,1.97-.01v-5.68h3.74s11.3-.01,11.3-.01v11.38h-5.68v5.69h-11.38v5.67h-11.38v-.04h-3.57v-5.64h-7.81v-.05h-3.52v-5.64h-5.67v-34.02h3.98v.05h1.69v-5.71h3.95s7.38.01,7.38.01v-5.69h14.95v5.69h11.38v5.59h5.68v11.38Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "224.51",
          width: "3.76",
          height: "5.67",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "213.18",
          width: "3.57",
          height: "5.69",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "225.21 218.85 225.21 218.86 224.77 218.86 224.77 224.56 221.26 224.56 221.26 218.85 225.21 218.85",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "215.58",
          y: "241.51",
          width: "3.5",
          height: "17.01",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "219.56 224.51 219.56 224.56 219.09 224.56 219.09 241.51 215.58 241.51 215.58 224.51 219.56 224.51",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "230.25",
          width: "3.74",
          height: "5.62",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "247.15",
          width: "3.74",
          height: "5.68",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "252.85",
          width: "3.66",
          height: "5.66",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "264.22",
          width: "3.57",
          height: "5.64",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "221.26",
          y: "258.52",
          width: "3.52",
          height: "5.64",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
    ],
    cvxFXN: [
      {
        balise: "path",
        data: {
          d: "M185.82,126.32h-5.52c-29.82,1.98-52.45,24.54-54.53,54.36v5.75c2.08,29.89,24.64,52.65,54.59,54.53h5.4c29.94-1.99,52.75-24.61,54.64-54.59v-5.4c-2.04-29.94-24.57-52.78-54.59-54.64h0ZM136.24,183.41c-2.51-20.42,11.43-39.97,30.34-47.05,4.15-1.56,8.27-2.41,12.38-2.58,17.74-.7,33.49,5.83,43.9,20.22.08.13.12.28.08.42-.02.03-.02.07-.03.1v.02s-.03.07-.07.1c-.02.03-.05.05-.07.07l-.02.02c-.07.05-.13.07-.22.08-.03,0-.05.02-.08.02s-.08,0-.13-.02c-19.01-4.57-35.27,4.47-42.91,22.16-.23.53-.8.81-1.71.81-3.67.02-7.36,0-11.03-.02h-.42l-6.61.02c-.65,0-.96.33-.96.96v9.84c0,.52.42.91.93.91l13.46.02c.5,0,.75.25.8.73.03.37-.1.78-.4,1.28-4.57,7.81-12.86,11.73-21.67,10.27-9.05-1.5-14.45-9.52-15.55-18.38h0ZM192.53,233.12c-5.93,1.08-12.38.75-18.34-.28-12.1-2.09-22.4-8.26-29.94-18.01-.02-.02-.2-.22-.58-.6-.23-.23-.33-.5-.33-.76,0-.03,0-.07.02-.1,0-.02.02-.03.02-.07,0-.02.02-.03.02-.05v-.02s.02-.03.03-.05c0-.02.02-.03.03-.03.02-.02.03-.03.05-.07.01-.01.02-.02.03-.02.02-.02.03-.03.05-.03.02-.02.03-.03.07-.03.02-.02.05-.03.07-.03s.03-.02.05-.02.03-.02.07-.02.07-.02.1-.02.08,0,.12.02c12.61,2.77,23.63.08,33.06-8.04,4.02-3.94,7.14-8.49,9.37-13.66.53-1.25,1.06-1.56,2.38-1.58,5.93-.05,11.91-.1,17.94-.17.43,0,.8-.37.78-.8l-.07-10.12c0-.43-.35-.78-.78-.78l-13.77.03s-.08,0-.13-.02h-.02s-.02,0-.03-.02c-.02,0-.05-.02-.07-.02-.02-.02-.05-.02-.07-.03-.02,0-.03-.02-.05-.02s-.02-.02-.02-.02c-.02-.02-.05-.03-.07-.05-.02-.02-.03-.03-.05-.05-.02-.02-.03-.03-.05-.07l-.03-.03s-.02-.02-.02-.03c0-.02-.02-.02-.02-.03h0v-.02s-.02-.02-.02-.03c-.02-.02-.02-.03-.02-.07,0-.02-.02-.03-.02-.03,0-.02-.02-.03-.02-.05,0-.03-.02-.07-.02-.1,0-.08.02-.17.05-.25.43-1.13,1.05-2.23,1.86-3.27,4.6-6.06,10.75-8.87,18.41-8.39,9.54.58,15.52,8.02,17.15,17.03,4.22,23.48-14.4,46.5-37.2,50.86h0Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M222.95,154.44s-.02.07-.03.1v.02s-.03.07-.07.1c-.02.03-.05.05-.07.07l-.02.02c-.07.05-.13.07-.22.08-.03,0-.05.02-.08.02s-.08,0-.13-.02c-19.01-4.57-35.27,4.47-42.91,22.16-.23.53-.8.81-1.71.81-3.67.02-7.36,0-11.03-.02h-.42l-6.61.02c-.65,0-.96.33-.96.96v9.84c0,.52.42.91.93.91l13.46.02c.5,0,.75.25.8.73.03.37-.1.78-.4,1.28-4.57,7.81-12.86,11.73-21.67,10.27-9.05-1.51-14.47-9.52-15.55-18.39-2.53-20.42,11.41-39.97,30.32-47.05,4.15-1.56,8.27-2.41,12.39-2.58,17.74-.7,33.49,5.83,43.9,20.22.08.13.12.28.08.43h0Z",
          fill: "#1f6fb7",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M192.53,233.12c-5.93,1.08-12.38.75-18.34-.28-12.1-2.09-22.4-8.26-29.94-18.01-.02-.02-.2-.22-.58-.6-.23-.23-.33-.5-.33-.76,0-.03,0-.07.02-.1,0-.02.02-.03.02-.07,0-.02.02-.03.02-.05v-.02s.02-.03.03-.05c0-.02.02-.03.03-.03.02-.02.03-.03.05-.07.01-.01.02-.02.03-.02.02-.02.03-.03.05-.03.02-.02.03-.03.07-.03.02-.02.05-.03.07-.03s.03-.02.05-.02.03-.02.07-.02.07-.02.1-.02.08,0,.12.02c12.61,2.77,23.63.08,33.06-8.04,4.02-3.94,7.14-8.49,9.37-13.66.53-1.25,1.06-1.56,2.38-1.58,5.93-.05,11.91-.1,17.94-.17.43,0,.8-.37.78-.8l-.07-10.12c0-.43-.35-.78-.78-.78l-13.77.03s-.08,0-.13-.02h-.02s-.02,0-.03-.02c-.02,0-.05-.02-.07-.02-.02-.02-.05-.02-.07-.03-.02,0-.03-.02-.05-.02s-.02-.02-.02-.02c-.02-.02-.05-.03-.07-.05-.02-.02-.03-.03-.05-.05-.02-.02-.03-.03-.05-.07l-.03-.03s-.02-.02-.02-.03c0-.02-.02-.02-.02-.03h0v-.02s-.02-.02-.02-.03c-.02-.02-.02-.03-.02-.07,0-.02-.02-.03-.02-.03,0-.02-.02-.03-.02-.05,0-.03-.02-.07-.02-.1,0-.08.02-.17.05-.25.43-1.13,1.05-2.23,1.86-3.27,4.6-6.06,10.75-8.87,18.41-8.39,9.54.58,15.52,8.02,17.15,17.03,4.22,23.48-14.4,46.5-37.2,50.86h0Z",
          fill: "#ec3f36",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M240.09,198.14c-23.96,0-43.39,19.43-43.39,43.39s19.43,43.39,43.39,43.39,43.39-19.42,43.39-43.39-19.43-43.39-43.39-43.39ZM264.6,235.84v.1h-11.3v-.08h-3.74v-5.62h-1.88v-.06h-3.76v-5.67h-7.63v5.74h-5.68v22.6h5.59v5.66h7.72v-5.66h3.66s1.97-.01,1.97-.01v-5.68h3.74s11.3-.01,11.3-.01v11.38h-5.68v5.69h-11.38v5.67h-11.38v-.04h-3.57v-5.64h-7.81v-.05h-3.52v-5.64h-5.67v-34.02h3.98v.05h1.69v-5.71h3.95s7.38.01,7.38.01v-5.69h14.95v5.69h11.38v5.59h5.68v11.38Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "224.51",
          width: "3.76",
          height: "5.67",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "213.18",
          width: "3.57",
          height: "5.69",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "225.21 218.85 225.21 218.86 224.77 218.86 224.77 224.56 221.26 224.56 221.26 218.85 225.21 218.85",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "215.58",
          y: "241.51",
          width: "3.5",
          height: "17.01",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "219.56 224.51 219.56 224.56 219.09 224.56 219.09 241.51 215.58 241.51 215.58 224.51 219.56 224.51",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "230.25",
          width: "3.74",
          height: "5.62",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "247.15",
          width: "3.74",
          height: "5.68",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "252.85",
          width: "3.66",
          height: "5.66",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "264.22",
          width: "3.57",
          height: "5.64",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "221.26",
          y: "258.52",
          width: "3.52",
          height: "5.64",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
    ],
    cvxFXS: [
      {
        balise: "path",
        data: {
          d: "M202.86,220.51c6.31-10.73,5.21-27.07-3.35-35.45-4.77-9.61-42.16-13.49-49.14-20.91-7.22-11.14,9.61-15.85,18.6-14.41,9.14.68,13.45,5.86,14.95,14.16.76.08,15.85-.55,20.17-.76-.18-4.42-1.22-8.78-2.93-12.86,4.25-4.26,12.8-12.82,17.05-17.07-3.42-3.42-10.29-10.3-13.71-13.71-4.3,4.3-12.96,12.96-17.26,17.26-11.5-5.06-30.97-5.19-42.11.05-4.33-4.32-13.06-13.01-17.39-17.32l-6.86,6.87-6.84,6.86c4.32,4.32,13.01,13.01,17.34,17.32-5.23,12.77-.14,27.35,12.53,33.98,5.11,3.72,34.8,10.31,36.09,11.67,10.19,4.04,7.69,16.36-.82,20.53-12.56,5.95-31.2,1.58-33.48-14.97-.19-.87-.34-1.61-.36-1.65-.02-.04-19.42,1.82-19.51,1.93.26,5.65,2.56,12.24,5.03,17.04-4.2,4.18-12.63,12.62-16.82,16.82l13.71,13.71c4.32-4.32,13.02-13.02,17.34-17.34,10.96,5.05,29.4,5.68,42.85.75,4.13,4.13,12.45,12.45,16.58,16.58l13.71-13.71c-3.82-3.84-11.53-11.55-15.36-15.37Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M240.09,198.14c-23.96,0-43.39,19.43-43.39,43.39s19.43,43.39,43.39,43.39,43.39-19.42,43.39-43.39-19.43-43.39-43.39-43.39ZM264.6,235.84v.1h-11.3v-.08h-3.74v-5.62h-1.88v-.06h-3.76v-5.67h-7.63v5.74h-5.68v22.6h5.59v5.66h7.72v-5.66h3.66s1.97-.01,1.97-.01v-5.68h3.74s11.3-.01,11.3-.01v11.38h-5.68v5.69h-11.38v5.67h-11.38v-.04h-3.57v-5.64h-7.81v-.05h-3.52v-5.64h-5.67v-34.02h3.98v.05h1.69v-5.71h3.95s7.38.01,7.38.01v-5.69h14.95v5.69h11.38v5.59h5.68v11.38Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "224.51",
          width: "3.76",
          height: "5.67",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "213.18",
          width: "3.57",
          height: "5.69",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "225.21 218.85 225.21 218.86 224.77 218.86 224.77 224.56 221.26 224.56 221.26 218.85 225.21 218.85",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "215.58",
          y: "241.51",
          width: "3.5",
          height: "17.01",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "219.56 224.51 219.56 224.56 219.09 224.56 219.09 241.51 215.58 241.51 215.58 224.51 219.56 224.51",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "230.25",
          width: "3.74",
          height: "5.62",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "247.15",
          width: "3.74",
          height: "5.68",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "252.85",
          width: "3.66",
          height: "5.66",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "264.22",
          width: "3.57",
          height: "5.64",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "221.26",
          y: "258.52",
          width: "3.52",
          height: "5.64",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
    ],
    cvxPRISMA: [
      {
        balise: "path",
        data: {
          d: "M175.51,119.76c.26,0,.5.27.5.67v23.31l11-6.68h0s0,.01,0,.01l-10.04-16.95c-.06-.15-.16-.28-.28-.39-.43-.35-1.05-.3-1.42.1.08-.05.15-.07.23-.07Z",
          fill: "#fc306b",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M176.01,261.31v-19.2h-.02s0,1.33,0,1.33l-23.8-14.54,22.84,32.67c.03.06.07.12.12.17.41.47,1.13.52,1.6.11,0,0-.01,0-.02,0-.32.21-.72-.09-.72-.54Z",
          fill: "#4f28dd",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M131.3,197.65l.78.46,43.91,24.95v-26.7l-34.16-20.18-11.15,18.61c-.23.35-.35.76-.34,1.18v.18c.09.61.44,1.16.96,1.5Z",
          fill: "#0bb875",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M175.99,242.1v-19.03l-43.91-24.95-.78-.44c-.52-.35-.87-.9-.96-1.52.15.82.48,1.6.96,2.28l20.9,30.48,23.8,14.54v-1.35Z",
          fill: "#1a78d7",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M175.99,143.75h.01s-.02-23.32-.02-23.32c0-.39-.23-.65-.48-.67-.08,0-.15.02-.23.07-.01,0-.02,0-.04.01-.04.03-10.27,17.21-10.27,17.21l11.02,6.68v.02Z",
          fill: "#e91224",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "175.99 168.81 175.99 156.29 175.99 143.76 175.99 143.75 175.99 143.75 175.99 143.73 164.97 137.05 153.96 155.68 153.96 155.68 153.97 155.67 175.99 168.81",
          fill: "#f86e30",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M176.01,243.45v17.82c0,.51.39.8.72.59,0,0,.01,0,.02,0,0,0,0,0,0,0,.06-.05.11-.1.15-.17.03-.03.06-.07.07-.11l16.17-23.11c.08-1.98.3-3.92.63-5.83l-17.75,10.81Z",
          fill: "#827ff4",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M176.02,222.8l44.68-25.14c.52-.34.87-.9.96-1.51-.03.15-.07.31-.11.46.06-.15.1-.31.12-.48v-.18c.02-.42-.09-.84-.33-1.19l-11.17-18.58-34.15,20.19v26.43Z",
          fill: "#74ca38",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M220.7,197.66l-44.68,25.14h-.01v20.65l17.75-10.81c2.63-15.24,12.88-27.86,26.69-33.8l.25-.36c.39-.57.67-1.2.85-1.86.04-.15.08-.3.11-.46-.09.62-.44,1.17-.96,1.51Z",
          fill: "#53aef9",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "176.01 143.74 176.01 143.74 175.99 143.75 175.99 143.75 175.99 143.76 175.99 156.29 175.99 168.81 176 168.82 198.03 155.68 187.02 137.07 187.01 137.06 176.01 143.74",
          fill: "#f78f31",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "176 196.37 176 168.82 175.99 168.81 153.97 155.67 153.96 155.68 141.82 176.18 141.82 176.18 175.99 196.36 176 196.37",
          fill: "#feb92f",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "176 196.37 176 196.38 176.02 196.37 210.17 176.18 198.03 155.68 176 168.82 176 196.37",
          fill: "#ffc866",
          "stroke-width": "0",
        },
      },
      {
        balise: "path",
        data: {
          d: "M240.09,198.14c-23.96,0-43.39,19.43-43.39,43.39s19.43,43.39,43.39,43.39,43.39-19.42,43.39-43.39-19.43-43.39-43.39-43.39ZM264.6,235.84v.1h-11.3v-.08h-3.74v-5.62h-1.88v-.06h-3.76v-5.67h-7.63v5.74h-5.68v22.6h5.59v5.66h7.72v-5.66h3.66s1.97-.01,1.97-.01v-5.68h3.74s11.3-.01,11.3-.01v11.38h-5.68v5.69h-11.38v5.67h-11.38v-.04h-3.57v-5.64h-7.81v-.05h-3.52v-5.64h-5.67v-34.02h3.98v.05h1.69v-5.71h3.95s7.38.01,7.38.01v-5.69h14.95v5.69h11.38v5.59h5.68v11.38Z",
          fill: "#fff",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "224.51",
          width: "3.76",
          height: "5.67",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "213.18",
          width: "3.57",
          height: "5.69",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "225.21 218.85 225.21 218.86 224.77 218.86 224.77 224.56 221.26 224.56 221.26 218.85 225.21 218.85",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "215.58",
          y: "241.51",
          width: "3.5",
          height: "17.01",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
      {
        balise: "polygon",
        data: {
          points:
            "219.56 224.51 219.56 224.56 219.09 224.56 219.09 241.51 215.58 241.51 215.58 224.51 219.56 224.51",
          fill: "#60d8a4",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "230.25",
          width: "3.74",
          height: "5.62",
          fill: "#1682fe",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "249.56",
          y: "247.15",
          width: "3.74",
          height: "5.68",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "243.92",
          y: "252.85",
          width: "3.66",
          height: "5.66",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "232.59",
          y: "264.22",
          width: "3.57",
          height: "5.64",
          fill: "#ff5a5a",
          "stroke-width": "0",
        },
      },
      {
        balise: "rect",
        data: {
          x: "221.26",
          y: "258.52",
          width: "3.52",
          height: "5.64",
          fill: "#f4bb3b",
          "stroke-width": "0",
        },
      },
    ],
  },
  cCe =
    '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 1000"><path name="contour" fill="blue" d="M0 0h800v1000H0z"/><path stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M26 26h748v948H26z"/><path fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M41 41.3h718V959H41z"/><path fill="#fff" fill-rule="evenodd" d="M717.9 347v43.8L701.7 406H82.1v-59h635.8zm0 203.6v43.8l-16.2 15.2H82.1v-59h635.8zm0 105.5v43.8l-16.2 15.2H82.1v-59h635.8z"/><path fill="#00f" d="m711.1 846.6-27.2 47.5-6.8-11.9 13.6-23.7h-54.3l6.8-11.9h67.9z"/><path fill="#ff0" d="m717.9 858.5-34 59.4-27.1-47.5h13.6l13.5 23.7 27.2-47.5 6.8 11.9z"/><path fill="red" d="m656.8 870.4 27.1 47.5h-13.5l-34-59.4h54.3l-6.8 11.9h-27.1z"/><path fill="none" stroke="#fff" stroke-miterlimit="11.3" stroke-width="2" d="M601 82.4h117.4l-.5 219.6M199 917.9l-116.4.3V766"/><path fill="#fff" fill-rule="evenodd" d="M717.9 448.8v43.8l-16.2 15.2H82.1v-59h635.8z"/><path fill="#fff" d="M117.2 765.9H199v116.5h-81.8z"/><text transform="translate(98.3 388.1)" font-weight="bold" font-size="35" font-family="andale mono, monospace">ID</text><text transform="translate(98.3 591.8)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Balance</text><text transform="translate(98.3 697.3)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Claimable</text><text transform="translate(98.3 490)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Pending</text><text name="symbol" x="87%" y="22%" text-anchor="end" font-size="48" fill="#fff" font-family="andale mono, monospace" font-weight="bold">X</text><text name="tokenId" x="87%" y="39%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="pending" x="87%" y="49%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="balance" x="87%" y="59%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="claimable" x="87%" y="70%" text-anchor="end" font-size="35" font-family="andale mono, monospace">$X</text><text name="hoursLock" x="19.9%" y="87%" text-anchor="middle" font-size="23" font-family="andale mono, monospace">X         h</text><path name="padlock" fill="#FF0000" d="M148,800.21V790.12h5v-5h10.09v5h10.09V780H163.12v-5H153v5H142.94v10.09h-5v10.09h-5.05v35.32H183.3V800.21Zm15.13,20.18H160.6v5.05h-5v-5.05H153v-7.56h10.09Z"/><path name="error1" d="M15.29,19.82l.13.13v2.11l-.13.13H13.17L13,22.06V20l.13-.13ZM15.18,7.1l.13.13V17.75l-.13.13h-1.9l-.13-.13V7.23l.13-.13Z" fill="red" transform="translate(300 672)" /><path name="error2" d="M14.23,28.46A14.23,14.23,0,1,1,28.46,14.23,14.25,14.25,0,0,1,14.23,28.46Zm0-26.66A12.43,12.43,0,1,0,26.66,14.23,12.44,12.44,0,0,0,14.23,1.8Z" fill="red" transform="translate(300 672)" /><text x="87%" y="15%" text-anchor="end" font-size="50" fill="#fff" font-family="andale mono, monospace">STAKING</text></svg>',
  fCe =
    '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 1000"><path name="contour" fill="blue" d="M0 0h800v1000H0z"/><path stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M26 26h748v948H26z"/><path fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M41 41.3h718V959H41z"/><path fill="#fff" fill-rule="evenodd" d="M717.9 347v43.8L701.7 406H82.1v-59h635.8zm0 203.6v43.8l-16.2 15.2H82.1v-59h635.8zm0 105.5v43.8l-16.2 15.2H82.1v-59h635.8z"/><path fill="#00f" d="m711.1 846.6-27.2 47.5-6.8-11.9 13.6-23.7h-54.3l6.8-11.9h67.9z"/><path fill="#ff0" d="m717.9 858.5-34 59.4-27.1-47.5h13.6l13.5 23.7 27.2-47.5 6.8 11.9z"/><path fill="red" d="m656.8 870.4 27.1 47.5h-13.5l-34-59.4h54.3l-6.8 11.9h-27.1z"/><path fill="none" stroke="#fff" stroke-miterlimit="11.3" stroke-width="2" d="M601 82.4h117.4l-.5 219.6M199 917.9l-116.4.3V766"/><path fill="#fff" fill-rule="evenodd" d="M717.9 448.8v43.8l-16.2 15.2H82.1v-59h635.8z"/><path fill="#fff" d="M117.2 765.9H199v116.5h-81.8z"/><text x="87%" y="22%" text-anchor="end" font-size="60" fill="#fff" font-family="andale mono, monospace" font-weight="bold">BOND         CVG</text><text transform="translate(98.3 388.1)" font-weight="bold" font-size="35" font-family="andale mono, monospace">ID</text><text transform="translate(98.3 591.8)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Pending</text><text transform="translate(98.3 697.3)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Claimable</text><text transform="translate(98.3 490)" font-weight="bold" font-size="35" font-family="andale mono, monospace">Term</text><path fill="#00f" d="m269.2 99.2-66.5 116.3-16.6-29.1 33.2-58.1H86.4L103 99.2h166.2z"/><path fill="#ff0" d="m285.8 128.3-83.1 145.4-66.4-116.3h33.2l33.2 58.1 66.5-116.3 16.6 29.1z"/><path fill="#fe0000" d="m136.3 157.4 66.4 116.3h-33.2L86.4 128.3h132.9l-16.6 29.1h-66.4z"/><text name="tokenId" x="87%" y="39%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="term" x="87%" y="49%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X/X/X</text><text name="pending" x="87%" y="59%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X         CVG($X)</text><text name="claimable" x="87%" y="70%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X         CVG($X)</text><text name="hoursLock" x="19.9%" y="87%" text-anchor="middle" font-size="23" font-family="andale mono, monospace">X         h</text><path name="padlock" fill="#FF0000" d="M147.92,800.32V790.23h5v-5h10.1v5h10.09V780.14H163.05v-5H153v5H142.87v10.09h-5v10.09h-5.05v35.32h50.44V800.32Zm15.13,20.18h-2.52v5h-5.06v-5H153v-7.56h10.1Z"/></svg>',
  dCe =
    '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 1404.99"><path name="contour" fill="blue" d="M0 0h800v1404.99H0z"/><path stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M26 26.01h748v1352.98H26z"/><path fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="5" d="M41 41.33h718v1322.66H41z"/><path fill="#00f" d="m711.1 1251.57-27.17 47.54-6.79-11.88 13.58-23.78h-54.33l6.79-11.88h67.92z"/><path fill="#ff0" d="m717.89 1263.45-33.96 59.43-27.17-47.54h13.59l13.58 23.77 27.17-47.54 6.79 11.88z"/><path fill="red" d="m656.76 1275.34 27.17 47.54h-13.58l-33.96-59.43h54.33l-6.79 11.89h-27.17z"/><path fill="none" stroke="#fff" stroke-miterlimit="11.34" stroke-width="2" d="M601 78.99h117.39l-.5 219.56M199 1322.85l-116.89.38V1175.7"/><path fill="#fff" d="M116.96 1175.7h81.85v116.45h-81.85z"/><path fill="#00f" d="m269.35 111.99-66.59 116.54-16.65-29.14 33.3-58.27H86.22l16.65-29.13h166.48z"/><path fill="#ff0" d="M286 141.12 202.76 286.8l-66.59-116.54h33.29l33.3 58.27 66.59-116.54L286 141.12z"/><path fill="red" d="m136.17 170.26 66.59 116.54h-33.3L86.22 141.12h133.19l-16.65 29.14h-66.59z"/><path fill="#fff" fill-rule="evenodd" d="M717.89 536.4v43.8l-16.22 15.2H82.11v-59h635.78zm0 414.64v43.8l-16.22 15.2H82.11v-59h635.78zm0 105.5v43.8l-16.22 15.2H82.11v-59h635.78zm0-207.32v43.8l-16.22 15.2H82.11v-59h635.78zm0-414.64v43.8l-16.22 15.2H82.11v-59h635.78zm0 203.64v43.8l-16.22 15.2H82.11v-59h635.78zm0 105.5v43.8l-16.22 15.2H82.11v-59h635.78z"/><path d="M716.89 336.18v49H253.8v-49h463.09m5-5H248.8v59h473.09v-59Z" fill="#fff"/><path fill="#fff" fill-rule="evenodd" d="M227 331.19v43.8l-16.22 15.2H82.11v-59H227z"/><text text-anchor="end" x="85%" y="16%" font-size="60" fill="#fff" font-family="andale mono, monospace" font-weight="bold">Lock</text><text transform="translate(103.48 370.47)" font-size="35" font-family="andale mono, monospace" font-weight="bold">ys/ve</text><text transform="translate(98.36 475.73)" font-size="35" font-family="andale mono, monospace" font-weight="bold">ID</text><text transform="translate(98.36 577.55)" font-size="35" font-family="andale mono, monospace" font-weight="bold">CVG         Locked</text><text transform="translate(98.36 679.37)" font-size="35" font-family="andale mono, monospace" font-weight="bold">Lock end</text><text transform="translate(98.36 784.87)" font-size="35" font-family="andale mono, monospace" font-weight="bold">ysCVG</text><text transform="translate(98.36 890.37)" font-size="35" font-family="andale mono, monospace" font-weight="bold">veCVG</text><text transform="translate(98.36 992.18)" font-size="35" font-family="andale mono, monospace" font-weight="bold">mgCVG</text><text transform="translate(98.36 1097.68)" font-size="35" font-family="andale mono, monospace" font-weight="bold">Claimable</text><rect name="ysBarre" x="260" y="341.99" width="359" height="37.33" fill="blue"/><text name="ysPercent" x="439" y="26.3%" text-anchor="middle" font-size="22" fill="#fff" font-family="andale mono, monospace">X%</text><text name="tokenId" x="87%" y="34%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="cvgLocked" x="87%" y="41.3%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X ($X)</text><text name="lockEnd" x="87%" y="48.4%" text-anchor="end" font-size="35" font-family="andale mono, monospace">cvgCycle X</text><text name="ysCvg" x="87%" y="56%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="veCvg" x="87%" y="63.4%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="mgCvg" x="87%" y="70.8%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="claimable" x="87%" y="78.2%" text-anchor="end" font-size="35" font-family="andale mono, monospace">$X</text><text name="hoursLock" x="19.9%" y="91%" text-anchor="middle" font-size="23" font-family="andale mono, monospace">X h</text><path name="padlock" fill="#FF0000" d="M147.8,1212v-10.09h5v-5h10.09v5H173v-10.09H162.93v-5H152.84v5H142.75v10.09h-5V1212h-5.05v35.32h50.45V1212Zm15.13,20.18h-2.52v5h-5v-5h-2.52v-7.56h10.09Z"/></svg>',
  hCe =
    '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 1000"><rect name="contour" width="800" height="1000" fill="blue"/><rect x="26" y="26.01" width="748" height="947.99" stroke="#fff" stroke-miterlimit="10" stroke-width="5"/><rect x="41" y="41.33" width="718" height="917.67" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="5"/><polyline points="601 82.44 718.39 82.44 717.89 302" fill="none" stroke="#fff" stroke-miterlimit="11.34" stroke-width="2" fill-rule="evenodd"/><polyline points="199 917.89 82.61 918.23 82.61 766" fill="none" stroke="#fff" stroke-miterlimit="11.34" stroke-width="2" fill-rule="evenodd"/><polygon points="711.1 846.6 683.95 894.11 677.17 882.24 690.74 858.48 636.44 858.48 643.23 846.6 711.1 846.6" fill="blue"/><polygon points="717.89 858.48 683.95 917.87 656.8 870.36 670.38 870.36 683.95 894.11 711.1 846.6 717.89 858.48" fill="#ff0"/><polygon points="656.8 870.36 683.95 917.87 670.38 917.87 636.44 858.48 690.74 858.48 683.95 870.36 656.8 870.36" fill="#fe0000"/><polygon points="717.89 347 717.89 390.8 701.67 406 82.11 406 82.11 347 717.89 347" fill="#fff" fill-rule="evenodd"/><polygon points="717.89 659.24 717.89 703.04 701.67 718.24 82.11 718.24 82.11 659.24 717.89 659.24" fill="#fff" fill-rule="evenodd"/><polygon points="717.89 552.48 717.89 596.28 701.67 611.48 82.11 611.48 82.11 552.48 717.89 552.48" fill="#fff" fill-rule="evenodd"/><polygon points="717.89 448.82 717.89 492.62 701.67 507.82 82.11 507.82 82.11 448.82 717.89 448.82" fill="#fff" fill-rule="evenodd"/><polygon points="269.19 99.21 202.73 215.52 186.11 186.44 219.34 128.29 86.42 128.29 103.03 99.21 269.19 99.21" fill="blue"/><polygon points="285.8 128.29 202.73 273.68 136.26 157.37 169.5 157.37 202.73 215.52 269.19 99.21 285.8 128.29" fill="#ff0"/><polygon points="136.26 157.37 202.73 273.68 169.5 273.68 86.42 128.29 219.34 128.29 202.73 157.37 136.26 157.37" fill="#fe0000"/><text name="title" text-anchor="end" x="85%" y="23%" font-size="60" fill="#fff" font-family="andale mono, monospace" font-weight="bold"> X </text><text transform="translate(91.29 389.45)" font-size="36" font-family="andale mono, monospace" font-weight="bold">ID</text><text transform="translate(91.65 701.69)" font-size="36" font-family="andale mono, monospace" font-weight="bold">Released</text><text transform="translate(91.28 594.93)" font-size="36" font-family="andale mono, monospace" font-weight="bold">Claimable</text><text transform="translate(93.23 487.05)" font-size="36" font-family="andale mono, monospace" font-weight="bold">CVG         Amount</text><text name="tokenId" x="87%" y="39%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X</text><text name="cvgAmount" x="87%" y="49%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X CVG</text><text name="claimable" x="87%" y="59.3%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X CVG</text><text name="released" x="87%" y="70%" text-anchor="end" font-size="35" font-family="andale mono, monospace">X CVG</text></svg>',
  kv = { staking: cCe, bond: fCe, locking: dCe, presale: hCe },
  Iv = "#ffff00",
  J8 = "#00FF00",
  pCe =
    "M178.18,800.32V790.23h-5V780.14H163.05v-5H153v5H142.86v10.09h-5v10.09h-5v35.32h50.46V800.32ZM163.05,820.5h-2.53v5h-5v-5H153v-7.56h10.1Zm5-20.18H147.91V790.23h5v-5h10.1v5h5Z",
  mCe =
    "M178.26,800.21V790.12h-5V780H163.12v-5H153v5H142.94v10.09h-5v10.09h-5.05v35.32H183.3V800.21ZM163.12,820.4H160.6v5h-5v-5H153v-7.57h10.09Zm5-20.19H148V790.12h5v-5h10.09v5h5Z",
  gCe =
    "M178.07 1209.99v-10.1h-5v-10.09h-10.14v-5h-10.09v5h-10.09v10.09h-5v10.1h-5.05v35.31h50.45v-35.31Zm-15.14 20.18h-2.52v5h-5v-5h-2.53v-7.57h10.09Zm5-20.18H147.8v-10.1h5v-5h10.09v5h5Z";
class yCe {
  async createSvgs(e, n) {
    const r = this.filterSvg(e);
    return (
      (r.sdtStaking = await this.renderStakingSvgs(
        r.sdtStaking,
        n.stakedao.sdtStakingPositionManager
      )),
      (r.bond = await this.renderBondSvgs(r.bond, n.bondPositionManager)),
      (r.locking = await this.renderLockingSvgs(
        r.locking,
        n.lockingPositionManager
      )),
      (r.presale = await this.renderPresaleSvgs(r.presale, n.vestingCvg)),
      r
    );
  }
  async loadSvg(e) {
    return await (await fetch(e)).text();
  }
  filterSvg(e) {
    const n = {
      locking: [],
      bond: [],
      sdtStaking: [],
      cvxStaking: [],
      presale: [],
    };
    for (const r of e.lockingInfos) n.locking.push(r);
    for (const r of e.bondInfos) n.bond.push(r);
    for (const r of e.sdtStakingInfos) n.sdtStaking.push(r);
    for (const r of e.presaleInfos) n.presale.push(r);
    return n;
  }
  async renderLockingSvgs(e, n) {
    const r = [];
    for (const a of e) {
      const o = {
          name: "rect",
          type: "element",
          children: [],
          attributes: {
            x: "260",
            y: "341.99",
            fill: "#ff0",
            width: "225",
            height: "37.33",
          },
          value: "",
        },
        l = {
          name: "",
          type: "text",
          value: "0",
          children: [],
          attributes: {},
        },
        u = {
          name: "text",
          type: "element",
          value: "",
          children: [],
          attributes: {
            x: "0",
            y: "26.3%",
            fill: "#fff",
            "text-anchor": "middle",
            "font-size": "22",
            "font-family": "andale mono, monospace",
          },
        };
      let f = !1;
      const c = kv.locking,
        d = await Cv(c);
      for (const g of d.children) {
        const w = g.attributes.name;
        switch (!0) {
          case w === "ysBarre": {
            a.ysPercentage.toString() === "0"
              ? ((g.attributes.x = 260),
                (g.attributes.width = 449),
                (g.attributes.fill = "blue"))
              : a.ysPercentage.toString() === "100"
              ? ((g.attributes.x = 260),
                (g.attributes.width = 449),
                (g.attributes.fill = "#ff0"))
              : ((g.attributes.x = 260),
                (g.attributes.width = a.gaugePosition.ysWidth.toString()),
                (g.attributes.fill = "#ff0"),
                (o.attributes.x = (
                  a.gaugePosition.ysWidth + BigInt(260)
                ).toString()),
                (o.attributes.width = a.gaugePosition.veWidth.toString()),
                (o.attributes.fill = "blue"),
                d.children.push(o));
            break;
          }
          case w === "ysPercent": {
            if (a.ysPercentage.toString() === "0")
              (g.attributes.x = "484.5"),
                (g.attributes.fill = "#fff"),
                (g.children[0].value = "100%");
            else if (a.ysPercentage.toString() === "100")
              (g.attributes.x = "484.5"),
                (g.attributes.fill = "#1d1d1b"),
                (g.children[0].value = "100%");
            else {
              const y = a.gaugePosition.ysWidth / 2n + BigInt(260),
                v =
                  a.gaugePosition.veWidth / 2n +
                  a.gaugePosition.ysWidth +
                  BigInt(260);
              (g.attributes.x = y.toString()),
                (g.attributes.fill = "#1d1d1b"),
                (g.children[0].value = `${a.ysPercentage.toString()}%`),
                (u.attributes.x = v.toString()),
                (l.value = `${(100n - a.ysPercentage).toString()}%`),
                u.children.push(l),
                d.children.push(u);
            }
            break;
          }
          case w === "tokenId": {
            g.children[0].value = a.tokenId;
            break;
          }
          case w === "cvgLocked": {
            const y = Math.floor(ri(a.cvgLocked)),
              v = Math.floor(ri(a.cvgLockedInUsd));
            g.children[0].value = `${y.toLocaleString(
              "en-US"
            )} ($${v.toLocaleString("en-US")})`;
            break;
          }
          case w === "lockEnd": {
            g.children[0].value = `cvgCycle ${a.lockEnd}`;
            break;
          }
          case w === "ysCvg": {
            const y = a.ysCvgActual,
              v = a.ysCvgNext,
              E = Math.floor(ri(y));
            if (y === v || v === 0n)
              g.children[0].value = E.toLocaleString("en-US");
            else {
              const S = Math.floor(ri(v));
              g.children[0].value = `${E.toLocaleString(
                "en-US"
              )} / ${S.toLocaleString("en-US")}`;
            }
            break;
          }
          case w === "veCvg": {
            const y = Math.floor(ri(a.veCvg));
            g.children[0].value = y.toLocaleString("en-US");
            break;
          }
          case w === "mgCvg": {
            const y = Math.floor(ri(a.mgCvg));
            g.children[0].value = y.toLocaleString("en-US");
            break;
          }
          case w === "claimable": {
            if (a.claimableInUsd.toString() !== "0") {
              const y = Math.floor(ri(a.claimableInUsd));
              y === 0
                ? (g.children[0].value = "<$1")
                : (g.children[0].value = `$${y.toLocaleString("en-US")}`);
            } else g.children[0].value = "$0";
            break;
          }
          case w === "padlock": {
            a.isLocked && ((g.attributes.fill = J8), (g.attributes.d = gCe));
            break;
          }
          case w === "hoursLock": {
            a.isLocked
              ? (g.children[0].value = `&lt;${Number(a.hoursLock) + 1} h`)
              : (g.children[0].value = "-");
            break;
          }
          case w === "contour": {
            a.claimableInUsd.toString() !== "0" &&
              ((g.attributes.fill = Iv), (f = !0));
            break;
          }
        }
      }
      const m = {
        svg: this.convertJsonToSvgString(d),
        manager: n,
        id: a.tokenId,
        type: "LOCKING",
        isClaimable: f,
        data: a,
      };
      r.push(m);
    }
    return r;
  }
  async renderStakingSvgs(e, n) {
    const r = [];
    for (const i of e) {
      let s = !1;
      const a = kv.staking,
        o = await Cv(a);
      for (const f of o.children) {
        const c = f.attributes.name;
        switch (!0) {
          case c === "symbol": {
            f.children[0].value = i.symbol;
            let d = uCe[i.symbol];
            d = d || lCe;
            for (const p of d) {
              const m = {
                name: p.balise,
                type: "element",
                children: [],
                attributes: p.data,
              };
              p.balise == "text" &&
                (m.children = [{ type: "text", value: p.textContent }]),
                o.children.push(m);
            }
            break;
          }
          case c === "tokenId":
            f.children[0].value = i.tokenId;
            break;
          case c === "pending": {
            const d = Math.floor(ri(i.pending));
            f.children[0].value = d.toLocaleString("en-US");
            break;
          }
          case c === "balance": {
            const d = Math.floor(ri(i.totalStaked));
            f.children[0].value = d.toLocaleString("en-US");
            break;
          }
          case c === "claimable": {
            if (i.claimableInUsd.toString() !== "0") {
              const d = Math.floor(ri(i.claimableInUsd));
              d === 0
                ? (f.children[0].value = "<$1")
                : (f.children[0].value = `$${d.toLocaleString("en-US")}`);
            } else f.children[0].value = "$0";
            break;
          }
          case c === "error1": {
            i.erroneousAmount || (f.attributes.fill = "#fff");
            break;
          }
          case c === "error2": {
            i.erroneousAmount || (f.attributes.fill = "#fff");
            break;
          }
          case c === "padlock":
            i.isLocked && ((f.attributes.fill = J8), (f.attributes.d = mCe));
            break;
          case c === "hoursLock":
            i.isLocked
              ? (f.children[0].value = `&lt;${Number(i.hoursLock) + 1} h`)
              : (f.children[0].value = "-");
            break;
          case c === "contour":
            i.claimableInUsd.toString() !== "0" &&
              ((f.attributes.fill = Iv), (s = !0));
            break;
        }
      }
      const u = {
        svg: this.convertJsonToSvgString(o),
        manager: n,
        id: i.tokenId,
        type: "STAKING",
        isClaimable: s,
        data: i,
      };
      r.push(u);
    }
    return r;
  }
  async renderPresaleSvgs(e, n) {
    const {
      ibo: r,
      seedPresaleCvg: i,
      wlPresaleCvg: s,
    } = await oi.getStaticData();
    let a, o;
    const l = [];
    for (const u of e) {
      const f = u.presaleInfo;
      let c = !1;
      const d = kv.presale,
        p = await Cv(d);
      for (const w of p.children) {
        const y = w.attributes.name;
        switch (!0) {
          case y === "title":
            u.presaleType === 0n
              ? ((a = i), (w.children[0].value = "SeedPresale"), (o = "SEED"))
              : u.presaleType === 1n
              ? ((a = s), (w.children[0].value = "WlPresale"), (o = "WL"))
              : ((a = r), (w.children[0].value = "Ibo"), (o = "IBO"));
            break;
          case y === "tokenId":
            w.children[0].value = `${u.tokenId}`;
            break;
          case y === "cvgAmount": {
            const v = Math.floor(ri(f.totalCvg));
            w.children[0].value = `${v.toLocaleString("en-US")} CVG`;
            break;
          }
          case y === "claimable": {
            const v = ri(f.amountReleasable);
            let E = 0;
            if (v.toString() !== "0.0") {
              let S = Math.floor(v);
              S !== 0 ? (E = S.toLocaleString("en-US")) : (E = "< 1"), (c = !0);
            }
            w.children[0].value = `${E} CVG`;
            break;
          }
          case y === "released": {
            const v = Math.floor(ri(f.amountRedeemed));
            w.children[0].value = `${v.toLocaleString("en-US")} CVG`;
            break;
          }
          case y === "contour":
            f.amountReleasable.toString() !== "0" &&
              ((w.attributes.fill = Iv), (c = !0));
            break;
        }
      }
      const g = {
        svg: this.convertJsonToSvgString(p),
        manager: a,
        id: u.tokenId,
        type: o,
        vesting: n,
        isClaimable: c,
        data: u,
      };
      l.push(g);
    }
    return l;
  }
  async renderBondSvgs(e, n) {
    const r = [];
    for (const i of e) {
      let s = !1;
      const a = kv.bond,
        o = await Cv(a);
      for (const f of o.children) {
        const c = f.attributes.name;
        switch (!0) {
          case c === "tokenId":
            f.children[0].value = i.tokenId;
            break;
          case c === "term":
            i.termTimestamp.toString() > "0"
              ? (f.children[0].value = `${i.month}/${i.day}/${i.year}`)
              : (f.children[0].value = "Fully Vested");
            break;
          case c === "pending": {
            const d = Math.floor(ri(i.pending)),
              p = Math.floor(Eh(i.pending * i.cvgPrice, 36));
            f.children[0].value = `${d.toLocaleString(
              "en-US"
            )} CVG($${p.toLocaleString("en-US")})`;
            break;
          }
          case c === "claimable": {
            const d = Math.floor(ri(i.cvgClaimable)),
              p = Math.floor(Eh(i.cvgClaimable * i.cvgPrice, 36));
            f.children[0].value = `${d.toLocaleString(
              "en-US"
            )} CVG($${p.toLocaleString("en-US")})`;
            break;
          }
          case c === "padlock":
            i.isLocked && ((f.attributes.fill = J8), (f.attributes.d = pCe));
            break;
          case c === "hoursLock":
            i.isLocked
              ? (f.children[0].value = `&lt;${Number(i.hoursLock) + 1} h`)
              : (f.children[0].value = "-");
            break;
          case c === "contour":
            i.cvgClaimable.toString() !== "0" &&
              ((f.attributes.fill = Iv), (s = !0));
            break;
        }
      }
      const u = {
        svg: this.convertJsonToSvgString(o),
        manager: n,
        id: i.tokenId,
        type: "BOND",
        isClaimable: s,
        data: i,
      };
      r.push(u);
    }
    return r;
  }
  convertJsonToSvgString(e) {
    let n = "";
    return (
      e.type === "element"
        ? ((n += `<${e.name}`),
          e.attributes &&
            Object.keys(e.attributes).forEach((r) => {
              n += ` ${r}="${e.attributes[r]}"`;
            }),
          e.children && e.children.length > 0
            ? ((n += ">"),
              e.children.forEach((r) => {
                n += this.convertJsonToSvgString(r);
              }),
              (n += `</${e.name}>`))
            : (n += "/>"))
        : e.type === "text" && (n += e.value),
      n
    );
  }
}
const Im = new yCe(),
  vCe = "hh-sol-artifact-1",
  bCe = "SdtStakingPositionManager",
  wCe = "contracts/Staking/StakeDAO/SdtStakingPositionManager.sol",
  _Ce = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "uint8", name: "version", type: "uint8" },
      ],
      name: "Initialized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [],
      name: "BUFFER",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "checkIncreaseDepositCompliance",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "contract ISdtStakingPositionService",
              name: "stakingContract",
              type: "address",
            },
            { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
          ],
          internalType:
            "struct ISdtStakingPositionManager.ClaimSdtStakingContract[]",
          name: "claimInput",
          type: "tuple[]",
        },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "checkMultipleClaimCompliance",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "receiver", type: "address" },
      ],
      name: "checkTokenFullCompliance",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "cvgControlTower",
      outputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getComplianceInfo",
      outputs: [
        { internalType: "address", name: "", type: "address" },
        { internalType: "address", name: "", type: "address" },
        { internalType: "uint256", name: "", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "getTokenIdsAndStakingContracts",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "stakingContract",
              type: "address",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
          ],
          internalType: "struct SdtStakingPositionManager.TokenStaking[]",
          name: "",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_wallet", type: "address" }],
      name: "getTokenIdsForWallet",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract ICvgControlTower",
          name: "_cvgControlTower",
          type: "address",
        },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "logoInfo",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "symbol", type: "string" },
            { internalType: "uint256", name: "pending", type: "uint256" },
            { internalType: "uint256", name: "totalStaked", type: "uint256" },
            { internalType: "uint256", name: "cvgClaimable", type: "uint256" },
            {
              components: [
                {
                  internalType: "contract IERC20",
                  name: "token",
                  type: "address",
                },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              internalType: "struct ICommonStruct.TokenAmount[]",
              name: "sdtClaimable",
              type: "tuple[]",
            },
            {
              internalType: "uint256",
              name: "unlockingTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct ISdtStakingLogo.LogoInfos",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "maxLockingTime",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "nextId",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "newBaseURI", type: "string" }],
      name: "setBaseURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "timestamp", type: "uint256" },
      ],
      name: "setLock",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "newMaxLockingTime", type: "uint256" },
      ],
      name: "setMaxLockingTime",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "stakingPerTokenId",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "unlockingTimestampPerToken",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  ECe = { _format: vCe, contractName: bCe, sourceName: wCe, abi: _Ce };
class xCe {
  bcService = new Td();
  async getNftContract(e) {
    const {
      ibo: n,
      seedPresaleCvg: r,
      wlPresaleCvg: i,
      bondPositionManager: s,
      lockingPositionManager: a,
      stakedao: o,
    } = await oi.getStaticData();
    switch (e) {
      case "seed-presale":
        return new kr(r, BAe.abi, await this.bcService.getStaticProvider());
      case "wl-presale":
        return new kr(i, NAe.abi, await this.bcService.getStaticProvider());
      case "ibo-presale":
        return new kr(n, CAe.abi, await this.bcService.getStaticProvider());
      case "bond":
        return new kr(s, TG.abi, await this.bcService.getStaticProvider());
      case "lock":
        return new kr(a, X8.abi, await this.bcService.getStaticProvider());
      case "sdt-staking":
        return new kr(
          o.sdtStakingPositionManager,
          ECe.abi,
          await this.bcService.getStaticProvider()
        );
    }
  }
  async getOwner(e, n) {
    let r = await this.getNftContract(e);
    if (!r) return null;
    try {
      return await r.ownerOf(n);
    } catch {
      return null;
    }
  }
  async getSvg(e, n) {
    switch (e) {
      case "lock":
        return this.getLockSvg(n);
      case "sdt-staking":
        return this.getSdtStakingSvg(n);
      case "bond":
        return this.getBondSvg(n);
      case "seed-presale":
        return this.getPresaleSvg(e, n);
      case "wl-presale":
        return this.getPresaleSvg(e, n);
      case "ibo-presale":
        return this.getPresaleSvg(e, n);
    }
  }
  async getPresaleSvg(e, n) {
    const r = await this.bcService.getStaticProvider(),
      { vestingCvg: i } = await oi.getStaticData();
    let s;
    switch (e) {
      case "seed-presale":
        s = 0n;
        break;
      case "wl-presale":
        s = 1n;
        break;
      case "ibo-presale":
        s = 2n;
        break;
    }
    const a = new kr(i, WL.abi, r);
    let o;
    try {
      o = await a.getInfoVestingTokenId(n, s);
    } catch {
      return { noPosition: !0 };
    }
    const l = { tokenId: BigInt(n), presaleInfo: o, presaleType: s };
    return { svg: (await Im.renderPresaleSvgs([l], i))?.at(0), data: l };
  }
  async getLockSvg(e) {
    const { lockingPositionManager: n, lockingLogo: r } =
        await oi.getStaticData(),
      i = {
        contractName: "locking",
        contractAddress: n,
        logo: r,
        abi: YSe.abi,
      };
    return this.getSvgInner(i, e);
  }
  async getSdtStakingSvg(e) {
    const { stakedao: n } = await oi.getStaticData(),
      r = {
        contractName: "sdt-staking",
        contractAddress: n.sdtStakingPositionManager,
        logo: n.sdtStakingLogo,
        abi: oAe.abi,
      };
    return this.getSvgInner(r, e);
  }
  async getBondSvg(e) {
    const { bondPositionManager: n, bondLogo: r } = await oi.getStaticData(),
      i = { contractName: "bond", contractAddress: n, logo: r, abi: nAe.abi };
    return this.getSvgInner(i, e);
  }
  async getSvgInner(e, n) {
    const r = await this.bcService.getStaticProvider(),
      i = e.contractName;
    let s, a;
    const o = new kr(e.logo, e.abi, r);
    try {
      a = await o.getLogoInfo(n);
    } catch {
      return { noPosition: !0 };
    }
    switch (i) {
      case "bond": {
        s = await Im.renderBondSvgs([a], e.contractAddress);
        break;
      }
      case "locking": {
        s = await Im.renderLockingSvgs([a], e.contractAddress);
        break;
      }
      case "sdt-staking": {
        s = await Im.renderStakingSvgs([a], e.contractAddress);
        break;
      }
    }
    return { svg: s?.at(0), data: a };
  }
  async getCvgPepePositions(e, n) {
    const r = [];
    let i = e.tokenURI.slice(0, -2);
    for (const s of e.tokenIds) {
      const a = `${i.replace(
        "ipfs://",
        "https://cloudflare-ipfs.com/ipfs/"
      )}/${s.toString()}`;
      try {
        const o = await fetch(a);
        if (o.status === 200) {
          const f = {
            url: (await o.json()).image.replace(
              "ipfs://",
              "https://cloudflare-ipfs.com/ipfs/"
            ),
            id: s.toString(),
            manager: n,
            type: "CVGPEPE",
          };
          r.push(f);
        }
      } catch (o) {
        console.error(o);
      }
    }
    return r;
  }
  async getGalleryInfos(e) {
    const n = [e],
      r = await this.bcService.getStaticProvider(),
      i = new eu(Z8.abi),
      a = await new Ly(Z8.abi, Z8.bytecode).getDeployTransaction(...n);
    let o;
    try {
      await r.estimateGas(a);
    } catch (u) {
      o = u.data;
    }
    return i.parseError(o).args;
  }
  async getAllPositions(e) {
    const n = await oi.getStaticData(),
      [r] = await this.getGalleryInfos(e),
      i = await Im.createSvgs(r, n);
    return (
      (i.pepe = await this.getCvgPepePositions(r.cvgPepeInfos, n.cvgPepe)), i
    );
  }
  async transferNft(e, n, r, i) {
    const s = new kr(r, X8.abi, e),
      a = await e.getAddress();
    return await s.transferFrom(a, n, i);
  }
  async lockTimeNft(e, n, r, i) {
    const s = (await (await this.bcService.getStaticProvider()).getBlock())
        .timestamp,
      a = n * 3600 + s;
    return await new kr(r, X8.abi, e).setLock(i, a);
  }
  async claimNft(e, n, r, i) {
    const s = new kr(n, WL.abi, e);
    return r === "SEED"
      ? await s.releaseSeed(i)
      : r === "WL"
      ? await s.releaseWl(i)
      : await s.releaseIbo(i);
  }
  async claimBoost(e, n, r, i) {
    const s = new kr(n, EAe.abi, e);
    return r === "WL" ? await s.claimBoostWl(i) : await s.claimBoostIbo(i);
  }
}
const qL = new xCe(),
  Ky = Z.createContext(null),
  TCe = ({ children: t, type: e, tknId: n }) => {
    const [r, i] = Z.useState(void 0),
      [s, a] = Z.useState(void 0),
      [o, l] = Z.useState(void 0),
      [u, f] = Z.useState(void 0);
    async function c(p, m) {
      return await qL.getSvg(p, m);
    }
    Z.useEffect(() => {
      r === void 0 &&
        o === void 0 &&
        qL.getOwner(e, n).then((p) => {
          p
            ? (f(p),
              c(e, n).then((m) => {
                i(m?.data), a(m?.svg);
              }))
            : l(!0);
        });
    }, []);
    const d = { svg: s, nftData: r, noPosition: o, owner: u };
    return G.jsx(Ky.Provider, { value: d, children: t });
  };
function SCe({ className: t, style: e, children: n }) {
  return G.jsx("div", {
    className: `Panel  ${t || ""} `,
    style: e,
    children: n,
  });
}
function ACe() {
  const { nftData: t } = Z.useContext(Ky),
    e = new Date(Number(t?.termTimestamp) * 1e3);
  return G.jsxs(G.Fragment, {
    children: [
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Type" }),
          G.jsx("div", { className: "color-quiet", children: "Bond position" }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsxs("div", {
            className: "font-bold  mb-1",
            children: [
              "Lock ",
              !t?.isLocked &&
                G.jsx("i", {
                  className: "pi pi-exclamation-triangle color-bg-tonic ",
                }),
            ],
          }),
          G.jsx("div", {
            className: "color-quiet",
            children: t?.isLocked
              ? G.jsx(G.Fragment, {
                  children:
                    "the position is currently locked, no claims can be made.",
                })
              : G.jsx(G.Fragment, {
                  children:
                    "A bond position represents a discounted CVG purchase, with vesting on it. CVG can be claimed at any time during the linear vesting.",
                }),
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "font-bold mb-1",
            children: "Description",
          }),
          G.jsxs("div", {
            className: "color-quiet max-w-55rem",
            children: [
              G.jsx("div", {
                className: "my-2",
                children:
                  "A bond position represents a CVG purchase, with vesting on it.",
              }),
              G.jsx("div", {
                className: "my-2",
                children:
                  "CVG can be claimed at any time during the linear vesting.",
              }),
              G.jsxs("a", {
                href: "/bond",
                className: "color-light-blue",
                children: [" ", "Go to the feature"],
              }),
            ],
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "font-bold mb-1",
            children: "Vesting end ",
          }),
          G.jsx("div", {
            className: "color-quiet max-w-55rem",
            children: e?.toLocaleDateString(),
          }),
        ],
      }),
    ],
  });
}
function CCe() {
  const { nftData: t } = Z.useContext(Ky),
    { actualCycle: e } = Z.useContext($y);
  return G.jsxs(G.Fragment, {
    children: [
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Type" }),
          G.jsx("div", {
            className: "color-quiet",
            children: "Locking position",
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsxs("div", {
            className: "font-bold  mb-1",
            children: [
              "Lock ",
              !t?.isLocked &&
                G.jsx("i", {
                  className: "pi pi-exclamation-triangle color-bg-tonic ",
                }),
            ],
          }),
          G.jsx("div", {
            className: "color-quiet",
            children: t?.isLocked
              ? G.jsx(G.Fragment, {
                  children:
                    "the position is currently locked, no claims can be made.",
                })
              : G.jsxs(G.Fragment, {
                  children: [
                    "The position is currently ",
                    G.jsx("span", {
                      className: "text-white",
                      children: "not locked",
                    }),
                    ", claims can be made at any time.",
                  ],
                }),
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "font-bold mb-1",
            children: "Description",
          }),
          G.jsxs("div", {
            className: "color-quiet max-w-55rem",
            children: [
              G.jsxs("div", {
                children: [
                  "A locking position consists of CVG tokens, divided between",
                  " ",
                  G.jsxs("span", {
                    className: "color-tonic",
                    children: [" ysCvg ", Number(t.ysPercentage), "% "],
                  }),
                  " and",
                  " ",
                  G.jsxs("span", {
                    className: "color-veCvg",
                    children: ["veCVG ", 100 - Number(t.ysPercentage), "%"],
                  }),
                ],
              }),
              G.jsxs("div", {
                className: "my-2",
                children: [
                  "The veCVG portion is utilized for voting on gauge weights and participating in CVG governance.",
                  G.jsx("br", {}),
                  "Meanwhile, ysCVG enables the holder to claim a portion of the treasury rewards during each Treasury Distribution Event (TDE).",
                ],
              }),
              G.jsxs("a", {
                href: "/lock",
                className: "color-light-blue",
                children: [" ", "Go to the feature"],
              }),
            ],
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Duration" }),
          G.jsxs("div", {
            className: "color-quiet",
            children: [
              "The underlying CVGs can be recovered in ",
              Number(t.lockEnd) - Number(e),
              " weeks.",
            ],
          }),
        ],
      }),
    ],
  });
}
function kCe() {
  const { nftData: t } = Z.useContext(Ky);
  return G.jsxs(G.Fragment, {
    children: [
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Type" }),
          G.jsx("div", {
            className: "color-quiet",
            children: "Staking position",
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsxs("div", {
            className: "font-bold  mb-1",
            children: [
              "Lock ",
              !t?.isLocked &&
                G.jsx("i", {
                  className: "pi pi-exclamation-triangle color-bg-tonic ",
                }),
            ],
          }),
          G.jsx("div", {
            className: "color-quiet",
            children: t?.isLocked
              ? G.jsx(G.Fragment, {
                  children:
                    "the position is currently locked, no claims,or withdraw can be made.",
                })
              : G.jsxs(G.Fragment, {
                  children: [
                    "The position is currently ",
                    G.jsx("span", {
                      className: "text-white",
                      children: "not locked",
                    }),
                    ", claims and withdrawals can be made at any time.",
                  ],
                }),
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "font-bold mb-1",
            children: "Description",
          }),
          G.jsxs("div", {
            className: "color-quiet max-w-55rem",
            children: [
              G.jsxs("div", {
                className: "my-2",
                children: [
                  "A staking position entails depositing an asset (",
                  t?.symbol,
                  "), into Convergence's staking contracts.",
                  G.jsx("br", {}),
                  "The holder of this token is entitled to boosted native rewards, in addition to receiving supplementary CVG rewards.",
                ],
              }),
              G.jsxs("a", {
                href: "/stake",
                className: "color-light-blue",
                children: [" ", "Go to the feature"],
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
function ICe({ presaleType: t }) {
  const e = t.split("-").at(0).toUpperCase();
  return G.jsxs(G.Fragment, {
    children: [
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Type" }),
          G.jsx("div", { className: "color-quiet", children: e }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "font-bold mb-1",
            children: "Description",
          }),
          G.jsxs("div", {
            className: "color-quiet max-w-55rem",
            children: [
              "A presale token (seed, presale, ibo) is an NFT that represents early financial contribution to Convergence, prior to its official launch.",
              G.jsx("br", {}),
              "Underlying CVG tokens can be claimed at any time during the linear vesting.",
            ],
          }),
        ],
      }),
      G.jsxs("div", {
        children: [
          G.jsx("div", { className: "font-bold mb-1", children: "Claim" }),
          G.jsxs("div", {
            className: "color-quiet max-w-55rem",
            children: [
              "Claims can be managed on the positions page.",
              G.jsx("br", {}),
              G.jsxs("a", {
                href: "/positions",
                className: "color-light-blue",
                children: [" ", "Go to the feature"],
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
function OCe({ type: t, tknId: e }) {
  const { svg: n, noPosition: r, owner: i } = Z.useContext(Ky);
  return !n && r === void 0
    ? G.jsx(S1, { className: "h-1rem" })
    : r
    ? G.jsx(G.Fragment, {
        children: G.jsx("div", {
          className:
            "flex flex-column justify-content-center align-items-center md:flex-row  h-10rem",
          children: "This position does not exist.",
        }),
      })
    : G.jsxs("div", {
        children: [
          G.jsx("div", {
            className: "mb-4",
            children: G.jsxs("a", {
              href: "/positions",
              className:
                "no-underline p-2 color-light-blue flex align-items-center gap-2",
              children: [
                G.jsx("i", { className: "pi pi-angle-double-left" }),
                " Return to positions",
              ],
            }),
          }),
          G.jsxs("div", {
            className: "flex flex-column md:flex-row gap-4",
            children: [
              G.jsx("div", {
                className: " ",
                children: G.jsx("div", {
                  className: "w-full md:w-18rem mx-auto  max-w-18rem ",
                  dangerouslySetInnerHTML: { __html: n?.svg || "" },
                }),
              }),
              G.jsxs("div", {
                className: " flex flex-column gap-4 flex-grow-1 px-4",
                children: [
                  G.jsxs("div", {
                    className: "text-lg",
                    children: [
                      "Tkn.",
                      G.jsx("div", {
                        className: "color-tonic",
                        children: _G(e),
                      }),
                    ],
                  }),
                  G.jsxs("div", {
                    className: "flex flex-column gap-1 ",
                    children: [
                      G.jsx("span", {
                        className: "text-lg",
                        children: "Owner:",
                      }),
                      G.jsx("a", {
                        href: `https://etherscan.io//address/${i}`,
                        target: "_blank",
                        rel: "noreferrer",
                        className: "  color-quiet no-underline",
                        children: G.jsx("div", {
                          className: " ",
                          children: G.jsx(Mg, { address: i }),
                        }),
                      }),
                    ],
                  }),
                  t === "bond" && G.jsx(ACe, {}),
                  t === "lock" && G.jsx(CCe, {}),
                  t === "sdt-staking" && G.jsx(kCe, {}),
                  ["seed-presale", "wl-presale", "ibo-presale"].includes(t) &&
                    G.jsx(ICe, { presaleType: t }),
                ],
              }),
            ],
          }),
        ],
      });
}
const PCe = "/assets/planet-98aec29b.png";
function Qx() {
  return G.jsx("div", {
    className: "grid",
    children: G.jsxs("div", {
      className: " col-offset-1 col-10 text-center flex flex-wrap",
      children: [
        G.jsx("h1", {
          className: " text-2xl my-5",
          children: " Hello you are lost in zone 404 ",
        }),
        G.jsx("img", {
          src: PCe,
          alt: "404 zone",
          className: "w-full max-w-20rem",
        }),
        G.jsx("br", {}),
      ],
    }),
  });
}
function NCe() {
  let { tknId: t, type: e } = Vre();
  return !e || !t
    ? G.jsx(Qx, {})
    : [
        "bond",
        "sdt-staking",
        "lock",
        "seed-presale",
        "wl-presale",
        "ibo-presale",
      ].includes(e)
    ? G.jsx(TCe, {
        type: e,
        tknId: t,
        children: G.jsx(FSe, {
          children: G.jsx(SCe, {
            className: "m-auto my-8  min-h-30rem",
            children: G.jsx(OCe, { type: e, tknId: t }),
          }),
        }),
      })
    : G.jsx(Qx, {});
}
const Fl = (t) => (!t || t === "new" ? "new" : `Tkn. ${_G(t)}`),
  Ov = (t) => (t ? `${t} weeks` : "N/A"),
  DCe = {
    "bond.deposit": {
      title: "Deposit {asset}",
      message:
        "You are about to deposit <span class='color-tonic'>{value} {asset}</span> (${usdValue}) to buy discounted CVG. Your tokens will be released linearly, according to the bond vesting period.",
      confirm: !1,
      fields: {
        asset: { label: "Asset:" },
        value: { label: "Deposited value:" },
        cvgAmount: { label: "CVG amount:" },
        usdValue: { label: "USD($) value:" },
        tokenId: { label: "Token Id:", transform: Fl },
      },
    },
    "bond.depositAndLock": {
      title: "Bond & Lock {asset}",
      message:
        "You are about to deposit <span class='color-tonic'>{value} {asset}</span> (${usdValue}) to buy discounted CVG. These tokens will automatically be locked.",
      confirm:
        "Locking is irreversible. Your CVG cannot be redeemed before the end of the lock period.",
      fields: {
        asset: { label: "Asset:" },
        value: { label: "Deposited value:" },
        cvgAmount: { label: "CVG amount:" },
        usdValue: { label: "USD($) value:" },
        lockDuration: { label: "Lock duration:", transform: Ov },
        tokenId: { label: "Lock Token Id:", transform: Fl },
      },
    },
    "lock.create": {
      title: "Create Lock Position",
      message:
        "You are about to lock <span class='color-tonic'>{value}</span> CVG for <span class='color-tonic'>{lockDuration}</span> weeks.",
      confirm:
        "Locking is irreversible. Your CVG cannot be redeemed before the end of the lock period.",
      fields: {
        value: { label: "Deposited value:" },
        lockDuration: { label: "Lock duration:", transform: Ov },
        tokenId: { label: "Lock Token Id:", transform: Fl },
      },
    },
    "lock.increaseTime": {
      title: "Increase Lock Time",
      message:
        "You are about to increase the lock duration of your position. Your position will expire in <span class='color-tonic'>{lockDuration}</span> more weeks.",
      confirm:
        "Increasing your lock time will prevent you from redeeming your CVG for the added duration.",
      fields: {
        value: { label: "Added amount:" },
        lockDuration: { label: "Added duration:", transform: Ov },
        tokenId: { label: "Lock Token Id:", transform: Fl },
      },
    },
    "lock.increaseAmount": {
      title: "Increase Lock Amount",
      message: "You are about to increase the lock amount of your position.",
      confirm:
        "Locking is irreversible. Your CVG cannot be redeemed before the end of the lock period.",
      fields: {
        value: { label: "Added amount:" },
        tokenId: { label: "Lock Token Id:", transform: Fl },
      },
    },
    "lock.increaseTimeAmount": {
      title: "Increase Lock Time & Amount",
      message:
        "You are about to increase both the lock duration and amount of your position. Your position will expire in <span class='color-tonic'>{lockDuration}</span> more weeks.",
      confirm:
        "Locking is irreversible. Your CVG cannot be redeemed before the end of the lock period.",
      fields: {
        value: { label: "Added amount:" },
        lockDuration: { label: "Added duration:", transform: Ov },
        tokenId: { label: "Lock Token Id:", transform: Fl },
      },
    },
    "staking.deposit": {
      title: "Stake {asset}",
      message:
        "You are about to deposit <span class='color-tonic'>{value} {asset}</span>. Funds can be withdrawn at any time.",
      confirm:
        "You will be eligible to claim rewards, starting at Cycle {cycle}.",
      fields: {
        asset: { label: "Asset:" },
        value: { label: "Deposited value:" },
        tokenId: { label: "Token Id:", transform: Fl },
        cycle: { hide: !0 },
      },
    },
    "staking.withdraw": {
      title: "Unstake {asset}",
      message:
        "You are about to remove <span class='color-tonic'>{value} {asset}</span> from the staking contract.",
      confirm:
        "Your withdrawn balance won't be eligible to claim next Cycle rewards.",
      fields: {
        asset: { label: "Asset:" },
        value: { label: "Withdrawn value:" },
        tokenId: { label: "Token Id:", transform: Fl },
      },
    },
    "staking.convertCvgSdt": {
      title: "Convert cvgSDT",
      message:
        "You are about to convert <span class='color-tonic'>{value} SDT </span> to <span class='color-tonic'> cvgSDT </span>.",
      confirm:
        "Converting SDT to cvgSDT is irreversible, a cvgSDT/SDT curve pool allows you to exit your position.",
      fields: { value: { label: "Converted value:" } },
    },
    "staking.convertAndDepositCvgSdt": {
      title: "Convert & Stake cvgSDT",
      message:
        "You are about to convert <span class='color-tonic'>{value} SDT </span> to <span class='color-tonic'> cvgSDT </span> and stake it.",
      confirm:
        "Converting SDT to cvgSDT is irreversible, a cvgSDT/SDT curve pool allows you to exit your position. You will be eligible to claim rewards, starting at Cycle {cycle}.",
      fields: {
        value: { label: "Converted value:" },
        tokenId: { label: "Token Id:", transform: Fl },
        cycle: { hide: !0 },
      },
    },
    "staking.depositCvgSdt": {
      title: "Stake cvgSDT",
      message:
        "You are about to stake <span class='color-tonic'>{value} cvgSDT</span> in the cvgSDT staking contract.",
      confirm:
        "You will be eligible to claim rewards, starting at Cycle {cycle}.",
      fields: {
        value: { label: "Staked value:" },
        tokenId: { label: "Token Id:", transform: Fl },
        cycle: { hide: !0 },
      },
    },
    "staking.withdrawCvgSdt": {
      title: "Unstake cvgSDT",
      message:
        "You are about to unstake <span class='color-tonic'>{value} cvgSDT</span> from the cvgSDT staking contract.",
      confirm:
        "Your withdrawn balance won't be eligible to claim next Cycle rewards.",
      fields: {
        asset: { label: "Asset:" },
        value: { label: "Unstaked value:" },
        tokenId: { label: "Token Id:", transform: Fl },
      },
    },
    "staking.procsseSdtRewards": {
      title: "Process rewards",
      message:
        "You are about to process the rewards for {staking} staking </span> ",
      confirm: !1,
      fields: { staking: { label: "Staking :" }, value: { hide: !0 } },
    },
    "airdrop.veCvgClaim": {
      title: "Claim veCVG airdrop rewards",
      message:
        "You are about to claim your reward from veCVG airdrop. </span> ",
      confirm: !1,
    },
    "staking.stkCvgEth.deposit": {
      title: "Stake CVG",
      confirm: !1,
      fields: { token: { label: "Token:" }, value: { label: "Value:" } },
    },
    "staking.stkCvgEth.withdraw": {
      title: "Unstake  stkCvgEth",
      confirm: !1,
      fields: { value: { label: "Value:" } },
    },
  },
  KL = {
    ACTION_REJECTED: "You have rejected the transaction",
    "ERC20: transfer amount exceeds allowance": "Not enough allowance",
    "ERC20: transfer amount exceeds balance": "Not enough Balance",
    SLIPPAGE_ERROR: "Slippage error",
    INVALID_SLIPPAGE: "Slippage error",
  },
  dq = {
    WITHDRAW_EXCEEDS_STAKED_AMOUNT:
      "You don't have that many assets in the staking contract",
    DEPOSIT_PAUSED: "The deposit on this contract is paused ",
    TOKEN_TIMELOCKED:
      "You cannot withdraw from this token , it is time locked.",
  },
  hq = {
    MAX_CVG_PER_BOND:
      "It is not possible to buy such a quantity of CVG tokens in a single transaction.",
  },
  pq = {},
  RCe = { staking: dq, bond: hq, lock: pq },
  MCe = (t, e) => {
    let n;
    return (
      Object.entries(t).some(([r, i]) => {
        if (e?.message?.includes(r)) return (n = i), !0;
      }),
      n
    );
  },
  LCe = (t, e) => {
    let n;
    ["lock", "bond", "staking"].includes(e)
      ? (n = [KL, RCe[e]])
      : (n = [KL, dq, hq, pq]);
    let r;
    return n.some((i) => ((r = MCe(i, t)), r !== void 0)), r;
  },
  Wh = Qa.createContext(null);
class Xa {
  static No = "no";
  static MustApprove = "MustApprove";
  static MustIncrease = "MustIncrease";
  static Ok = "Ok";
  static Error = "error";
}
const BCe = ({ children: t }) => {
  const { notifyError: e } = Z.useContext($h),
    { isWellConnected: n, address: r, getSigner: i } = x1(),
    [s, a] = Z.useState(!1),
    [o, l] = Z.useState(void 0),
    [u, f] = Z.useState(void 0),
    [c, d] = Z.useState(!1),
    [p, m] = Z.useState(void 0),
    [g, w] = Z.useState(0n),
    [y, v] = Z.useState(void 0),
    [E, S] = Z.useState(!1),
    [D, P] = Z.useState(!1),
    [x, _] = Z.useState(void 0),
    [A, N] = Z.useState(void 0);
  Z.useEffect(() => {
    p?.token || v(Xa.No);
  }, []);
  const M = Z.useMemo(
      () => ({ ...(u?.params || {}), value: al(u?.value || 0) }),
      [u]
    ),
    T = Z.useMemo(() => {
      const R = {
        finalizeDisable:
          (o?.confirm ? !E : !1) ||
          [Xa.MustApprove, Xa.MustIncrease].includes(y),
        displayFinalize: void 0,
        displayFinalizing: void 0,
        displaySuccess: A !== void 0,
        displayError: !!x?.human,
      };
      return (
        (R.displayFinalizing = D && !R.displaySuccess && !R.displayError),
        (R.displayFinalize = !D && !R.displaySuccess && !R.displayError),
        R
      );
    }, [x, D, E, y, A]);
  Z.useEffect(() => {
    p !== void 0 &&
      y === void 0 &&
      n &&
      tu
        .refreshTokenInfos(r, {
          contract: p.contract,
          token: p.token.tokenAddress,
        })
        .then((R) => {
          O(R?.allowance[p.contract]);
        });
  });
  const O = (R) => {
      if ((w(R), R === 0n)) {
        v(Xa.MustApprove);
        return;
      }
      if (v0(R, 18) / v0(u.valueRaw, 18) > 0.99) {
        v(Xa.Ok);
        return;
      }
      if (R < u.valueRaw) {
        v(Xa.MustIncrease);
        return;
      }
      v(Xa.No);
    },
    I = async () => {
      const R = await i();
      d(!0);
      try {
        (await tu.doApprove(p.token.tokenAddress, p.contract, R))
          .wait()
          .then(() => {
            d(!1), v(void 0);
          })
          .catch(() => {
            v(Xa.Error), d(!1);
          }),
          d(!0);
      } catch {
        v(Xa.Error), d(!1);
      }
    },
    k = async () => {
      P(!0);
      const R = (V) => {
        console.error(V), P(!1);
        const oe = LCe(V, void 0);
        _({ raw: V?.message, human: oe || "No data on this error." });
      };
      try {
        const V = await u.perform();
        V.wait()
          .then(() => {
            if (
              (N(V.hash),
              P(!1),
              u?.afterPerform && typeof u?.afterPerform == "function")
            )
              try {
                u.afterPerform();
              } catch (oe) {
                console.error(oe);
              }
          })
          .catch((oe) => {
            R(oe);
          });
      } catch (V) {
        R(V);
      }
    },
    L = (R, V, oe) => {
      const le = DCe[R];
      if (!le) {
        e(`action ${R} have no active definition`);
        return;
      }
      U(), l(le), f(V), m(oe), a(!0);
    },
    U = () => {
      a(!1),
        l(void 0),
        f(void 0),
        m(void 0),
        d(!1),
        v(void 0),
        S(!1),
        P(!1),
        N(void 0),
        _(void 0);
    },
    B = {
      opened: s,
      state: T,
      openProcessAction: L,
      closeProcessAction: () => {
        U();
      },
      processDefinition: o,
      process: u,
      approving: c,
      doApprove: I,
      confirmed: E,
      setConfirmed: S,
      finalizing: D,
      doFinalize: k,
      allowance: g,
      allowanceStatus: y,
      allowanceDefinition: p,
      error: x,
      success: A,
      paramsObject: M,
    };
  return G.jsx(Wh.Provider, { value: B, children: t });
};
function FCe() {
  const {
    allowanceStatus: t,
    allowanceDefinition: e,
    approving: n,
    doApprove: r,
  } = Z.useContext(Wh);
  return e?.token
    ? G.jsxs("div", {
        className: "mt-4 flex flex-column gap-2 lg:ml-2",
        hidden: t === Xa.No,
        children: [
          G.jsx("div", { children: "Approve:" }),
          G.jsxs("div", {
            className: "text-sm color-quiet flex flex-column gap-1",
            children: [
              G.jsxs("span", {
                className: "flex flex-wrap gap-1 align-items-center ",
                children: [
                  G.jsxs("span", { children: ["Token: ", e?.token?.name] }),
                  G.jsx("a", {
                    className: "color-quiet text-xs ",
                    href: `https://etherscan.io//address/${e?.token?.tokenAddress}`,
                    target: "_blank",
                    rel: "noreferrer",
                    children: G.jsx(Mg, { address: e?.token?.tokenAddress }),
                  }),
                ],
              }),
              G.jsxs("span", {
                className: "flex flex-wrap gap-1 align-items-center ",
                children: [
                  G.jsx("span", { children: "Spender:" }),
                  G.jsx("a", {
                    className: "color-quiet text-xs ",
                    href: `https://etherscan.io//address/${e?.contract}`,
                    target: "_blank",
                    rel: "noreferrer",
                    children: G.jsx(Mg, { address: e?.contract }),
                  }),
                ],
              }),
            ],
          }),
          G.jsxs("div", {
            children: [
              n &&
                G.jsxs("div", {
                  className: "overflow-hidden flex gap-2 color-quiet",
                  children: [G.jsx(KT, {}), " Check your wallet", " "],
                }),
              !n &&
                t === Xa.MustApprove &&
                G.jsx(iu, { className: "Btn", label: "Approve", onClick: r }),
              !n &&
                t === Xa.MustIncrease &&
                G.jsx(iu, { className: "Btn", label: "Approve+", onClick: r }),
              !n &&
                t === Xa.Error &&
                G.jsxs(G.Fragment, {
                  children: [
                    G.jsx(iu, {
                      className: "Btn",
                      label: "Approve",
                      onClick: r,
                    }),
                    G.jsx("span", {
                      className: " color-red text-xs ",
                      children: "An error occurred in your approving process",
                    }),
                  ],
                }),
              !n &&
                t === Xa.Ok &&
                G.jsxs("div", {
                  className: "color-green flex gap-2 align-items-center",
                  children: [
                    G.jsx("div", {
                      className: "w-1rem h-auto",
                      children: G.jsxs("svg", {
                        width: "25",
                        height: "24",
                        viewBox: "0 0 25 24",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [
                          G.jsx("circle", {
                            cx: "12.75",
                            cy: "12",
                            r: "9",
                            stroke: "currentcolor",
                            strokeWidth: "2",
                          }),
                          G.jsx("path", {
                            d: "M8.75 12L11.75 15L16.75 9",
                            stroke: "currentcolor",
                            strokeWidth: "2",
                          }),
                        ],
                      }),
                    }),
                    G.jsx("span", { children: "Approved" }),
                  ],
                }),
            ],
          }),
        ],
      })
    : G.jsx(G.Fragment, {});
}
function $Ce({
  legend: t,
  children: e,
  className: n,
  legendClassName: r = "",
}) {
  return G.jsxs("fieldset", {
    className: `${n || ""} border-dark-gray border-1 px-4 py-2 `,
    children: [
      G.jsx("legend", { className: `p-2  ${r || ""}`, children: t }),
      e,
    ],
  });
}
function UCe() {
  const { processDefinition: t, paramsObject: e } = Z.useContext(Wh),
    n = jT(t?.message, e),
    r = (i, s) => {
      const a = t?.fields[i]?.transform;
      return typeof a == "function" ? a(s) : s;
    };
  return G.jsx($Ce, {
    className: "p-2",
    legend: "Action overview",
    legendClassName: "color-quiet",
    children: G.jsxs("div", {
      className: "flex flex-column h-full justify-content-center gap-3 mb-2",
      children: [
        G.jsx("p", { className: "", dangerouslySetInnerHTML: { __html: n } }),
        G.jsx("div", {
          className: "flex flex-column gap-2 ",
          children: Object.entries(e)
            .filter(([i]) => t?.fields && !t?.fields[i]?.hide)
            .map(([i, s]) =>
              G.jsxs(
                "div",
                {
                  className: "flex justify-content-between",
                  children: [
                    G.jsx("label", {
                      className: "color-quiet",
                      children: t?.fields[i]?.label || i,
                    }),
                    G.jsx("div", {
                      className: "info-block min-w-10rem text-center",
                      children: r(i, s),
                    }),
                  ],
                },
                i
              )
            ),
        }),
      ],
    }),
  });
}
function jCe() {
  const {
      processDefinition: t,
      confirmed: e,
      setConfirmed: n,
      doFinalize: r,
      state: i,
      paramsObject: s,
    } = Z.useContext(Wh),
    a = () =>
      t?.confirm
        ? G.jsxs(G.Fragment, {
            children: [
              G.jsxs("div", {
                className: "flex gap-3 mb-2 align-items-center cursor-pointer",
                role: "button",
                onClick: () => n(!e),
                children: [
                  G.jsx("div", {
                    className: `${e ? "color-tonic" : "color-quiet"}`,
                    children: G.jsx("div", {
                      className: "w-1rem h-auto",
                      children: G.jsxs("svg", {
                        width: "25",
                        height: "24",
                        viewBox: "0 0 25 24",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [
                          G.jsx("circle", {
                            cx: "12.75",
                            cy: "12",
                            r: "9",
                            stroke: "currentcolor",
                            strokeWidth: "2",
                          }),
                          e &&
                            G.jsx("path", {
                              d: "M8.75 12L11.75 15L16.75 9",
                              stroke: "currentcolor",
                              strokeWidth: "2",
                            }),
                        ],
                      }),
                    }),
                  }),
                  G.jsx("div", { children: jT(t?.confirm, s) }),
                ],
              }),
              G.jsx("div", {
                className: "ml-4 text-sm color-quiet",
                children: "Confirm to finalize",
              }),
            ],
          })
        : G.jsx(G.Fragment, {});
  return G.jsxs(G.Fragment, {
    children: [
      G.jsx(a, {}),
      G.jsx(iu, {
        className: "Btn mt-4",
        onClick: r,
        disabled: i?.finalizeDisable,
        children: "Finalize",
      }),
    ],
  });
}
function HCe() {
  const { success: t } = Z.useContext(Wh);
  return G.jsxs("div", {
    className: "p-2 text-center flex flex-column gap-2",
    children: [
      G.jsx("div", {
        children: G.jsxs("svg", {
          width: "70",
          height: "70",
          className: "mx-auto",
          viewBox: "0 0 121 121",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          children: [
            G.jsx("circle", {
              cx: "60.9668",
              cy: "60.5",
              r: "45",
              fill: "#80FF77",
            }),
            G.jsx("path", {
              d: "M40.9668 60.5L55.9668 75.5L80.9668 45.5",
              stroke: "black",
              strokeWidth: "10",
            }),
          ],
        }),
      }),
      G.jsx("div", {
        className: "text-xl text-center color-green",
        children: "Transaction confirmed",
      }),
      G.jsxs("div", {
        className: "flex gap-2 align-items-center justify-content-center",
        children: [
          G.jsx("span", { className: "color-quiet", children: " tx link:" }),
          G.jsx("span", {
            className: "info-block p-1",
            children: G.jsx("a", {
              href: `https://etherscan.io//tx/${t}`,
              target: "_blank",
              rel: "noreferrer",
              children: G.jsx(Mg, { address: t }),
            }),
          }),
        ],
      }),
    ],
  });
}
function zCe() {
  const { error: t } = Z.useContext(Wh);
  return G.jsxs("div", {
    className: "p-2 text-center flex flex-column gap-2",
    children: [
      G.jsx("div", {
        children: G.jsx("svg", {
          width: "121",
          height: "121",
          viewBox: "0 0 121 121",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          children: G.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M105.967 60.5C105.967 85.3528 85.8196 105.5 60.9668 105.5C36.114 105.5 15.9668 85.3528 15.9668 60.5C15.9668 35.6472 36.114 15.5 60.9668 15.5C85.8196 15.5 105.967 35.6472 105.967 60.5ZM60.9668 67.5711L44.5023 84.0355L37.4313 76.9645L53.8957 60.5L37.4313 44.0355L44.5023 36.9645L60.9668 53.4289L77.4313 36.9645L84.5023 44.0355L68.0379 60.5L84.5023 76.9645L77.4313 84.0355L60.9668 67.5711Z",
            fill: "#D10000",
          }),
        }),
      }),
      G.jsx("div", {
        className: "text-xl text-center color-red",
        children: "Transaction has failed",
      }),
      G.jsxs("p", {
        className: "flex flex-column gap-2 align-items-center",
        children: [
          "Error : ",
          t.human,
          G.jsx("button", {
            className: "Btn Btn-nostyle color-quiet text-sm",
            onClick: () => navigator?.clipboard?.writeText(t.raw),
            children: G.jsxs("div", {
              className: "flex  align-items-center gap-1 ",
              children: [
                G.jsx("i", { className: "pi pi-copy" }),
                G.jsx("span", { children: " Copy raw error" }),
              ],
            }),
          }),
        ],
      }),
    ],
  });
}
function VCe() {
  return G.jsxs("div", {
    className: "text-center",
    children: [
      G.jsx("img", { src: "/images/icon/finalize.gif", alt: "Finalize" }),
      G.jsxs("div", {
        className: "color-quiet",
        children: [
          "Check your wallet ",
          G.jsx("br", {}),
          G.jsx("span", {
            className: "text-xs",
            children: "or The transaction on your wallet will soon appear",
          }),
        ],
      }),
    ],
  });
}
function GCe() {
  const {
      opened: t,
      closeProcessAction: e,
      processDefinition: n,
      process: r,
      state: i,
    } = Z.useContext(Wh),
    s = jT(n?.title, r?.params || {}),
    a = G.jsxs("div", {
      children: [
        r?.iconSrc &&
          G.jsx("img", {
            src: r?.iconSrc,
            alt: "logo",
            className: "staking-asset-logo w-2rem mr-2",
          }),
        G.jsx("span", { className: "vertical-align-super", children: s }),
      ],
    });
  return G.jsx(N1, {
    header: a,
    closable: !0,
    visible: t,
    className: "max-w-45rem",
    style: { width: "60vw" },
    breakpoints: { "960px": "80vw", "641px": "96vw" },
    onHide: () => e(),
    closeOnEscape: !0,
    dismissableMask: !0,
    children: G.jsxs("div", {
      className: "px-2",
      children: [
        G.jsx(UCe, {}),
        G.jsx(FCe, {}),
        G.jsxs("div", {
          className: "border-top-1 border-quiet mt-4 pt-4 lg:ml-2",
          children: [
            i.displayFinalize && G.jsx(jCe, {}),
            i.displayFinalizing && G.jsx(VCe, {}),
            i.displaySuccess && G.jsx(HCe, {}),
            i.displayError && G.jsx(zCe, {}),
          ],
        }),
      ],
    }),
  });
}
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var mq = qCe,
  XL = KCe,
  WCe = Object.prototype.toString,
  Pv = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function qCe(t, e) {
  if (typeof t != "string")
    throw new TypeError("argument str must be a string");
  for (var n = {}, r = e || {}, i = r.decode || XCe, s = 0; s < t.length; ) {
    var a = t.indexOf("=", s);
    if (a === -1) break;
    var o = t.indexOf(";", s);
    if (o === -1) o = t.length;
    else if (o < a) {
      s = t.lastIndexOf(";", a - 1) + 1;
      continue;
    }
    var l = t.slice(s, a).trim();
    if (n[l] === void 0) {
      var u = t.slice(a + 1, o).trim();
      u.charCodeAt(0) === 34 && (u = u.slice(1, -1)), (n[l] = QCe(u, i));
    }
    s = o + 1;
  }
  return n;
}
function KCe(t, e, n) {
  var r = n || {},
    i = r.encode || ZCe;
  if (typeof i != "function") throw new TypeError("option encode is invalid");
  if (!Pv.test(t)) throw new TypeError("argument name is invalid");
  var s = i(e);
  if (s && !Pv.test(s)) throw new TypeError("argument val is invalid");
  var a = t + "=" + s;
  if (r.maxAge != null) {
    var o = r.maxAge - 0;
    if (isNaN(o) || !isFinite(o))
      throw new TypeError("option maxAge is invalid");
    a += "; Max-Age=" + Math.floor(o);
  }
  if (r.domain) {
    if (!Pv.test(r.domain)) throw new TypeError("option domain is invalid");
    a += "; Domain=" + r.domain;
  }
  if (r.path) {
    if (!Pv.test(r.path)) throw new TypeError("option path is invalid");
    a += "; Path=" + r.path;
  }
  if (r.expires) {
    var l = r.expires;
    if (!YCe(l) || isNaN(l.valueOf()))
      throw new TypeError("option expires is invalid");
    a += "; Expires=" + l.toUTCString();
  }
  if (
    (r.httpOnly && (a += "; HttpOnly"),
    r.secure && (a += "; Secure"),
    r.partitioned && (a += "; Partitioned"),
    r.priority)
  ) {
    var u =
      typeof r.priority == "string" ? r.priority.toLowerCase() : r.priority;
    switch (u) {
      case "low":
        a += "; Priority=Low";
        break;
      case "medium":
        a += "; Priority=Medium";
        break;
      case "high":
        a += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (r.sameSite) {
    var f =
      typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite;
    switch (f) {
      case !0:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}
function XCe(t) {
  return t.indexOf("%") !== -1 ? decodeURIComponent(t) : t;
}
function ZCe(t) {
  return encodeURIComponent(t);
}
function YCe(t) {
  return WCe.call(t) === "[object Date]" || t instanceof Date;
}
function QCe(t, e) {
  try {
    return e(t);
  } catch {
    return t;
  }
}
function JCe() {
  const t = typeof global > "u" ? void 0 : global.TEST_HAS_DOCUMENT_COOKIE;
  return typeof t == "boolean"
    ? t
    : typeof document == "object" && typeof document.cookie == "string";
}
function eke(t) {
  return typeof t == "string"
    ? mq(t)
    : typeof t == "object" && t !== null
    ? t
    : {};
}
function e4(t, e = {}) {
  const n = tke(t);
  if (!e.doNotParse)
    try {
      return JSON.parse(n);
    } catch {}
  return t;
}
function tke(t) {
  return t && t[0] === "j" && t[1] === ":" ? t.substr(2) : t;
}
class nke {
  constructor(e, n = {}) {
    (this.changeListeners = []),
      (this.HAS_DOCUMENT_COOKIE = !1),
      (this.update = () => {
        if (!this.HAS_DOCUMENT_COOKIE) return;
        const i = this.cookies;
        (this.cookies = mq(document.cookie)), this._checkChanges(i);
      });
    const r = typeof document > "u" ? "" : document.cookie;
    (this.cookies = eke(e || r)),
      (this.defaultSetOptions = n),
      (this.HAS_DOCUMENT_COOKIE = JCe());
  }
  _emitChange(e) {
    for (let n = 0; n < this.changeListeners.length; ++n)
      this.changeListeners[n](e);
  }
  _checkChanges(e) {
    new Set(Object.keys(e).concat(Object.keys(this.cookies))).forEach((r) => {
      e[r] !== this.cookies[r] &&
        this._emitChange({ name: r, value: e4(this.cookies[r]) });
    });
  }
  _startPolling() {
    this.pollingInterval = setInterval(this.update, 300);
  }
  _stopPolling() {
    this.pollingInterval && clearInterval(this.pollingInterval);
  }
  get(e, n = {}) {
    return n.doNotUpdate || this.update(), e4(this.cookies[e], n);
  }
  getAll(e = {}) {
    e.doNotUpdate || this.update();
    const n = {};
    for (let r in this.cookies) n[r] = e4(this.cookies[r], e);
    return n;
  }
  set(e, n, r) {
    r
      ? (r = Object.assign(Object.assign({}, this.defaultSetOptions), r))
      : (r = this.defaultSetOptions);
    const i = typeof n == "string" ? n : JSON.stringify(n);
    (this.cookies = Object.assign(Object.assign({}, this.cookies), { [e]: i })),
      this.HAS_DOCUMENT_COOKIE && (document.cookie = XL(e, i, r)),
      this._emitChange({ name: e, value: n, options: r });
  }
  remove(e, n) {
    const r = (n = Object.assign(
      Object.assign(Object.assign({}, this.defaultSetOptions), n),
      { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 }
    ));
    (this.cookies = Object.assign({}, this.cookies)),
      delete this.cookies[e],
      this.HAS_DOCUMENT_COOKIE && (document.cookie = XL(e, "", r)),
      this._emitChange({ name: e, value: void 0, options: n });
  }
  addChangeListener(e) {
    this.changeListeners.push(e),
      this.HAS_DOCUMENT_COOKIE &&
        this.changeListeners.length === 1 &&
        (typeof window == "object" && "cookieStore" in window
          ? window.cookieStore.addEventListener("change", this.update)
          : this._startPolling());
  }
  removeChangeListener(e) {
    const n = this.changeListeners.indexOf(e);
    n >= 0 && this.changeListeners.splice(n, 1),
      this.HAS_DOCUMENT_COOKIE &&
        this.changeListeners.length === 0 &&
        (typeof window == "object" && "cookieStore" in window
          ? window.cookieStore.removeEventListener("change", this.update)
          : this._stopPolling());
  }
}
var gq = { exports: {} },
  vr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ks = typeof Symbol == "function" && Symbol.for,
  vS = ks ? Symbol.for("react.element") : 60103,
  bS = ks ? Symbol.for("react.portal") : 60106,
  E6 = ks ? Symbol.for("react.fragment") : 60107,
  x6 = ks ? Symbol.for("react.strict_mode") : 60108,
  T6 = ks ? Symbol.for("react.profiler") : 60114,
  S6 = ks ? Symbol.for("react.provider") : 60109,
  A6 = ks ? Symbol.for("react.context") : 60110,
  wS = ks ? Symbol.for("react.async_mode") : 60111,
  C6 = ks ? Symbol.for("react.concurrent_mode") : 60111,
  k6 = ks ? Symbol.for("react.forward_ref") : 60112,
  I6 = ks ? Symbol.for("react.suspense") : 60113,
  rke = ks ? Symbol.for("react.suspense_list") : 60120,
  O6 = ks ? Symbol.for("react.memo") : 60115,
  P6 = ks ? Symbol.for("react.lazy") : 60116,
  ike = ks ? Symbol.for("react.block") : 60121,
  ske = ks ? Symbol.for("react.fundamental") : 60117,
  ake = ks ? Symbol.for("react.responder") : 60118,
  oke = ks ? Symbol.for("react.scope") : 60119;
function Uo(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case vS:
        switch (((t = t.type), t)) {
          case wS:
          case C6:
          case E6:
          case T6:
          case x6:
          case I6:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case A6:
              case k6:
              case P6:
              case O6:
              case S6:
                return t;
              default:
                return e;
            }
        }
      case bS:
        return e;
    }
  }
}
function yq(t) {
  return Uo(t) === C6;
}
vr.AsyncMode = wS;
vr.ConcurrentMode = C6;
vr.ContextConsumer = A6;
vr.ContextProvider = S6;
vr.Element = vS;
vr.ForwardRef = k6;
vr.Fragment = E6;
vr.Lazy = P6;
vr.Memo = O6;
vr.Portal = bS;
vr.Profiler = T6;
vr.StrictMode = x6;
vr.Suspense = I6;
vr.isAsyncMode = function (t) {
  return yq(t) || Uo(t) === wS;
};
vr.isConcurrentMode = yq;
vr.isContextConsumer = function (t) {
  return Uo(t) === A6;
};
vr.isContextProvider = function (t) {
  return Uo(t) === S6;
};
vr.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === vS;
};
vr.isForwardRef = function (t) {
  return Uo(t) === k6;
};
vr.isFragment = function (t) {
  return Uo(t) === E6;
};
vr.isLazy = function (t) {
  return Uo(t) === P6;
};
vr.isMemo = function (t) {
  return Uo(t) === O6;
};
vr.isPortal = function (t) {
  return Uo(t) === bS;
};
vr.isProfiler = function (t) {
  return Uo(t) === T6;
};
vr.isStrictMode = function (t) {
  return Uo(t) === x6;
};
vr.isSuspense = function (t) {
  return Uo(t) === I6;
};
vr.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === E6 ||
    t === C6 ||
    t === T6 ||
    t === x6 ||
    t === I6 ||
    t === rke ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === P6 ||
        t.$$typeof === O6 ||
        t.$$typeof === S6 ||
        t.$$typeof === A6 ||
        t.$$typeof === k6 ||
        t.$$typeof === ske ||
        t.$$typeof === ake ||
        t.$$typeof === oke ||
        t.$$typeof === ike))
  );
};
vr.typeOf = Uo;
gq.exports = vr;
var lke = gq.exports,
  vq = lke,
  uke = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  cke = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  bq = {};
bq[vq.ForwardRef] = uke;
bq[vq.Memo] = cke;
const fke = Z.createContext(new nke());
function dke() {
  return (
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u"
  );
}
function wq(t) {
  const e = Z.useContext(fke);
  if (!e) throw new Error("Missing <CookiesProvider>");
  const [n, r] = Z.useState(() => e.getAll());
  dke() &&
    Z.useLayoutEffect(() => {
      function o() {
        const l = e.getAll({ doNotUpdate: !0 });
        hke(t || null, l, n) && r(l);
      }
      return (
        e.addChangeListener(o),
        () => {
          e.removeChangeListener(o);
        }
      );
    }, [e, n]);
  const i = Z.useMemo(() => e.set.bind(e), [e]),
    s = Z.useMemo(() => e.remove.bind(e), [e]),
    a = Z.useMemo(() => e.update.bind(e), [e]);
  return [n, i, s, a];
}
function hke(t, e, n) {
  if (!t) return !0;
  for (let r of t) if (e[r] !== n[r]) return !0;
  return !1;
}
function Jx() {
  return (
    (Jx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Jx.apply(this, arguments)
  );
}
var N6 = Z.forwardRef(function (t, e) {
  var n = Z.useRef(null),
    r = Z.useRef(null),
    i = Z.useRef(null),
    s = Z.useRef(null),
    a = Z.useRef(!1),
    o = Z.useRef(!1),
    l = Z.useRef(null),
    u = Z.useRef(null),
    f = Z.useRef(null),
    c = Z.useRef(null),
    d = Z.useRef(null),
    p = Z.useRef(!1),
    m = function () {
      var N = getComputedStyle(n.current),
        M = getComputedStyle(i.current),
        T = it.getHeight(n.current) - parseInt(M.height, 10);
      N["max-height"] !== "none" &&
        T === 0 &&
        (r.current.offsetHeight + parseInt(M.height, 10) >
        parseInt(N["max-height"], 10)
          ? (n.current.style.height = N["max-height"])
          : (n.current.style.height =
              r.current.offsetHeight +
              parseFloat(N.paddingTop) +
              parseFloat(N.paddingBottom) +
              parseFloat(N.borderTopWidth) +
              parseFloat(N.borderBottomWidth) +
              "px"));
    },
    g = function () {
      var N = r.current.scrollWidth,
        M = r.current.clientWidth,
        T = (n.current.clientHeight - i.current.clientHeight) * -1;
      f.current = M / N;
      var O = r.current.scrollHeight,
        I = r.current.clientHeight,
        k = (n.current.clientWidth - s.current.clientWidth) * -1;
      (c.current = I / O),
        (d.current = window.requestAnimationFrame(function () {
          f.current >= 1
            ? it.addClass(i.current, "p-scrollpanel-hidden")
            : (it.removeClass(i.current, "p-scrollpanel-hidden"),
              (i.current.style.cssText =
                "width:" +
                Math.max(f.current * 100, 10) +
                "%; left:" +
                (r.current.scrollLeft / N) * 100 +
                "%;bottom:" +
                T +
                "px;")),
            c.current >= 1
              ? it.addClass(s.current, "p-scrollpanel-hidden")
              : (it.removeClass(s.current, "p-scrollpanel-hidden"),
                (s.current.style.cssText =
                  "height:" +
                  Math.max(c.current * 100, 10) +
                  "%; top: calc(" +
                  (r.current.scrollTop / O) * 100 +
                  "% - " +
                  i.current.clientHeight +
                  "px);right:" +
                  k +
                  "px;"));
        }));
    },
    w = function (N) {
      (o.current = !0),
        (u.current = N.pageY),
        it.addClass(s.current, "p-scrollpanel-grabbed"),
        it.addClass(document.body, "p-scrollpanel-grabbed"),
        document.addEventListener("mousemove", v),
        document.addEventListener("mouseup", D),
        N.preventDefault();
    },
    y = function (N) {
      (a.current = !0),
        (l.current = N.pageX),
        it.addClass(i.current, "p-scrollpanel-grabbed"),
        it.addClass(document.body, "p-scrollpanel-grabbed"),
        document.addEventListener("mousemove", v),
        document.addEventListener("mouseup", D),
        N.preventDefault();
    },
    v = function (N) {
      a.current ? E(N) : (o.current || E(N), S(N));
    },
    E = function (N) {
      var M = N.pageX - l.current;
      (l.current = N.pageX),
        (d.current = window.requestAnimationFrame(function () {
          r.current.scrollLeft += M / f.current;
        }));
    },
    S = function (N) {
      var M = N.pageY - u.current;
      (u.current = N.pageY),
        (d.current = window.requestAnimationFrame(function () {
          r.current.scrollTop += M / c.current;
        }));
    },
    D = function A(N) {
      it.removeClass(s.current, "p-scrollpanel-grabbed"),
        it.removeClass(i.current, "p-scrollpanel-grabbed"),
        it.removeClass(document.body, "p-scrollpanel-grabbed"),
        document.removeEventListener("mousemove", v),
        document.removeEventListener("mouseup", A),
        (a.current = !1),
        (o.current = !1);
    },
    P = function () {
      g();
    };
  f1(function () {
    g(), window.addEventListener("resize", g), m(), (p.current = !0);
  }),
    bl(function () {
      p.current && window.removeEventListener("resize", g),
        d.current && window.cancelAnimationFrame(d.current);
    }),
    Z.useImperativeHandle(e, function () {
      return {
        props: t,
        refresh: P,
        getElement: function () {
          return n.current;
        },
        getContent: function () {
          return r.current;
        },
        getXBar: function () {
          return i.current;
        },
        getYBar: function () {
          return s.current;
        },
      };
    });
  var x = Vn.findDiffKeys(t, N6.defaultProps),
    _ = ji("p-scrollpanel p-component", t.className);
  return Z.createElement(
    "div",
    Jx({ ref: n, id: t.id, className: _, style: t.style }, x),
    Z.createElement(
      "div",
      { className: "p-scrollpanel-wrapper" },
      Z.createElement(
        "div",
        {
          ref: r,
          className: "p-scrollpanel-content",
          onScroll: g,
          onMouseEnter: g,
        },
        t.children
      )
    ),
    Z.createElement("div", {
      ref: i,
      className: "p-scrollpanel-bar p-scrollpanel-bar-x",
      onMouseDown: y,
    }),
    Z.createElement("div", {
      ref: s,
      className: "p-scrollpanel-bar p-scrollpanel-bar-y",
      onMouseDown: w,
    })
  );
});
N6.displayName = "ScrollPanel";
N6.defaultProps = {
  __TYPE: "ScrollPanel",
  id: null,
  style: null,
  className: null,
};
function pke() {
  const [, t] = wq(["accept_disclaimer"]),
    e = Z.useRef(null),
    n = () => {
      let r = 30,
        i = new Date();
      i.setTime(i.getTime() + r * 24 * 60 * 60 * 1e3),
        t("accept_disclaimer", "true", { path: "/", expires: i });
    };
  return G.jsx(N1, {
    header: "Convergence services disclaimer",
    headerClassName: "color-tonic",
    visible: !0,
    style: { width: "70vw", height: "90dvh" },
    onHide: () => {},
    breakpoints: { "640px": "90vw" },
    modal: !0,
    blockScroll: !1,
    closable: !1,
    children: G.jsxs("div", {
      className: "mt-4 overflow-hidden mb-6",
      children: [
        G.jsx(N6, {
          ref: e,
          style: { height: "71dvh" },
          children: G.jsxs("div", {
            className: "flex flex-column gap-2 ",
            children: [
              G.jsx("h1", {
                className: "text-xl",
                children: "Terms of Use for Convergence protocol",
              }),
              G.jsxs("p", {
                className: "color-tonic",
                children: [
                  "Please read this Agreement set out herein carefully before clicking the ",
                  G.jsx("b", { children: "“I AGREE”" }),
                  " button on the designated web address.",
                ],
              }),
              G.jsx("h2", { children: "1. Introduction" }),
              G.jsxs("p", {
                className: "",
                children: [
                  'Welcome to Convergence protocol, a decentralized finance platform. This document, the "',
                  G.jsx("strong", {
                    className: "font-bold",
                    children: "Terms of Use",
                  }),
                  '", governs your access to and use of our services, including any content, functionality, and services offered on or through:',
                  " ",
                  G.jsx("a", {
                    href: "https://cvg.finance/",
                    target: "_blank",
                    rel: "noreferrer",
                    children: "cvg.finance",
                  }),
                  " ",
                  "(hereafter referred to as the “",
                  G.jsx("strong", { className: "font-bold", children: "App" }),
                  "”).",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  'The purpose of these Terms is to outline the legal agreement between you (the user) and Convergence protocol (hereafter referred to as "',
                  G.jsx("strong", { className: "font-bold", children: "we" }),
                  '", "',
                  G.jsx("strong", { className: "font-bold", children: "us" }),
                  '", or "',
                  G.jsx("strong", { className: "font-bold", children: "our" }),
                  '"). By accessing or using our services, you acknowledge that you have read, understood, and agreed to be bound by these Terms, as well as our Privacy Policy and any other policies or agreements referenced herein.',
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  G.jsx("strong", {
                    className: "font-bold",
                    children:
                      "It's important to note that these Terms constitute a legally binding agreement between you and Convergence protocol. If you do not agree with any part of these Terms, you must not access or use our services.",
                  }),
                ],
              }),
              G.jsx("h2", { children: "2. Acceptance of Terms" }),
              G.jsxs("p", {
                className: "",
                children: [
                  "Your access to or use of the services offered by Convergence protocol serves as your explicit confirmation of acceptance of these Terms and your agreement to adhere to them. This acceptance constitutes a binding contract between you and Convergence protocol.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "To engage with our services, you must have attained the age of majority in your jurisdiction, thereby possessing the legal capacity to enter into binding contracts. By agreeing to these Terms, you assert that you meet this age criterion. If you represent an organization or entity in accessing our services, you warrant that you have the required authority to bind said organization or entity to these Terms.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "We reserve the right to revise or update these Terms at any given time, and such modifications become effective immediately upon their posting. These changes apply to all subsequent accesses and use of our services. We recommend that you regularly review these Terms to stay informed of any amendments, as your continued use of our services post-update signifies your acceptance of the revised Terms.",
                ],
              }),
              G.jsx("h2", { children: "3. User compliance and restrictions" }),
              G.jsxs("div", {
                className: "",
                children: [
                  'Access to the App is provided on an "as is" and "as available" basis. We cannot guarantee continuous availability or uninterrupted operation of the App or its content. Access may occasionally be interrupted, suspended, or restricted due to factors like faults, errors, unforeseen circumstances, or scheduled maintenance.',
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "We reserve the right to limit the App's availability to any individual, geographic area, or jurisdiction at our discretion. Currently, access is restricted for individuals accessing the App from the following jurisdictions:",
                  " ",
                  G.jsx("strong", { className: "font-bold", children: "USA" }),
                  ", ",
                  G.jsx("strong", {
                    className: "font-bold",
                    children: "China",
                  }),
                  ",",
                  G.jsx("strong", {
                    className: "font-bold",
                    children: "Syria",
                  }),
                  ", ",
                  G.jsx("strong", { className: "font-bold", children: "Iran" }),
                  ", and",
                  " ",
                  G.jsx("strong", {
                    className: "font-bold",
                    children: "North Korea",
                  }),
                  ".",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "We may modify or remove the content of the App at any time. Some content may be outdated at any given time, and we are not obligated to update it. We do not assure the App or any of its content will be error-free or without omissions.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "Your access and use of the App can be terminated by us at any time and at our sole discretion. We may particularly suspend or disable your access to the App if we deem it reasonable, for example, due to a breach of these Terms or for security reasons.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "By using the App, you commit to comply with all relevant local and international legal requirements, rules, and regulations applicable to your engagement with the App. The following actions are strictly forbidden:",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  G.jsxs("ol", {
                    className: "ml-4",
                    children: [
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "1. Utilizing the App or any part of its content for commercial purposes unless explicitly authorized by us.",
                      }),
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "2. Engaging in any form of hacking, unauthorized modifications or access, or introducing harmful code into the App.",
                      }),
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "3. Replicating, modifying, transmitting, adapting, or sharing any portion of the App or its content in any form.",
                      }),
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "4. Employing the App for any illegal activities.",
                      }),
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "5. Any actions that could interrupt or adversely affect the normal functioning of the App.",
                      }),
                      G.jsx("li", {
                        className: "mb-2",
                        children:
                          "6. Concealing or altering the IP address of your accessing device, or taking steps to prevent the correct identification of your IP address while using the App.",
                      }),
                    ],
                  }),
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "You are responsible for ensuring that your use of the Application does not infringe on the rights of others or the operation of the Application. Any unauthorized use may result in termination of your access and legal action.",
                ],
              }),
              G.jsx("h2", { children: "4. User responsibilities" }),
              G.jsxs("p", {
                className: "",
                children: [
                  "As a user of Convergence protocol, accessible via",
                  " ",
                  G.jsx("a", {
                    target: "_blank",
                    rel: "noreferrer",
                    href: "https://cvg.finance/",
                    children: "cvg.finance",
                  }),
                  ", you assume specific responsibilities to ensure a secure and effective use of the platform.",
                ],
              }),
              G.jsx("h3", {
                className: "color-tonic",
                children: "4.1. Security and System configuration",
              }),
              G.jsx("p", {
                className: "",
                children:
                  "You are responsible for securing your information technology, computer programs, and the material you use to access our services. This responsibility includes the use of your own virus protection software. We recommend regularly updating your security software and remaining vigilant against potential security threats.",
              }),
              G.jsx("h3", {
                className: "color-tonic",
                children: "4.2. Platform security efforts",
              }),
              G.jsx("p", {
                className: "",
                children:
                  "While we strive to maintain a secure, efficient, and bug-free environment on our platform, we cannot guarantee complete security or immunity from bugs or viruses. We employ the best efforts in terms of security, especially regarding the front-end of our platform, to provide a safe user experience. This includes regular updates, security audits, and monitoring to address potential vulnerabilities promptly.",
              }),
              G.jsx("h3", {
                className: "color-tonic",
                children: "4.3. Limitation of liability",
              }),
              G.jsx("p", {
                className: "",
                children:
                  "Despite our best efforts in securing the platform, we cannot be held liable for any damage or loss resulting from security breaches, bugs, or viruses that may occur despite our preventive measures. Users should acknowledge this risk and take personal measures to safeguard their data and assets when interacting with Convergence protocol.",
              }),
              G.jsx("h2", { children: "5. Risks acknowledgment" }),
              G.jsxs("p", {
                children: [
                  'By using the App, you acknowledge that you have been informed of and understand the risks associated with its use. For a detailed explanation of these risks, please refer to our separate document titled "',
                  G.jsx("a", {
                    target: "_blank",
                    rel: "noreferrer",
                    href: "https://cvg.finance/2024-01-18-Convergence-Protocol-Assumption-of-Risks.pdf",
                    children: "Assumption of risks",
                  }),
                  '." This document provides comprehensive information about potential risks and should be read carefully to ensure a full understanding of the terms and conditions related to the use of the Application. Your continued use of the App signifies your acceptance of these risks and the terms outlined in the Assumption of risks document',
                ],
              }),
              G.jsx("h2", {
                children: "6. Ownership and use of Intellectual Property",
              }),
              G.jsxs("p", {
                children: [
                  "This App and all of its contents, including texts, graphics, logos, and software, are Our exclusive property, protected under intellectual property laws. The rights to all content, including but not limited to copyright and trademarks, are expressly reserved.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "The domain name",
                  " ",
                  G.jsx("a", {
                    target: "_blank",
                    rel: "noreferrer",
                    href: "https://cvg.finance",
                    children: "cvg.finance",
                  }),
                  " ",
                  "is a unique identifier of our organization. Its use on any other website or digital platform is strictly prohibited without our explicit written permission.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "You agree to refrain from engaging in any activity that involves monitoring, utilizing, or replicating content from our web pages without our prior written consent. Unauthorized activities, including copying or reproducing content, may result in legal action.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "While you maintain copyright ownership over the data you upload or submit to the Application, you hereby grant us an irrevocable, worldwide, royalty-free license to use, copy, distribute, publish, and transmit this data in any form we deem appropriate.",
                ],
              }),
              G.jsx("h2", { children: "7. Privacy policy" }),
              G.jsxs("p", {
                children: [
                  'By using the App, you agree to the terms of our Privacy Policy, which is outlined in a separate document titled "Privacy Policy." This document details how we collect, use, protect, and share your personal information in connection with your use of the App. It is essential that you review our Privacy Policy to understand our practices.',
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "Your continued use of the Application indicates your consent to the practices described in the Privacy Policy and any updates to it. The Privacy Policy is an integral part of these terms and can be accessed",
                  " ",
                  G.jsx("a", {
                    target: "_blank",
                    rel: "noreferrer",
                    href: "https://cvg.finance/2024-01-24-Convergence-protocol-Privacy-Policy.pdf",
                    children: "there",
                  }),
                  ".",
                ],
              }),
              G.jsx("h2", { children: "8. Contact information" }),
              G.jsxs("p", {
                children: [
                  "For any inquiries or assistance related to the Convergence protocol, users are encouraged to reach out to our support team. We are committed to providing guidance and resolving issues in a timely and efficient manner.",
                  G.jsx("br", {}),
                  G.jsx("br", {}),
                  "Contact us via email (",
                  G.jsx("a", {
                    href: "mailto:contact@cvg.finance",
                    children: "contact@cvg.finance",
                  }),
                  ") or visit our community discord for additional support and information. Our team is dedicated to ensuring a positive and supportive experience for all users of the Convergence protocol.",
                ],
              }),
              G.jsx("div", {
                className: "my-2 color-quiet",
                children: "Thank you for your attention",
              }),
            ],
          }),
        }),
        G.jsxs("div", {
          className:
            "my-3 flex-column sm:flex-row flex flex-warp align-items-center gap-1",
          children: [
            G.jsx("div", {
              children: G.jsx(iu, {
                label: "I Agree",
                onClick: n,
                className: "w-auto Btn white-space-nowrap",
              }),
            }),
            G.jsx("small", {
              className: "color-quiet text-xs",
              children: "Your response will be stored in a cookie for 30 days",
            }),
          ],
        }),
      ],
    }),
  });
}
const _q = Object.prototype.toString;
function _S(t) {
  switch (_q.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return tf(t, Error);
  }
}
function D1(t, e) {
  return _q.call(t) === `[object ${e}]`;
}
function ES(t) {
  return D1(t, "ErrorEvent");
}
function ZL(t) {
  return D1(t, "DOMError");
}
function mke(t) {
  return D1(t, "DOMException");
}
function Xu(t) {
  return D1(t, "String");
}
function xS(t) {
  return t === null || (typeof t != "object" && typeof t != "function");
}
function t1(t) {
  return D1(t, "Object");
}
function D6(t) {
  return typeof Event < "u" && tf(t, Event);
}
function gke(t) {
  return typeof Element < "u" && tf(t, Element);
}
function yke(t) {
  return D1(t, "RegExp");
}
function TS(t) {
  return !!(t && t.then && typeof t.then == "function");
}
function vke(t) {
  return (
    t1(t) &&
    "nativeEvent" in t &&
    "preventDefault" in t &&
    "stopPropagation" in t
  );
}
function Eq(t) {
  return typeof t == "number" && t !== t;
}
function tf(t, e) {
  try {
    return t instanceof e;
  } catch {
    return !1;
  }
}
function xq(t) {
  return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue));
}
function x0(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e
    ? t
    : `${t.slice(0, e)}...`;
}
function YL(t, e) {
  if (!Array.isArray(t)) return "";
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    try {
      xq(i) ? n.push("[VueViewModel]") : n.push(String(i));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(e);
}
function bke(t, e, n = !1) {
  return Xu(t)
    ? yke(e)
      ? e.test(t)
      : Xu(e)
      ? n
        ? t === e
        : t.includes(e)
      : !1
    : !1;
}
function Xy(t, e = [], n = !1) {
  return e.some((r) => bke(t, r, n));
}
function wke(t, e, n = 250, r, i, s, a) {
  if (
    !s.exception ||
    !s.exception.values ||
    !a ||
    !tf(a.originalException, Error)
  )
    return;
  const o =
    s.exception.values.length > 0
      ? s.exception.values[s.exception.values.length - 1]
      : void 0;
  o &&
    (s.exception.values = _ke(
      e9(t, e, i, a.originalException, r, s.exception.values, o, 0),
      n
    ));
}
function e9(t, e, n, r, i, s, a, o) {
  if (s.length >= n + 1) return s;
  let l = [...s];
  if (tf(r[i], Error)) {
    QL(a, o);
    const u = t(e, r[i]),
      f = l.length;
    JL(u, i, f, o), (l = e9(t, e, n, r[i], i, [u, ...l], u, f));
  }
  return (
    Array.isArray(r.errors) &&
      r.errors.forEach((u, f) => {
        if (tf(u, Error)) {
          QL(a, o);
          const c = t(e, u),
            d = l.length;
          JL(c, `errors[${f}]`, d, o), (l = e9(t, e, n, u, i, [c, ...l], c, d));
        }
      }),
    l
  );
}
function QL(t, e) {
  (t.mechanism = t.mechanism || { type: "generic", handled: !0 }),
    (t.mechanism = { ...t.mechanism, is_exception_group: !0, exception_id: e });
}
function JL(t, e, n, r) {
  (t.mechanism = t.mechanism || { type: "generic", handled: !0 }),
    (t.mechanism = {
      ...t.mechanism,
      type: "chained",
      source: e,
      exception_id: n,
      parent_id: r,
    });
}
function _ke(t, e) {
  return t.map((n) => (n.value && (n.value = x0(n.value, e)), n));
}
function Nv(t) {
  return t && t.Math == Math ? t : void 0;
}
const wr =
  (typeof globalThis == "object" && Nv(globalThis)) ||
  (typeof window == "object" && Nv(window)) ||
  (typeof self == "object" && Nv(self)) ||
  (typeof global == "object" && Nv(global)) ||
  (function () {
    return this;
  })() ||
  {};
function R6() {
  return wr;
}
function Tq(t, e, n) {
  const r = n || wr,
    i = (r.__SENTRY__ = r.__SENTRY__ || {});
  return i[t] || (i[t] = e());
}
const bb = R6(),
  Eke = 80;
function n1(t, e = {}) {
  if (!t) return "<unknown>";
  try {
    let n = t;
    const r = 5,
      i = [];
    let s = 0,
      a = 0;
    const o = " > ",
      l = o.length;
    let u;
    const f = Array.isArray(e) ? e : e.keyAttrs,
      c = (!Array.isArray(e) && e.maxStringLength) || Eke;
    for (
      ;
      n &&
      s++ < r &&
      ((u = xke(n, f)),
      !(u === "html" || (s > 1 && a + i.length * l + u.length >= c)));

    )
      i.push(u), (a += u.length), (n = n.parentNode);
    return i.reverse().join(o);
  } catch {
    return "<unknown>";
  }
}
function xke(t, e) {
  const n = t,
    r = [];
  let i, s, a, o, l;
  if (!n || !n.tagName) return "";
  r.push(n.tagName.toLowerCase());
  const u =
    e && e.length
      ? e.filter((c) => n.getAttribute(c)).map((c) => [c, n.getAttribute(c)])
      : null;
  if (u && u.length)
    u.forEach((c) => {
      r.push(`[${c[0]}="${c[1]}"]`);
    });
  else if ((n.id && r.push(`#${n.id}`), (i = n.className), i && Xu(i)))
    for (s = i.split(/\s+/), l = 0; l < s.length; l++) r.push(`.${s[l]}`);
  const f = ["aria-label", "type", "name", "title", "alt"];
  for (l = 0; l < f.length; l++)
    (a = f[l]), (o = n.getAttribute(a)), o && r.push(`[${a}="${o}"]`);
  return r.join("");
}
function Tke() {
  try {
    return bb.document.location.href;
  } catch {
    return "";
  }
}
function Ske(t) {
  return bb.document && bb.document.querySelector
    ? bb.document.querySelector(t)
    : null;
}
const R1 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  Ake = "Sentry Logger ",
  t9 = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  nw = {};
function M6(t) {
  if (!("console" in wr)) return t();
  const e = wr.console,
    n = {},
    r = Object.keys(nw);
  r.forEach((i) => {
    const s = nw[i];
    (n[i] = e[i]), (e[i] = s);
  });
  try {
    return t();
  } finally {
    r.forEach((i) => {
      e[i] = n[i];
    });
  }
}
function Cke() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0;
    },
    disable: () => {
      t = !1;
    },
    isEnabled: () => t,
  };
  return (
    R1
      ? t9.forEach((n) => {
          e[n] = (...r) => {
            t &&
              M6(() => {
                wr.console[n](`${Ake}[${n}]:`, ...r);
              });
          };
        })
      : t9.forEach((n) => {
          e[n] = () => {};
        }),
    e
  );
}
const Xe = Cke(),
  kke = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Ike(t) {
  return t === "http" || t === "https";
}
function Zy(t, e = !1) {
  const {
    host: n,
    path: r,
    pass: i,
    port: s,
    projectId: a,
    protocol: o,
    publicKey: l,
  } = t;
  return `${o}://${l}${e && i ? `:${i}` : ""}@${n}${s ? `:${s}` : ""}/${
    r && `${r}/`
  }${a}`;
}
function Oke(t) {
  const e = kke.exec(t);
  if (!e) {
    M6(() => {
      console.error(`Invalid Sentry Dsn: ${t}`);
    });
    return;
  }
  const [n, r, i = "", s, a = "", o] = e.slice(1);
  let l = "",
    u = o;
  const f = u.split("/");
  if ((f.length > 1 && ((l = f.slice(0, -1).join("/")), (u = f.pop())), u)) {
    const c = u.match(/^\d+/);
    c && (u = c[0]);
  }
  return Sq({
    host: s,
    pass: i,
    path: l,
    projectId: u,
    port: a,
    protocol: n,
    publicKey: r,
  });
}
function Sq(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId,
  };
}
function Pke(t) {
  if (!R1) return !0;
  const { port: e, projectId: n, protocol: r } = t;
  return ["protocol", "publicKey", "host", "projectId"].find((a) =>
    t[a] ? !1 : (Xe.error(`Invalid Sentry Dsn: ${a} missing`), !0)
  )
    ? !1
    : n.match(/^\d+$/)
    ? Ike(r)
      ? e && isNaN(parseInt(e, 10))
        ? (Xe.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1)
        : !0
      : (Xe.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1)
    : (Xe.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function Aq(t) {
  const e = typeof t == "string" ? Oke(t) : Sq(t);
  if (!(!e || !Pke(e))) return e;
}
class Fu extends Error {
  constructor(e, n = "warn") {
    super(e),
      (this.message = e),
      (this.name = new.target.prototype.constructor.name),
      Object.setPrototypeOf(this, new.target.prototype),
      (this.logLevel = n);
  }
}
function Ns(t, e, n) {
  if (!(e in t)) return;
  const r = t[e],
    i = n(r);
  typeof i == "function" && Cq(i, r), (t[e] = i);
}
function uy(t, e, n) {
  try {
    Object.defineProperty(t, e, { value: n, writable: !0, configurable: !0 });
  } catch {
    R1 && Xe.log(`Failed to add non-enumerable property "${e}" to object`, t);
  }
}
function Cq(t, e) {
  try {
    const n = e.prototype || {};
    (t.prototype = e.prototype = n), uy(t, "__sentry_original__", e);
  } catch {}
}
function SS(t) {
  return t.__sentry_original__;
}
function Nke(t) {
  return Object.keys(t)
    .map((e) => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`)
    .join("&");
}
function kq(t) {
  if (_S(t))
    return { message: t.message, name: t.name, stack: t.stack, ...tB(t) };
  if (D6(t)) {
    const e = {
      type: t.type,
      target: eB(t.target),
      currentTarget: eB(t.currentTarget),
      ...tB(t),
    };
    return (
      typeof CustomEvent < "u" && tf(t, CustomEvent) && (e.detail = t.detail), e
    );
  } else return t;
}
function eB(t) {
  try {
    return gke(t) ? n1(t) : Object.prototype.toString.call(t);
  } catch {
    return "<unknown>";
  }
}
function tB(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e;
  } else return {};
}
function Dke(t, e = 40) {
  const n = Object.keys(kq(t));
  if ((n.sort(), !n.length)) return "[object has no keys]";
  if (n[0].length >= e) return x0(n[0], e);
  for (let r = n.length; r > 0; r--) {
    const i = n.slice(0, r).join(", ");
    if (!(i.length > e)) return r === n.length ? i : x0(i, e);
  }
  return "";
}
function rd(t) {
  return n9(t, new Map());
}
function n9(t, e) {
  if (t1(t)) {
    const n = e.get(t);
    if (n !== void 0) return n;
    const r = {};
    e.set(t, r);
    for (const i of Object.keys(t)) typeof t[i] < "u" && (r[i] = n9(t[i], e));
    return r;
  }
  if (Array.isArray(t)) {
    const n = e.get(t);
    if (n !== void 0) return n;
    const r = [];
    return (
      e.set(t, r),
      t.forEach((i) => {
        r.push(n9(i, e));
      }),
      r
    );
  }
  return t;
}
const Iq = 50,
  nB = /\(error: (.*)\)/,
  rB = /captureMessage|captureException/;
function Oq(...t) {
  const e = t.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0) => {
    const i = [],
      s = n.split(`
`);
    for (let a = r; a < s.length; a++) {
      const o = s[a];
      if (o.length > 1024) continue;
      const l = nB.test(o) ? o.replace(nB, "$1") : o;
      if (!l.match(/\S*Error: /)) {
        for (const u of e) {
          const f = u(l);
          if (f) {
            i.push(f);
            break;
          }
        }
        if (i.length >= Iq) break;
      }
    }
    return Mke(i);
  };
}
function Rke(t) {
  return Array.isArray(t) ? Oq(...t) : t;
}
function Mke(t) {
  if (!t.length) return [];
  const e = Array.from(t);
  return (
    /sentryWrapped/.test(e[e.length - 1].function || "") && e.pop(),
    e.reverse(),
    rB.test(e[e.length - 1].function || "") &&
      (e.pop(), rB.test(e[e.length - 1].function || "") && e.pop()),
    e.slice(0, Iq).map((n) => ({
      ...n,
      filename: n.filename || e[e.length - 1].filename,
      function: n.function || "?",
    }))
  );
}
const t4 = "<anonymous>";
function nf(t) {
  try {
    return !t || typeof t != "function" ? t4 : t.name || t4;
  } catch {
    return t4;
  }
}
const wb = {},
  iB = {};
function qh(t, e) {
  (wb[t] = wb[t] || []), wb[t].push(e);
}
function Kh(t, e) {
  iB[t] || (e(), (iB[t] = !0));
}
function su(t, e) {
  const n = t && wb[t];
  if (n)
    for (const r of n)
      try {
        r(e);
      } catch (i) {
        R1 &&
          Xe.error(
            `Error while triggering instrumentation handler.
Type: ${t}
Name: ${nf(r)}
Error:`,
            i
          );
      }
}
function Lke(t) {
  const e = "console";
  qh(e, t), Kh(e, Bke);
}
function Bke() {
  "console" in wr &&
    t9.forEach(function (t) {
      t in wr.console &&
        Ns(wr.console, t, function (e) {
          return (
            (nw[t] = e),
            function (...n) {
              su("console", { args: n, level: t });
              const i = nw[t];
              i && i.apply(wr.console, n);
            }
          );
        });
    });
}
function ka() {
  const t = wr,
    e = t.crypto || t.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
    e &&
      e.getRandomValues &&
      (n = () => e.getRandomValues(new Uint8Array(1))[0]);
  } catch {}
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (r) =>
    (r ^ ((n() & 15) >> (r / 4))).toString(16)
  );
}
function Pq(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0;
}
function $f(t) {
  const { message: e, event_id: n } = t;
  if (e) return e;
  const r = Pq(t);
  return r
    ? r.type && r.value
      ? `${r.type}: ${r.value}`
      : r.type || r.value || n || "<unknown>"
    : n || "<unknown>";
}
function r9(t, e, n) {
  const r = (t.exception = t.exception || {}),
    i = (r.values = r.values || []),
    s = (i[0] = i[0] || {});
  s.value || (s.value = e || ""), s.type || (s.type = n || "Error");
}
function cy(t, e) {
  const n = Pq(t);
  if (!n) return;
  const r = { type: "generic", handled: !0 },
    i = n.mechanism;
  if (((n.mechanism = { ...r, ...i, ...e }), e && "data" in e)) {
    const s = { ...(i && i.data), ...e.data };
    n.mechanism.data = s;
  }
}
function sB(t) {
  if (t && t.__sentry_captured__) return !0;
  try {
    uy(t, "__sentry_captured__", !0);
  } catch {}
  return !1;
}
function Nq(t) {
  return Array.isArray(t) ? t : [t];
}
const Np = wr,
  Fke = 1e3;
let aB, i9, s9;
function $ke(t) {
  const e = "dom";
  qh(e, t), Kh(e, Uke);
}
function Uke() {
  if (!Np.document) return;
  const t = su.bind(null, "dom"),
    e = oB(t, !0);
  Np.document.addEventListener("click", e, !1),
    Np.document.addEventListener("keypress", e, !1),
    ["EventTarget", "Node"].forEach((n) => {
      const r = Np[n] && Np[n].prototype;
      !r ||
        !r.hasOwnProperty ||
        !r.hasOwnProperty("addEventListener") ||
        (Ns(r, "addEventListener", function (i) {
          return function (s, a, o) {
            if (s === "click" || s == "keypress")
              try {
                const l = this,
                  u = (l.__sentry_instrumentation_handlers__ =
                    l.__sentry_instrumentation_handlers__ || {}),
                  f = (u[s] = u[s] || { refCount: 0 });
                if (!f.handler) {
                  const c = oB(t);
                  (f.handler = c), i.call(this, s, c, o);
                }
                f.refCount++;
              } catch {}
            return i.call(this, s, a, o);
          };
        }),
        Ns(r, "removeEventListener", function (i) {
          return function (s, a, o) {
            if (s === "click" || s == "keypress")
              try {
                const l = this,
                  u = l.__sentry_instrumentation_handlers__ || {},
                  f = u[s];
                f &&
                  (f.refCount--,
                  f.refCount <= 0 &&
                    (i.call(this, s, f.handler, o),
                    (f.handler = void 0),
                    delete u[s]),
                  Object.keys(u).length === 0 &&
                    delete l.__sentry_instrumentation_handlers__);
              } catch {}
            return i.call(this, s, a, o);
          };
        }));
    });
}
function jke(t) {
  if (t.type !== i9) return !1;
  try {
    if (!t.target || t.target._sentryId !== s9) return !1;
  } catch {}
  return !0;
}
function Hke(t, e) {
  return t !== "keypress"
    ? !1
    : !e || !e.tagName
    ? !0
    : !(
        e.tagName === "INPUT" ||
        e.tagName === "TEXTAREA" ||
        e.isContentEditable
      );
}
function oB(t, e = !1) {
  return (n) => {
    if (!n || n._sentryCaptured) return;
    const r = zke(n);
    if (Hke(n.type, r)) return;
    uy(n, "_sentryCaptured", !0), r && !r._sentryId && uy(r, "_sentryId", ka());
    const i = n.type === "keypress" ? "input" : n.type;
    jke(n) ||
      (t({ event: n, name: i, global: e }),
      (i9 = n.type),
      (s9 = r ? r._sentryId : void 0)),
      clearTimeout(aB),
      (aB = Np.setTimeout(() => {
        (s9 = void 0), (i9 = void 0);
      }, Fke));
  };
}
function zke(t) {
  try {
    return t.target;
  } catch {
    return null;
  }
}
const a9 = R6();
function Dq() {
  if (!("fetch" in a9)) return !1;
  try {
    return (
      new Headers(), new Request("http://www.example.com"), new Response(), !0
    );
  } catch {
    return !1;
  }
}
function o9(t) {
  return (
    t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
  );
}
function Vke() {
  if (typeof EdgeRuntime == "string") return !0;
  if (!Dq()) return !1;
  if (o9(a9.fetch)) return !0;
  let t = !1;
  const e = a9.document;
  if (e && typeof e.createElement == "function")
    try {
      const n = e.createElement("iframe");
      (n.hidden = !0),
        e.head.appendChild(n),
        n.contentWindow &&
          n.contentWindow.fetch &&
          (t = o9(n.contentWindow.fetch)),
        e.head.removeChild(n);
    } catch (n) {
      R1 &&
        Xe.warn(
          "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
          n
        );
    }
  return t;
}
function Rq(t) {
  const e = "fetch";
  qh(e, t), Kh(e, Gke);
}
function Gke() {
  Vke() &&
    Ns(wr, "fetch", function (t) {
      return function (...e) {
        const { method: n, url: r } = Wke(e),
          i = {
            args: e,
            fetchData: { method: n, url: r },
            startTimestamp: Date.now(),
          };
        return (
          su("fetch", { ...i }),
          t.apply(wr, e).then(
            (s) => {
              const a = { ...i, endTimestamp: Date.now(), response: s };
              return su("fetch", a), s;
            },
            (s) => {
              const a = { ...i, endTimestamp: Date.now(), error: s };
              throw (su("fetch", a), s);
            }
          )
        );
      };
    });
}
function l9(t, e) {
  return !!t && typeof t == "object" && !!t[e];
}
function lB(t) {
  return typeof t == "string"
    ? t
    : t
    ? l9(t, "url")
      ? t.url
      : t.toString
      ? t.toString()
      : ""
    : "";
}
function Wke(t) {
  if (t.length === 0) return { method: "GET", url: "" };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: lB(n),
      method: l9(r, "method") ? String(r.method).toUpperCase() : "GET",
    };
  }
  const e = t[0];
  return {
    url: lB(e),
    method: l9(e, "method") ? String(e.method).toUpperCase() : "GET",
  };
}
let Dv = null;
function Mq(t) {
  const e = "error";
  qh(e, t), Kh(e, qke);
}
function qke() {
  (Dv = wr.onerror),
    (wr.onerror = function (t, e, n, r, i) {
      return (
        su("error", { column: r, error: i, line: n, msg: t, url: e }),
        Dv && !Dv.__SENTRY_LOADER__ ? Dv.apply(this, arguments) : !1
      );
    }),
    (wr.onerror.__SENTRY_INSTRUMENTED__ = !0);
}
let Rv = null;
function Lq(t) {
  const e = "unhandledrejection";
  qh(e, t), Kh(e, Kke);
}
function Kke() {
  (Rv = wr.onunhandledrejection),
    (wr.onunhandledrejection = function (t) {
      return (
        su("unhandledrejection", t),
        Rv && !Rv.__SENTRY_LOADER__ ? Rv.apply(this, arguments) : !0
      );
    }),
    (wr.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0);
}
const Mv = R6();
function Xke() {
  const t = Mv.chrome,
    e = t && t.app && t.app.runtime,
    n = "history" in Mv && !!Mv.history.pushState && !!Mv.history.replaceState;
  return !e && n;
}
const Om = wr;
let Lv;
function AS(t) {
  const e = "history";
  qh(e, t), Kh(e, Zke);
}
function Zke() {
  if (!Xke()) return;
  const t = Om.onpopstate;
  Om.onpopstate = function (...n) {
    const r = Om.location.href,
      i = Lv;
    if (((Lv = r), su("history", { from: i, to: r }), t))
      try {
        return t.apply(this, n);
      } catch {}
  };
  function e(n) {
    return function (...r) {
      const i = r.length > 2 ? r[2] : void 0;
      if (i) {
        const s = Lv,
          a = String(i);
        (Lv = a), su("history", { from: s, to: a });
      }
      return n.apply(this, r);
    };
  }
  Ns(Om.history, "pushState", e), Ns(Om.history, "replaceState", e);
}
const Yke = wr,
  Jp = "__sentry_xhr_v3__";
function Bq(t) {
  const e = "xhr";
  qh(e, t), Kh(e, Qke);
}
function Qke() {
  if (!Yke.XMLHttpRequest) return;
  const t = XMLHttpRequest.prototype;
  Ns(t, "open", function (e) {
    return function (...n) {
      const r = Date.now(),
        i = Xu(n[0]) ? n[0].toUpperCase() : void 0,
        s = Jke(n[1]);
      if (!i || !s) return e.apply(this, n);
      (this[Jp] = { method: i, url: s, request_headers: {} }),
        i === "POST" &&
          s.match(/sentry_key/) &&
          (this.__sentry_own_request__ = !0);
      const a = () => {
        const o = this[Jp];
        if (o && this.readyState === 4) {
          try {
            o.status_code = this.status;
          } catch {}
          const l = {
            args: [i, s],
            endTimestamp: Date.now(),
            startTimestamp: r,
            xhr: this,
          };
          su("xhr", l);
        }
      };
      return (
        "onreadystatechange" in this &&
        typeof this.onreadystatechange == "function"
          ? Ns(this, "onreadystatechange", function (o) {
              return function (...l) {
                return a(), o.apply(this, l);
              };
            })
          : this.addEventListener("readystatechange", a),
        Ns(this, "setRequestHeader", function (o) {
          return function (...l) {
            const [u, f] = l,
              c = this[Jp];
            return (
              c && Xu(u) && Xu(f) && (c.request_headers[u.toLowerCase()] = f),
              o.apply(this, l)
            );
          };
        }),
        e.apply(this, n)
      );
    };
  }),
    Ns(t, "send", function (e) {
      return function (...n) {
        const r = this[Jp];
        if (!r) return e.apply(this, n);
        n[0] !== void 0 && (r.body = n[0]);
        const i = {
          args: [r.method, r.url],
          startTimestamp: Date.now(),
          xhr: this,
        };
        return su("xhr", i), e.apply(this, n);
      };
    });
}
function Jke(t) {
  if (Xu(t)) return t;
  try {
    return t.toString();
  } catch {}
}
function eIe() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function tIe() {
  return "npm";
}
function nIe() {
  return (
    !eIe() &&
    Object.prototype.toString.call(typeof process < "u" ? process : 0) ===
      "[object process]"
  );
}
function rIe(t, e) {
  return t.require(e);
}
function iIe() {
  const t = typeof WeakSet == "function",
    e = t ? new WeakSet() : [];
  function n(i) {
    if (t) return e.has(i) ? !0 : (e.add(i), !1);
    for (let s = 0; s < e.length; s++) if (e[s] === i) return !0;
    return e.push(i), !1;
  }
  function r(i) {
    if (t) e.delete(i);
    else
      for (let s = 0; s < e.length; s++)
        if (e[s] === i) {
          e.splice(s, 1);
          break;
        }
  }
  return [n, r];
}
function Mf(t, e = 100, n = 1 / 0) {
  try {
    return u9("", t, e, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function Fq(t, e = 3, n = 100 * 1024) {
  const r = Mf(t, e);
  return lIe(r) > n ? Fq(t, e - 1, n) : r;
}
function u9(t, e, n = 1 / 0, r = 1 / 0, i = iIe()) {
  const [s, a] = i;
  if (
    e == null ||
    (["number", "boolean", "string"].includes(typeof e) && !Eq(e))
  )
    return e;
  const o = sIe(t, e);
  if (!o.startsWith("[object ")) return o;
  if (e.__sentry_skip_normalization__) return e;
  const l =
    typeof e.__sentry_override_normalization_depth__ == "number"
      ? e.__sentry_override_normalization_depth__
      : n;
  if (l === 0) return o.replace("object ", "");
  if (s(e)) return "[Circular ~]";
  const u = e;
  if (u && typeof u.toJSON == "function")
    try {
      const p = u.toJSON();
      return u9("", p, l - 1, r, i);
    } catch {}
  const f = Array.isArray(e) ? [] : {};
  let c = 0;
  const d = kq(e);
  for (const p in d) {
    if (!Object.prototype.hasOwnProperty.call(d, p)) continue;
    if (c >= r) {
      f[p] = "[MaxProperties ~]";
      break;
    }
    const m = d[p];
    (f[p] = u9(p, m, l - 1, r, i)), c++;
  }
  return a(e), f;
}
function sIe(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events)
      return "[Domain]";
    if (t === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && e === global) return "[Global]";
    if (typeof window < "u" && e === window) return "[Window]";
    if (typeof document < "u" && e === document) return "[Document]";
    if (xq(e)) return "[VueViewModel]";
    if (vke(e)) return "[SyntheticEvent]";
    if (typeof e == "number" && e !== e) return "[NaN]";
    if (typeof e == "function") return `[Function: ${nf(e)}]`;
    if (typeof e == "symbol") return `[${String(e)}]`;
    if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
    const n = aIe(e);
    return /^HTML(\w*)Element$/.test(n)
      ? `[HTMLElement: ${n}]`
      : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function aIe(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype";
}
function oIe(t) {
  return ~-encodeURI(t).split(/%..|./).length;
}
function lIe(t) {
  return oIe(JSON.stringify(t));
}
var Oc;
(function (t) {
  t[(t.PENDING = 0)] = "PENDING";
  const n = 1;
  t[(t.RESOLVED = n)] = "RESOLVED";
  const r = 2;
  t[(t.REJECTED = r)] = "REJECTED";
})(Oc || (Oc = {}));
function Ih(t) {
  return new Io((e) => {
    e(t);
  });
}
function CS(t) {
  return new Io((e, n) => {
    n(t);
  });
}
class Io {
  constructor(e) {
    Io.prototype.__init.call(this),
      Io.prototype.__init2.call(this),
      Io.prototype.__init3.call(this),
      Io.prototype.__init4.call(this),
      (this._state = Oc.PENDING),
      (this._handlers = []);
    try {
      e(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  then(e, n) {
    return new Io((r, i) => {
      this._handlers.push([
        !1,
        (s) => {
          if (!e) r(s);
          else
            try {
              r(e(s));
            } catch (a) {
              i(a);
            }
        },
        (s) => {
          if (!n) i(s);
          else
            try {
              r(n(s));
            } catch (a) {
              i(a);
            }
        },
      ]),
        this._executeHandlers();
    });
  }
  catch(e) {
    return this.then((n) => n, e);
  }
  finally(e) {
    return new Io((n, r) => {
      let i, s;
      return this.then(
        (a) => {
          (s = !1), (i = a), e && e();
        },
        (a) => {
          (s = !0), (i = a), e && e();
        }
      ).then(() => {
        if (s) {
          r(i);
          return;
        }
        n(i);
      });
    });
  }
  __init() {
    this._resolve = (e) => {
      this._setResult(Oc.RESOLVED, e);
    };
  }
  __init2() {
    this._reject = (e) => {
      this._setResult(Oc.REJECTED, e);
    };
  }
  __init3() {
    this._setResult = (e, n) => {
      if (this._state === Oc.PENDING) {
        if (TS(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        (this._state = e), (this._value = n), this._executeHandlers();
      }
    };
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Oc.PENDING) return;
      const e = this._handlers.slice();
      (this._handlers = []),
        e.forEach((n) => {
          n[0] ||
            (this._state === Oc.RESOLVED && n[1](this._value),
            this._state === Oc.REJECTED && n[2](this._value),
            (n[0] = !0));
        });
    };
  }
}
function uIe(t) {
  const e = [];
  function n() {
    return t === void 0 || e.length < t;
  }
  function r(a) {
    return e.splice(e.indexOf(a), 1)[0];
  }
  function i(a) {
    if (!n())
      return CS(new Fu("Not adding Promise because buffer limit was reached."));
    const o = a();
    return (
      e.indexOf(o) === -1 && e.push(o),
      o.then(() => r(o)).then(null, () => r(o).then(null, () => {})),
      o
    );
  }
  function s(a) {
    return new Io((o, l) => {
      let u = e.length;
      if (!u) return o(!0);
      const f = setTimeout(() => {
        a && a > 0 && o(!1);
      }, a);
      e.forEach((c) => {
        Ih(c).then(() => {
          --u || (clearTimeout(f), o(!0));
        }, l);
      });
    });
  }
  return { $: e, add: i, drain: s };
}
function n4(t) {
  if (!t) return {};
  const e = t.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
  );
  if (!e) return {};
  const n = e[6] || "",
    r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r,
  };
}
const cIe = ["fatal", "error", "warning", "log", "info", "debug"];
function fIe(t) {
  return t === "warn" ? "warning" : cIe.includes(t) ? t : "log";
}
const $q = R6(),
  c9 = { nowSeconds: () => Date.now() / 1e3 };
function dIe() {
  const { performance: t } = $q;
  if (!t || !t.now) return;
  const e = Date.now() - t.now();
  return { now: () => t.now(), timeOrigin: e };
}
function hIe() {
  try {
    return rIe(module, "perf_hooks").performance;
  } catch {
    return;
  }
}
const r4 = nIe() ? hIe() : dIe(),
  uB =
    r4 === void 0 ? c9 : { nowSeconds: () => (r4.timeOrigin + r4.now()) / 1e3 },
  L6 = c9.nowSeconds.bind(c9),
  Oh = uB.nowSeconds.bind(uB),
  nc = (() => {
    const { performance: t } = $q;
    if (!t || !t.now) return;
    const e = 3600 * 1e3,
      n = t.now(),
      r = Date.now(),
      i = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
      s = i < e,
      a = t.timing && t.timing.navigationStart,
      l = typeof a == "number" ? Math.abs(a + n - r) : e,
      u = l < e;
    return s || u ? (i <= l ? t.timeOrigin : a) : r;
  })(),
  f9 = "baggage",
  Uq = "sentry-",
  pIe = /^sentry-/,
  mIe = 8192;
function gIe(t) {
  if (!Xu(t) && !Array.isArray(t)) return;
  let e = {};
  if (Array.isArray(t))
    e = t.reduce((r, i) => {
      const s = cB(i);
      return { ...r, ...s };
    }, {});
  else {
    if (!t) return;
    e = cB(t);
  }
  const n = Object.entries(e).reduce((r, [i, s]) => {
    if (i.match(pIe)) {
      const a = i.slice(Uq.length);
      r[a] = s;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0) return n;
}
function d9(t) {
  if (!t) return;
  const e = Object.entries(t).reduce(
    (n, [r, i]) => (i && (n[`${Uq}${r}`] = i), n),
    {}
  );
  return yIe(e);
}
function cB(t) {
  return t
    .split(",")
    .map((e) => e.split("=").map((n) => decodeURIComponent(n.trim())))
    .reduce((e, [n, r]) => ((e[n] = r), e), {});
}
function yIe(t) {
  if (Object.keys(t).length !== 0)
    return Object.entries(t).reduce((e, [n, r], i) => {
      const s = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
        a = i === 0 ? s : `${e},${s}`;
      return a.length > mIe
        ? (R1 &&
            Xe.warn(
              `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`
            ),
          e)
        : a;
    }, "");
}
const vIe = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
);
function bIe(t) {
  if (!t) return;
  const e = t.match(vIe);
  if (!e) return;
  let n;
  return (
    e[3] === "1" ? (n = !0) : e[3] === "0" && (n = !1),
    { traceId: e[1], parentSampled: n, parentSpanId: e[2] }
  );
}
function wIe(t, e) {
  const n = bIe(t),
    r = gIe(e),
    { traceId: i, parentSpanId: s, parentSampled: a } = n || {},
    o = { traceId: i || ka(), spanId: ka().substring(16), sampled: a };
  return (
    s && (o.parentSpanId = s),
    r && (o.dsc = r),
    { traceparentData: n, dynamicSamplingContext: r, propagationContext: o }
  );
}
function kS(t = ka(), e = ka().substring(16), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${t}-${e}${r}`;
}
function Yy(t, e = []) {
  return [t, e];
}
function _Ie(t, e) {
  const [n, r] = t;
  return [n, [...r, e]];
}
function fB(t, e) {
  const n = t[1];
  for (const r of n) {
    const i = r[0].type;
    if (e(r, i)) return !0;
  }
  return !1;
}
function h9(t, e) {
  return (e || new TextEncoder()).encode(t);
}
function EIe(t, e) {
  const [n, r] = t;
  let i = JSON.stringify(n);
  function s(a) {
    typeof i == "string"
      ? (i = typeof a == "string" ? i + a : [h9(i, e), a])
      : i.push(typeof a == "string" ? h9(a, e) : a);
  }
  for (const a of r) {
    const [o, l] = a;
    if (
      (s(`
${JSON.stringify(o)}
`),
      typeof l == "string" || l instanceof Uint8Array)
    )
      s(l);
    else {
      let u;
      try {
        u = JSON.stringify(l);
      } catch {
        u = JSON.stringify(Mf(l));
      }
      s(u);
    }
  }
  return typeof i == "string" ? i : xIe(i);
}
function xIe(t) {
  const e = t.reduce((i, s) => i + s.length, 0),
    n = new Uint8Array(e);
  let r = 0;
  for (const i of t) n.set(i, r), (r += i.length);
  return n;
}
function TIe(t, e) {
  const n = typeof t.data == "string" ? h9(t.data, e) : t.data;
  return [
    rd({
      type: "attachment",
      length: n.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType,
    }),
    n,
  ];
}
const SIe = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  statsd: "unknown",
};
function dB(t) {
  return SIe[t];
}
function jq(t) {
  if (!t || !t.sdk) return;
  const { name: e, version: n } = t.sdk;
  return { name: e, version: n };
}
function AIe(t, e, n, r) {
  const i =
    t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...(e && { sdk: e }),
    ...(!!n && r && { dsn: Zy(r) }),
    ...(i && { trace: rd({ ...i }) }),
  };
}
function CIe(t, e, n) {
  const r = [
    { type: "client_report" },
    { timestamp: n || L6(), discarded_events: t },
  ];
  return Yy(e ? { dsn: e } : {}, [r]);
}
const kIe = 60 * 1e3;
function IIe(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? kIe : r - e;
}
function OIe(t, e) {
  return t[e] || t.all || 0;
}
function PIe(t, e, n = Date.now()) {
  return OIe(t, e) > n;
}
function NIe(t, { statusCode: e, headers: n }, r = Date.now()) {
  const i = { ...t },
    s = n && n["x-sentry-rate-limits"],
    a = n && n["retry-after"];
  if (s)
    for (const o of s.trim().split(",")) {
      const [l, u] = o.split(":", 2),
        f = parseInt(l, 10),
        c = (isNaN(f) ? 60 : f) * 1e3;
      if (!u) i.all = r + c;
      else for (const d of u.split(";")) i[d] = r + c;
    }
  else a ? (i.all = r + IIe(a, r)) : e === 429 && (i.all = r + 60 * 1e3);
  return i;
}
const an = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  IS = "production";
function OS() {
  return Tq("globalEventProcessors", () => []);
}
function DIe(t) {
  OS().push(t);
}
function rw(t, e, n, r = 0) {
  return new Io((i, s) => {
    const a = t[r];
    if (e === null || typeof a != "function") i(e);
    else {
      const o = a({ ...e }, n);
      an &&
        a.id &&
        o === null &&
        Xe.log(`Event processor "${a.id}" dropped event`),
        TS(o)
          ? o.then((l) => rw(t, l, n, r + 1).then(i)).then(null, s)
          : rw(t, o, n, r + 1)
              .then(i)
              .then(null, s);
    }
  });
}
function RIe(t) {
  const e = Oh(),
    n = {
      sid: ka(),
      init: !0,
      timestamp: e,
      started: e,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => LIe(n),
    };
  return t && r1(n, t), n;
}
function r1(t, e = {}) {
  if (
    (e.user &&
      (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address),
      !t.did &&
        !e.did &&
        (t.did = e.user.id || e.user.email || e.user.username)),
    (t.timestamp = e.timestamp || Oh()),
    e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism),
    e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration),
    e.sid && (t.sid = e.sid.length === 32 ? e.sid : ka()),
    e.init !== void 0 && (t.init = e.init),
    !t.did && e.did && (t.did = `${e.did}`),
    typeof e.started == "number" && (t.started = e.started),
    t.ignoreDuration)
  )
    t.duration = void 0;
  else if (typeof e.duration == "number") t.duration = e.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0;
  }
  e.release && (t.release = e.release),
    e.environment && (t.environment = e.environment),
    !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress),
    !t.userAgent && e.userAgent && (t.userAgent = e.userAgent),
    typeof e.errors == "number" && (t.errors = e.errors),
    e.status && (t.status = e.status);
}
function MIe(t, e) {
  let n = {};
  e ? (n = { status: e }) : t.status === "ok" && (n = { status: "exited" }),
    r1(t, n);
}
function LIe(t) {
  return rd({
    sid: `${t.sid}`,
    init: t.init,
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did:
      typeof t.did == "number" || typeof t.did == "string"
        ? `${t.did}`
        : void 0,
    duration: t.duration,
    abnormal_mechanism: t.abnormal_mechanism,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent,
    },
  });
}
const BIe = 100;
class id {
  constructor() {
    (this._notifyingListeners = !1),
      (this._scopeListeners = []),
      (this._eventProcessors = []),
      (this._breadcrumbs = []),
      (this._attachments = []),
      (this._user = {}),
      (this._tags = {}),
      (this._extra = {}),
      (this._contexts = {}),
      (this._sdkProcessingMetadata = {}),
      (this._propagationContext = hB());
  }
  static clone(e) {
    const n = new id();
    return (
      e &&
        ((n._breadcrumbs = [...e._breadcrumbs]),
        (n._tags = { ...e._tags }),
        (n._extra = { ...e._extra }),
        (n._contexts = { ...e._contexts }),
        (n._user = e._user),
        (n._level = e._level),
        (n._span = e._span),
        (n._session = e._session),
        (n._transactionName = e._transactionName),
        (n._fingerprint = e._fingerprint),
        (n._eventProcessors = [...e._eventProcessors]),
        (n._requestSession = e._requestSession),
        (n._attachments = [...e._attachments]),
        (n._sdkProcessingMetadata = { ...e._sdkProcessingMetadata }),
        (n._propagationContext = { ...e._propagationContext })),
      n
    );
  }
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this;
  }
  setUser(e) {
    return (
      (this._user = e || {}),
      this._session && r1(this._session, { user: e }),
      this._notifyScopeListeners(),
      this
    );
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(e) {
    return (this._requestSession = e), this;
  }
  setTags(e) {
    return (
      (this._tags = { ...this._tags, ...e }), this._notifyScopeListeners(), this
    );
  }
  setTag(e, n) {
    return (
      (this._tags = { ...this._tags, [e]: n }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtras(e) {
    return (
      (this._extra = { ...this._extra, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtra(e, n) {
    return (
      (this._extra = { ...this._extra, [e]: n }),
      this._notifyScopeListeners(),
      this
    );
  }
  setFingerprint(e) {
    return (this._fingerprint = e), this._notifyScopeListeners(), this;
  }
  setLevel(e) {
    return (this._level = e), this._notifyScopeListeners(), this;
  }
  setTransactionName(e) {
    return (this._transactionName = e), this._notifyScopeListeners(), this;
  }
  setContext(e, n) {
    return (
      n === null ? delete this._contexts[e] : (this._contexts[e] = n),
      this._notifyScopeListeners(),
      this
    );
  }
  setSpan(e) {
    return (this._span = e), this._notifyScopeListeners(), this;
  }
  getSpan() {
    return this._span;
  }
  getTransaction() {
    const e = this.getSpan();
    return e && e.transaction;
  }
  setSession(e) {
    return (
      e ? (this._session = e) : delete this._session,
      this._notifyScopeListeners(),
      this
    );
  }
  getSession() {
    return this._session;
  }
  update(e) {
    if (!e) return this;
    if (typeof e == "function") {
      const n = e(this);
      return n instanceof id ? n : this;
    }
    return (
      e instanceof id
        ? ((this._tags = { ...this._tags, ...e._tags }),
          (this._extra = { ...this._extra, ...e._extra }),
          (this._contexts = { ...this._contexts, ...e._contexts }),
          e._user && Object.keys(e._user).length && (this._user = e._user),
          e._level && (this._level = e._level),
          e._fingerprint && (this._fingerprint = e._fingerprint),
          e._requestSession && (this._requestSession = e._requestSession),
          e._propagationContext &&
            (this._propagationContext = e._propagationContext))
        : t1(e) &&
          ((e = e),
          (this._tags = { ...this._tags, ...e.tags }),
          (this._extra = { ...this._extra, ...e.extra }),
          (this._contexts = { ...this._contexts, ...e.contexts }),
          e.user && (this._user = e.user),
          e.level && (this._level = e.level),
          e.fingerprint && (this._fingerprint = e.fingerprint),
          e.requestSession && (this._requestSession = e.requestSession),
          e.propagationContext &&
            (this._propagationContext = e.propagationContext)),
      this
    );
  }
  clear() {
    return (
      (this._breadcrumbs = []),
      (this._tags = {}),
      (this._extra = {}),
      (this._user = {}),
      (this._contexts = {}),
      (this._level = void 0),
      (this._transactionName = void 0),
      (this._fingerprint = void 0),
      (this._requestSession = void 0),
      (this._span = void 0),
      (this._session = void 0),
      this._notifyScopeListeners(),
      (this._attachments = []),
      (this._propagationContext = hB()),
      this
    );
  }
  addBreadcrumb(e, n) {
    const r = typeof n == "number" ? n : BIe;
    if (r <= 0) return this;
    const i = { timestamp: L6(), ...e },
      s = this._breadcrumbs;
    return (
      s.push(i),
      (this._breadcrumbs = s.length > r ? s.slice(-r) : s),
      this._notifyScopeListeners(),
      this
    );
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return (this._breadcrumbs = []), this._notifyScopeListeners(), this;
  }
  addAttachment(e) {
    return this._attachments.push(e), this;
  }
  getAttachments() {
    return this._attachments;
  }
  clearAttachments() {
    return (this._attachments = []), this;
  }
  applyToEvent(e, n = {}, r) {
    if (
      (this._extra &&
        Object.keys(this._extra).length &&
        (e.extra = { ...this._extra, ...e.extra }),
      this._tags &&
        Object.keys(this._tags).length &&
        (e.tags = { ...this._tags, ...e.tags }),
      this._user &&
        Object.keys(this._user).length &&
        (e.user = { ...this._user, ...e.user }),
      this._contexts &&
        Object.keys(this._contexts).length &&
        (e.contexts = { ...this._contexts, ...e.contexts }),
      this._level && (e.level = this._level),
      this._transactionName && (e.transaction = this._transactionName),
      this._span)
    ) {
      e.contexts = { trace: this._span.getTraceContext(), ...e.contexts };
      const a = this._span.transaction;
      if (a) {
        e.sdkProcessingMetadata = {
          dynamicSamplingContext: a.getDynamicSamplingContext(),
          ...e.sdkProcessingMetadata,
        };
        const o = a.name;
        o && (e.tags = { transaction: o, ...e.tags });
      }
    }
    this._applyFingerprint(e);
    const i = this._getBreadcrumbs(),
      s = [...(e.breadcrumbs || []), ...i];
    return (
      (e.breadcrumbs = s.length > 0 ? s : void 0),
      (e.sdkProcessingMetadata = {
        ...e.sdkProcessingMetadata,
        ...this._sdkProcessingMetadata,
        propagationContext: this._propagationContext,
      }),
      rw([...(r || []), ...OS(), ...this._eventProcessors], e, n)
    );
  }
  setSDKProcessingMetadata(e) {
    return (
      (this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e }),
      this
    );
  }
  setPropagationContext(e) {
    return (this._propagationContext = e), this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  _getBreadcrumbs() {
    return this._breadcrumbs;
  }
  _notifyScopeListeners() {
    this._notifyingListeners ||
      ((this._notifyingListeners = !0),
      this._scopeListeners.forEach((e) => {
        e(this);
      }),
      (this._notifyingListeners = !1));
  }
  _applyFingerprint(e) {
    (e.fingerprint = e.fingerprint ? Nq(e.fingerprint) : []),
      this._fingerprint &&
        (e.fingerprint = e.fingerprint.concat(this._fingerprint)),
      e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
  }
}
function hB() {
  return { traceId: ka(), spanId: ka().substring(16) };
}
const fy = "7.86.0",
  Hq = parseFloat(fy),
  FIe = 100;
class zq {
  constructor(e, n = new id(), r = Hq) {
    (this._version = r),
      (this._stack = [{ scope: n }]),
      e && this.bindClient(e);
  }
  isOlderThan(e) {
    return this._version < e;
  }
  bindClient(e) {
    const n = this.getStackTop();
    (n.client = e), e && e.setupIntegrations && e.setupIntegrations();
  }
  pushScope() {
    const e = id.clone(this.getScope());
    return this.getStack().push({ client: this.getClient(), scope: e }), e;
  }
  popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
  withScope(e) {
    const n = this.pushScope();
    try {
      e(n);
    } finally {
      this.popScope();
    }
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getStack() {
    return this._stack;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  captureException(e, n) {
    const r = (this._lastEventId = n && n.event_id ? n.event_id : ka()),
      i = new Error("Sentry syntheticException");
    return (
      this._withClient((s, a) => {
        s.captureException(
          e,
          { originalException: e, syntheticException: i, ...n, event_id: r },
          a
        );
      }),
      r
    );
  }
  captureMessage(e, n, r) {
    const i = (this._lastEventId = r && r.event_id ? r.event_id : ka()),
      s = new Error(e);
    return (
      this._withClient((a, o) => {
        a.captureMessage(
          e,
          n,
          { originalException: e, syntheticException: s, ...r, event_id: i },
          o
        );
      }),
      i
    );
  }
  captureEvent(e, n) {
    const r = n && n.event_id ? n.event_id : ka();
    return (
      e.type || (this._lastEventId = r),
      this._withClient((i, s) => {
        i.captureEvent(e, { ...n, event_id: r }, s);
      }),
      r
    );
  }
  lastEventId() {
    return this._lastEventId;
  }
  addBreadcrumb(e, n) {
    const { scope: r, client: i } = this.getStackTop();
    if (!i) return;
    const { beforeBreadcrumb: s = null, maxBreadcrumbs: a = FIe } =
      (i.getOptions && i.getOptions()) || {};
    if (a <= 0) return;
    const l = { timestamp: L6(), ...e },
      u = s ? M6(() => s(l, n)) : l;
    u !== null &&
      (i.emit && i.emit("beforeAddBreadcrumb", u, n), r.addBreadcrumb(u, a));
  }
  setUser(e) {
    this.getScope().setUser(e);
  }
  setTags(e) {
    this.getScope().setTags(e);
  }
  setExtras(e) {
    this.getScope().setExtras(e);
  }
  setTag(e, n) {
    this.getScope().setTag(e, n);
  }
  setExtra(e, n) {
    this.getScope().setExtra(e, n);
  }
  setContext(e, n) {
    this.getScope().setContext(e, n);
  }
  configureScope(e) {
    const { scope: n, client: r } = this.getStackTop();
    r && e(n);
  }
  run(e) {
    const n = pB(this);
    try {
      e(this);
    } finally {
      pB(n);
    }
  }
  getIntegration(e) {
    const n = this.getClient();
    if (!n) return null;
    try {
      return n.getIntegration(e);
    } catch {
      return (
        an &&
          Xe.warn(`Cannot retrieve integration ${e.id} from the current Hub`),
        null
      );
    }
  }
  startTransaction(e, n) {
    const r = this._callExtensionMethod("startTransaction", e, n);
    return (
      an &&
        !r &&
        (this.getClient()
          ? Xe.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`)
          : Xe.warn(
              "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
            )),
      r
    );
  }
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders");
  }
  captureSession(e = !1) {
    if (e) return this.endSession();
    this._sendSessionUpdate();
  }
  endSession() {
    const n = this.getStackTop().scope,
      r = n.getSession();
    r && MIe(r), this._sendSessionUpdate(), n.setSession();
  }
  startSession(e) {
    const { scope: n, client: r } = this.getStackTop(),
      { release: i, environment: s = IS } = (r && r.getOptions()) || {},
      { userAgent: a } = wr.navigator || {},
      o = RIe({
        release: i,
        environment: s,
        user: n.getUser(),
        ...(a && { userAgent: a }),
        ...e,
      }),
      l = n.getSession && n.getSession();
    return (
      l && l.status === "ok" && r1(l, { status: "exited" }),
      this.endSession(),
      n.setSession(o),
      o
    );
  }
  shouldSendDefaultPii() {
    const e = this.getClient(),
      n = e && e.getOptions();
    return !!(n && n.sendDefaultPii);
  }
  _sendSessionUpdate() {
    const { scope: e, client: n } = this.getStackTop(),
      r = e.getSession();
    r && n && n.captureSession && n.captureSession(r);
  }
  _withClient(e) {
    const { scope: n, client: r } = this.getStackTop();
    r && e(r, n);
  }
  _callExtensionMethod(e, ...n) {
    const i = Qy().__SENTRY__;
    if (i && i.extensions && typeof i.extensions[e] == "function")
      return i.extensions[e].apply(this, n);
    an && Xe.warn(`Extension method ${e} couldn't be found, doing nothing.`);
  }
}
function Qy() {
  return (wr.__SENTRY__ = wr.__SENTRY__ || { extensions: {}, hub: void 0 }), wr;
}
function pB(t) {
  const e = Qy(),
    n = p9(e);
  return Vq(e, t), n;
}
function Ei() {
  const t = Qy();
  if (t.__SENTRY__ && t.__SENTRY__.acs) {
    const e = t.__SENTRY__.acs.getCurrentHub();
    if (e) return e;
  }
  return $Ie(t);
}
function $Ie(t = Qy()) {
  return (!UIe(t) || p9(t).isOlderThan(Hq)) && Vq(t, new zq()), p9(t);
}
function UIe(t) {
  return !!(t && t.__SENTRY__ && t.__SENTRY__.hub);
}
function p9(t) {
  return Tq("hub", () => new zq(), t);
}
function Vq(t, e) {
  if (!t) return !1;
  const n = (t.__SENTRY__ = t.__SENTRY__ || {});
  return (n.hub = e), !0;
}
function Jy(t) {
  return (t || Ei()).getScope().getTransaction();
}
let mB = !1;
function jIe() {
  mB || ((mB = !0), Mq(m9), Lq(m9));
}
function m9() {
  const t = Jy();
  if (t) {
    const e = "internal_error";
    an && Xe.log(`[Tracing] Transaction: ${e} -> Global error occured`),
      t.setStatus(e);
  }
}
m9.tag = "sentry_tracingErrorCallback";
class Gq {
  constructor(e = 1e3) {
    (this._maxlen = e), (this.spans = []);
  }
  add(e) {
    this.spans.length > this._maxlen
      ? (e.spanRecorder = void 0)
      : this.spans.push(e);
  }
}
class PS {
  constructor(e = {}) {
    (this.traceId = e.traceId || ka()),
      (this.spanId = e.spanId || ka().substring(16)),
      (this.startTimestamp = e.startTimestamp || Oh()),
      (this.tags = e.tags || {}),
      (this.data = e.data || {}),
      (this.instrumenter = e.instrumenter || "sentry"),
      (this.origin = e.origin || "manual"),
      e.parentSpanId && (this.parentSpanId = e.parentSpanId),
      "sampled" in e && (this.sampled = e.sampled),
      e.op && (this.op = e.op),
      e.description && (this.description = e.description),
      e.name && (this.description = e.name),
      e.status && (this.status = e.status),
      e.endTimestamp && (this.endTimestamp = e.endTimestamp);
  }
  get name() {
    return this.description || "";
  }
  set name(e) {
    this.setName(e);
  }
  startChild(e) {
    const n = new PS({
      ...e,
      parentSpanId: this.spanId,
      sampled: this.sampled,
      traceId: this.traceId,
    });
    if (
      ((n.spanRecorder = this.spanRecorder),
      n.spanRecorder && n.spanRecorder.add(n),
      (n.transaction = this.transaction),
      an && n.transaction)
    ) {
      const r = (e && e.op) || "< unknown op >",
        i = n.transaction.name || "< unknown name >",
        s = n.transaction.spanId,
        a = `[Tracing] Starting '${r}' span on transaction '${i}' (${s}).`;
      (n.transaction.metadata.spanMetadata[n.spanId] = { logMessage: a }),
        Xe.log(a);
    }
    return n;
  }
  setTag(e, n) {
    return (this.tags = { ...this.tags, [e]: n }), this;
  }
  setData(e, n) {
    return (this.data = { ...this.data, [e]: n }), this;
  }
  setStatus(e) {
    return (this.status = e), this;
  }
  setHttpStatus(e) {
    this.setTag("http.status_code", String(e)),
      this.setData("http.response.status_code", e);
    const n = HIe(e);
    return n !== "unknown_error" && this.setStatus(n), this;
  }
  setName(e) {
    this.description = e;
  }
  isSuccess() {
    return this.status === "ok";
  }
  finish(e) {
    if (an && this.transaction && this.transaction.spanId !== this.spanId) {
      const { logMessage: n } =
        this.transaction.metadata.spanMetadata[this.spanId];
      n && Xe.log(n.replace("Starting", "Finishing"));
    }
    this.endTimestamp = typeof e == "number" ? e : Oh();
  }
  toTraceparent() {
    return kS(this.traceId, this.spanId, this.sampled);
  }
  toContext() {
    return rd({
      data: this.data,
      description: this.description,
      endTimestamp: this.endTimestamp,
      op: this.op,
      parentSpanId: this.parentSpanId,
      sampled: this.sampled,
      spanId: this.spanId,
      startTimestamp: this.startTimestamp,
      status: this.status,
      tags: this.tags,
      traceId: this.traceId,
    });
  }
  updateWithContext(e) {
    return (
      (this.data = e.data || {}),
      (this.description = e.description),
      (this.endTimestamp = e.endTimestamp),
      (this.op = e.op),
      (this.parentSpanId = e.parentSpanId),
      (this.sampled = e.sampled),
      (this.spanId = e.spanId || this.spanId),
      (this.startTimestamp = e.startTimestamp || this.startTimestamp),
      (this.status = e.status),
      (this.tags = e.tags || {}),
      (this.traceId = e.traceId || this.traceId),
      this
    );
  }
  getTraceContext() {
    return rd({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      trace_id: this.traceId,
      origin: this.origin,
    });
  }
  toJSON() {
    return rd({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      start_timestamp: this.startTimestamp,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      timestamp: this.endTimestamp,
      trace_id: this.traceId,
      origin: this.origin,
    });
  }
}
function HIe(t) {
  if (t < 400 && t >= 100) return "ok";
  if (t >= 400 && t < 500)
    switch (t) {
      case 401:
        return "unauthenticated";
      case 403:
        return "permission_denied";
      case 404:
        return "not_found";
      case 409:
        return "already_exists";
      case 413:
        return "failed_precondition";
      case 429:
        return "resource_exhausted";
      default:
        return "invalid_argument";
    }
  if (t >= 500 && t < 600)
    switch (t) {
      case 501:
        return "unimplemented";
      case 503:
        return "unavailable";
      case 504:
        return "deadline_exceeded";
      default:
        return "internal_error";
    }
  return "unknown_error";
}
function B6(t, e, n) {
  const r = e.getOptions(),
    { publicKey: i } = e.getDsn() || {},
    { segment: s } = (n && n.getUser()) || {},
    a = rd({
      environment: r.environment || IS,
      release: r.release,
      user_segment: s,
      public_key: i,
      trace_id: t,
    });
  return e.emit && e.emit("createDsc", a), a;
}
class Wq extends PS {
  constructor(e, n) {
    super(e),
      delete this.description,
      (this._measurements = {}),
      (this._contexts = {}),
      (this._hub = n || Ei()),
      (this._name = e.name || ""),
      (this.metadata = { source: "custom", ...e.metadata, spanMetadata: {} }),
      (this._trimEnd = e.trimEnd),
      (this.transaction = this);
    const r = this.metadata.dynamicSamplingContext;
    r && (this._frozenDynamicSamplingContext = { ...r });
  }
  get name() {
    return this._name;
  }
  set name(e) {
    this.setName(e);
  }
  setName(e, n = "custom") {
    (this._name = e), (this.metadata.source = n);
  }
  initSpanRecorder(e = 1e3) {
    this.spanRecorder || (this.spanRecorder = new Gq(e)),
      this.spanRecorder.add(this);
  }
  setContext(e, n) {
    n === null ? delete this._contexts[e] : (this._contexts[e] = n);
  }
  setMeasurement(e, n, r = "") {
    this._measurements[e] = { value: n, unit: r };
  }
  setMetadata(e) {
    this.metadata = { ...this.metadata, ...e };
  }
  finish(e) {
    const n = this._finishTransaction(e);
    if (n) return this._hub.captureEvent(n);
  }
  toContext() {
    const e = super.toContext();
    return rd({ ...e, name: this.name, trimEnd: this._trimEnd });
  }
  updateWithContext(e) {
    return (
      super.updateWithContext(e),
      (this.name = e.name || ""),
      (this._trimEnd = e.trimEnd),
      this
    );
  }
  getDynamicSamplingContext() {
    if (this._frozenDynamicSamplingContext)
      return this._frozenDynamicSamplingContext;
    const e = this._hub || Ei(),
      n = e.getClient();
    if (!n) return {};
    const r = e.getScope(),
      i = B6(this.traceId, n, r),
      s = this.metadata.sampleRate;
    s !== void 0 && (i.sample_rate = `${s}`);
    const a = this.metadata.source;
    return (
      a && a !== "url" && (i.transaction = this.name),
      this.sampled !== void 0 && (i.sampled = String(this.sampled)),
      i
    );
  }
  setHub(e) {
    this._hub = e;
  }
  _finishTransaction(e) {
    if (this.endTimestamp !== void 0) return;
    this.name ||
      (an &&
        Xe.warn(
          "Transaction has no name, falling back to `<unlabeled transaction>`."
        ),
      (this.name = "<unlabeled transaction>")),
      super.finish(e);
    const n = this._hub.getClient();
    if (
      (n && n.emit && n.emit("finishTransaction", this), this.sampled !== !0)
    ) {
      an &&
        Xe.log(
          "[Tracing] Discarding transaction because its trace was not chosen to be sampled."
        ),
        n && n.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const r = this.spanRecorder
      ? this.spanRecorder.spans.filter((o) => o !== this && o.endTimestamp)
      : [];
    this._trimEnd &&
      r.length > 0 &&
      (this.endTimestamp = r.reduce((o, l) =>
        o.endTimestamp && l.endTimestamp
          ? o.endTimestamp > l.endTimestamp
            ? o
            : l
          : o
      ).endTimestamp);
    const i = this.metadata,
      s = {
        contexts: { ...this._contexts, trace: this.getTraceContext() },
        spans: r,
        start_timestamp: this.startTimestamp,
        tags: this.tags,
        timestamp: this.endTimestamp,
        transaction: this.name,
        type: "transaction",
        sdkProcessingMetadata: {
          ...i,
          dynamicSamplingContext: this.getDynamicSamplingContext(),
        },
        ...(i.source && { transaction_info: { source: i.source } }),
      };
    return (
      Object.keys(this._measurements).length > 0 &&
        (an &&
          Xe.log(
            "[Measurements] Adding measurements to transaction",
            JSON.stringify(this._measurements, void 0, 2)
          ),
        (s.measurements = this._measurements)),
      an && Xe.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`),
      s
    );
  }
}
const _b = { idleTimeout: 1e3, finalTimeout: 3e4, heartbeatInterval: 5e3 },
  zIe = "finishReason",
  _p = [
    "heartbeatFailed",
    "idleTimeout",
    "documentHidden",
    "finalTimeout",
    "externalFinish",
    "cancelled",
  ];
class VIe extends Gq {
  constructor(e, n, r, i) {
    super(i),
      (this._pushActivity = e),
      (this._popActivity = n),
      (this.transactionSpanId = r);
  }
  add(e) {
    e.spanId !== this.transactionSpanId &&
      ((e.finish = (n) => {
        (e.endTimestamp = typeof n == "number" ? n : Oh()),
          this._popActivity(e.spanId);
      }),
      e.endTimestamp === void 0 && this._pushActivity(e.spanId)),
      super.add(e);
  }
}
class GIe extends Wq {
  constructor(
    e,
    n,
    r = _b.idleTimeout,
    i = _b.finalTimeout,
    s = _b.heartbeatInterval,
    a = !1
  ) {
    super(e, n),
      (this._idleHub = n),
      (this._idleTimeout = r),
      (this._finalTimeout = i),
      (this._heartbeatInterval = s),
      (this._onScope = a),
      (this.activities = {}),
      (this._heartbeatCounter = 0),
      (this._finished = !1),
      (this._idleTimeoutCanceledPermanently = !1),
      (this._beforeFinishCallbacks = []),
      (this._finishReason = _p[4]),
      a &&
        (an &&
          Xe.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`),
        n.configureScope((o) => o.setSpan(this))),
      this._restartIdleTimeout(),
      setTimeout(() => {
        this._finished ||
          (this.setStatus("deadline_exceeded"),
          (this._finishReason = _p[3]),
          this.finish());
      }, this._finalTimeout);
  }
  finish(e = Oh()) {
    if (
      ((this._finished = !0),
      (this.activities = {}),
      this.op === "ui.action.click" && this.setTag(zIe, this._finishReason),
      this.spanRecorder)
    ) {
      an &&
        Xe.log(
          "[Tracing] finishing IdleTransaction",
          new Date(e * 1e3).toISOString(),
          this.op
        );
      for (const n of this._beforeFinishCallbacks) n(this, e);
      (this.spanRecorder.spans = this.spanRecorder.spans.filter((n) => {
        if (n.spanId === this.spanId) return !0;
        n.endTimestamp ||
          ((n.endTimestamp = e),
          n.setStatus("cancelled"),
          an &&
            Xe.log(
              "[Tracing] cancelling span since transaction ended early",
              JSON.stringify(n, void 0, 2)
            ));
        const r = n.startTimestamp < e,
          i = (this._finalTimeout + this._idleTimeout) / 1e3,
          s = n.endTimestamp - this.startTimestamp < i;
        if (an) {
          const a = JSON.stringify(n, void 0, 2);
          r
            ? s ||
              Xe.log(
                "[Tracing] discarding Span since it finished after Transaction final timeout",
                a
              )
            : Xe.log(
                "[Tracing] discarding Span since it happened after Transaction was finished",
                a
              );
        }
        return r && s;
      })),
        an && Xe.log("[Tracing] flushing IdleTransaction");
    } else an && Xe.log("[Tracing] No active IdleTransaction");
    if (this._onScope) {
      const n = this._idleHub.getScope();
      n.getTransaction() === this && n.setSpan(void 0);
    }
    return super.finish(e);
  }
  registerBeforeFinishCallback(e) {
    this._beforeFinishCallbacks.push(e);
  }
  initSpanRecorder(e) {
    if (!this.spanRecorder) {
      const n = (i) => {
          this._finished || this._pushActivity(i);
        },
        r = (i) => {
          this._finished || this._popActivity(i);
        };
      (this.spanRecorder = new VIe(n, r, this.spanId, e)),
        an && Xe.log("Starting heartbeat"),
        this._pingHeartbeat();
    }
    this.spanRecorder.add(this);
  }
  cancelIdleTimeout(
    e,
    { restartOnChildSpanChange: n } = { restartOnChildSpanChange: !0 }
  ) {
    (this._idleTimeoutCanceledPermanently = n === !1),
      this._idleTimeoutID &&
        (clearTimeout(this._idleTimeoutID),
        (this._idleTimeoutID = void 0),
        Object.keys(this.activities).length === 0 &&
          this._idleTimeoutCanceledPermanently &&
          ((this._finishReason = _p[5]), this.finish(e)));
  }
  setFinishReason(e) {
    this._finishReason = e;
  }
  _restartIdleTimeout(e) {
    this.cancelIdleTimeout(),
      (this._idleTimeoutID = setTimeout(() => {
        !this._finished &&
          Object.keys(this.activities).length === 0 &&
          ((this._finishReason = _p[1]), this.finish(e));
      }, this._idleTimeout));
  }
  _pushActivity(e) {
    this.cancelIdleTimeout(void 0, {
      restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently,
    }),
      an && Xe.log(`[Tracing] pushActivity: ${e}`),
      (this.activities[e] = !0),
      an &&
        Xe.log(
          "[Tracing] new activities count",
          Object.keys(this.activities).length
        );
  }
  _popActivity(e) {
    if (
      (this.activities[e] &&
        (an && Xe.log(`[Tracing] popActivity ${e}`),
        delete this.activities[e],
        an &&
          Xe.log(
            "[Tracing] new activities count",
            Object.keys(this.activities).length
          )),
      Object.keys(this.activities).length === 0)
    ) {
      const n = Oh();
      this._idleTimeoutCanceledPermanently
        ? ((this._finishReason = _p[5]), this.finish(n))
        : this._restartIdleTimeout(n + this._idleTimeout / 1e3);
    }
  }
  _beat() {
    if (this._finished) return;
    const e = Object.keys(this.activities).join("");
    e === this._prevHeartbeatString
      ? this._heartbeatCounter++
      : (this._heartbeatCounter = 1),
      (this._prevHeartbeatString = e),
      this._heartbeatCounter >= 3
        ? (an &&
            Xe.log(
              "[Tracing] Transaction finished because of no change for 3 heart beats"
            ),
          this.setStatus("deadline_exceeded"),
          (this._finishReason = _p[0]),
          this.finish())
        : this._pingHeartbeat();
  }
  _pingHeartbeat() {
    an &&
      Xe.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`),
      setTimeout(() => {
        this._beat();
      }, this._heartbeatInterval);
  }
}
function WIe(t, e, n, r, i) {
  const { normalizeDepth: s = 3, normalizeMaxBreadth: a = 1e3 } = t,
    o = {
      ...e,
      event_id: e.event_id || n.event_id || ka(),
      timestamp: e.timestamp || L6(),
    },
    l = n.integrations || t.integrations.map((d) => d.name);
  qIe(o, t), ZIe(o, l), e.type === void 0 && KIe(o, t.stackParser);
  let u = r;
  n.captureContext && (u = id.clone(u).update(n.captureContext)),
    n.mechanism && cy(o, n.mechanism);
  let f = Ih(o);
  const c = i && i.getEventProcessors ? i.getEventProcessors() : [];
  if (u) {
    if (u.getAttachments) {
      const d = [...(n.attachments || []), ...u.getAttachments()];
      d.length && (n.attachments = d);
    }
    f = u.applyToEvent(o, n, c);
  } else f = rw([...c, ...OS()], o, n);
  return f.then(
    (d) => (d && XIe(d), typeof s == "number" && s > 0 ? YIe(d, s, a) : d)
  );
}
function qIe(t, e) {
  const { environment: n, release: r, dist: i, maxValueLength: s = 250 } = e;
  "environment" in t || (t.environment = "environment" in e ? n : IS),
    t.release === void 0 && r !== void 0 && (t.release = r),
    t.dist === void 0 && i !== void 0 && (t.dist = i),
    t.message && (t.message = x0(t.message, s));
  const a = t.exception && t.exception.values && t.exception.values[0];
  a && a.value && (a.value = x0(a.value, s));
  const o = t.request;
  o && o.url && (o.url = x0(o.url, s));
}
const gB = new WeakMap();
function KIe(t, e) {
  const n = wr._sentryDebugIds;
  if (!n) return;
  let r;
  const i = gB.get(e);
  i ? (r = i) : ((r = new Map()), gB.set(e, r));
  const s = Object.keys(n).reduce((a, o) => {
    let l;
    const u = r.get(o);
    u ? (l = u) : ((l = e(o)), r.set(o, l));
    for (let f = l.length - 1; f >= 0; f--) {
      const c = l[f];
      if (c.filename) {
        a[c.filename] = n[o];
        break;
      }
    }
    return a;
  }, {});
  try {
    t.exception.values.forEach((a) => {
      a.stacktrace.frames.forEach((o) => {
        o.filename && (o.debug_id = s[o.filename]);
      });
    });
  } catch {}
}
function XIe(t) {
  const e = {};
  try {
    t.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((i) => {
        i.debug_id &&
          (i.abs_path
            ? (e[i.abs_path] = i.debug_id)
            : i.filename && (e[i.filename] = i.debug_id),
          delete i.debug_id);
      });
    });
  } catch {}
  if (Object.keys(e).length === 0) return;
  (t.debug_meta = t.debug_meta || {}),
    (t.debug_meta.images = t.debug_meta.images || []);
  const n = t.debug_meta.images;
  Object.keys(e).forEach((r) => {
    n.push({ type: "sourcemap", code_file: r, debug_id: e[r] });
  });
}
function ZIe(t, e) {
  e.length > 0 &&
    ((t.sdk = t.sdk || {}),
    (t.sdk.integrations = [...(t.sdk.integrations || []), ...e]));
}
function YIe(t, e, n) {
  if (!t) return null;
  const r = {
    ...t,
    ...(t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map((i) => ({
        ...i,
        ...(i.data && { data: Mf(i.data, e, n) }),
      })),
    }),
    ...(t.user && { user: Mf(t.user, e, n) }),
    ...(t.contexts && { contexts: Mf(t.contexts, e, n) }),
    ...(t.extra && { extra: Mf(t.extra, e, n) }),
  };
  return (
    t.contexts &&
      t.contexts.trace &&
      r.contexts &&
      ((r.contexts.trace = t.contexts.trace),
      t.contexts.trace.data &&
        (r.contexts.trace.data = Mf(t.contexts.trace.data, e, n))),
    t.spans &&
      (r.spans = t.spans.map(
        (i) => (i.data && (i.data = Mf(i.data, e, n)), i)
      )),
    r
  );
}
function QIe(t) {
  if (t)
    return JIe(t) ? { captureContext: t } : tOe(t) ? { captureContext: t } : t;
}
function JIe(t) {
  return t instanceof id || typeof t == "function";
}
const eOe = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext",
];
function tOe(t) {
  return Object.keys(t).some((e) => eOe.includes(e));
}
function qq(t, e) {
  return Ei().captureException(t, QIe(e));
}
function Kq(t) {
  Ei().withScope(t);
}
function NS() {
  return Ei().getClient();
}
function DS(t) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
  const e = NS(),
    n = t || (e && e.getOptions());
  return (
    !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
  );
}
function Xq(t, e, n) {
  if (!DS(e)) return (t.sampled = !1), t;
  if (t.sampled !== void 0)
    return t.setMetadata({ sampleRate: Number(t.sampled) }), t;
  let r;
  return (
    typeof e.tracesSampler == "function"
      ? ((r = e.tracesSampler(n)), t.setMetadata({ sampleRate: Number(r) }))
      : n.parentSampled !== void 0
      ? (r = n.parentSampled)
      : typeof e.tracesSampleRate < "u"
      ? ((r = e.tracesSampleRate), t.setMetadata({ sampleRate: Number(r) }))
      : ((r = 1), t.setMetadata({ sampleRate: r })),
    nOe(r)
      ? r
        ? ((t.sampled = Math.random() < r),
          t.sampled
            ? (an &&
                Xe.log(`[Tracing] starting ${t.op} transaction - ${t.name}`),
              t)
            : (an &&
                Xe.log(
                  `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
                    r
                  )})`
                ),
              t))
        : (an &&
            Xe.log(
              `[Tracing] Discarding transaction because ${
                typeof e.tracesSampler == "function"
                  ? "tracesSampler returned 0 or false"
                  : "a negative sampling decision was inherited or tracesSampleRate is set to 0"
              }`
            ),
          (t.sampled = !1),
          t)
      : (an &&
          Xe.warn(
            "[Tracing] Discarding transaction because of invalid sample rate."
          ),
        (t.sampled = !1),
        t)
  );
}
function nOe(t) {
  return Eq(t) || !(typeof t == "number" || typeof t == "boolean")
    ? (an &&
        Xe.warn(
          `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
            t
          )} of type ${JSON.stringify(typeof t)}.`
        ),
      !1)
    : t < 0 || t > 1
    ? (an &&
        Xe.warn(
          `[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${t}.`
        ),
      !1)
    : !0;
}
function rOe() {
  const e = this.getScope().getSpan();
  return e ? { "sentry-trace": e.toTraceparent() } : {};
}
function iOe(t, e) {
  const n = this.getClient(),
    r = (n && n.getOptions()) || {},
    i = r.instrumenter || "sentry",
    s = t.instrumenter || "sentry";
  i !== s &&
    (an &&
      Xe.error(`A transaction was started with instrumenter=\`${s}\`, but the SDK is configured with the \`${i}\` instrumenter.
The transaction will not be sampled. Please use the ${i} instrumentation to start transactions.`),
    (t.sampled = !1));
  let a = new Wq(t, this);
  return (
    (a = Xq(a, r, {
      parentSampled: t.parentSampled,
      transactionContext: t,
      ...e,
    })),
    a.sampled && a.initSpanRecorder(r._experiments && r._experiments.maxSpans),
    n && n.emit && n.emit("startTransaction", a),
    a
  );
}
function yB(t, e, n, r, i, s, a) {
  const o = t.getClient(),
    l = (o && o.getOptions()) || {};
  let u = new GIe(e, t, n, r, a, i);
  return (
    (u = Xq(u, l, {
      parentSampled: e.parentSampled,
      transactionContext: e,
      ...s,
    })),
    u.sampled && u.initSpanRecorder(l._experiments && l._experiments.maxSpans),
    o && o.emit && o.emit("startTransaction", u),
    u
  );
}
function sOe() {
  const t = Qy();
  t.__SENTRY__ &&
    ((t.__SENTRY__.extensions = t.__SENTRY__.extensions || {}),
    t.__SENTRY__.extensions.startTransaction ||
      (t.__SENTRY__.extensions.startTransaction = iOe),
    t.__SENTRY__.extensions.traceHeaders ||
      (t.__SENTRY__.extensions.traceHeaders = rOe),
    jIe());
}
function aOe(t, e) {
  return (
    e &&
      ((t.sdk = t.sdk || {}),
      (t.sdk.name = t.sdk.name || e.name),
      (t.sdk.version = t.sdk.version || e.version),
      (t.sdk.integrations = [
        ...(t.sdk.integrations || []),
        ...(e.integrations || []),
      ]),
      (t.sdk.packages = [...(t.sdk.packages || []), ...(e.packages || [])])),
    t
  );
}
function oOe(t, e, n, r) {
  const i = jq(n),
    s = {
      sent_at: new Date().toISOString(),
      ...(i && { sdk: i }),
      ...(!!r && e && { dsn: Zy(e) }),
    },
    a =
      "aggregates" in t
        ? [{ type: "sessions" }, t]
        : [{ type: "session" }, t.toJSON()];
  return Yy(s, [a]);
}
function lOe(t, e, n, r) {
  const i = jq(n),
    s = t.type && t.type !== "replay_event" ? t.type : "event";
  aOe(t, n && n.sdk);
  const a = AIe(t, i, r, e);
  return delete t.sdkProcessingMetadata, Yy(a, [[{ type: s }, t]]);
}
const uOe = "7";
function Zq(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`;
}
function cOe(t) {
  return `${Zq(t)}${t.projectId}/envelope/`;
}
function fOe(t, e) {
  return Nke({
    sentry_key: t.publicKey,
    sentry_version: uOe,
    ...(e && { sentry_client: `${e.name}/${e.version}` }),
  });
}
function dOe(t, e = {}) {
  const n = typeof e == "string" ? e : e.tunnel,
    r = typeof e == "string" || !e._metadata ? void 0 : e._metadata.sdk;
  return n || `${cOe(t)}?${fOe(t, r)}`;
}
function hOe(t, e) {
  const n = Aq(t);
  if (!n) return "";
  const r = `${Zq(n)}embed/error-page/`;
  let i = `dsn=${Zy(n)}`;
  for (const s in e)
    if (s !== "dsn" && s !== "onClose")
      if (s === "user") {
        const a = e.user;
        if (!a) continue;
        a.name && (i += `&name=${encodeURIComponent(a.name)}`),
          a.email && (i += `&email=${encodeURIComponent(a.email)}`);
      } else i += `&${encodeURIComponent(s)}=${encodeURIComponent(e[s])}`;
  return `${r}?${i}`;
}
const vB = [];
function pOe(t) {
  const e = {};
  return (
    t.forEach((n) => {
      const { name: r } = n,
        i = e[r];
      (i && !i.isDefaultInstance && n.isDefaultInstance) || (e[r] = n);
    }),
    Object.keys(e).map((n) => e[n])
  );
}
function mOe(t) {
  const e = t.defaultIntegrations || [],
    n = t.integrations;
  e.forEach((a) => {
    a.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n)
    ? (r = [...e, ...n])
    : typeof n == "function"
    ? (r = Nq(n(e)))
    : (r = e);
  const i = pOe(r),
    s = yOe(i, (a) => a.name === "Debug");
  if (s !== -1) {
    const [a] = i.splice(s, 1);
    i.push(a);
  }
  return i;
}
function gOe(t, e) {
  const n = {};
  return (
    e.forEach((r) => {
      r && Yq(t, r, n);
    }),
    n
  );
}
function Yq(t, e, n) {
  if (
    ((n[e.name] = e),
    vB.indexOf(e.name) === -1 && (e.setupOnce(DIe, Ei), vB.push(e.name)),
    e.setup && typeof e.setup == "function" && e.setup(t),
    t.on && typeof e.preprocessEvent == "function")
  ) {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (i, s) => r(i, s, t));
  }
  if (t.addEventProcessor && typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e),
      i = Object.assign((s, a) => r(s, a, t), { id: e.name });
    t.addEventProcessor(i);
  }
  an && Xe.log(`Integration installed: ${e.name}`);
}
function yOe(t, e) {
  for (let n = 0; n < t.length; n++) if (e(t[n]) === !0) return n;
  return -1;
}
const bB = "Not capturing exception because it's already been captured.";
class vOe {
  constructor(e) {
    if (
      ((this._options = e),
      (this._integrations = {}),
      (this._integrationsInitialized = !1),
      (this._numProcessing = 0),
      (this._outcomes = {}),
      (this._hooks = {}),
      (this._eventProcessors = []),
      e.dsn
        ? (this._dsn = Aq(e.dsn))
        : an && Xe.warn("No DSN provided, client will not send events."),
      this._dsn)
    ) {
      const n = dOe(this._dsn, e);
      this._transport = e.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n,
      });
    }
  }
  captureException(e, n, r) {
    if (sB(e)) {
      an && Xe.log(bB);
      return;
    }
    let i = n && n.event_id;
    return (
      this._process(
        this.eventFromException(e, n)
          .then((s) => this._captureEvent(s, n, r))
          .then((s) => {
            i = s;
          })
      ),
      i
    );
  }
  captureMessage(e, n, r, i) {
    let s = r && r.event_id;
    const a = xS(e)
      ? this.eventFromMessage(String(e), n, r)
      : this.eventFromException(e, r);
    return (
      this._process(
        a
          .then((o) => this._captureEvent(o, r, i))
          .then((o) => {
            s = o;
          })
      ),
      s
    );
  }
  captureEvent(e, n, r) {
    if (n && n.originalException && sB(n.originalException)) {
      an && Xe.log(bB);
      return;
    }
    let i = n && n.event_id;
    return (
      this._process(
        this._captureEvent(e, n, r).then((s) => {
          i = s;
        })
      ),
      i
    );
  }
  captureSession(e) {
    typeof e.release != "string"
      ? an &&
        Xe.warn("Discarded session because of missing or non-string release")
      : (this.sendSession(e), r1(e, { init: !1 }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(e) {
    const n = this._transport;
    return n
      ? this._isClientDoneProcessing(e).then((r) =>
          n.flush(e).then((i) => r && i)
        )
      : Ih(!0);
  }
  close(e) {
    return this.flush(e).then((n) => ((this.getOptions().enabled = !1), n));
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  setupIntegrations(e) {
    ((e && !this._integrationsInitialized) ||
      (this._isEnabled() && !this._integrationsInitialized)) &&
      ((this._integrations = gOe(this, this._options.integrations)),
      (this._integrationsInitialized = !0));
  }
  getIntegrationById(e) {
    return this._integrations[e];
  }
  getIntegration(e) {
    try {
      return this._integrations[e.id] || null;
    } catch {
      return (
        an &&
          Xe.warn(
            `Cannot retrieve integration ${e.id} from the current Client`
          ),
        null
      );
    }
  }
  addIntegration(e) {
    Yq(this, e, this._integrations);
  }
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = lOe(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const s of n.attachments || [])
      r = _Ie(
        r,
        TIe(
          s,
          this._options.transportOptions &&
            this._options.transportOptions.textEncoder
        )
      );
    const i = this._sendEnvelope(r);
    i && i.then((s) => this.emit("afterSendEvent", e, s), null);
  }
  sendSession(e) {
    const n = oOe(e, this._dsn, this._options._metadata, this._options.tunnel);
    this._sendEnvelope(n);
  }
  recordDroppedEvent(e, n, r) {
    if (this._options.sendClientReports) {
      const i = `${e}:${n}`;
      an && Xe.log(`Adding outcome: "${i}"`),
        (this._outcomes[i] = this._outcomes[i] + 1 || 1);
    }
  }
  on(e, n) {
    this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(n);
  }
  emit(e, ...n) {
    this._hooks[e] && this._hooks[e].forEach((r) => r(...n));
  }
  _updateSessionFromEvent(e, n) {
    let r = !1,
      i = !1;
    const s = n.exception && n.exception.values;
    if (s) {
      i = !0;
      for (const l of s) {
        const u = l.mechanism;
        if (u && u.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const a = e.status === "ok";
    ((a && e.errors === 0) || (a && r)) &&
      (r1(e, {
        ...(r && { status: "crashed" }),
        errors: e.errors || Number(i || r),
      }),
      this.captureSession(e));
  }
  _isClientDoneProcessing(e) {
    return new Io((n) => {
      let r = 0;
      const i = 1,
        s = setInterval(() => {
          this._numProcessing == 0
            ? (clearInterval(s), n(!0))
            : ((r += i), e && r >= e && (clearInterval(s), n(!1)));
        }, i);
    });
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  _prepareEvent(e, n, r) {
    const i = this.getOptions(),
      s = Object.keys(this._integrations);
    return (
      !n.integrations && s.length > 0 && (n.integrations = s),
      this.emit("preprocessEvent", e, n),
      WIe(i, e, n, r, this).then((a) => {
        if (a === null) return a;
        const { propagationContext: o } = a.sdkProcessingMetadata || {};
        if (!(a.contexts && a.contexts.trace) && o) {
          const { traceId: u, spanId: f, parentSpanId: c, dsc: d } = o;
          a.contexts = {
            trace: { trace_id: u, span_id: f, parent_span_id: c },
            ...a.contexts,
          };
          const p = d || B6(u, this, r);
          a.sdkProcessingMetadata = {
            dynamicSamplingContext: p,
            ...a.sdkProcessingMetadata,
          };
        }
        return a;
      })
    );
  }
  _captureEvent(e, n = {}, r) {
    return this._processEvent(e, n, r).then(
      (i) => i.event_id,
      (i) => {
        if (an) {
          const s = i;
          s.logLevel === "log" ? Xe.log(s.message) : Xe.warn(s);
        }
      }
    );
  }
  _processEvent(e, n, r) {
    const i = this.getOptions(),
      { sampleRate: s } = i,
      a = Jq(e),
      o = Qq(e),
      l = e.type || "error",
      u = `before send for type \`${l}\``;
    if (o && typeof s == "number" && Math.random() > s)
      return (
        this.recordDroppedEvent("sample_rate", "error", e),
        CS(
          new Fu(
            `Discarding event because it's not included in the random sample (sampling rate = ${s})`,
            "log"
          )
        )
      );
    const f = l === "replay_event" ? "replay" : l;
    return this._prepareEvent(e, n, r)
      .then((c) => {
        if (c === null)
          throw (
            (this.recordDroppedEvent("event_processor", f, e),
            new Fu(
              "An event processor returned `null`, will not send event.",
              "log"
            ))
          );
        if (n.data && n.data.__sentry__ === !0) return c;
        const p = wOe(i, c, n);
        return bOe(p, u);
      })
      .then((c) => {
        if (c === null)
          throw (
            (this.recordDroppedEvent("before_send", f, e),
            new Fu(`${u} returned \`null\`, will not send event.`, "log"))
          );
        const d = r && r.getSession();
        !a && d && this._updateSessionFromEvent(d, c);
        const p = c.transaction_info;
        if (a && p && c.transaction !== e.transaction) {
          const m = "custom";
          c.transaction_info = { ...p, source: m };
        }
        return this.sendEvent(c, n), c;
      })
      .then(null, (c) => {
        throw c instanceof Fu
          ? c
          : (this.captureException(c, {
              data: { __sentry__: !0 },
              originalException: c,
            }),
            new Fu(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${c}`));
      });
  }
  _process(e) {
    this._numProcessing++,
      e.then(
        (n) => (this._numProcessing--, n),
        (n) => (this._numProcessing--, n)
      );
  }
  _sendEnvelope(e) {
    if ((this.emit("beforeEnvelope", e), this._isEnabled() && this._transport))
      return this._transport.send(e).then(null, (n) => {
        an && Xe.error("Error while sending event:", n);
      });
    an && Xe.error("Transport disabled");
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return (
      (this._outcomes = {}),
      Object.keys(e).map((n) => {
        const [r, i] = n.split(":");
        return { reason: r, category: i, quantity: e[n] };
      })
    );
  }
}
function bOe(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (TS(t))
    return t.then(
      (r) => {
        if (!t1(r) && r !== null) throw new Fu(n);
        return r;
      },
      (r) => {
        throw new Fu(`${e} rejected with ${r}`);
      }
    );
  if (!t1(t) && t !== null) throw new Fu(n);
  return t;
}
function wOe(t, e, n) {
  const { beforeSend: r, beforeSendTransaction: i } = t;
  return Qq(e) && r ? r(e, n) : Jq(e) && i ? i(e, n) : e;
}
function Qq(t) {
  return t.type === void 0;
}
function Jq(t) {
  return t.type === "transaction";
}
function _Oe(t, e) {
  e.debug === !0 &&
    (an
      ? Xe.enable()
      : M6(() => {
          console.warn(
            "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."
          );
        }));
  const n = Ei();
  n.getScope().update(e.initialScope);
  const i = new t(e);
  n.bindClient(i);
}
const EOe = 30;
function eK(t, e, n = uIe(t.bufferSize || EOe)) {
  let r = {};
  const i = (a) => n.drain(a);
  function s(a) {
    const o = [];
    if (
      (fB(a, (c, d) => {
        const p = dB(d);
        if (PIe(r, p)) {
          const m = wB(c, d);
          t.recordDroppedEvent("ratelimit_backoff", p, m);
        } else o.push(c);
      }),
      o.length === 0)
    )
      return Ih();
    const l = Yy(a[0], o),
      u = (c) => {
        fB(l, (d, p) => {
          const m = wB(d, p);
          t.recordDroppedEvent(c, dB(p), m);
        });
      },
      f = () =>
        e({ body: EIe(l, t.textEncoder) }).then(
          (c) => (
            c.statusCode !== void 0 &&
              (c.statusCode < 200 || c.statusCode >= 300) &&
              an &&
              Xe.warn(
                `Sentry responded with status code ${c.statusCode} to sent event.`
              ),
            (r = NIe(r, c)),
            c
          ),
          (c) => {
            throw (u("network_error"), c);
          }
        );
    return n.add(f).then(
      (c) => c,
      (c) => {
        if (c instanceof Fu)
          return (
            an && Xe.error("Skipped sending event because buffer is full."),
            u("queue_overflow"),
            Ih()
          );
        throw c;
      }
    );
  }
  return (s.__sentry__baseTransport__ = !0), { send: s, flush: i };
}
function wB(t, e) {
  if (!(e !== "event" && e !== "transaction"))
    return Array.isArray(t) ? t[1] : void 0;
}
let _B;
class F6 {
  static __initStatic() {
    this.id = "FunctionToString";
  }
  constructor() {
    this.name = F6.id;
  }
  setupOnce() {
    _B = Function.prototype.toString;
    try {
      Function.prototype.toString = function (...e) {
        const n = SS(this) || this;
        return _B.apply(n, e);
      };
    } catch {}
  }
}
F6.__initStatic();
const xOe = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
  ],
  TOe = [
    /^.*\/healthcheck$/,
    /^.*\/healthy$/,
    /^.*\/live$/,
    /^.*\/ready$/,
    /^.*\/heartbeat$/,
    /^.*\/health$/,
    /^.*\/healthz$/,
  ];
class $6 {
  static __initStatic() {
    this.id = "InboundFilters";
  }
  constructor(e = {}) {
    (this.name = $6.id), (this._options = e);
  }
  setupOnce(e, n) {}
  processEvent(e, n, r) {
    const i = r.getOptions(),
      s = SOe(this._options, i);
    return AOe(e, s) ? null : e;
  }
}
$6.__initStatic();
function SOe(t = {}, e = {}) {
  return {
    allowUrls: [...(t.allowUrls || []), ...(e.allowUrls || [])],
    denyUrls: [...(t.denyUrls || []), ...(e.denyUrls || [])],
    ignoreErrors: [
      ...(t.ignoreErrors || []),
      ...(e.ignoreErrors || []),
      ...(t.disableErrorDefaults ? [] : xOe),
    ],
    ignoreTransactions: [
      ...(t.ignoreTransactions || []),
      ...(e.ignoreTransactions || []),
      ...(t.disableTransactionDefaults ? [] : TOe),
    ],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0,
  };
}
function AOe(t, e) {
  return e.ignoreInternal && NOe(t)
    ? (an &&
        Xe.warn(`Event dropped due to being internal Sentry Error.
Event: ${$f(t)}`),
      !0)
    : COe(t, e.ignoreErrors)
    ? (an &&
        Xe.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${$f(t)}`),
      !0)
    : kOe(t, e.ignoreTransactions)
    ? (an &&
        Xe.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${$f(t)}`),
      !0)
    : IOe(t, e.denyUrls)
    ? (an &&
        Xe.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${$f(t)}.
Url: ${iw(t)}`),
      !0)
    : OOe(t, e.allowUrls)
    ? !1
    : (an &&
        Xe.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${$f(t)}.
Url: ${iw(t)}`),
      !0);
}
function COe(t, e) {
  return t.type || !e || !e.length ? !1 : POe(t).some((n) => Xy(n, e));
}
function kOe(t, e) {
  if (t.type !== "transaction" || !e || !e.length) return !1;
  const n = t.transaction;
  return n ? Xy(n, e) : !1;
}
function IOe(t, e) {
  if (!e || !e.length) return !1;
  const n = iw(t);
  return n ? Xy(n, e) : !1;
}
function OOe(t, e) {
  if (!e || !e.length) return !0;
  const n = iw(t);
  return n ? Xy(n, e) : !0;
}
function POe(t) {
  const e = [];
  t.message && e.push(t.message);
  let n;
  try {
    n = t.exception.values[t.exception.values.length - 1];
  } catch {}
  return (
    n &&
      n.value &&
      (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`)),
    an &&
      e.length === 0 &&
      Xe.error(`Could not extract message for event ${$f(t)}`),
    e
  );
}
function NOe(t) {
  try {
    return t.exception.values[0].type === "SentryError";
  } catch {}
  return !1;
}
function DOe(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function iw(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames;
    } catch {}
    return e ? DOe(e) : null;
  } catch {
    return an && Xe.error(`Cannot extract url for event ${$f(t)}`), null;
  }
}
const nr = wr;
let g9 = 0;
function tK() {
  return g9 > 0;
}
function ROe() {
  g9++,
    setTimeout(() => {
      g9--;
    });
}
function i1(t, e = {}, n) {
  if (typeof t != "function") return t;
  try {
    const i = t.__sentry_wrapped__;
    if (i) return i;
    if (SS(t)) return t;
  } catch {
    return t;
  }
  const r = function () {
    const i = Array.prototype.slice.call(arguments);
    try {
      n && typeof n == "function" && n.apply(this, arguments);
      const s = i.map((a) => i1(a, e));
      return t.apply(this, s);
    } catch (s) {
      throw (
        (ROe(),
        Kq((a) => {
          a.addEventProcessor(
            (o) => (
              e.mechanism && (r9(o, void 0, void 0), cy(o, e.mechanism)),
              (o.extra = { ...o.extra, arguments: i }),
              o
            )
          ),
            qq(s);
        }),
        s)
      );
    }
  };
  try {
    for (const i in t)
      Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i]);
  } catch {}
  Cq(r, t), uy(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable &&
      Object.defineProperty(r, "name", {
        get() {
          return t.name;
        },
      });
  } catch {}
  return r;
}
const dl = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function nK(t, e) {
  const n = RS(t, e),
    r = { type: e && e.name, value: FOe(e) };
  return (
    n.length && (r.stacktrace = { frames: n }),
    r.type === void 0 &&
      r.value === "" &&
      (r.value = "Unrecoverable error caught"),
    r
  );
}
function MOe(t, e, n, r) {
  const s = Ei().getClient(),
    a = s && s.getOptions().normalizeDepth,
    o = {
      exception: {
        values: [
          {
            type: D6(e)
              ? e.constructor.name
              : r
              ? "UnhandledRejection"
              : "Error",
            value: jOe(e, { isUnhandledRejection: r }),
          },
        ],
      },
      extra: { __serialized__: Fq(e, a) },
    };
  if (n) {
    const l = RS(t, n);
    l.length && (o.exception.values[0].stacktrace = { frames: l });
  }
  return o;
}
function i4(t, e) {
  return { exception: { values: [nK(t, e)] } };
}
function RS(t, e) {
  const n = e.stacktrace || e.stack || "",
    r = BOe(e);
  try {
    return t(n, r);
  } catch {}
  return [];
}
const LOe = /Minified React error #\d+;/i;
function BOe(t) {
  if (t) {
    if (typeof t.framesToPop == "number") return t.framesToPop;
    if (LOe.test(t.message)) return 1;
  }
  return 0;
}
function FOe(t) {
  const e = t && t.message;
  return e
    ? e.error && typeof e.error.message == "string"
      ? e.error.message
      : e
    : "No error message";
}
function $Oe(t, e, n, r) {
  const i = (n && n.syntheticException) || void 0,
    s = MS(t, e, i, r);
  return (
    cy(s),
    (s.level = "error"),
    n && n.event_id && (s.event_id = n.event_id),
    Ih(s)
  );
}
function UOe(t, e, n = "info", r, i) {
  const s = (r && r.syntheticException) || void 0,
    a = y9(t, e, s, i);
  return (a.level = n), r && r.event_id && (a.event_id = r.event_id), Ih(a);
}
function MS(t, e, n, r, i) {
  let s;
  if (ES(e) && e.error) return i4(t, e.error);
  if (ZL(e) || mke(e)) {
    const a = e;
    if ("stack" in e) s = i4(t, e);
    else {
      const o = a.name || (ZL(a) ? "DOMError" : "DOMException"),
        l = a.message ? `${o}: ${a.message}` : o;
      (s = y9(t, l, n, r)), r9(s, l);
    }
    return (
      "code" in a && (s.tags = { ...s.tags, "DOMException.code": `${a.code}` }),
      s
    );
  }
  return _S(e)
    ? i4(t, e)
    : t1(e) || D6(e)
    ? ((s = MOe(t, e, n, i)), cy(s, { synthetic: !0 }), s)
    : ((s = y9(t, e, n, r)),
      r9(s, `${e}`, void 0),
      cy(s, { synthetic: !0 }),
      s);
}
function y9(t, e, n, r) {
  const i = { message: e };
  if (r && n) {
    const s = RS(t, n);
    s.length &&
      (i.exception = { values: [{ value: e, stacktrace: { frames: s } }] });
  }
  return i;
}
function jOe(t, { isUnhandledRejection: e }) {
  const n = Dke(t),
    r = e ? "promise rejection" : "exception";
  return ES(t)
    ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\``
    : D6(t)
    ? `Event \`${HOe(t)}\` (type=${t.type}) captured as ${r}`
    : `Object captured as ${r} with keys: ${n}`;
}
function HOe(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0;
  } catch {}
}
function zOe(t, { metadata: e, tunnel: n, dsn: r }) {
  const i = {
      event_id: t.event_id,
      sent_at: new Date().toISOString(),
      ...(e && e.sdk && { sdk: { name: e.sdk.name, version: e.sdk.version } }),
      ...(!!n && !!r && { dsn: Zy(r) }),
    },
    s = VOe(t);
  return Yy(i, [s]);
}
function VOe(t) {
  return [{ type: "user_report" }, t];
}
class GOe extends vOe {
  constructor(e) {
    const n = nr.SENTRY_SDK_SOURCE || tIe();
    (e._metadata = e._metadata || {}),
      (e._metadata.sdk = e._metadata.sdk || {
        name: "sentry.javascript.browser",
        packages: [{ name: `${n}:@sentry/browser`, version: fy }],
        version: fy,
      }),
      super(e),
      e.sendClientReports &&
        nr.document &&
        nr.document.addEventListener("visibilitychange", () => {
          nr.document.visibilityState === "hidden" && this._flushOutcomes();
        });
  }
  eventFromException(e, n) {
    return $Oe(this._options.stackParser, e, n, this._options.attachStacktrace);
  }
  eventFromMessage(e, n = "info", r) {
    return UOe(
      this._options.stackParser,
      e,
      n,
      r,
      this._options.attachStacktrace
    );
  }
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      dl && Xe.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = zOe(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel,
    });
    this._sendEnvelope(n);
  }
  _prepareEvent(e, n, r) {
    return (
      (e.platform = e.platform || "javascript"), super._prepareEvent(e, n, r)
    );
  }
  _flushOutcomes() {
    const e = this._clearOutcomes();
    if (e.length === 0) {
      dl && Xe.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      dl && Xe.log("No dsn provided, will not send outcomes");
      return;
    }
    dl && Xe.log("Sending outcomes:", e);
    const n = CIe(e, this._options.tunnel && Zy(this._dsn));
    this._sendEnvelope(n);
  }
}
let Zm;
function WOe() {
  if (Zm) return Zm;
  if (o9(nr.fetch)) return (Zm = nr.fetch.bind(nr));
  const t = nr.document;
  let e = nr.fetch;
  if (t && typeof t.createElement == "function")
    try {
      const n = t.createElement("iframe");
      (n.hidden = !0), t.head.appendChild(n);
      const r = n.contentWindow;
      r && r.fetch && (e = r.fetch), t.head.removeChild(n);
    } catch (n) {
      dl &&
        Xe.warn(
          "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
          n
        );
    }
  return (Zm = e.bind(nr));
}
function qOe() {
  Zm = void 0;
}
function KOe(t, e = WOe()) {
  let n = 0,
    r = 0;
  function i(s) {
    const a = s.body.length;
    (n += a), r++;
    const o = {
      body: s.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions,
    };
    try {
      return e(t.url, o).then(
        (l) => (
          (n -= a),
          r--,
          {
            statusCode: l.status,
            headers: {
              "x-sentry-rate-limits": l.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": l.headers.get("Retry-After"),
            },
          }
        )
      );
    } catch (l) {
      return qOe(), (n -= a), r--, CS(l);
    }
  }
  return eK(t, i);
}
const XOe = 4;
function ZOe(t) {
  function e(n) {
    return new Io((r, i) => {
      const s = new XMLHttpRequest();
      (s.onerror = i),
        (s.onreadystatechange = () => {
          s.readyState === XOe &&
            r({
              statusCode: s.status,
              headers: {
                "x-sentry-rate-limits": s.getResponseHeader(
                  "X-Sentry-Rate-Limits"
                ),
                "retry-after": s.getResponseHeader("Retry-After"),
              },
            });
        }),
        s.open("POST", t.url);
      for (const a in t.headers)
        Object.prototype.hasOwnProperty.call(t.headers, a) &&
          s.setRequestHeader(a, t.headers[a]);
      s.send(n.body);
    });
  }
  return eK(t, e);
}
const U6 = "?",
  YOe = 30,
  QOe = 40,
  JOe = 50;
function LS(t, e, n, r) {
  const i = { filename: t, function: e, in_app: !0 };
  return n !== void 0 && (i.lineno = n), r !== void 0 && (i.colno = r), i;
}
const ePe =
    /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  tPe = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  nPe = (t) => {
    const e = ePe.exec(t);
    if (e) {
      if (e[2] && e[2].indexOf("eval") === 0) {
        const s = tPe.exec(e[2]);
        s && ((e[2] = s[1]), (e[3] = s[2]), (e[4] = s[3]));
      }
      const [r, i] = rK(e[1] || U6, e[2]);
      return LS(i, r, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0);
    }
  },
  rPe = [YOe, nPe],
  iPe =
    /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  sPe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  aPe = (t) => {
    const e = iPe.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const s = sPe.exec(e[3]);
        s &&
          ((e[1] = e[1] || "eval"), (e[3] = s[1]), (e[4] = s[2]), (e[5] = ""));
      }
      let r = e[3],
        i = e[1] || U6;
      return (
        ([i, r] = rK(i, r)),
        LS(r, i, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
      );
    }
  },
  oPe = [JOe, aPe],
  lPe =
    /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
  uPe = (t) => {
    const e = lPe.exec(t);
    return e ? LS(e[2], e[1] || U6, +e[3], e[4] ? +e[4] : void 0) : void 0;
  },
  cPe = [QOe, uPe],
  fPe = [rPe, oPe, cPe],
  dPe = Oq(...fPe),
  rK = (t, e) => {
    const n = t.indexOf("safari-extension") !== -1,
      r = t.indexOf("safari-web-extension") !== -1;
    return n || r
      ? [
          t.indexOf("@") !== -1 ? t.split("@")[0] : U6,
          n ? `safari-extension:${e}` : `safari-web-extension:${e}`,
        ]
      : [t, e];
  };
class M1 {
  static __initStatic() {
    this.id = "GlobalHandlers";
  }
  constructor(e) {
    (this.name = M1.id),
      (this._options = { onerror: !0, onunhandledrejection: !0, ...e }),
      (this._installFunc = { onerror: hPe, onunhandledrejection: pPe });
  }
  setupOnce() {
    Error.stackTraceLimit = 50;
    const e = this._options;
    for (const n in e) {
      const r = this._installFunc[n];
      r && e[n] && (vPe(n), r(), (this._installFunc[n] = void 0));
    }
  }
}
M1.__initStatic();
function hPe() {
  Mq((t) => {
    const [e, n, r] = sK();
    if (!e.getIntegration(M1)) return;
    const { msg: i, url: s, line: a, column: o, error: l } = t;
    if (tK()) return;
    const u =
      l === void 0 && Xu(i)
        ? yPe(i, s, a, o)
        : iK(MS(n, l || i, void 0, r, !1), s, a, o);
    (u.level = "error"),
      e.captureEvent(u, {
        originalException: l,
        mechanism: { handled: !1, type: "onerror" },
      });
  });
}
function pPe() {
  Lq((t) => {
    const [e, n, r] = sK();
    if (!e.getIntegration(M1)) return;
    if (tK()) return !0;
    const i = mPe(t),
      s = xS(i) ? gPe(i) : MS(n, i, void 0, r, !0);
    (s.level = "error"),
      e.captureEvent(s, {
        originalException: i,
        mechanism: { handled: !1, type: "onunhandledrejection" },
      });
  });
}
function mPe(t) {
  if (xS(t)) return t;
  const e = t;
  try {
    if ("reason" in e) return e.reason;
    if ("detail" in e && "reason" in e.detail) return e.detail.reason;
  } catch {}
  return t;
}
function gPe(t) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          value: `Non-Error promise rejection captured with value: ${String(
            t
          )}`,
        },
      ],
    },
  };
}
function yPe(t, e, n, r) {
  const i =
    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let s = ES(t) ? t.message : t,
    a = "Error";
  const o = s.match(i);
  return (
    o && ((a = o[1]), (s = o[2])),
    iK({ exception: { values: [{ type: a, value: s }] } }, e, n, r)
  );
}
function iK(t, e, n, r) {
  const i = (t.exception = t.exception || {}),
    s = (i.values = i.values || []),
    a = (s[0] = s[0] || {}),
    o = (a.stacktrace = a.stacktrace || {}),
    l = (o.frames = o.frames || []),
    u = isNaN(parseInt(r, 10)) ? void 0 : r,
    f = isNaN(parseInt(n, 10)) ? void 0 : n,
    c = Xu(e) && e.length > 0 ? e : Tke();
  return (
    l.length === 0 &&
      l.push({ colno: u, filename: c, function: "?", in_app: !0, lineno: f }),
    t
  );
}
function vPe(t) {
  dl && Xe.log(`Global Handler attached: ${t}`);
}
function sK() {
  const t = Ei(),
    e = t.getClient(),
    n = (e && e.getOptions()) || {
      stackParser: () => [],
      attachStacktrace: !1,
    };
  return [t, n.stackParser, n.attachStacktrace];
}
const bPe = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload",
];
class j6 {
  static __initStatic() {
    this.id = "TryCatch";
  }
  constructor(e) {
    (this.name = j6.id),
      (this._options = {
        XMLHttpRequest: !0,
        eventTarget: !0,
        requestAnimationFrame: !0,
        setInterval: !0,
        setTimeout: !0,
        ...e,
      });
  }
  setupOnce() {
    this._options.setTimeout && Ns(nr, "setTimeout", EB),
      this._options.setInterval && Ns(nr, "setInterval", EB),
      this._options.requestAnimationFrame &&
        Ns(nr, "requestAnimationFrame", wPe),
      this._options.XMLHttpRequest &&
        "XMLHttpRequest" in nr &&
        Ns(XMLHttpRequest.prototype, "send", _Pe);
    const e = this._options.eventTarget;
    e && (Array.isArray(e) ? e : bPe).forEach(EPe);
  }
}
j6.__initStatic();
function EB(t) {
  return function (...e) {
    const n = e[0];
    return (
      (e[0] = i1(n, {
        mechanism: {
          data: { function: nf(t) },
          handled: !1,
          type: "instrument",
        },
      })),
      t.apply(this, e)
    );
  };
}
function wPe(t) {
  return function (e) {
    return t.apply(this, [
      i1(e, {
        mechanism: {
          data: { function: "requestAnimationFrame", handler: nf(t) },
          handled: !1,
          type: "instrument",
        },
      }),
    ]);
  };
}
function _Pe(t) {
  return function (...e) {
    const n = this;
    return (
      ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((i) => {
        i in n &&
          typeof n[i] == "function" &&
          Ns(n, i, function (s) {
            const a = {
                mechanism: {
                  data: { function: i, handler: nf(s) },
                  handled: !1,
                  type: "instrument",
                },
              },
              o = SS(s);
            return o && (a.mechanism.data.handler = nf(o)), i1(s, a);
          });
      }),
      t.apply(this, e)
    );
  };
}
function EPe(t) {
  const e = nr,
    n = e[t] && e[t].prototype;
  !n ||
    !n.hasOwnProperty ||
    !n.hasOwnProperty("addEventListener") ||
    (Ns(n, "addEventListener", function (r) {
      return function (i, s, a) {
        try {
          typeof s.handleEvent == "function" &&
            (s.handleEvent = i1(s.handleEvent, {
              mechanism: {
                data: { function: "handleEvent", handler: nf(s), target: t },
                handled: !1,
                type: "instrument",
              },
            }));
        } catch {}
        return r.apply(this, [
          i,
          i1(s, {
            mechanism: {
              data: { function: "addEventListener", handler: nf(s), target: t },
              handled: !1,
              type: "instrument",
            },
          }),
          a,
        ]);
      };
    }),
    Ns(n, "removeEventListener", function (r) {
      return function (i, s, a) {
        const o = s;
        try {
          const l = o && o.__sentry_wrapped__;
          l && r.call(this, i, l, a);
        } catch {}
        return r.call(this, i, o, a);
      };
    }));
}
const xPe = "cause",
  TPe = 5;
class H6 {
  static __initStatic() {
    this.id = "LinkedErrors";
  }
  constructor(e = {}) {
    (this.name = H6.id),
      (this._key = e.key || xPe),
      (this._limit = e.limit || TPe);
  }
  setupOnce() {}
  preprocessEvent(e, n, r) {
    const i = r.getOptions();
    wke(nK, i.stackParser, i.maxValueLength, this._key, this._limit, e, n);
  }
}
H6.__initStatic();
class z6 {
  static __initStatic() {
    this.id = "HttpContext";
  }
  constructor() {
    this.name = z6.id;
  }
  setupOnce() {}
  preprocessEvent(e) {
    if (!nr.navigator && !nr.location && !nr.document) return;
    const n = (e.request && e.request.url) || (nr.location && nr.location.href),
      { referrer: r } = nr.document || {},
      { userAgent: i } = nr.navigator || {},
      s = {
        ...(e.request && e.request.headers),
        ...(r && { Referer: r }),
        ...(i && { "User-Agent": i }),
      },
      a = { ...e.request, ...(n && { url: n }), headers: s };
    e.request = a;
  }
}
z6.__initStatic();
class V6 {
  static __initStatic() {
    this.id = "Dedupe";
  }
  constructor() {
    this.name = V6.id;
  }
  setupOnce(e, n) {}
  processEvent(e) {
    if (e.type) return e;
    try {
      if (SPe(e, this._previousEvent))
        return (
          dl &&
            Xe.warn(
              "Event dropped due to being a duplicate of previously captured event."
            ),
          null
        );
    } catch {}
    return (this._previousEvent = e);
  }
}
V6.__initStatic();
function SPe(t, e) {
  return e ? !!(APe(t, e) || CPe(t, e)) : !1;
}
function APe(t, e) {
  const n = t.message,
    r = e.message;
  return !(
    (!n && !r) ||
    (n && !r) ||
    (!n && r) ||
    n !== r ||
    !oK(t, e) ||
    !aK(t, e)
  );
}
function CPe(t, e) {
  const n = xB(e),
    r = xB(t);
  return !(
    !n ||
    !r ||
    n.type !== r.type ||
    n.value !== r.value ||
    !oK(t, e) ||
    !aK(t, e)
  );
}
function aK(t, e) {
  let n = TB(t),
    r = TB(e);
  if (!n && !r) return !0;
  if ((n && !r) || (!n && r) || ((n = n), (r = r), r.length !== n.length))
    return !1;
  for (let i = 0; i < r.length; i++) {
    const s = r[i],
      a = n[i];
    if (
      s.filename !== a.filename ||
      s.lineno !== a.lineno ||
      s.colno !== a.colno ||
      s.function !== a.function
    )
      return !1;
  }
  return !0;
}
function oK(t, e) {
  let n = t.fingerprint,
    r = e.fingerprint;
  if (!n && !r) return !0;
  if ((n && !r) || (!n && r)) return !1;
  (n = n), (r = r);
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function xB(t) {
  return t.exception && t.exception.values && t.exception.values[0];
}
function TB(t) {
  const e = t.exception;
  if (e)
    try {
      return e.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
const Bv = 1024;
class G6 {
  static __initStatic() {
    this.id = "Breadcrumbs";
  }
  constructor(e) {
    (this.name = G6.id),
      (this.options = {
        console: !0,
        dom: !0,
        fetch: !0,
        history: !0,
        sentry: !0,
        xhr: !0,
        ...e,
      });
  }
  setupOnce() {
    if (
      (this.options.console && Lke(OPe),
      this.options.dom && $ke(IPe(this.options.dom)),
      this.options.xhr && Bq(PPe),
      this.options.fetch && Rq(NPe),
      this.options.history && AS(DPe),
      this.options.sentry)
    ) {
      const e = NS();
      e && e.on && e.on("beforeSendEvent", kPe);
    }
  }
}
G6.__initStatic();
function kPe(t) {
  Ei().addBreadcrumb(
    {
      category: `sentry.${t.type === "transaction" ? "transaction" : "event"}`,
      event_id: t.event_id,
      level: t.level,
      message: $f(t),
    },
    { event: t }
  );
}
function IPe(t) {
  function e(n) {
    let r,
      i = typeof t == "object" ? t.serializeAttribute : void 0,
      s =
        typeof t == "object" && typeof t.maxStringLength == "number"
          ? t.maxStringLength
          : void 0;
    s &&
      s > Bv &&
      (dl &&
        Xe.warn(
          `\`dom.maxStringLength\` cannot exceed ${Bv}, but a value of ${s} was configured. Sentry will use ${Bv} instead.`
        ),
      (s = Bv)),
      typeof i == "string" && (i = [i]);
    try {
      const a = n.event;
      r = RPe(a)
        ? n1(a.target, { keyAttrs: i, maxStringLength: s })
        : n1(a, { keyAttrs: i, maxStringLength: s });
    } catch {
      r = "<unknown>";
    }
    r.length !== 0 &&
      Ei().addBreadcrumb(
        { category: `ui.${n.name}`, message: r },
        { event: n.event, name: n.name, global: n.global }
      );
  }
  return e;
}
function OPe(t) {
  const e = {
    category: "console",
    data: { arguments: t.args, logger: "console" },
    level: fIe(t.level),
    message: YL(t.args, " "),
  };
  if (t.level === "assert")
    if (t.args[0] === !1)
      (e.message = `Assertion failed: ${
        YL(t.args.slice(1), " ") || "console.assert"
      }`),
        (e.data.arguments = t.args.slice(1));
    else return;
  Ei().addBreadcrumb(e, { input: t.args, level: t.level });
}
function PPe(t) {
  const { startTimestamp: e, endTimestamp: n } = t,
    r = t.xhr[Jp];
  if (!e || !n || !r) return;
  const { method: i, url: s, status_code: a, body: o } = r,
    l = { method: i, url: s, status_code: a },
    u = { xhr: t.xhr, input: o, startTimestamp: e, endTimestamp: n };
  Ei().addBreadcrumb({ category: "xhr", data: l, type: "http" }, u);
}
function NPe(t) {
  const { startTimestamp: e, endTimestamp: n } = t;
  if (
    n &&
    !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST")
  )
    if (t.error) {
      const r = t.fetchData,
        i = {
          data: t.error,
          input: t.args,
          startTimestamp: e,
          endTimestamp: n,
        };
      Ei().addBreadcrumb(
        { category: "fetch", data: r, level: "error", type: "http" },
        i
      );
    } else {
      const r = t.response,
        i = { ...t.fetchData, status_code: r && r.status },
        s = { input: t.args, response: r, startTimestamp: e, endTimestamp: n };
      Ei().addBreadcrumb({ category: "fetch", data: i, type: "http" }, s);
    }
}
function DPe(t) {
  let e = t.from,
    n = t.to;
  const r = n4(nr.location.href);
  let i = e ? n4(e) : void 0;
  const s = n4(n);
  (!i || !i.path) && (i = r),
    r.protocol === s.protocol && r.host === s.host && (n = s.relative),
    r.protocol === i.protocol && r.host === i.host && (e = i.relative),
    Ei().addBreadcrumb({ category: "navigation", data: { from: e, to: n } });
}
function RPe(t) {
  return !!t && !!t.target;
}
const MPe = [
  new $6(),
  new F6(),
  new j6(),
  new G6(),
  new M1(),
  new H6(),
  new V6(),
  new z6(),
];
function LPe(t = {}) {
  t.defaultIntegrations === void 0 && (t.defaultIntegrations = MPe),
    t.release === void 0 &&
      (typeof __SENTRY_RELEASE__ == "string" &&
        (t.release = __SENTRY_RELEASE__),
      nr.SENTRY_RELEASE &&
        nr.SENTRY_RELEASE.id &&
        (t.release = nr.SENTRY_RELEASE.id)),
    t.autoSessionTracking === void 0 && (t.autoSessionTracking = !0),
    t.sendClientReports === void 0 && (t.sendClientReports = !0);
  const e = {
    ...t,
    stackParser: Rke(t.stackParser || dPe),
    integrations: mOe(t),
    transport: t.transport || (Dq() ? KOe : ZOe),
  };
  _Oe(GOe, e), t.autoSessionTracking && BPe();
}
function SB(t = {}, e = Ei()) {
  if (!nr.document) {
    dl && Xe.error("Global document not defined in showReportDialog call");
    return;
  }
  const { client: n, scope: r } = e.getStackTop(),
    i = t.dsn || (n && n.getDsn());
  if (!i) {
    dl && Xe.error("DSN not configured for showReportDialog call");
    return;
  }
  r && (t.user = { ...r.getUser(), ...t.user }),
    t.eventId || (t.eventId = e.lastEventId());
  const s = nr.document.createElement("script");
  (s.async = !0),
    (s.crossOrigin = "anonymous"),
    (s.src = hOe(i, t)),
    t.onLoad && (s.onload = t.onLoad);
  const { onClose: a } = t;
  if (a) {
    const l = (u) => {
      if (u.data === "__sentry_reportdialog_closed__")
        try {
          a();
        } finally {
          nr.removeEventListener("message", l);
        }
    };
    nr.addEventListener("message", l);
  }
  const o = nr.document.head || nr.document.body;
  o
    ? o.appendChild(s)
    : dl &&
      Xe.error("Not injecting report dialog. No injection point found in HTML");
}
function AB(t) {
  t.startSession({ ignoreDuration: !0 }), t.captureSession();
}
function BPe() {
  if (typeof nr.document > "u") {
    dl &&
      Xe.warn(
        "Session tracking in non-browser environment with @sentry/browser is not supported."
      );
    return;
  }
  const t = Ei();
  t.captureSession &&
    (AB(t),
    AS(({ from: e, to: n }) => {
      e !== void 0 && e !== n && AB(Ei());
    }));
}
const si = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  Ir = wr;
function FPe() {
  Ir && Ir.document
    ? Ir.document.addEventListener("visibilitychange", () => {
        const t = Jy();
        if (Ir.document.hidden && t) {
          const e = "cancelled";
          si &&
            Xe.log(
              `[Tracing] Transaction: ${e} -> since tab moved to the background, op: ${t.op}`
            ),
            t.status || t.setStatus(e),
            t.setTag("visibilitychange", "document.hidden"),
            t.finish();
        }
      })
    : si &&
      Xe.warn(
        "[Tracing] Could not set up background tab detection due to lack of global document"
      );
}
const BS = (t, e, n) => {
    let r, i;
    return (s) => {
      e.value >= 0 &&
        (s || n) &&
        ((i = e.value - (r || 0)),
        (i || r === void 0) && ((r = e.value), (e.delta = i), t(e)));
    };
  },
  $Pe = () =>
    `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`,
  UPe = () => {
    const t = Ir.performance.timing,
      e = Ir.performance.navigation.type,
      n = {
        entryType: "navigation",
        startTime: 0,
        type: e == 2 ? "back_forward" : e === 1 ? "reload" : "navigate",
      };
    for (const r in t)
      r !== "navigationStart" &&
        r !== "toJSON" &&
        (n[r] = Math.max(t[r] - t.navigationStart, 0));
    return n;
  },
  lK = () =>
    Ir.__WEB_VITALS_POLYFILL__
      ? Ir.performance &&
        ((performance.getEntriesByType &&
          performance.getEntriesByType("navigation")[0]) ||
          UPe())
      : Ir.performance &&
        performance.getEntriesByType &&
        performance.getEntriesByType("navigation")[0],
  uK = () => {
    const t = lK();
    return (t && t.activationStart) || 0;
  },
  FS = (t, e) => {
    const n = lK();
    let r = "navigate";
    return (
      n &&
        (Ir.document.prerendering || uK() > 0
          ? (r = "prerender")
          : (r = n.type.replace(/_/g, "-"))),
      {
        name: t,
        value: typeof e > "u" ? -1 : e,
        rating: "good",
        delta: 0,
        entries: [],
        id: $Pe(),
        navigationType: r,
      }
    );
  },
  W6 = (t, e, n) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const r = new PerformanceObserver((i) => {
          e(i.getEntries());
        });
        return r.observe(Object.assign({ type: t, buffered: !0 }, n || {})), r;
      }
    } catch {}
  },
  q6 = (t, e) => {
    const n = (r) => {
      (r.type === "pagehide" || Ir.document.visibilityState === "hidden") &&
        (t(r),
        e &&
          (removeEventListener("visibilitychange", n, !0),
          removeEventListener("pagehide", n, !0)));
    };
    addEventListener("visibilitychange", n, !0),
      addEventListener("pagehide", n, !0);
  },
  jPe = (t) => {
    const e = FS("CLS", 0);
    let n,
      r = 0,
      i = [];
    const s = (o) => {
        o.forEach((l) => {
          if (!l.hadRecentInput) {
            const u = i[0],
              f = i[i.length - 1];
            r &&
            i.length !== 0 &&
            l.startTime - f.startTime < 1e3 &&
            l.startTime - u.startTime < 5e3
              ? ((r += l.value), i.push(l))
              : ((r = l.value), (i = [l])),
              r > e.value && ((e.value = r), (e.entries = i), n && n());
          }
        });
      },
      a = W6("layout-shift", s);
    if (a) {
      n = BS(t, e);
      const o = () => {
        s(a.takeRecords()), n(!0);
      };
      return q6(o), o;
    }
  };
let Eb = -1;
const HPe = () =>
    Ir.document.visibilityState === "hidden" && !Ir.document.prerendering
      ? 0
      : 1 / 0,
  zPe = () => {
    q6(({ timeStamp: t }) => {
      Eb = t;
    }, !0);
  },
  $S = () => (
    Eb < 0 && ((Eb = HPe()), zPe()),
    {
      get firstHiddenTime() {
        return Eb;
      },
    }
  ),
  VPe = (t) => {
    const e = $S(),
      n = FS("FID");
    let r;
    const i = (o) => {
        o.startTime < e.firstHiddenTime &&
          ((n.value = o.processingStart - o.startTime),
          n.entries.push(o),
          r(!0));
      },
      s = (o) => {
        o.forEach(i);
      },
      a = W6("first-input", s);
    (r = BS(t, n)),
      a &&
        q6(() => {
          s(a.takeRecords()), a.disconnect();
        }, !0);
  },
  CB = {},
  GPe = (t) => {
    const e = $S(),
      n = FS("LCP");
    let r;
    const i = (a) => {
        const o = a[a.length - 1];
        if (o) {
          const l = Math.max(o.startTime - uK(), 0);
          l < e.firstHiddenTime && ((n.value = l), (n.entries = [o]), r());
        }
      },
      s = W6("largest-contentful-paint", i);
    if (s) {
      r = BS(t, n);
      const a = () => {
        CB[n.id] ||
          (i(s.takeRecords()), s.disconnect(), (CB[n.id] = !0), r(!0));
      };
      return (
        ["keydown", "click"].forEach((o) => {
          addEventListener(o, a, { once: !0, capture: !0 });
        }),
        q6(a, !0),
        a
      );
    }
  },
  dg = {},
  sw = {};
let cK, fK, dK;
function WPe(t) {
  return jS("cls", t, XPe, cK);
}
function qPe(t) {
  return jS("lcp", t, YPe, dK);
}
function KPe(t) {
  return jS("fid", t, ZPe, fK);
}
function US(t, e) {
  return hK(t, e), sw[t] || (QPe(t), (sw[t] = !0)), pK(t, e);
}
function K6(t, e) {
  const n = dg[t];
  if (!(!n || !n.length))
    for (const r of n)
      try {
        r(e);
      } catch (i) {
        si &&
          Xe.error(
            `Error while triggering instrumentation handler.
Type: ${t}
Name: ${nf(r)}
Error:`,
            i
          );
      }
}
function XPe() {
  jPe((t) => {
    K6("cls", { metric: t }), (cK = t);
  });
}
function ZPe() {
  VPe((t) => {
    K6("fid", { metric: t }), (fK = t);
  });
}
function YPe() {
  GPe((t) => {
    K6("lcp", { metric: t }), (dK = t);
  });
}
function jS(t, e, n, r) {
  return (
    hK(t, e), sw[t] || (n(), (sw[t] = !0)), r && e({ metric: r }), pK(t, e)
  );
}
function QPe(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0),
    W6(
      t,
      (n) => {
        K6(t, { entries: n });
      },
      e
    );
}
function hK(t, e) {
  (dg[t] = dg[t] || []), dg[t].push(e);
}
function pK(t, e) {
  return () => {
    const n = dg[t];
    if (!n) return;
    const r = n.indexOf(e);
    r !== -1 && n.splice(r, 1);
  };
}
function s4(t) {
  return typeof t == "number" && isFinite(t);
}
function s1(t, { startTimestamp: e, ...n }) {
  return (
    e && t.startTimestamp > e && (t.startTimestamp = e),
    t.startChild({ startTimestamp: e, ...n })
  );
}
const JPe = 2147483647;
function Qi(t) {
  return t / 1e3;
}
function mK() {
  return Ir && Ir.addEventListener && Ir.performance;
}
let kB = 0,
  pi = {},
  Pu,
  hg;
function eNe() {
  const t = mK();
  if (t && nc) {
    t.mark && Ir.performance.mark("sentry-tracing-init");
    const e = sNe(),
      n = rNe(),
      r = iNe();
    return () => {
      e(), n(), r();
    };
  }
  return () => {};
}
function tNe() {
  US("longtask", ({ entries: t }) => {
    for (const e of t) {
      const n = Jy();
      if (!n) return;
      const r = Qi(nc + e.startTime),
        i = Qi(e.duration);
      n.startChild({
        description: "Main UI thread blocked",
        op: "ui.long-task",
        origin: "auto.ui.browser.metrics",
        startTimestamp: r,
        endTimestamp: r + i,
      });
    }
  });
}
function nNe() {
  US("event", ({ entries: t }) => {
    for (const e of t) {
      const n = Jy();
      if (!n) return;
      if (e.name === "click") {
        const r = Qi(nc + e.startTime),
          i = Qi(e.duration);
        n.startChild({
          description: n1(e.target),
          op: `ui.interaction.${e.name}`,
          origin: "auto.ui.browser.metrics",
          startTimestamp: r,
          endTimestamp: r + i,
        });
      }
    }
  });
}
function rNe() {
  return WPe(({ metric: t }) => {
    const e = t.entries.pop();
    e &&
      (si && Xe.log("[Measurements] Adding CLS"),
      (pi.cls = { value: t.value, unit: "" }),
      (hg = e));
  });
}
function iNe() {
  return qPe(({ metric: t }) => {
    const e = t.entries.pop();
    e &&
      (si && Xe.log("[Measurements] Adding LCP"),
      (pi.lcp = { value: t.value, unit: "millisecond" }),
      (Pu = e));
  });
}
function sNe() {
  return KPe(({ metric: t }) => {
    const e = t.entries.pop();
    if (!e) return;
    const n = Qi(nc),
      r = Qi(e.startTime);
    si && Xe.log("[Measurements] Adding FID"),
      (pi.fid = { value: t.value, unit: "millisecond" }),
      (pi["mark.fid"] = { value: n + r, unit: "second" });
  });
}
function aNe(t) {
  const e = mK();
  if (!e || !Ir.performance.getEntries || !nc) return;
  si && Xe.log("[Tracing] Adding & adjusting spans using Performance API");
  const n = Qi(nc),
    r = e.getEntries();
  let i, s;
  if (
    (r.slice(kB).forEach((a) => {
      const o = Qi(a.startTime),
        l = Qi(a.duration);
      if (!(t.op === "navigation" && n + o < t.startTimestamp))
        switch (a.entryType) {
          case "navigation": {
            lNe(t, a, n),
              (i = n + Qi(a.responseStart)),
              (s = n + Qi(a.requestStart));
            break;
          }
          case "mark":
          case "paint":
          case "measure": {
            oNe(t, a, o, l, n);
            const u = $S(),
              f = a.startTime < u.firstHiddenTime;
            a.name === "first-paint" &&
              f &&
              (si && Xe.log("[Measurements] Adding FP"),
              (pi.fp = { value: a.startTime, unit: "millisecond" })),
              a.name === "first-contentful-paint" &&
                f &&
                (si && Xe.log("[Measurements] Adding FCP"),
                (pi.fcp = { value: a.startTime, unit: "millisecond" }));
            break;
          }
          case "resource": {
            const u = a.name.replace(Ir.location.origin, "");
            cNe(t, a, u, o, l, n);
            break;
          }
        }
    }),
    (kB = Math.max(r.length - 1, 0)),
    fNe(t),
    t.op === "pageload")
  ) {
    typeof i == "number" &&
      (si && Xe.log("[Measurements] Adding TTFB"),
      (pi.ttfb = { value: (i - t.startTimestamp) * 1e3, unit: "millisecond" }),
      typeof s == "number" &&
        s <= i &&
        (pi["ttfb.requestTime"] = {
          value: (i - s) * 1e3,
          unit: "millisecond",
        })),
      ["fcp", "fp", "lcp"].forEach((o) => {
        if (!pi[o] || n >= t.startTimestamp) return;
        const l = pi[o].value,
          u = n + Qi(l),
          f = Math.abs((u - t.startTimestamp) * 1e3),
          c = f - l;
        si && Xe.log(`[Measurements] Normalized ${o} from ${l} to ${f} (${c})`),
          (pi[o].value = f);
      });
    const a = pi["mark.fid"];
    a &&
      pi.fid &&
      (s1(t, {
        description: "first input delay",
        endTimestamp: a.value + Qi(pi.fid.value),
        op: "ui.action",
        origin: "auto.ui.browser.metrics",
        startTimestamp: a.value,
      }),
      delete pi["mark.fid"]),
      "fcp" in pi || delete pi.cls,
      Object.keys(pi).forEach((o) => {
        t.setMeasurement(o, pi[o].value, pi[o].unit);
      }),
      dNe(t);
  }
  (Pu = void 0), (hg = void 0), (pi = {});
}
function oNe(t, e, n, r, i) {
  const s = i + n,
    a = s + r;
  return (
    s1(t, {
      description: e.name,
      endTimestamp: a,
      op: e.entryType,
      origin: "auto.resource.browser.metrics",
      startTimestamp: s,
    }),
    s
  );
}
function lNe(t, e, n) {
  [
    "unloadEvent",
    "redirect",
    "domContentLoadedEvent",
    "loadEvent",
    "connect",
  ].forEach((r) => {
    Fv(t, e, r, n);
  }),
    Fv(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"),
    Fv(t, e, "fetch", n, "cache", "domainLookupStart"),
    Fv(t, e, "domainLookup", n, "DNS"),
    uNe(t, e, n);
}
function Fv(t, e, n, r, i, s) {
  const a = s ? e[s] : e[`${n}End`],
    o = e[`${n}Start`];
  !o ||
    !a ||
    s1(t, {
      op: "browser",
      origin: "auto.browser.browser.metrics",
      description: i || n,
      startTimestamp: r + Qi(o),
      endTimestamp: r + Qi(a),
    });
}
function uNe(t, e, n) {
  s1(t, {
    op: "browser",
    origin: "auto.browser.browser.metrics",
    description: "request",
    startTimestamp: n + Qi(e.requestStart),
    endTimestamp: n + Qi(e.responseEnd),
  }),
    s1(t, {
      op: "browser",
      origin: "auto.browser.browser.metrics",
      description: "response",
      startTimestamp: n + Qi(e.responseStart),
      endTimestamp: n + Qi(e.responseEnd),
    });
}
function cNe(t, e, n, r, i, s) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const a = {};
  a4(a, e, "transferSize", "http.response_transfer_size"),
    a4(a, e, "encodedBodySize", "http.response_content_length"),
    a4(a, e, "decodedBodySize", "http.decoded_response_content_length"),
    "renderBlockingStatus" in e &&
      (a["resource.render_blocking_status"] = e.renderBlockingStatus);
  const o = s + r,
    l = o + i;
  s1(t, {
    description: n,
    endTimestamp: l,
    op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
    origin: "auto.resource.browser.metrics",
    startTimestamp: o,
    data: a,
  });
}
function fNe(t) {
  const e = Ir.navigator;
  if (!e) return;
  const n = e.connection;
  n &&
    (n.effectiveType && t.setTag("effectiveConnectionType", n.effectiveType),
    n.type && t.setTag("connectionType", n.type),
    s4(n.rtt) &&
      (pi["connection.rtt"] = { value: n.rtt, unit: "millisecond" })),
    s4(e.deviceMemory) && t.setTag("deviceMemory", `${e.deviceMemory} GB`),
    s4(e.hardwareConcurrency) &&
      t.setTag("hardwareConcurrency", String(e.hardwareConcurrency));
}
function dNe(t) {
  Pu &&
    (si && Xe.log("[Measurements] Adding LCP Data"),
    Pu.element && t.setTag("lcp.element", n1(Pu.element)),
    Pu.id && t.setTag("lcp.id", Pu.id),
    Pu.url && t.setTag("lcp.url", Pu.url.trim().slice(0, 200)),
    t.setTag("lcp.size", Pu.size)),
    hg &&
      hg.sources &&
      (si && Xe.log("[Measurements] Adding CLS Data"),
      hg.sources.forEach((e, n) =>
        t.setTag(`cls.source.${n + 1}`, n1(e.node))
      ));
}
function a4(t, e, n, r) {
  const i = e[n];
  i != null && i < JPe && (t[r] = i);
}
function hNe(t, e, n, r, i = "auto.http.browser") {
  if (!DS() || !t.fetchData) return;
  const s = e(t.fetchData.url);
  if (t.endTimestamp && s) {
    const p = t.fetchData.__span;
    if (!p) return;
    const m = r[p];
    if (m) {
      if (t.response) {
        m.setHttpStatus(t.response.status);
        const g =
          t.response &&
          t.response.headers &&
          t.response.headers.get("content-length");
        if (g) {
          const w = parseInt(g);
          w > 0 && m.setData("http.response_content_length", w);
        }
      } else t.error && m.setStatus("internal_error");
      m.finish(), delete r[p];
    }
    return;
  }
  const a = Ei(),
    o = a.getScope(),
    l = a.getClient(),
    u = o.getSpan(),
    { method: f, url: c } = t.fetchData,
    d =
      s && u
        ? u.startChild({
            data: { url: c, type: "fetch", "http.method": f },
            description: `${f} ${c}`,
            op: "http.client",
            origin: i,
          })
        : void 0;
  if (
    (d && ((t.fetchData.__span = d.spanId), (r[d.spanId] = d)),
    n(t.fetchData.url) && l)
  ) {
    const p = t.args[0];
    t.args[1] = t.args[1] || {};
    const m = t.args[1];
    m.headers = pNe(p, l, o, m, d);
  }
  return d;
}
function pNe(t, e, n, r, i) {
  const s = i || n.getSpan(),
    a = s && s.transaction,
    { traceId: o, sampled: l, dsc: u } = n.getPropagationContext(),
    f = s ? s.toTraceparent() : kS(o, void 0, l),
    c = a ? a.getDynamicSamplingContext() : u || B6(o, e, n),
    d = d9(c),
    p = typeof Request < "u" && tf(t, Request) ? t.headers : r.headers;
  if (p)
    if (typeof Headers < "u" && tf(p, Headers)) {
      const m = new Headers(p);
      return m.append("sentry-trace", f), d && m.append(f9, d), m;
    } else if (Array.isArray(p)) {
      const m = [...p, ["sentry-trace", f]];
      return d && m.push([f9, d]), m;
    } else {
      const m = "baggage" in p ? p.baggage : void 0,
        g = [];
      return (
        Array.isArray(m) ? g.push(...m) : m && g.push(m),
        d && g.push(d),
        {
          ...p,
          "sentry-trace": f,
          baggage: g.length > 0 ? g.join(",") : void 0,
        }
      );
    }
  else return { "sentry-trace": f, baggage: d };
}
const v9 = ["localhost", /^\/(?!\/)/],
  b9 = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    tracingOrigins: v9,
    tracePropagationTargets: v9,
  };
function mNe(t) {
  const {
      traceFetch: e,
      traceXHR: n,
      tracePropagationTargets: r,
      tracingOrigins: i,
      shouldCreateSpanForRequest: s,
      enableHTTPTimings: a,
    } = { traceFetch: b9.traceFetch, traceXHR: b9.traceXHR, ...t },
    o = typeof s == "function" ? s : (f) => !0,
    l = (f) => bNe(f, r || i),
    u = {};
  e &&
    Rq((f) => {
      const c = hNe(f, o, l, u);
      a && c && IB(c);
    }),
    n &&
      Bq((f) => {
        const c = wNe(f, o, l, u);
        a && c && IB(c);
      });
}
function gNe(t) {
  return (
    t.entryType === "resource" &&
    "initiatorType" in t &&
    typeof t.nextHopProtocol == "string" &&
    (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest")
  );
}
function IB(t) {
  const e = t.data.url;
  if (!e) return;
  const n = US("resource", ({ entries: r }) => {
    r.forEach((i) => {
      gNe(i) &&
        i.name.endsWith(e) &&
        (vNe(i).forEach((a) => t.setData(...a)), setTimeout(n));
    });
  });
}
function yNe(t) {
  let e = "unknown",
    n = "unknown",
    r = "";
  for (const i of t) {
    if (i === "/") {
      [e, n] = t.split("/");
      break;
    }
    if (!isNaN(Number(i))) {
      (e = r === "h" ? "http" : r), (n = t.split(r)[1]);
      break;
    }
    r += i;
  }
  return r === t && (e = r), { name: e, version: n };
}
function Cu(t = 0) {
  return ((nc || performance.timeOrigin) + t) / 1e3;
}
function vNe(t) {
  const { name: e, version: n } = yNe(t.nextHopProtocol),
    r = [];
  return (
    r.push(["network.protocol.version", n], ["network.protocol.name", e]),
    nc
      ? [
          ...r,
          ["http.request.redirect_start", Cu(t.redirectStart)],
          ["http.request.fetch_start", Cu(t.fetchStart)],
          ["http.request.domain_lookup_start", Cu(t.domainLookupStart)],
          ["http.request.domain_lookup_end", Cu(t.domainLookupEnd)],
          ["http.request.connect_start", Cu(t.connectStart)],
          ["http.request.secure_connection_start", Cu(t.secureConnectionStart)],
          ["http.request.connection_end", Cu(t.connectEnd)],
          ["http.request.request_start", Cu(t.requestStart)],
          ["http.request.response_start", Cu(t.responseStart)],
          ["http.request.response_end", Cu(t.responseEnd)],
        ]
      : r
  );
}
function bNe(t, e) {
  return Xy(t, e || v9);
}
function wNe(t, e, n, r) {
  const i = t.xhr,
    s = i && i[Jp];
  if (!DS() || !i || i.__sentry_own_request__ || !s) return;
  const a = e(s.url);
  if (t.endTimestamp && a) {
    const c = i.__sentry_xhr_span_id__;
    if (!c) return;
    const d = r[c];
    d &&
      s.status_code !== void 0 &&
      (d.setHttpStatus(s.status_code), d.finish(), delete r[c]);
    return;
  }
  const o = Ei(),
    l = o.getScope(),
    u = l.getSpan(),
    f =
      a && u
        ? u.startChild({
            data: { type: "xhr", "http.method": s.method, url: s.url },
            description: `${s.method} ${s.url}`,
            op: "http.client",
            origin: "auto.http.browser",
          })
        : void 0;
  if (
    (f &&
      ((i.__sentry_xhr_span_id__ = f.spanId),
      (r[i.__sentry_xhr_span_id__] = f)),
    i.setRequestHeader && n(s.url))
  )
    if (f) {
      const c = f && f.transaction,
        d = c && c.getDynamicSamplingContext(),
        p = d9(d);
      OB(i, f.toTraceparent(), p);
    } else {
      const c = o.getClient(),
        { traceId: d, sampled: p, dsc: m } = l.getPropagationContext(),
        g = kS(d, void 0, p),
        w = m || (c ? B6(d, c, l) : void 0),
        y = d9(w);
      OB(i, g, y);
    }
  return f;
}
function OB(t, e, n) {
  try {
    t.setRequestHeader("sentry-trace", e), n && t.setRequestHeader(f9, n);
  } catch {}
}
function _Ne(t, e = !0, n = !0) {
  if (!Ir || !Ir.location) {
    si &&
      Xe.warn(
        "Could not initialize routing instrumentation due to invalid location"
      );
    return;
  }
  let r = Ir.location.href,
    i;
  e &&
    (i = t({
      name: Ir.location.pathname,
      startTimestamp: nc ? nc / 1e3 : void 0,
      op: "pageload",
      origin: "auto.pageload.browser",
      metadata: { source: "url" },
    })),
    n &&
      AS(({ to: s, from: a }) => {
        if (a === void 0 && r && r.indexOf(s) !== -1) {
          r = void 0;
          return;
        }
        a !== s &&
          ((r = void 0),
          i &&
            (si &&
              Xe.log(
                `[Tracing] Finishing current transaction with op: ${i.op}`
              ),
            i.finish()),
          (i = t({
            name: Ir.location.pathname,
            op: "navigation",
            origin: "auto.navigation.browser",
            metadata: { source: "url" },
          })));
      });
}
const ENe = "BrowserTracing",
  xNe = {
    ..._b,
    markBackgroundTransactions: !0,
    routingInstrumentation: _Ne,
    startTransactionOnLocationChange: !0,
    startTransactionOnPageLoad: !0,
    enableLongTask: !0,
    _experiments: {},
    ...b9,
  };
class TNe {
  constructor(e) {
    (this.name = ENe),
      (this._hasSetTracePropagationTargets = !1),
      sOe(),
      si &&
        (this._hasSetTracePropagationTargets = !!(
          e &&
          (e.tracePropagationTargets || e.tracingOrigins)
        )),
      (this.options = { ...xNe, ...e }),
      this.options._experiments.enableLongTask !== void 0 &&
        (this.options.enableLongTask =
          this.options._experiments.enableLongTask),
      e &&
        !e.tracePropagationTargets &&
        e.tracingOrigins &&
        (this.options.tracePropagationTargets = e.tracingOrigins),
      (this._collectWebVitals = eNe()),
      this.options.enableLongTask && tNe(),
      this.options._experiments.enableInteractions && nNe();
  }
  setupOnce(e, n) {
    this._getCurrentHub = n;
    const i = n().getClient(),
      s = i && i.getOptions(),
      {
        routingInstrumentation: a,
        startTransactionOnLocationChange: o,
        startTransactionOnPageLoad: l,
        markBackgroundTransactions: u,
        traceFetch: f,
        traceXHR: c,
        shouldCreateSpanForRequest: d,
        enableHTTPTimings: p,
        _experiments: m,
      } = this.options,
      g = s && s.tracePropagationTargets,
      w = g || this.options.tracePropagationTargets;
    si &&
      this._hasSetTracePropagationTargets &&
      g &&
      Xe.warn(
        "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."
      ),
      a(
        (y) => {
          const v = this._createRouteTransaction(y);
          return (
            this.options._experiments.onStartRouteTransaction &&
              this.options._experiments.onStartRouteTransaction(v, y, n),
            v
          );
        },
        l,
        o
      ),
      u && FPe(),
      m.enableInteractions && this._registerInteractionListener(),
      mNe({
        traceFetch: f,
        traceXHR: c,
        tracePropagationTargets: w,
        shouldCreateSpanForRequest: d,
        enableHTTPTimings: p,
      });
  }
  _createRouteTransaction(e) {
    if (!this._getCurrentHub) {
      si &&
        Xe.warn(
          `[Tracing] Did not create ${e.op} transaction because _getCurrentHub is invalid.`
        );
      return;
    }
    const n = this._getCurrentHub(),
      {
        beforeNavigate: r,
        idleTimeout: i,
        finalTimeout: s,
        heartbeatInterval: a,
      } = this.options,
      o = e.op === "pageload",
      l = o ? PB("sentry-trace") : "",
      u = o ? PB("baggage") : "",
      {
        traceparentData: f,
        dynamicSamplingContext: c,
        propagationContext: d,
      } = wIe(l, u),
      p = {
        ...e,
        ...f,
        metadata: { ...e.metadata, dynamicSamplingContext: f && !c ? {} : c },
        trimEnd: !0,
      },
      m = typeof r == "function" ? r(p) : p,
      g = m === void 0 ? { ...p, sampled: !1 } : m;
    (g.metadata =
      g.name !== p.name ? { ...g.metadata, source: "custom" } : g.metadata),
      (this._latestRouteName = g.name),
      (this._latestRouteSource = g.metadata && g.metadata.source),
      g.sampled === !1 &&
        si &&
        Xe.log(
          `[Tracing] Will not send ${g.op} transaction because of beforeNavigate.`
        ),
      si && Xe.log(`[Tracing] Starting ${g.op} transaction on scope`);
    const { location: w } = Ir,
      y = yB(n, g, i, s, !0, { location: w }, a),
      v = n.getScope();
    return (
      o && f
        ? v.setPropagationContext(d)
        : v.setPropagationContext({
            traceId: y.traceId,
            spanId: y.spanId,
            parentSpanId: y.parentSpanId,
            sampled: y.sampled,
          }),
      y.registerBeforeFinishCallback((E) => {
        this._collectWebVitals(), aNe(E);
      }),
      y
    );
  }
  _registerInteractionListener() {
    let e;
    const n = () => {
      const {
          idleTimeout: r,
          finalTimeout: i,
          heartbeatInterval: s,
        } = this.options,
        a = "ui.action.click",
        o = Jy();
      if (o && o.op && ["navigation", "pageload"].includes(o.op)) {
        si &&
          Xe.warn(
            `[Tracing] Did not create ${a} transaction because a pageload or navigation transaction is in progress.`
          );
        return;
      }
      if (
        (e &&
          (e.setFinishReason("interactionInterrupted"),
          e.finish(),
          (e = void 0)),
        !this._getCurrentHub)
      ) {
        si &&
          Xe.warn(
            `[Tracing] Did not create ${a} transaction because _getCurrentHub is invalid.`
          );
        return;
      }
      if (!this._latestRouteName) {
        si &&
          Xe.warn(
            `[Tracing] Did not create ${a} transaction because _latestRouteName is missing.`
          );
        return;
      }
      const l = this._getCurrentHub(),
        { location: u } = Ir,
        f = {
          name: this._latestRouteName,
          op: a,
          trimEnd: !0,
          metadata: { source: this._latestRouteSource || "url" },
        };
      e = yB(l, f, r, i, !0, { location: u }, s);
    };
    ["click"].forEach((r) => {
      addEventListener(r, n, { once: !1, capture: !0 });
    });
  }
}
function PB(t) {
  const e = Ske(`meta[name=${t}]`);
  return e ? e.getAttribute("content") : void 0;
}
function SNe(t) {
  const e = { _metadata: {}, ...t };
  (e._metadata.sdk = e._metadata.sdk || {
    name: "sentry.javascript.react",
    packages: [{ name: "npm:@sentry/react", version: fy }],
    version: fy,
  }),
    LPe(e);
}
const ANe = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function CNe(t) {
  const e = t.match(/^([^.]+)/);
  return e !== null && parseInt(e[0]) >= 17;
}
const NB = { componentStack: null, error: null, eventId: null };
function kNe(t, e) {
  const n = new WeakMap();
  function r(i, s) {
    if (!n.has(i)) {
      if (i.cause) return n.set(i, !0), r(i.cause, s);
      i.cause = s;
    }
  }
  r(t, e);
}
class HS extends Z.Component {
  constructor(e) {
    super(e),
      HS.prototype.__init.call(this),
      (this.state = NB),
      (this._openFallbackReportDialog = !0);
    const n = NS();
    n &&
      n.on &&
      e.showDialog &&
      ((this._openFallbackReportDialog = !1),
      n.on("afterSendEvent", (r) => {
        !r.type &&
          r.event_id === this._lastEventId &&
          SB({ ...e.dialogOptions, eventId: this._lastEventId });
      }));
  }
  componentDidCatch(e, { componentStack: n }) {
    const {
      beforeCapture: r,
      onError: i,
      showDialog: s,
      dialogOptions: a,
    } = this.props;
    Kq((o) => {
      if (CNe(Z.version) && _S(e)) {
        const u = new Error(e.message);
        (u.name = `React ErrorBoundary ${e.name}`), (u.stack = n), kNe(e, u);
      }
      r && r(o, e, n);
      const l = qq(e, {
        captureContext: { contexts: { react: { componentStack: n } } },
        mechanism: { handled: !1 },
      });
      i && i(e, n, l),
        s &&
          ((this._lastEventId = l),
          this._openFallbackReportDialog && SB({ ...a, eventId: l })),
        this.setState({ error: e, componentStack: n, eventId: l });
    });
  }
  componentDidMount() {
    const { onMount: e } = this.props;
    e && e();
  }
  componentWillUnmount() {
    const { error: e, componentStack: n, eventId: r } = this.state,
      { onUnmount: i } = this.props;
    i && i(e, n, r);
  }
  __init() {
    this.resetErrorBoundary = () => {
      const { onReset: e } = this.props,
        { error: n, componentStack: r, eventId: i } = this.state;
      e && e(n, r, i), this.setState(NB);
    };
  }
  render() {
    const { fallback: e, children: n } = this.props,
      r = this.state;
    if (r.error) {
      let i;
      return (
        typeof e == "function"
          ? (i = e({
              error: r.error,
              componentStack: r.componentStack,
              resetError: this.resetErrorBoundary,
              eventId: r.eventId,
            }))
          : (i = e),
        Z.isValidElement(i)
          ? i
          : (e &&
              ANe &&
              Xe.warn("fallback did not produce a valid ReactElement"),
            null)
      );
    }
    return typeof n == "function" ? n() : n;
  }
}
function INe() {
  const t = Z.lazy(() =>
      qe(
        () => import("./Dashboard-ff445ef4.js"),
        [
          "assets/Dashboard-ff445ef4.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/constants-9f52a2ae.js",
          "assets/staking.stakedao.service-87aa0857.js",
          "assets/CurvePool-852682be.js",
          "assets/stakeDaoUtils-f752dab6.js",
          "assets/staking.convex.service-00231db1.js",
          "assets/convexStaking-08fe3d07.js",
          "assets/CvxAssetStakingService-f8fb6638.js",
          "assets/generateCategoricalChart-3ca79930.js",
          "assets/AreaChart-6867f386.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/InfoCircle-1ebdcaad.js",
          "assets/ProgressMarker-94cd9f18.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/BlockCvgPrice-a35422e8.js",
        ]
      )
    ),
    e = Z.lazy(() =>
      qe(
        () => import("./Claim-7dd3c6c5.js"),
        [
          "assets/Claim-7dd3c6c5.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/PageHelp-3dfbb5e1.js",
          "assets/claim.stakedao.service-b2494336.js",
          "assets/staking.stakedao.service-87aa0857.js",
          "assets/CurvePool-852682be.js",
          "assets/stakeDaoUtils-f752dab6.js",
          "assets/staking.convex.service-49185c18.js",
          "assets/CvxAssetStakingService-f8fb6638.js",
          "assets/convexUtils-7f054622.js",
          "assets/convexStaking-08fe3d07.js",
          "assets/staking.convex.service-00231db1.js",
          "assets/HeaderInfoPanelContainer-15db6aee.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/WalletConnectedButton-5c407b26.js",
          "assets/InfoCircle-1ebdcaad.js",
          "assets/Slippage-d86a5baa.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/ysCvgClaim.service-bbde5ab6.js",
        ]
      )
    ),
    n = Z.lazy(() =>
      qe(
        () => import("./StakeSdt-0b42ff08.js"),
        [
          "assets/StakeSdt-0b42ff08.js",
          "assets/staking.stakedao.service-87aa0857.js",
          "assets/CurvePool-852682be.js",
          "assets/stakeDaoUtils-f752dab6.js",
          "assets/claim.stakedao.service-b2494336.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/rewards.service-40a9454a.js",
          "assets/MaxButton-198646ac.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/SortHeader-c05039fc.js",
          "assets/ContractDisplay-4267b497.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/HourGlassIcon-925d813a.js",
          "assets/CryptoInput-761efc45.js",
          "assets/utils-03ca5988.js",
          "assets/panel.esm-d8f41b63.js",
          "assets/ProgressMarker-94cd9f18.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/PageHelp-3dfbb5e1.js",
          "assets/HeaderInfoPanelContainer-15db6aee.js",
        ]
      )
    ),
    r = Z.lazy(() =>
      qe(
        () => import("./StakeCvg-cf743f1e.js"),
        [
          "assets/StakeCvg-cf743f1e.js",
          "assets/CryptoInput-761efc45.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/utils-03ca5988.js",
          "assets/MaxButton-198646ac.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/Slippage-d86a5baa.js",
          "assets/WalletConnectedButton-5c407b26.js",
          "assets/ContractDisplay-4267b497.js",
          "assets/ErrorDisplay-8be22464.js",
        ]
      )
    ),
    i = Z.lazy(() =>
      qe(
        () => import("./StakeCvx-987b28fa.js"),
        [
          "assets/StakeCvx-987b28fa.js",
          "assets/staking.convex.service-00231db1.js",
          "assets/convexStaking-08fe3d07.js",
          "assets/CvxAssetStakingService-f8fb6638.js",
          "assets/CurvePool-852682be.js",
          "assets/PanelV2-fa4ca1d1.js",
          "assets/HourGlassIcon-925d813a.js",
          "assets/InfoCircle-1ebdcaad.js",
        ]
      )
    ),
    s = Z.lazy(() =>
      qe(
        () => import("./Bond-e2b149fb.js"),
        [
          "assets/Bond-e2b149fb.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/PageHelp-3dfbb5e1.js",
          "assets/HeaderInfoPanelContainer-15db6aee.js",
          "assets/MaxButton-198646ac.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/BlockCvgPrice-a35422e8.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/AllocationSlider-b467ce73.js",
          "assets/lock.service-f4c84d65.js",
          "assets/rewards.service-40a9454a.js",
          "assets/ysCvgClaim.service-bbde5ab6.js",
          "assets/ProgressMarker-94cd9f18.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/ContractDisplay-4267b497.js",
          "assets/Slippage-d86a5baa.js",
          "assets/InfoCircle-1ebdcaad.js",
          "assets/utils-03ca5988.js",
          "assets/SortHeader-c05039fc.js",
        ]
      )
    ),
    a = Z.lazy(() =>
      qe(
        () => import("./LockCreate-4156d750.js"),
        [
          "assets/LockCreate-4156d750.js",
          "assets/AllocationSlider-b467ce73.js",
          "assets/lock.service-f4c84d65.js",
          "assets/rewards.service-40a9454a.js",
          "assets/ysCvgClaim.service-bbde5ab6.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/PageHelp-3dfbb5e1.js",
          "assets/HeaderInfoPanelContainer-15db6aee.js",
          "assets/WalletConnectedButton-5c407b26.js",
          "assets/MaxButton-198646ac.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/panel.esm-d8f41b63.js",
          "assets/ProgressMarker-94cd9f18.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/generateCategoricalChart-3ca79930.js",
          "assets/AreaChart-6867f386.js",
        ]
      )
    ),
    o = Z.lazy(() =>
      qe(
        () => import("./GaugesVote-d4cdf85b.js"),
        [
          "assets/GaugesVote-d4cdf85b.js",
          "assets/lock.service-f4c84d65.js",
          "assets/rewards.service-40a9454a.js",
          "assets/KeyValueDisplay-ec59a4c2.js",
          "assets/PageHelp-3dfbb5e1.js",
          "assets/HeaderInfoPanelContainer-15db6aee.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/utils-03ca5988.js",
          "assets/stakeDaoUtils-f752dab6.js",
          "assets/convexUtils-7f054622.js",
          "assets/convexStaking-08fe3d07.js",
        ]
      )
    ),
    l = Z.lazy(() =>
      qe(
        () => import("./Ecosystem-47220d25.js"),
        [
          "assets/Ecosystem-47220d25.js",
          "assets/ExpanderBlock-3577170a.js",
          "assets/stakeDaoUtils-f752dab6.js",
        ]
      )
    ),
    u = Z.lazy(() =>
      qe(
        () => import("./Gallery-bba207b1.js"),
        [
          "assets/Gallery-bba207b1.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/ExpanderBlock-3577170a.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/ErrorDisplay-8be22464.js",
        ]
      )
    ),
    f = Z.lazy(() =>
      qe(
        () => import("./Harvest-10ffc2e2.js"),
        [
          "assets/Harvest-10ffc2e2.js",
          "assets/staking.stakedao.service-87aa0857.js",
          "assets/CurvePool-852682be.js",
          "assets/stakeDaoUtils-f752dab6.js",
          "assets/staking.convex.service-49185c18.js",
          "assets/CvxAssetStakingService-f8fb6638.js",
          "assets/convexUtils-7f054622.js",
          "assets/convexStaking-08fe3d07.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
          "assets/PageHelp-3dfbb5e1.js",
        ]
      )
    ),
    c = Z.lazy(() =>
      qe(
        () => import("./AirdropVeSDT-046a8724.js"),
        [
          "assets/AirdropVeSDT-046a8724.js",
          "assets/ProgressMarker-94cd9f18.js",
          "assets/ErrorDisplay-8be22464.js",
          "assets/ProcessActionButton-77d53bd6.js",
          "assets/ValueConnectedButton-ea3b8760.js",
        ]
      )
    ),
    d = Z.lazy(() =>
      qe(
        () => import("./StakeCvxDetail-0f22440b.js"),
        [
          "assets/StakeCvxDetail-0f22440b.js",
          "assets/staking.convex.service-00231db1.js",
          "assets/convexStaking-08fe3d07.js",
          "assets/CvxAssetStakingService-f8fb6638.js",
          "assets/CurvePool-852682be.js",
          "assets/lock.service-f4c84d65.js",
          "assets/rewards.service-40a9454a.js",
          "assets/constants-9f52a2ae.js",
          "assets/dropdown.esm-4d742924.js",
          "assets/inputnumber.esm-7912d73a.js",
          "assets/utils-03ca5988.js",
          "assets/InfoCircle-1ebdcaad.js",
          "assets/CryptoInput-761efc45.js",
          "assets/PanelV2-fa4ca1d1.js",
          "assets/HourGlassIcon-925d813a.js",
          "assets/generateCategoricalChart-3ca79930.js",
        ]
      )
    ),
    p = Z.lazy(() =>
      qe(
        () => import("./YsTdeOne-5420234e.js"),
        [
          "assets/YsTdeOne-5420234e.js",
          "assets/WalletConnectedButton-5c407b26.js",
          "assets/ErrorDisplay-8be22464.js",
        ]
      )
    ),
    [m] = wq(["accept_disclaimer"]);
  return G.jsx(HS, {
    children: G.jsx(cie, {
      children: G.jsx(jbe, {
        children: G.jsx(lme, {
          web3Onboard: ASe,
          children: G.jsx(M5e, {
            children: G.jsxs("div", {
              className: "App",
              children: [
                G.jsx(Swe, {}),
                G.jsx(dwe, {}),
                G.jsx(L5e, {
                  children: G.jsxs(BCe, {
                    children: [
                      G.jsx(Awe, {}),
                      G.jsx(swe, {}),
                      m.accept_disclaimer !== !0
                        ? G.jsx(pke, {})
                        : G.jsx("div", {
                            className: "Main",
                            role: "main",
                            children: G.jsx(Z.Suspense, {
                              fallback: G.jsx(Cwe, {}),
                              children: G.jsxs(iie, {
                                children: [
                                  G.jsx(Li, {
                                    index: void 0,
                                    path: "/",
                                    element: G.jsx(t, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/claim",
                                    element: G.jsx(e, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake",
                                    element: G.jsx(n, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake/sdt",
                                    element: G.jsx(n, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake/cvg",
                                    element: G.jsx(r, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake",
                                    element: G.jsx(n, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake/sdt",
                                    element: G.jsx(n, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake/cvx",
                                    element: G.jsx(i, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/stake/cvx/:staking",
                                    element: G.jsx(d, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/sdt-harvest",
                                    element: G.jsx(f, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/bond",
                                    element: G.jsx(s, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/lock",
                                    element: G.jsx(a, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/gauges",
                                    element: G.jsx(o, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/contracts",
                                    element: G.jsx(l, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/positions",
                                    element: G.jsx(u, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/positions/:type/:tknId",
                                    element: G.jsx(NCe, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/airdrop/vesdt",
                                    element: G.jsx(c, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "/ys-tde-one",
                                    element: G.jsx(p, {}),
                                  }),
                                  G.jsx(Li, {
                                    path: "*",
                                    element: G.jsx(Qx, {}),
                                  }),
                                ],
                              }),
                            }),
                          }),
                      G.jsx(GCe, {}),
                    ],
                  }),
                }),
                G.jsx(fwe, {}),
                G.jsx(_6, {}),
              ],
            }),
          }),
        }),
      }),
    }),
  });
}
const ONe =
  "https://a2d3f5bc11b435827abb34e5749d404a@o4506640869359616.ingest.sentry.io/4506667093393408";
SNe({ dsn: ONe, integrations: [new TNe()], tracesSampleRate: 1 });
o4.createRoot(document.getElementById("root")).render(G.jsx(INe, {}));
export {
  x1 as $,
  rh as A,
  Td as B,
  lRe as C,
  eRe as D,
  fU as E,
  Ks as F,
  $h as G,
  Mie as H,
  oU as I,
  NNe as J,
  PNe as K,
  Dh as L,
  zm as M,
  Uy as N,
  Vn as O,
  Lr as P,
  iu as Q,
  mh as R,
  Lbe as S,
  xw as T,
  lU as U,
  oRe as V,
  vp as W,
  rU as X,
  SCe as Y,
  wa as Z,
  FSe as _,
  Gm as a,
  lke as a$,
  zDe as a0,
  HDe as a1,
  dd as a2,
  Fbe as a3,
  tu as a4,
  kr as a5,
  GR as a6,
  S1 as a7,
  EG as a8,
  ZDe as a9,
  UDe as aA,
  T1 as aB,
  LDe as aC,
  XDe as aD,
  Mg as aE,
  Qa as aF,
  KDe as aG,
  xG as aH,
  uRe as aI,
  Eh as aJ,
  tRe as aK,
  M5e as aL,
  qL as aM,
  VDe as aN,
  ECe as aO,
  qDe as aP,
  yr as aQ,
  Wh as aR,
  BDe as aS,
  WDe as aT,
  RDe as aU,
  qN as aV,
  Vre as aW,
  sRe as aX,
  Bbe as aY,
  oa as aZ,
  Ur as a_,
  ri as aa,
  mbe as ab,
  KT as ac,
  _x as ad,
  _G as ae,
  N1 as af,
  YDe as ag,
  GDe as ah,
  HT as ai,
  $De as aj,
  zz as ak,
  l8 as al,
  aRe as am,
  rRe as an,
  MDe as ao,
  $Ce as ap,
  yp as aq,
  eu as ar,
  Ly as as,
  J0 as at,
  hb as au,
  WN as av,
  V5 as aw,
  Hre as ax,
  cRe as ay,
  T5e as az,
  db as b,
  Ln as b$,
  yde as b0,
  Wbe as b1,
  X8 as b2,
  hU as b3,
  ix as b4,
  sx as b5,
  MR as b6,
  LR as b7,
  QD as b8,
  QN as b9,
  be as bA,
  Ge as bB,
  _e as bC,
  ao as bD,
  Fe as bE,
  jr as bF,
  Ze as bG,
  Hr as bH,
  ze as bI,
  Jt as bJ,
  Uc as bK,
  Xc as bL,
  Xr as bM,
  JH as bN,
  Bn as bO,
  Dn as bP,
  Rn as bQ,
  fz as bR,
  We as bS,
  xr as bT,
  Ww as bU,
  ic as bV,
  fDe as bW,
  mDe as bX,
  Cn as bY,
  Xg as bZ,
  cDe as b_,
  jR as ba,
  HR as bb,
  JN as bc,
  $R as bd,
  UR as be,
  eD as bf,
  w9 as bg,
  ODe as bh,
  NDe as bi,
  Fo as bj,
  DI as bk,
  hr as bl,
  hj as bm,
  td as bn,
  Ri as bo,
  M7 as bp,
  L7 as bq,
  Qoe as br,
  ele as bs,
  W_e as bt,
  ss as bu,
  is as bv,
  ns as bw,
  rs as bx,
  Oe as by,
  mt as bz,
  l5e as c,
  Lh as c$,
  Mu as c0,
  bt as c1,
  vde as c2,
  zde as c3,
  _d as c4,
  EDe as c5,
  rhe as c6,
  ir as c7,
  Ia as c8,
  $O as c9,
  Jhe as cA,
  oDe as cB,
  dDe as cC,
  BO as cD,
  gDe as cE,
  wDe as cF,
  uDe as cG,
  wh as cH,
  _1 as cI,
  Z7 as cJ,
  z0 as cK,
  w1 as cL,
  vDe as cM,
  Xde as cN,
  yDe as cO,
  _De as cP,
  Ez as cQ,
  Nde as cR,
  RO as cS,
  og as cT,
  dz as cU,
  xDe as cV,
  Q_ as cW,
  lDe as cX,
  dt as cY,
  OH as cZ,
  hDe as c_,
  ADe as ca,
  CDe as cb,
  ac as cc,
  w5 as cd,
  ihe as ce,
  ehe as cf,
  xz as cg,
  Gg as ch,
  wz as ci,
  so as cj,
  SDe as ck,
  pDe as cl,
  Yde as cm,
  ope as cn,
  aDe as co,
  lT as cp,
  S5 as cq,
  bDe as cr,
  sDe as cs,
  by as ct,
  LU as cu,
  QH as cv,
  hT as cw,
  Tpe as cx,
  TDe as cy,
  Wl as cz,
  v0 as d,
  wO as d$,
  EU as d0,
  LNe as d1,
  _U as d2,
  _l as d3,
  $se as d4,
  Rse as d5,
  Rh as d6,
  Tw as d7,
  od as d8,
  Kc as d9,
  E_ as dA,
  pI as dB,
  MNe as dC,
  uE as dD,
  k7 as dE,
  Dse as dF,
  Mh as dG,
  Use as dH,
  Xse as dI,
  wy as dJ,
  gI as dK,
  C7 as dL,
  O7 as dM,
  cE as dN,
  yI as dO,
  I7 as dP,
  Lg as dQ,
  BU as dR,
  pse as dS,
  _7 as dT,
  ed as dU,
  mse as dV,
  P0 as dW,
  Fse as dX,
  pj as dY,
  Ale as dZ,
  Ou as d_,
  lE as da,
  wU as db,
  wl as dc,
  gl as dd,
  D0 as de,
  aa as df,
  _r as dg,
  Mse as dh,
  bse as di,
  MU as dj,
  DU as dk,
  NU as dl,
  jse as dm,
  sf as dn,
  wse as dp,
  Pse as dq,
  mU as dr,
  Sw as ds,
  Jb as dt,
  T7 as du,
  yse as dv,
  x7 as dw,
  RNe as dx,
  Aw as dy,
  gse as dz,
  $y as e,
  cS as e0,
  Sle as e1,
  M8e as e2,
  P8e as e3,
  R8e as e4,
  kW as e5,
  L8e as e6,
  zh as e7,
  m6 as e8,
  eo as e9,
  Ic as eA,
  Kl as eB,
  E0 as eC,
  IW as eD,
  Vh as eE,
  YW as eF,
  qe as eG,
  Pa as ea,
  Vt as eb,
  JT as ec,
  A1 as ed,
  I3e as ee,
  YT as ef,
  Rx as eg,
  B8e as eh,
  iL as ei,
  kh as ej,
  Ixe as ek,
  Wy as el,
  y6 as em,
  CW as en,
  Mxe as eo,
  Qn as ep,
  P1 as eq,
  DEe as er,
  JM as es,
  TW as et,
  dxe as eu,
  cf as ev,
  dS as ew,
  v6 as ex,
  fS as ey,
  ZT as ez,
  iRe as f,
  jDe as g,
  Mbe as h,
  nRe as i,
  G as j,
  QDe as k,
  ji as l,
  Vm as m,
  al as n,
  zu as o,
  kDe as p,
  DNe as q,
  Z as r,
  oi as s,
  JDe as t,
  FDe as u,
  Zb as v,
  Gd as w,
  it as x,
  f1 as y,
  bl as z,
};
